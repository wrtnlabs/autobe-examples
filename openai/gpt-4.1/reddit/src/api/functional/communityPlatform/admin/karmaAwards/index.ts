import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformKarmaAward } from "../../../../structures/ICommunityPlatformKarmaAward";
import { IPageICommunityPlatformKarmaAward } from "../../../../structures/IPageICommunityPlatformKarmaAward";

/**
 * Create a new karma award record for a member (community_platform_karma_awards
 * table).
 *
 * Create a new karma award for a member. This operation inserts a new record
 * into the community_platform_karma_awards table, which tracks platform and
 * community-specific recognition (e.g., badges or awards) for user
 * achievements.
 *
 * Authorized actors for this operation include admins or trusted automation,
 * since it affects the display of official achievements and is subject to
 * strict business and audit rules. The operation accepts all required fields
 * (member, optional community, award type, reason/description, and event time).
 * The backend must validate that the member exists and optionally check that a
 * valid community is referenced for community-specific awards.
 *
 * Successful creation returns the full karma award record. If required
 * validation fails (e.g., member not found, invalid award_type, or improper
 * permissions), the operation should return detailed, actionable error messages
 * and log the event for audit compliance.
 *
 * This API complements member achievement flows and may trigger UI updates in
 * user profiles or award notifications. Related operations include
 * editing/updating awards or viewing accumulative karma summaries by
 * member/community.
 *
 * @param props.connection
 * @param props.body Information required to create a new karma award (member,
 *   optional community, award_type, event time, optional reason)
 * @path /communityPlatform/admin/karmaAwards
 * @accessor api.functional.communityPlatform.admin.karmaAwards.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information required to create a new karma award (member, optional
     * community, award_type, event time, optional reason)
     */
    body: ICommunityPlatformKarmaAward.ICreate;
  };
  export type Body = ICommunityPlatformKarmaAward.ICreate;
  export type Response = ICommunityPlatformKarmaAward;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/admin/karmaAwards",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/admin/karmaAwards";
  export const random = (): ICommunityPlatformKarmaAward =>
    typia.random<ICommunityPlatformKarmaAward>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated list of user karma awards.
 *
 * Retrieve a filtered and paginated listing of karma awards (reward
 * events/badges) granted to users, providing advanced query capabilities for
 * platform operators or for displaying award lists in user profiles.
 *
 * The operation is applicable for administrative or analytic purposes and
 * allows searching by member, specific community, award type, description, and
 * event time. It is used to display badges or trophies in user profiles, or to
 * track global and community-specific reward trends.
 *
 * Security is restricted to administrative roles; regular users do not have
 * access to the full award list in bulk. Care must be taken not to expose
 * private data, such as linkage to hidden communities, without proper
 * authorization.
 *
 * This operation integrates with the community_platform_karma_awards table,
 * returning paginated records in a summary view. It supports response limits,
 * sorting by event_time or award_type, and should handle error cases such as
 * malformed query filters or permission violations appropriately.
 *
 * @param props.connection
 * @param props.body Search and filter parameters for querying karma awards,
 *   including pagination, member/community targeting, and award type filters.
 * @path /communityPlatform/admin/karmaAwards
 * @accessor api.functional.communityPlatform.admin.karmaAwards.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search and filter parameters for querying karma awards, including
     * pagination, member/community targeting, and award type filters.
     */
    body: ICommunityPlatformKarmaAward.IRequest;
  };
  export type Body = ICommunityPlatformKarmaAward.IRequest;
  export type Response = IPageICommunityPlatformKarmaAward.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/admin/karmaAwards",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/admin/karmaAwards";
  export const random = (): IPageICommunityPlatformKarmaAward.ISummary =>
    typia.random<IPageICommunityPlatformKarmaAward.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve full detail for a single user karma award by ID.
 *
 * Retrieve all available fields for a single karma award (badge/reward event),
 * including member, optional community, award type, award reason, and
 * timestamps.
 *
 * This operation is accessible only to admins for audit or analytic purposes,
 * or in context where displaying the full details is appropriate (such as in a
 * user's own profile view if the caller is authorized). It is crucial for
 * compliance, dispute resolution, or for rendering historical achievements in a
 * user summary page.
 *
 * Parameter validation ensures that only valid, existing IDs are accepted;
 * error handling must distinguish between not found (nonexistent ID) and
 * unauthorized access (role or ownership invalid). Responses include all public
 * and administrative fields for the given award.
 *
 * The Prisma entity is community_platform_karma_awards, and the endpoint
 * returns the record mapped to ICommunityPlatformKarmaAward; sensitive or
 * internal fields are omitted if not relevant to the current user context.
 *
 * @param props.connection
 * @param props.karmaAwardId Unique identifier of the karma award record to
 *   retrieve
 * @path /communityPlatform/admin/karmaAwards/:karmaAwardId
 * @accessor api.functional.communityPlatform.admin.karmaAwards.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the karma award record to retrieve */
    karmaAwardId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformKarmaAward;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/admin/karmaAwards/:karmaAwardId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/karmaAwards/${encodeURIComponent(props.karmaAwardId ?? "null")}`;
  export const random = (): ICommunityPlatformKarmaAward =>
    typia.random<ICommunityPlatformKarmaAward>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("karmaAwardId")(() => typia.assert(props.karmaAwardId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing karma award by its ID (community_platform_karma_awards
 * table).
 *
 * Update an existing karma award record using its unique ID. This operation
 * modifies a record in the community_platform_karma_awards table, which logs
 * badges/awards assigned based on karma or achievements.
 *
 * It accepts the karmaAwardId as a path parameter and an update body specifying
 * the award's revised fields. Typical business flows supported include
 * administrative corrections, revocation of awards for compliance or policy
 * breaches, and updates to contextual descriptions or reasons.
 *
 * The operation must authorize only admin-level roles, validate that the
 * referenced award exists, and ensure that updates are consistent with
 * organization policies. Changes are logged for audit. Related APIs include
 * award creation and achievement feed endpoints for user profiles. If the
 * record does not exist or validation fails, a descriptive failure message
 * should be returned.
 *
 * This operation works directly with the community_platform_karma_awards Prisma
 * schema; only legitimate, schema-defined fields may be updated.
 *
 * @param props.connection
 * @param props.karmaAwardId Unique identifier of the karma award to update
 * @param props.body Fields for updating the karma award record (e.g., reason,
 *   type, community, event time, revocation info)
 * @path /communityPlatform/admin/karmaAwards/:karmaAwardId
 * @accessor api.functional.communityPlatform.admin.karmaAwards.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the karma award to update */
    karmaAwardId: string & tags.Format<"uuid">;

    /**
     * Fields for updating the karma award record (e.g., reason, type,
     * community, event time, revocation info)
     */
    body: ICommunityPlatformKarmaAward.IUpdate;
  };
  export type Body = ICommunityPlatformKarmaAward.IUpdate;
  export type Response = ICommunityPlatformKarmaAward;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/admin/karmaAwards/:karmaAwardId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/karmaAwards/${encodeURIComponent(props.karmaAwardId ?? "null")}`;
  export const random = (): ICommunityPlatformKarmaAward =>
    typia.random<ICommunityPlatformKarmaAward>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("karmaAwardId")(() => typia.assert(props.karmaAwardId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a karma award (community_platform_karma_awards) by ID
 * (admin only).
 *
 * Invoking this operation will permanently delete a karma award from the
 * community platform. The target of the operation is the
 * community_platform_karma_awards table within the database. The operation is
 * only available to admin users due to its impact on user reputations and
 * system auditing.
 *
 * The purpose is to allow administrators to remove awards that were granted in
 * error, are subject to compliance or moderation actions, or must be rescinded
 * for other business reasons. The operation checks for the existence of the
 * specified award and, if found, hard-deletes it—eliminating it from all user
 * profiles, badge displays, and relevant analytics calculations. The operation
 * does not support soft deletion, in alignment with the database schema which
 * lacks a deleted_at or similar field for karma awards.
 *
 * This operation is designed for rare, exceptional cases where an award's
 * presence is deemed inappropriate or incorrect. Use of this endpoint should be
 * carefully logged and subject to peer review to prevent accidental or
 * malicious deletions. Attempts to delete a non-existent award will result in
 * an error response indicating that the award was not found.
 *
 * Administrators must be aware that this operation's effect is irreversible.
 * After deletion, the karma award is removed from all associated user profiles
 * and cannot be restored. If auditability is necessary, external audit logging
 * should supplement this operation, as the primary database record will no
 * longer exist.
 *
 * @param props.connection
 * @param props.karmaAwardId Unique identifier (UUID) of the karma award to be
 *   deleted
 * @path /communityPlatform/admin/karmaAwards/:karmaAwardId
 * @accessor api.functional.communityPlatform.admin.karmaAwards.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier (UUID) of the karma award to be deleted */
    karmaAwardId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/admin/karmaAwards/:karmaAwardId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/karmaAwards/${encodeURIComponent(props.karmaAwardId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("karmaAwardId")(() => typia.assert(props.karmaAwardId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
