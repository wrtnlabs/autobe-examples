import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformKarmaThresholds } from "../../../../structures/ICommunityPlatformKarmaThresholds";
import { ICommunityPlatformKarmaThreshold } from "../../../../structures/ICommunityPlatformKarmaThreshold";
import { IPageICommunityPlatformKarmaThreshold } from "../../../../structures/IPageICommunityPlatformKarmaThreshold";

/**
 * Create a new karma threshold configuration
 * (community_platform_karma_thresholds).
 *
 * Create a new karma threshold setting to control feature access on the
 * platform or within a community. This API is utilized by administrators or
 * platform operators to set the minimum karma required to perform key actions
 * (e.g., post creation, voting, or unlocking features) by specifying
 * threshold_type, threshold_value, community ID (if applicable), and any
 * additional lock reason.
 *
 * Upon successful creation, the operation stores the record in the
 * community_platform_karma_thresholds table and returns the newly created
 * object. Incoming requests are validated for duplicates (unique threshold
 * types per community), reasonable karma values, and valid associations to
 * existing communities. Access is restricted to platform administrators, and
 * audit logs are generated for compliance.
 *
 * Errors may be returned if validation, uniqueness, or referencing constraints
 * are violated, such as attempting to set multiple thresholds of the same type
 * for a community or specifying a non-existent community. Related API
 * operations include updating or deleting threshold configurations as feature
 * policies change.
 *
 * @param props.connection
 * @param props.body Information needed to create a new karma threshold,
 *   including required karma value, feature type, lock reason, and (optional)
 *   target community
 * @path /communityPlatform/admin/karmaThresholds
 * @accessor api.functional.communityPlatform.admin.karmaThresholds.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information needed to create a new karma threshold, including
     * required karma value, feature type, lock reason, and (optional)
     * target community
     */
    body: ICommunityPlatformKarmaThresholds.ICreate;
  };
  export type Body = ICommunityPlatformKarmaThresholds.ICreate;
  export type Response = ICommunityPlatformKarmaThresholds;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/admin/karmaThresholds",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/admin/karmaThresholds";
  export const random = (): ICommunityPlatformKarmaThresholds =>
    typia.random<ICommunityPlatformKarmaThresholds>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated karma threshold definitions.
 *
 * This operation enables admins to search the list of karma thresholds, which
 * control gating/unlocking of features based on user community or global karma
 * scores. Supported filters may include threshold type (such as
 * 'post_creation', 'comment_voting'), target community, or global thresholds.
 * Pagination and sorting parameters are included in the request body for
 * efficient querying of potentially large datasets.
 *
 * This operation interacts with the community_platform_karma_thresholds table
 * as described in the Prisma schema documentation. It is used to configure and
 * audit platform or community rules regarding karma-gated features. Errors are
 * handled for invalid queries or access by unauthorized roles. Only platform
 * administrators are permitted to perform this operation, protecting the
 * integrity of feature gating.
 *
 * @param props.connection
 * @param props.body Filtering, sorting, and pagination criteria for karma
 *   thresholds search.
 * @path /communityPlatform/admin/karmaThresholds
 * @accessor api.functional.communityPlatform.admin.karmaThresholds.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filtering, sorting, and pagination criteria for karma thresholds
     * search.
     */
    body: ICommunityPlatformKarmaThreshold.IRequest;
  };
  export type Body = ICommunityPlatformKarmaThreshold.IRequest;
  export type Response = IPageICommunityPlatformKarmaThreshold;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/admin/karmaThresholds",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/admin/karmaThresholds";
  export const random = (): IPageICommunityPlatformKarmaThreshold =>
    typia.random<IPageICommunityPlatformKarmaThreshold>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a specific community karma threshold configuration
 * (community_platform_karma_thresholds).
 *
 * Retrieve the details of a single karma threshold configuration for the
 * platform or a specific community. This operation provides full information
 * about the threshold requirement, such as the threshold type (e.g.,
 * post_creation, comment_voting), required karma value, and optional feature
 * lock reason for feature gating.
 *
 * The API is used by frontend and backend services to enforce permissions or
 * display feature requirements to users. Only authorized roles with access to
 * platform settings or moderation features can access this information if the
 * threshold is configured as private. The karma threshold belongs to the
 * community_platform_karma_thresholds table, using a UUID identifier for
 * lookup.
 *
 * If the requested karmaThresholdId does not exist or is not accessible by the
 * current user role, the operation will return an appropriate error. No
 * sensitive or internal data is exposed; response contains only
 * public-meaningful configuration details. This operation is often coupled with
 * update or creation endpoints for administrative or moderation workflows.
 *
 * @param props.connection
 * @param props.karmaThresholdId The unique identifier (UUID) of the target
 *   karma threshold configuration
 * @path /communityPlatform/admin/karmaThresholds/:karmaThresholdId
 * @accessor api.functional.communityPlatform.admin.karmaThresholds.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * The unique identifier (UUID) of the target karma threshold
     * configuration
     */
    karmaThresholdId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformKarmaThresholds;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/admin/karmaThresholds/:karmaThresholdId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/karmaThresholds/${encodeURIComponent(props.karmaThresholdId ?? "null")}`;
  export const random = (): ICommunityPlatformKarmaThresholds =>
    typia.random<ICommunityPlatformKarmaThresholds>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("karmaThresholdId")(() =>
        typia.assert(props.karmaThresholdId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a karma threshold entry in the community_platform_karma_thresholds
 * table by its ID.
 *
 * Update an existing karma threshold by its unique identifier. The
 * karma_platform_karma_thresholds table manages configurable thresholds for
 * karma-based restrictions, such as limitations on posting, voting, or
 * community actions.
 *
 * This operation is restricted to admin users, who have the authority to modify
 * thresholds that impact platform permissions. Appropriate validation should
 * ensure updated threshold values are within allowed business constraints, do
 * not create duplicate entries within the same scope (global or community), and
 * that required fields are present. The system must reject updates that would
 * violate platform policy or create inconsistencies.
 *
 * Upon successful update, the complete threshold entry is returned for client
 * validation and audit purposes. Error handling must provide informative
 * feedback for any rejected update attempts, specifying constraint violations
 * or business rule failures encountered.
 *
 * @param props.connection
 * @param props.karmaThresholdId Unique identifier of the karma threshold
 *   setting to update.
 * @param props.body The set of fields to update on the specified karma
 *   threshold.
 * @path /communityPlatform/admin/karmaThresholds/:karmaThresholdId
 * @accessor api.functional.communityPlatform.admin.karmaThresholds.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the karma threshold setting to update. */
    karmaThresholdId: string & tags.Format<"uuid">;

    /** The set of fields to update on the specified karma threshold. */
    body: ICommunityPlatformKarmaThreshold.IUpdate;
  };
  export type Body = ICommunityPlatformKarmaThreshold.IUpdate;
  export type Response = ICommunityPlatformKarmaThreshold;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/admin/karmaThresholds/:karmaThresholdId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/karmaThresholds/${encodeURIComponent(props.karmaThresholdId ?? "null")}`;
  export const random = (): ICommunityPlatformKarmaThreshold =>
    typia.random<ICommunityPlatformKarmaThreshold>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("karmaThresholdId")(() =>
        typia.assert(props.karmaThresholdId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a karma threshold entry from the community_platform_karma_thresholds
 * table by its unique ID (hard delete).
 *
 * Permanently remove an existing karma threshold configuration from the
 * database by its unique ID. The community_platform_karma_thresholds table
 * stores minimum karma requirements for actions such as posting or
 * subscribing.
 *
 * This operation supports platform reconfiguration and policy evolution,
 * allowing the removal of obsolete or unnecessary feature gates. Admin-only
 * access ensures proper auditing and authority. There is no soft-delete for
 * this table, so once deleted, the record and its associated settings are
 * unrecoverable.
 *
 * Care should be taken to ensure that deletion does not cause users to bypass
 * necessary restrictions or break downstream business logic; potentially
 * critical rules should be confirmed prior to deletion. Error handling must
 * cover cases where the target threshold does not exist or is already deleted,
 * with clear, non-ambiguous error responses.
 *
 * @param props.connection
 * @param props.karmaThresholdId Unique identifier of the karma threshold
 *   setting to delete.
 * @path /communityPlatform/admin/karmaThresholds/:karmaThresholdId
 * @accessor api.functional.communityPlatform.admin.karmaThresholds.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the karma threshold setting to delete. */
    karmaThresholdId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/admin/karmaThresholds/:karmaThresholdId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/karmaThresholds/${encodeURIComponent(props.karmaThresholdId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("karmaThresholdId")(() =>
        typia.assert(props.karmaThresholdId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
