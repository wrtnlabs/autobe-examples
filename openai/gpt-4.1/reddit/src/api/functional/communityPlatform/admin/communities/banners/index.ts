import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunityBanner } from "../../../../../structures/ICommunityPlatformCommunityBanner";
import { IPageICommunityPlatformCommunityBanner } from "../../../../../structures/IPageICommunityPlatformCommunityBanner";

/**
 * Create a new banner for a community (community_platform_community_banners).
 *
 * This endpoint allows moderators or admins to upload and register a new visual
 * banner for a target community, referencing the
 * community_platform_community_banners table. The request body must specify the
 * associated file_upload_id from a previously uploaded image, and may include
 * order (for display rotation), alt_text for accessibility, and active/inactive
 * display status.
 *
 * Security is enforced such that only community moderators and platform admins
 * are allowed to manage community banners. The operation checks for duplicate
 * banners/order, ensures proper file format compliance, and enforces soft
 * deletion of replaced banners when necessary. On success, it returns detailed
 * metadata of the new banner entry, including its ID, association, display
 * metadata, and all audit fields.
 *
 * This operation is critical for community visual brand management and is used
 * alongside endpoints for listing, updating, and deleting banners. It
 * explicitly does not handle file upload (which must be completed prior in the
 * file uploads subsystem) and focuses on registering the banner with proper
 * metadata in the community context. Validation is applied as per schema, and
 * errors are returned if file references or permissions are invalid.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the target community to which a
 *   new banner will be added.
 * @param props.body Information and configuration for the new community banner
 *   to register.
 * @path /communityPlatform/admin/communities/:communityId/banners
 * @accessor api.functional.communityPlatform.admin.communities.banners.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the target community to which a new banner will
     * be added.
     */
    communityId: string & tags.Format<"uuid">;

    /**
     * Information and configuration for the new community banner to
     * register.
     */
    body: ICommunityPlatformCommunityBanner.ICreate;
  };
  export type Body = ICommunityPlatformCommunityBanner.ICreate;
  export type Response = ICommunityPlatformCommunityBanner;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/admin/communities/:communityId/banners",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/communities/${encodeURIComponent(props.communityId ?? "null")}/banners`;
  export const random = (): ICommunityPlatformCommunityBanner =>
    typia.random<ICommunityPlatformCommunityBanner>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a paginated, filterable list of banner images for a community
 * (community_platform_community_banners table).
 *
 * This API provides a mechanism to retrieve a paginated, filterable list of
 * banners linked to a specific community. It references the
 * community_platform_community_banners table, which holds banner metadata,
 * associations to communities, activation status, file references, and
 * accessibility information (such as alt text).
 *
 * The endpoint accepts communityId as a path parameter (UUID) to specify which
 * community's banners are to be listed. Additional filtering, sorting, or
 * searching parameters may be carried in the request body schema
 * (ICommunityPlatformCommunityBanner.IRequest), supporting moderation workflows
 * and community branding management.
 *
 * Only authenticated users with moderator or admin privileges for the target
 * community may utilize this operation. Returned data is paginated and includes
 * essential banner properties, file references, status (active/inactive),
 * order, and accessibility text. The result enables a web or dashboard UI to
 * review, manage, and prepare further updates or deletions for banners.
 *
 * @param props.connection
 * @param props.communityId The unique identifier of the community whose banners
 *   are being retrieved.
 * @param props.body Filter, search, and pagination criteria to query banners
 *   for a given community.
 * @path /communityPlatform/admin/communities/:communityId/banners
 * @accessor api.functional.communityPlatform.admin.communities.banners.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * The unique identifier of the community whose banners are being
     * retrieved.
     */
    communityId: string & tags.Format<"uuid">;

    /**
     * Filter, search, and pagination criteria to query banners for a given
     * community.
     */
    body: ICommunityPlatformCommunityBanner.IRequest;
  };
  export type Body = ICommunityPlatformCommunityBanner.IRequest;
  export type Response = IPageICommunityPlatformCommunityBanner;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/admin/communities/:communityId/banners",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/communities/${encodeURIComponent(props.communityId ?? "null")}/banners`;
  export const random = (): IPageICommunityPlatformCommunityBanner =>
    typia.random<IPageICommunityPlatformCommunityBanner>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the metadata or status of a specific community banner
 * (community_platform_community_banners).
 *
 * Updates the metadata of a banner image for a community, including changing
 * alternative text, updating the display order, and toggling its active status.
 * This operation references the community_platform_community_banners schema,
 * where each banner is linked to a community and file upload, and supports
 * updating all editable columns except the file_upload_id (which is immutable
 * after creation for audit and safety).
 *
 * Moderators and admins may use this API to adjust which banners are currently
 * visible, update their accessibility (alt_text), or reorder banner appearance
 * for branding purposes. The operation validates that the provided bannerId and
 * communityId exist and are correctly related, returning an error if not. It
 * fetches the current banner data, applies allowed updates, and saves the
 * changes if the calling user has sufficient rights (moderator for the given
 * community or admin). Changes are logged for audit.
 *
 * Attempting to update a banner for which the caller lacks permissions, for a
 * banner unrelated to the specified community, or for immutable fields will
 * result in a clear business error response. If the banner is archived
 * (soft-deleted), updates are not allowed. Related endpoints include banner
 * creation, listing, and deletion within the same community context.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the target community.
 * @param props.bannerId Unique identifier of the banner to update.
 * @param props.body Fields to update for the specific community banner (e.g.,
 *   alt_text, order, active).
 * @path /communityPlatform/admin/communities/:communityId/banners/:bannerId
 * @accessor api.functional.communityPlatform.admin.communities.banners.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target community. */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the banner to update. */
    bannerId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the specific community banner (e.g., alt_text,
     * order, active).
     */
    body: ICommunityPlatformCommunityBanner.IUpdate;
  };
  export type Body = ICommunityPlatformCommunityBanner.IUpdate;
  export type Response = ICommunityPlatformCommunityBanner;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/admin/communities/:communityId/banners/:bannerId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/communities/${encodeURIComponent(props.communityId ?? "null")}/banners/${encodeURIComponent(props.bannerId ?? "null")}`;
  export const random = (): ICommunityPlatformCommunityBanner =>
    typia.random<ICommunityPlatformCommunityBanner>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("bannerId")(() => typia.assert(props.bannerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete (archive) a specific community banner from a community
 * (community_platform_community_banners).
 *
 * Archives (soft-deletes) the designated banner image from a community,
 * ensuring that the banner is no longer displayed or returned in banner lists
 * to the UI. As defined in the community_platform_community_banners schema,
 * this operation sets the deleted_at field to the current timestamp, rather
 * than removing the record, supporting historical review, rollback, or audit
 * actions if needed.
 *
 * This endpoint asserts that the specified banner belongs to the given
 * community and that the requesting user has moderator or admin rights for that
 * community. Soft deletion retains the database record for compliance, but the
 * banner is omitted from public/community banner queries. Linked file upload
 * records are not deleted, so actual images persist and may be referenced by
 * other components or in audit flows.
 *
 * If a moderator or admin attempts to delete a banner already archived or
 * nonexistent, a clear error is returned. Related endpoints are available for
 * creating and updating banners, as well as restoring archived ones (in future
 * expansions). All deletion events are captured for audit review and
 * traceability.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the target community.
 * @param props.bannerId Unique identifier of the banner to archive
 *   (soft-delete).
 * @path /communityPlatform/admin/communities/:communityId/banners/:bannerId
 * @accessor api.functional.communityPlatform.admin.communities.banners.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the target community. */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the banner to archive (soft-delete). */
    bannerId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/admin/communities/:communityId/banners/:bannerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/communities/${encodeURIComponent(props.communityId ?? "null")}/banners/${encodeURIComponent(props.bannerId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("bannerId")(() => typia.assert(props.bannerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
