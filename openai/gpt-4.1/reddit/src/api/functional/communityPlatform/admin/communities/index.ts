import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunity } from "../../../../structures/ICommunityPlatformCommunity";
export * as rules from "./rules/index";
export * as banners from "./banners/index";
export * as images from "./images/index";
export * as statusChanges from "./statusChanges/index";
export * as moderatorAssignments from "./moderatorAssignments/index";

/**
 * Update and manage community properties in the community_platform_communities
 * table.
 *
 * This operation allows authorized users (community moderators or platform
 * admins) to update a community's properties, including title, description,
 * status, and URL slug, within the community_platform_communities table.
 *
 * Only users with moderator or admin roles may access this endpoint. The
 * operation strictly enforces all validation constraints, such as unique
 * name/slug, permissible status transitions (e.g., activating, suspending, or
 * banning a community), and character limits on title and description. Updates
 * to imagery or branding assets (e.g., icons, banners) are to be managed via
 * separate related endpoints, but references can be altered if schema
 * relationships exist.
 *
 * All modification events are logged with before-and-after snapshots for audit
 * and legal compliance. The endpoint implements business rules regarding
 * moderation policies, and an appropriate error message is returned if
 * validation fails (e.g., duplicate names, policy violations, or restrictions
 * due to banned/archive status).
 *
 * This operation is related to other community management APIs, including
 * creation, deletion (archival), moderator assignments, and status updates.
 * Edge cases, like concurrent updates or forbidden changes due to policy, are
 * handled according to platform error handling standards.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community to update.
 * @param props.body Data for updating community properties like title,
 *   description, status, and slug.
 * @path /communityPlatform/admin/communities/:communityId
 * @accessor api.functional.communityPlatform.admin.communities.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the community to update. */
    communityId: string & tags.Format<"uuid">;

    /**
     * Data for updating community properties like title, description,
     * status, and slug.
     */
    body: ICommunityPlatformCommunity.IUpdate;
  };
  export type Body = ICommunityPlatformCommunity.IUpdate;
  export type Response = ICommunityPlatformCommunity;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/admin/communities/:communityId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/communities/${encodeURIComponent(props.communityId ?? "null")}`;
  export const random = (): ICommunityPlatformCommunity =>
    typia.random<ICommunityPlatformCommunity>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Archive (soft delete) a community in the community_platform_communities
 * table.
 *
 * This operation allows platform administrators, and where permitted by
 * business logic, community moderators, to delete (soft archive) an existing
 * community by updating the deleted_at field in the
 * community_platform_communities table. Instead of a hard delete, the record is
 * marked as deleted for retention, recovery, and compliance purposes, as
 * required by audit policies.
 *
 * All associated posts, comments, subscriptions, and other relationships are
 * not hard-deleted, but should be marked as archived or handled according to
 * cascade or retention rules, ensuring that data is preserved for a set period
 * and can be restored if needed. Permissions are strictly checked, and only
 * users with the admin or moderator role (assigned to the target community) can
 * invoke this endpoint, provided current policy restrictions are satisfied.
 *
 * Comprehensive audit logs are maintained for all community deletions. An
 * appropriate error is returned if the action violates policy or references a
 * non-existent community. This endpoint is related to community creation,
 * property update, membership management, and moderation workflows.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community to archive (soft
 *   delete).
 * @path /communityPlatform/admin/communities/:communityId
 * @accessor api.functional.communityPlatform.admin.communities.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the community to archive (soft delete). */
    communityId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/admin/communities/:communityId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/communities/${encodeURIComponent(props.communityId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
