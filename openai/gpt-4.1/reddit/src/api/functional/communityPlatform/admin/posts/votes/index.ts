import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPostVote } from "../../../../../structures/ICommunityPlatformPostVote";
import { IPageICommunityPlatformPostVote } from "../../../../../structures/IPageICommunityPlatformPostVote";

/**
 * Retrieve the paginated list of all votes cast on a specific post from the
 * community_platform_post_votes table.
 *
 * This API operation lets a caller retrieve all voting records applied to a
 * single post, designated by the post's unique identifier. It provides the full
 * transaction history for upvotes and downvotes, referencing the fields from
 * community_platform_post_votes such as vote_value, created_at, updated_at,
 * deleted_at, and the associated user ID.
 *
 * Access control for this endpoint typically restricts listing votes to
 * moderators (for auditing) or to the post owner for self-view; in some
 * regulatory contexts, admin access may be required for full transparency. The
 * Prisma schema ensures referential integrity, linking post IDs to members and
 * making every vote traceable. Voting logs foster accountability, allowing
 * detection of anomalous voting patterns or enforcing anti-abuse measures.
 *
 * Returned results are paginated and may include details such as voter ID
 * (linked to community_platform_members), vote direction (+1 for upvote, -1 for
 * downvote), creation and update timestamps, and soft deletion state for
 * revoked votes. The response supports moderation UI, post audit logs, or
 * advanced analytical dashboards. If the requested postId does not exist, is
 * inaccessible, or if the user is unauthorized for viewing votes, the system
 * will return appropriate error messages or an empty list.
 *
 * @param props.connection
 * @param props.postId The unique identifier of the post for which votes will be
 *   listed.
 * @param props.body Criteria for filtering, sorting, and paginating vote
 *   records for a specific post. Includes order, filters, and page
 *   specification.
 * @path /communityPlatform/admin/posts/:postId/votes
 * @accessor api.functional.communityPlatform.admin.posts.votes.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** The unique identifier of the post for which votes will be listed. */
    postId: string & tags.Format<"uuid">;

    /**
     * Criteria for filtering, sorting, and paginating vote records for a
     * specific post. Includes order, filters, and page specification.
     */
    body: ICommunityPlatformPostVote.IRequest;
  };
  export type Body = ICommunityPlatformPostVote.IRequest;
  export type Response = IPageICommunityPlatformPostVote;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/admin/posts/:postId/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/posts/${encodeURIComponent(props.postId ?? "null")}/votes`;
  export const random = (): IPageICommunityPlatformPostVote =>
    typia.random<IPageICommunityPlatformPostVote>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single vote record for a post from the
 * community_platform_post_votes table using postId and voteId.
 *
 * This endpoint allows callers to view detailed information for a single vote
 * transaction on a post. The operation accepts both postId and voteId as path
 * parameters, ensuring the vote belongs to the specified post. The response
 * includes all key fields of a community_platform_post_votes record: vote_value
 * (+1 or -1), referenced member ID, creation and update timestamps, and soft
 * deletion state. This enables complete auditability and transparency into
 * voting actions on posts.
 *
 * Authorization for this endpoint is typically limited to moderators (for
 * community audit), admins (for compliance), and the vote owner for personal
 * review. The response readily supports moderation workflows, anti-abuse
 * investigations, or member-facing UIs showing voting history. Error handling
 * covers invalid IDs, non-existent records, or unauthorized access attempts,
 * returning appropriate messages or status codes in such cases.
 *
 * This operation leverages the full referential integrity of the voting records
 * in the Prisma model and ties each vote record to both its post and casting
 * member for fully traceable voting history.
 *
 * @param props.connection
 * @param props.postId The unique identifier of the post to which the vote
 *   belongs.
 * @param props.voteId The unique identifier of the vote record for the target
 *   post.
 * @path /communityPlatform/admin/posts/:postId/votes/:voteId
 * @accessor api.functional.communityPlatform.admin.posts.votes.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The unique identifier of the post to which the vote belongs. */
    postId: string & tags.Format<"uuid">;

    /** The unique identifier of the vote record for the target post. */
    voteId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformPostVote;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/admin/posts/:postId/votes/:voteId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/posts/${encodeURIComponent(props.postId ?? "null")}/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): ICommunityPlatformPostVote =>
    typia.random<ICommunityPlatformPostVote>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("voteId")(() => typia.assert(props.voteId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a specific user's vote from a given post
 * (community_platform_post_votes).
 *
 * This API endpoint enables users to remove their explicit upvote or downvote
 * from a specific post. It is intended for situations where the user wishes to
 * retract their previous voting actionâ€”such as changing their mind or
 * correcting a mis-click.
 *
 * The operation checks that the voteId belongs to a valid vote entry for the
 * indicated postId and verifies the requesting user's authority. If the
 * requester is not the original voter, but holds a moderator or admin role with
 * the appropriate permissions within the target post's community (or at the
 * platform level), deletion is allowed for moderation or abuse response.
 *
 * Votes are soft-deleted if the schema supports it (see
 * community_platform_post_votes.deleted_at); otherwise, they are permanently
 * removed from the database. Following deletion, the system will trigger
 * recalculation of the associated post's score, update the karma for the voter,
 * and audit-log the activity for review.
 *
 * Errors are returned in the following situations: the vote is not found,
 * belongs to another user without escalation rights, or the vote is already
 * deleted. Rate-limiting is enforced to prevent abuse, particularly by
 * automated (bot) clients.
 *
 * Related business functions include the POST and PATCH vote endpoints for
 * casting or changing a vote, and analytics/sorting recalculation flows for
 * post rankings and user karma.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post on which the vote was cast
 * @param props.voteId Unique identifier of the vote entry to be deleted
 * @path /communityPlatform/admin/posts/:postId/votes/:voteId
 * @accessor api.functional.communityPlatform.admin.posts.votes.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the post on which the vote was cast */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the vote entry to be deleted */
    voteId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/admin/posts/:postId/votes/:voteId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/posts/${encodeURIComponent(props.postId ?? "null")}/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("voteId")(() => typia.assert(props.voteId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
