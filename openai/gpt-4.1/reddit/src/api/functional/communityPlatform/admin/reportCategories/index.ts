import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformReportCategory } from "../../../../structures/ICommunityPlatformReportCategory";

/**
 * Create a new report category for content moderation/reporting
 * (community_platform_report_categories).
 *
 * This API endpoint enables platform administrators to add a new standardized
 * report category used in content flagging throughout the platform. The report
 * category will be presented as an explicit reason in user-facing reporting
 * dialogs, supporting both compliance and analytics around moderation flows.
 *
 * Permission to access this API is strictly limited to admin users, as the
 * maintenance of report categories is a critical moderation configuration
 * action. Use cases include adding categories for new types of abuse, evolving
 * legal requirements, or platform policy updates.
 *
 * All category names must be unique and human-readable, with the option to
 * permit or require users filing reports to submit additional descriptive text
 * (when allow_free_text is true). Category creation is logged for audit and
 * compliance purposes.
 *
 * Expected error conditions include attempts to create duplicate categories or
 * using disallowed category names. Resolved errors should provide actionable
 * information to the administrator regarding the naming or input violation.
 *
 * @param props.connection
 * @param props.body Data for the new report category, including unique name and
 *   free-text allowance.
 * @path /communityPlatform/admin/reportCategories
 * @accessor api.functional.communityPlatform.admin.reportCategories.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Data for the new report category, including unique name and free-text
     * allowance.
     */
    body: ICommunityPlatformReportCategory.ICreate;
  };
  export type Body = ICommunityPlatformReportCategory.ICreate;
  export type Response = ICommunityPlatformReportCategory;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/admin/reportCategories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/admin/reportCategories";
  export const random = (): ICommunityPlatformReportCategory =>
    typia.random<ICommunityPlatformReportCategory>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing report category (community_platform_report_categories).
 *
 * This endpoint grants admin users the ability to update the properties of a
 * report category. Updating categories is sometimes necessary to reflect
 * evolving moderation practices, new regulatory demands, or improved reporting
 * clarity for users.
 *
 * The core attributes updatable via this endpoint are the unique name and the
 * boolean flag permitting or requiring free-text details for reports in this
 * category. All changes are verified against schema requirements—names must
 * remain unique and meaningful, and structural changes should not compromise
 * any report referencing this category.
 *
 * Changes are rigorously audited. Attempting to update with a duplicate name or
 * unauthorized modifications will return descriptive errors. This flow ensures
 * platform-wide moderation consistency and the adaptability of reporting
 * infrastructure.
 *
 * @param props.connection
 * @param props.reportCategoryId Unique identifier of the report category to
 *   update.
 * @param props.body Updated data for the report category (e.g., new name or
 *   allow_free_text).
 * @path /communityPlatform/admin/reportCategories/:reportCategoryId
 * @accessor api.functional.communityPlatform.admin.reportCategories.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the report category to update. */
    reportCategoryId: string & tags.Format<"uuid">;

    /**
     * Updated data for the report category (e.g., new name or
     * allow_free_text).
     */
    body: ICommunityPlatformReportCategory.IUpdate;
  };
  export type Body = ICommunityPlatformReportCategory.IUpdate;
  export type Response = ICommunityPlatformReportCategory;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/admin/reportCategories/:reportCategoryId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/reportCategories/${encodeURIComponent(props.reportCategoryId ?? "null")}`;
  export const random = (): ICommunityPlatformReportCategory =>
    typia.random<ICommunityPlatformReportCategory>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reportCategoryId")(() =>
        typia.assert(props.reportCategoryId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a report category (community_platform_report_categories table) by ID.
 *
 * Delete a specific report category from the set of platform-supported
 * reporting reasons. This is a permanent removal—the report category is no
 * longer available for selection when users file content reports. The operation
 * ensures data integrity by disallowing deletion if the category is in use by
 * unresolved or active reports, avoiding accidental orphaning of moderation
 * workflows or untraceable report references.
 *
 * Only users with the admin role can execute this deletion. Adequate safeguards
 * must be in place to prevent the removal of report categories which might
 * impact in-use moderation or abuse workflows. The system should provide clear
 * error feedback if deletion is denied due to referential integrity checks or
 * if the category does not exist.
 *
 * This endpoint works in conjunction with index, creation, or update operations
 * on report categories, and is vital for platform policy evolution or
 * refinement of moderation terminology. All actions must be recorded in the
 * audit logs for compliance and accountability at the administrative level.
 *
 * @param props.connection
 * @param props.reportCategoryId Unique identifier of the report category to
 *   permanently remove
 * @path /communityPlatform/admin/reportCategories/:reportCategoryId
 * @accessor api.functional.communityPlatform.admin.reportCategories.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the report category to permanently remove */
    reportCategoryId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/admin/reportCategories/:reportCategoryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/reportCategories/${encodeURIComponent(props.reportCategoryId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reportCategoryId")(() =>
        typia.assert(props.reportCategoryId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
