import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformKarmaPenalty } from "../../../../structures/ICommunityPlatformKarmaPenalty";
import { IPageICommunityPlatformKarmaPenalty } from "../../../../structures/IPageICommunityPlatformKarmaPenalty";

/**
 * Create a karma penalty for a member (admin/moderator only,
 * community_platform_karma_penalties table).
 *
 * Use this API to impose a karma penalty on a user. Moderators and admins may
 * call this endpoint after reviewing violations, confirmed abuse, or as part of
 * escalation. All penalty types (deduction, suspension, etc.) must comply with
 * bounds set by platform policy. The penalty is applied immediately, and the
 * affected user's karma will be updated per the business logic and referenced
 * in their profile and permissions-checks. All penalty assignments are logged
 * for audit and compliance visibility.
 *
 * Only members with appropriate role and valid authentication may call this
 * API, typically from the moderation console, not by ordinary users. Attempts
 * to create penalties exceeding allowed limits or with invalid parameters will
 * result in clear error messages with reason codes. Related endpoints include
 * the karma ledger for current state and penalties/query for user history.
 *
 * @param props.connection
 * @param props.body Karma penalty creation payload conforming to required
 *   fields (member, penalty type, value, reason, optional community scope)
 * @path /communityPlatform/admin/karmaPenalties
 * @accessor api.functional.communityPlatform.admin.karmaPenalties.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Karma penalty creation payload conforming to required fields (member,
     * penalty type, value, reason, optional community scope)
     */
    body: ICommunityPlatformKarmaPenalty.ICreate;
  };
  export type Body = ICommunityPlatformKarmaPenalty.ICreate;
  export type Response = ICommunityPlatformKarmaPenalty;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/admin/karmaPenalties",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/admin/karmaPenalties";
  export const random = (): ICommunityPlatformKarmaPenalty =>
    typia.random<ICommunityPlatformKarmaPenalty>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated list of karma penalties
 * (community_platform_karma_penalties).
 *
 * Retrieve a filtered, paginated list of karma penalties assigned to platform
 * members. This operation supports advanced filtering on penalty type, status,
 * member, community, or time range, making it suitable for reviewing moderation
 * actions, account restrictions, or penalty analytics.
 *
 * Security considerations: This endpoint is intended for administrative or
 * moderation use due to sensitive enforcement data. Access should be permitted
 * only to roles responsible for user sanctions and moderation policy. Data
 * returned is restricted to authorized actors and must adhere to privacy and
 * audit guidelines.
 *
 * This operation interacts directly with the community_platform_karma_penalties
 * table, providing all penalty fields, relations to members and communities,
 * and relevant metadata for each penalty record. It supports pagination,
 * sorting, and search. Potential dependencies include user/member lookup APIs
 * for context enrichment. Error handling covers invalid filters, permission
 * denial, and data access violations.
 *
 * @param props.connection
 * @param props.body Criteria, filters, pagination, and sorting options for
 *   listing karma penalties.
 * @path /communityPlatform/admin/karmaPenalties
 * @accessor api.functional.communityPlatform.admin.karmaPenalties.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Criteria, filters, pagination, and sorting options for listing karma
     * penalties.
     */
    body: ICommunityPlatformKarmaPenalty.IRequest;
  };
  export type Body = ICommunityPlatformKarmaPenalty.IRequest;
  export type Response = IPageICommunityPlatformKarmaPenalty.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/admin/karmaPenalties",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/admin/karmaPenalties";
  export const random = (): IPageICommunityPlatformKarmaPenalty.ISummary =>
    typia.random<IPageICommunityPlatformKarmaPenalty.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details of a specific karma penalty
 * (community_platform_karma_penalties) by ID.
 *
 * Fetch detailed information for a specific karma penalty assigned to a
 * platform member. Returns all penalty attributes, including references to the
 * associated member, optional community context, penalty type (deduction,
 * suspension, etc.), status, value, reason, time span, and soft deletion flag
 * if applicable.
 *
 * This operation is designed for use by administrators and moderators who
 * require access to enforcement details for audit, user account interventions,
 * or appeals. Unauthorized users are denied access due to the privacy and
 * sensitivity of sanction information. Related APIs may include member lookups
 * or community reference endpoints for context.
 *
 * Error handling includes not found (invalid or revoked ID), permission denial,
 * and attempt to access penalties outside the user's moderation scope.
 *
 * @param props.connection
 * @param props.karmaPenaltyId Unique identifier of the target karma penalty
 *   record to retrieve.
 * @path /communityPlatform/admin/karmaPenalties/:karmaPenaltyId
 * @accessor api.functional.communityPlatform.admin.karmaPenalties.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target karma penalty record to retrieve. */
    karmaPenaltyId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformKarmaPenalty;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/admin/karmaPenalties/:karmaPenaltyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/karmaPenalties/${encodeURIComponent(props.karmaPenaltyId ?? "null")}`;
  export const random = (): ICommunityPlatformKarmaPenalty =>
    typia.random<ICommunityPlatformKarmaPenalty>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("karmaPenaltyId")(() => typia.assert(props.karmaPenaltyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing karma penalty by ID (admin/moderator only,
 * community_platform_karma_penalties table).
 *
 * This endpoint enables a privileged user to update an existing karma penalty
 * imposed on a member. Typical use cases include completing a manual review,
 * reactivating, expiring, or revoking a penalty, or correcting errors from
 * prior entries. All updates are strictly validated—certain fields such as
 * penalty status, penalty value, and expiration can be changed under policy.
 * The operation logs the change for compliance and notifies affected users as
 * prescribed by the business flow.
 *
 * Only users with proper administrative or moderation role may call this.
 * Errors due to unauthorized access, transition to invalid penalty states, or
 * attempts to edit immutable fields will be met with informative error
 * responses recorded in the audit log. Related operations include penalty
 * history and ledger queries.
 *
 * @param props.connection
 * @param props.karmaPenaltyId Unique identifier for the karma penalty record to
 *   update
 * @param props.body Update data for the karma penalty (fields allowed by
 *   business policy)
 * @path /communityPlatform/admin/karmaPenalties/:karmaPenaltyId
 * @accessor api.functional.communityPlatform.admin.karmaPenalties.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the karma penalty record to update */
    karmaPenaltyId: string & tags.Format<"uuid">;

    /** Update data for the karma penalty (fields allowed by business policy) */
    body: ICommunityPlatformKarmaPenalty.IUpdate;
  };
  export type Body = ICommunityPlatformKarmaPenalty.IUpdate;
  export type Response = ICommunityPlatformKarmaPenalty;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/admin/karmaPenalties/:karmaPenaltyId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/karmaPenalties/${encodeURIComponent(props.karmaPenaltyId ?? "null")}`;
  export const random = (): ICommunityPlatformKarmaPenalty =>
    typia.random<ICommunityPlatformKarmaPenalty>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("karmaPenaltyId")(() => typia.assert(props.karmaPenaltyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently remove a karma penalty from the
 * community_platform_karma_penalties table by ID.
 *
 * This API endpoint enables authorized administrative actors to permanently
 * delete a karma penalty entry from the system. The primary use case is to
 * remove penalties that were incorrectly imposed or should be lifted ahead of
 * automatic expiration. The operation directly references the
 * 'community_platform_karma_penalties' table, with 'id' serving as the unique
 * identifier for deletion.
 *
 * Security restrictions are strictly enforced: only users with 'admin' or
 * designated 'moderator' roles can invoke this endpoint. A full audit log of
 * the action should be maintained separately for compliance. No soft-delete or
 * reversible behavior is provided, as 'deleted_at' is for logical deletion and
 * here actual removal is intended per admin/moderator intent.
 *
 * Care must be taken to ensure the referenced penalty still exists and has not
 * previously been deleted or revoked. The system should handle and communicate
 * errors such as 'penalty not found' or 'already deleted.' No request or
 * response body is returned aside from standard success/error signaling.
 *
 * @param props.connection
 * @param props.karmaPenaltyId Unique identifier of the karma penalty to be
 *   deleted.
 * @path /communityPlatform/admin/karmaPenalties/:karmaPenaltyId
 * @accessor api.functional.communityPlatform.admin.karmaPenalties.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the karma penalty to be deleted. */
    karmaPenaltyId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/admin/karmaPenalties/:karmaPenaltyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/karmaPenalties/${encodeURIComponent(props.karmaPenaltyId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("karmaPenaltyId")(() => typia.assert(props.karmaPenaltyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
