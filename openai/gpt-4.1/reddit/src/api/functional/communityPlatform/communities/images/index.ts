import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunityImage } from "../../../../structures/ICommunityPlatformCommunityImage";
import { IPageICommunityPlatformCommunityImage } from "../../../../structures/IPageICommunityPlatformCommunityImage";

/**
 * Search/filter paginated community images for a specific community
 * (community_platform_community_images).
 *
 * Retrieve a filterable and paginated list of images associated with a
 * particular community, enabling community branding asset management and user
 * display customization. Clients may specify image type (icon, background,
 * etc.), status (active/inactive), and sort order for consistent UI/UX
 * presentation.
 *
 * This endpoint validates the target community's existence and enforces
 * role-based access control (public for active images, broader for moderators
 * or admins). Filtering is performed on the
 * 'community_platform_community_images' table, joined with relevant file upload
 * data to provide actionable, display-ready information. Pagination prevents
 * overly large list payloads for high-image communities.
 *
 * Input validation enforces type and communityId constraints. Access is logged
 * for audit/compliance. Errors for missing community, or unauthorized access,
 * follow the platformâ€™s standard error format. This complements image upload,
 * detail-get, and update endpoints in the community asset APIs.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the target community for which
 *   to list images.
 * @param props.body Search criteria, filters, and pagination parameters for
 *   listing community images. Supports filtering by image type, activity
 *   status, and sort order.
 * @path /communityPlatform/communities/:communityId/images
 * @accessor api.functional.communityPlatform.communities.images.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the target community for which to list images. */
    communityId: string & tags.Format<"uuid">;

    /**
     * Search criteria, filters, and pagination parameters for listing
     * community images. Supports filtering by image type, activity status,
     * and sort order.
     */
    body: ICommunityPlatformCommunityImage.IRequest;
  };
  export type Body = ICommunityPlatformCommunityImage.IRequest;
  export type Response = IPageICommunityPlatformCommunityImage;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/communities/:communityId/images",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/communities/${encodeURIComponent(props.communityId ?? "null")}/images`;
  export const random = (): IPageICommunityPlatformCommunityImage =>
    typia.random<IPageICommunityPlatformCommunityImage>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information for a specific community image
 * (community_platform_community_images).
 *
 * Retrieve metadata for a single image associated with the specified community.
 * This includes file reference (to retrieve display URL), image type (e.g.,
 * icon, background), active status, upload time, ordering for UI purposes,
 * alternative text for accessibility, and community linkage.
 *
 * This endpoint validates both the communityId and imageId correspond to actual
 * data, returning detailed error information for missing or mismatched entries.
 * The operation enforces access control: active images are public, but
 * non-public image details may require moderator or admin access, as per
 * community configuration.
 *
 * Security and privacy concerns are respected; only non-sensitive metadata is
 * exposed in public mode. This operation is used by clients fetching display
 * assets, as well as moderators reviewing or managing uploaded images.
 * Operation can be combined with image update or delete for full asset
 * lifecycle management.
 *
 * @param props.connection
 * @param props.communityId Unique identifier for the target community
 *   containing the image.
 * @param props.imageId Unique identifier of the image entry to fetch details
 *   for.
 * @path /communityPlatform/communities/:communityId/images/:imageId
 * @accessor api.functional.communityPlatform.communities.images.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the target community containing the image. */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the image entry to fetch details for. */
    imageId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformCommunityImage;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/communities/:communityId/images/:imageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/communities/${encodeURIComponent(props.communityId ?? "null")}/images/${encodeURIComponent(props.imageId ?? "null")}`;
  export const random = (): ICommunityPlatformCommunityImage =>
    typia.random<ICommunityPlatformCommunityImage>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("imageId")(() => typia.assert(props.imageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
