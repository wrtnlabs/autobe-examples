import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformKarmaHistory } from "../../../../structures/ICommunityPlatformKarmaHistory";
import { IPageICommunityPlatformKarmaHistory } from "../../../../structures/IPageICommunityPlatformKarmaHistory";

/**
 * Retrieve a filtered, paginated history of karma events from the
 * community_platform_karma_history table.
 *
 * This API endpoint allows authenticated users to search, filter, and paginate
 * through the history of their own (or, with proper authorization, others')
 * karma-affecting events as tracked in the 'community_platform_karma_history'
 * table. Events may include post votes, comment votes, moderation penalties,
 * reward events, and system/admin adjustments.
 *
 * Request parameters may specify page size, offset, event types, time ranges,
 * affected resource IDs (post, comment, community), and sort order. The
 * endpoint supports advanced queries for self-service user insights, profile
 * displays, and compliance investigation by moderators/admins.
 *
 * Security ensures only users with proper roles access data; regular users see
 * their own event histories, while moderators/admins may access histories for
 * others if they have reason. The response includes relevant event metadata,
 * joined references to posts, comments, and community context where available,
 * using summary details to avoid data overload. The standard error handling
 * covers pagination parameter errors, unauthorized access attempts, and
 * internal server issues.
 *
 * @param props.connection
 * @param props.body Search and pagination criteria for karma history retrieval,
 *   including event type, resource scope, date range, sort order, and
 *   pagination settings.
 * @path /communityPlatform/member/karmaHistory
 * @accessor api.functional.communityPlatform.member.karmaHistory.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search and pagination criteria for karma history retrieval, including
     * event type, resource scope, date range, sort order, and pagination
     * settings.
     */
    body: ICommunityPlatformKarmaHistory.IRequest;
  };
  export type Body = ICommunityPlatformKarmaHistory.IRequest;
  export type Response = IPageICommunityPlatformKarmaHistory;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/member/karmaHistory",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/member/karmaHistory";
  export const random = (): IPageICommunityPlatformKarmaHistory =>
    typia.random<IPageICommunityPlatformKarmaHistory>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific karma history record by ID from the karma history table.
 *
 * This operation returns detailed information for a single karma history event,
 * such as when a user's content (post or comment) was voted on, moderated, or
 * otherwise changed their user karma.
 *
 * The API checks for existence of the record by the given karmaHistoryId (UUID)
 * and returns the entire record, including references to the member, optional
 * community, related post/comment, event type, change amount, event context,
 * and timestamps. Proper authorization is enforced so that members can only see
 * their own detailed karma history and moderators/admins can audit members if
 * needed.
 *
 * Typical usages include displaying the full breakdown of a member's karma
 * changes in their profile, supporting moderation analytics, or providing an
 * audit trail for compliance or user dispute resolution. Errors for not found,
 * unauthorized, or insufficient permission are returned according to policy.
 * This endpoint integrates directly with the community_platform_karma_history
 * table as defined in the Prisma schema.
 *
 * @param props.connection
 * @param props.karmaHistoryId Unique identifier of the target karma history
 *   record to retrieve.
 * @path /communityPlatform/member/karmaHistory/:karmaHistoryId
 * @accessor api.functional.communityPlatform.member.karmaHistory.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target karma history record to retrieve. */
    karmaHistoryId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformKarmaHistory;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/member/karmaHistory/:karmaHistoryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/karmaHistory/${encodeURIComponent(props.karmaHistoryId ?? "null")}`;
  export const random = (): ICommunityPlatformKarmaHistory =>
    typia.random<ICommunityPlatformKarmaHistory>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("karmaHistoryId")(() => typia.assert(props.karmaHistoryId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
