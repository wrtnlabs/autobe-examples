import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPost } from "../../../../structures/ICommunityPlatformPost";
export * as images from "./images/index";
export * as links from "./links/index";
export * as comments from "./comments/index";
export * as votes from "./votes/index";

/**
 * Create a new post in the community_platform_posts table by an authenticated
 * member.
 *
 * Create a new post (of type text, link, or image) in a specific community. The
 * operation enforces all validation and business logic as documented: unique
 * title per community, valid content type and length, quota/rate limits, and
 * that the requesting user is an active member (email verified, not banned).
 * The resulting post is associated to the community and user;
 * moderation-required communities may set the initial status to 'mod_queued'.
 *
 * Security: Membership and authentication are required; only 'member',
 * 'moderator', and 'admin' roles may use this endpoint. The API checks for
 * banned users, community access, and all content policy enforcement (banned
 * words, content type, etc.). Any validation failure returns a descriptive
 * error; otherwise, a created post record is returned including assigned ID and
 * status.
 *
 * The request body must conform to platform posting DTO conventions and refer
 * only to valid fields in the posts schema (including references to image
 * uploads or validated links). Associated post images or links are created via
 * subsidiary endpoints or as part of the post creation transaction when
 * provided in body.
 *
 * @param props.connection
 * @param props.body Fields required to create a new post, including title,
 *   content, type, and references to the target community and content
 *   attachments as appropriate.
 * @path /communityPlatform/member/posts
 * @accessor api.functional.communityPlatform.member.posts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Fields required to create a new post, including title, content, type,
     * and references to the target community and content attachments as
     * appropriate.
     */
    body: ICommunityPlatformPost.ICreate;
  };
  export type Body = ICommunityPlatformPost.ICreate;
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/member/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/member/posts";
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing post in the community platform (community_platform_posts
 * table).
 *
 * Update a post's content, title, content type, or status using this operation,
 * referencing the 'community_platform_posts' table. The platform allows the
 * post's author to update their content only when the post is within the
 * editable time window and the user's status is active and not under
 * restriction. Moderators or administrators may also update posts in
 * communities where they hold relevant privileges. All edit operations are
 * recorded for auditing, and the previous content is snapshotted for rollback
 * and transparency using "community_platform_comment_edits" if necessary.
 *
 * The operation enforces permission checks, rate limits, and business rule
 * validation, such as ensuring the title and content respect length and format
 * constraints. The operation also validates against community-specific posting
 * guidelines where applicable. Attempts to edit posts after the window expires
 * fail with an explicit error. Error scenarios include insufficient
 * permissions, non-existent post, or violation of update policies. Edits are
 * always traceable for business compliance and review.
 *
 * All changes are subject to audit trail logging, and the operation interacts
 * with related content (e.g., images, links) as defined by related tables and
 * business flows.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post to update
 * @param props.body New data for updating the post fields. Only fields allowed
 *   by business rules and schema are included.
 * @path /communityPlatform/member/posts/:postId
 * @accessor api.functional.communityPlatform.member.posts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the post to update */
    postId: string & tags.Format<"uuid">;

    /**
     * New data for updating the post fields. Only fields allowed by
     * business rules and schema are included.
     */
    body: ICommunityPlatformPost.IUpdate;
  };
  export type Body = ICommunityPlatformPost.IUpdate;
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/member/posts/:postId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Erase (delete or soft-delete) a post in the community platform
 * (community_platform_posts table).
 *
 * Permanently removes or soft-deletes a post from the system, targeting the
 * 'community_platform_posts' table. If a 'deleted_at' field is present, records
 * are soft-deleted by timestamping the field; otherwise, the record is removed
 * entirely (hard delete). Post authors may erase their own posts within policy
 * constraints (e.g., time window), while community moderators or platform
 * admins can erase any post in their scope of authority.
 *
 * All erasure actions are audited and may cascade recursively to comments,
 * votes, images, links, and moderation history related to the post, according
 * to referential integrity and business rules. Attempts to erase posts outside
 * policy constraints—such as expired window or insufficient rights—result in
 * errors with informative messages. Related entities are set to deleted
 * appropriately. This operation is secured to prevent unauthorized erasure and
 * ensures platform compliance.
 *
 * No response body is returned on success. Operation enforces all business,
 * moderation, and audit requirements.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post to erase/delete
 * @path /communityPlatform/member/posts/:postId
 * @accessor api.functional.communityPlatform.member.posts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the post to erase/delete */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/member/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
