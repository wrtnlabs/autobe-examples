import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommentVote } from "../../../../../structures/ICommunityPlatformCommentVote";

/**
 * Record a member's upvote or downvote on a specific comment
 * (community_platform_comment_votes).
 *
 * Create a new vote associated with a comment, ensuring idempotent
 * one-member-one-vote rules according to the business logic of the voting
 * system. The system checks if the member has an existing (active) vote and, if
 * so, may update the value instead of creating duplicates depending on the
 * application logic.
 *
 * Voting is an authenticated member-only action; guests or banned users are
 * blocked at the controller/authorization layer. Request validation enforces
 * that the vote value is strictly 1 or -1, and the commentId refers to a valid,
 * not-deleted comment for which the member has permission to vote (not their
 * own comment).
 *
 * All votes are recorded in community_platform_comment_votes, with relevant
 * auditing for anti-abuse monitoring. In case of quota violations, the
 * operation returns detailed error responses. Successful voting updates mutable
 * comment, user, and potentially community karma statistics; all actions are
 * subject to further review in case of suspected abuse.
 *
 * @param props.connection
 * @param props.commentId Unique identifier of the comment being voted on.
 * @param props.body Vote submission information: value must be +1 (upvote) or
 *   -1 (downvote).
 * @path /communityPlatform/member/comments/:commentId/votes
 * @accessor api.functional.communityPlatform.member.comments.votes.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the comment being voted on. */
    commentId: string & tags.Format<"uuid">;

    /**
     * Vote submission information: value must be +1 (upvote) or -1
     * (downvote).
     */
    body: ICommunityPlatformCommentVote.ICreate;
  };
  export type Body = ICommunityPlatformCommentVote.ICreate;
  export type Response = ICommunityPlatformCommentVote;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/member/comments/:commentId/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/comments/${encodeURIComponent(props.commentId ?? "null")}/votes`;
  export const random = (): ICommunityPlatformCommentVote =>
    typia.random<ICommunityPlatformCommentVote>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a member's upvote or downvote on a specific comment
 * (community_platform_comment_votes table).
 *
 * This endpoint lets an authenticated member update their previous vote on a
 * specific comment. The operation references the
 * community_platform_comment_votes table, where each vote entry is uniquely
 * identified by both the commentId (the comment being voted on) and the voteId
 * (the individual vote record).
 *
 * Members can switch their vote from upvote to downvote or vice versa by
 * providing new vote value details in the request body. All changes are
 * timestamped and impact comment ranking and author karma, per business rules.
 * Only the member who originally cast the vote can update it, and only if they
 * are not voting on their own comment. Moderators and admins may override in
 * edge cases, but typical usage is for self-initiated vote editing.
 *
 * Validation enforces one active vote per comment per member. Updating a vote
 * automatically revises karma for the comment's author. The operation requires
 * authentication (role: member) and will fail if the member tries to update
 * someone else's vote, or if either the comment or vote does not exist or is no
 * longer valid (e.g., deleted).
 *
 * @param props.connection
 * @param props.commentId Unique identifier of the comment being voted on.
 * @param props.voteId Unique identifier of the vote record to update.
 * @param props.body New vote details for the comment (e.g., vote_value: 1 for
 *   upvote, -1 for downvote).
 * @path /communityPlatform/member/comments/:commentId/votes/:voteId
 * @accessor api.functional.communityPlatform.member.comments.votes.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the comment being voted on. */
    commentId: string & tags.Format<"uuid">;

    /** Unique identifier of the vote record to update. */
    voteId: string & tags.Format<"uuid">;

    /**
     * New vote details for the comment (e.g., vote_value: 1 for upvote, -1
     * for downvote).
     */
    body: ICommunityPlatformCommentVote.IUpdate;
  };
  export type Body = ICommunityPlatformCommentVote.IUpdate;
  export type Response = ICommunityPlatformCommentVote;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/member/comments/:commentId/votes/:voteId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/comments/${encodeURIComponent(props.commentId ?? "null")}/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): ICommunityPlatformCommentVote =>
    typia.random<ICommunityPlatformCommentVote>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("voteId")(() => typia.assert(props.voteId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a member's vote on a comment (community_platform_comment_votes
 * table).
 *
 * This endpoint allows an authenticated member to revoke (soft delete) their
 * vote on a specific comment, effectively removing their previous upvote or
 * downvote. The operation interacts with the community_platform_comment_votes
 * table: each vote is uniquely identified by the commentId and voteId
 * parameters. The record's deleted_at field is set to the current timestamp
 * instead of being hard-deleted, preserving vote history for audit and
 * compliance reasons.
 *
 * By revoking the vote, the member's influence is removed from the comment's
 * score and from karma calculations for the comment's author. This helps
 * provide accurate, real-time ranking while maintaining transparent audit
 * trails. Only the member who originally cast the vote may perform this action.
 * The operation will fail if the vote does not exist, has already been deleted,
 * or does not belong to the authenticated user. Moderators and admins may
 * override in exceptional moderation scenarios, but this is a self-service
 * action for regular use.
 *
 * Security is strictly enforced to prevent users from erasing other users'
 * votes. The operation requires authentication via member role. Deletion
 * triggers system recalculations of vote totals and karma. Errors or invalid
 * attempts (e.g., removing a non-existent vote) yield clear, actionable
 * messages in line with error handling standards.
 *
 * @param props.connection
 * @param props.commentId Unique identifier of the comment whose vote is being
 *   revoked.
 * @param props.voteId Unique identifier of the vote record to delete.
 * @path /communityPlatform/member/comments/:commentId/votes/:voteId
 * @accessor api.functional.communityPlatform.member.comments.votes.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the comment whose vote is being revoked. */
    commentId: string & tags.Format<"uuid">;

    /** Unique identifier of the vote record to delete. */
    voteId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/member/comments/:commentId/votes/:voteId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/comments/${encodeURIComponent(props.commentId ?? "null")}/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("voteId")(() => typia.assert(props.voteId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
