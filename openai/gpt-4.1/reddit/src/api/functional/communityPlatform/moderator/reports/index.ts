import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformReport } from "../../../../structures/ICommunityPlatformReport";
import { IPageICommunityPlatformReport } from "../../../../structures/IPageICommunityPlatformReport";

/**
 * Retrieve a paginated, filtered list of submitted content reports from
 * community_platform_reports for moderation review.
 *
 * Search and retrieve reports submitted by users flagging inappropriate
 * content, via the community_platform_reports table. This operation enables
 * moderators and admins to access lists of content reports, filter them by
 * categories, workflow status, date, or specific content types (post or
 * comment), and sort by urgency, recency or severity for efficient review.
 *
 * Security is enforced so that only users with moderator or admin roles can
 * access this information, ensuring privacy and limiting exposure of sensitive
 * complaints. Business logic incorporates pagination and query-based searches
 * to allow bulk or targeted moderation workflows. The response data integrates
 * report status, moderator actions, report category and reason, and associated
 * content/user linkage as required for comprehensive moderation.
 *
 * Use of this endpoint supports scalable, compliant review and tracking of all
 * report events, upholding community governance and response standards. Errors
 * include requests by unauthorized users or invalid parameters for filtering or
 * sorting queries.
 *
 * @param props.connection
 * @param props.body Search and pagination filters for querying reports.
 * @path /communityPlatform/moderator/reports
 * @accessor api.functional.communityPlatform.moderator.reports.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search and pagination filters for querying reports. */
    body: ICommunityPlatformReport.IRequest;
  };
  export type Body = ICommunityPlatformReport.IRequest;
  export type Response = IPageICommunityPlatformReport.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/moderator/reports",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/moderator/reports";
  export const random = (): IPageICommunityPlatformReport.ISummary =>
    typia.random<IPageICommunityPlatformReport.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific content report
 * (community_platform_reports table).
 *
 * Retrieve full details and workflow status for a single content report, as
 * identified by reportId. This operation enables moderators, admins, or
 * authorized reviewers to observe the reporting member, the target post or
 * comment, category and reason, moderation actions taken, and workflow status
 * (pending, resolved, escalated, etc.), according to platform requirements and
 * compliance needs.
 *
 * Security is critical: Only users with appropriate moderator or administrative
 * permissions may access detailed report records, with all actions audited for
 * compliance. Sensitive details such as reporter identity, free-form reasons,
 * and moderation history are only revealed to those with the necessary
 * privileges, and may be redacted for lower-privilege viewers.
 *
 * The underlying community_platform_reports table includes all necessary data,
 * joined where relevant to referenced post, comment, and moderation category
 * tables. The endpoint should handle errors gracefully if the report does not
 * exist or the user lacks permissions, logging all access for trace and
 * review.
 *
 * @param props.connection
 * @param props.reportId Unique identifier for the report to retrieve.
 * @path /communityPlatform/moderator/reports/:reportId
 * @accessor api.functional.communityPlatform.moderator.reports.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the report to retrieve. */
    reportId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformReport;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/moderator/reports/:reportId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/moderator/reports/${encodeURIComponent(props.reportId ?? "null")}`;
  export const random = (): ICommunityPlatformReport =>
    typia.random<ICommunityPlatformReport>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reportId")(() => typia.assert(props.reportId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the status, result, or assigned moderator/admin for a report
 * (community_platform_reports).
 *
 * This API endpoint allows platform moderators or administrators to update the
 * status, moderation result, or moderator assignment for a specific report of
 * inappropriate content. Common status changes include marking the report as
 * 'under_review', 'resolved', 'dismissed', or 'escalated', and providing
 * details regarding any moderator actions taken (such as content removal, user
 * warning, or ban).
 *
 * Strict authorization is enforced: only the moderator, admin, or designated
 * staff may call this endpoint. The business logic ensures that report state
 * transitions follow allowed moderation workflows as per platform requirements
 * (e.g., only escalated reports can be moved to admin review, or only
 * resolved/dismissed status may close a report). All actions are tracked for
 * audit purposes, and actors must be verifiable community_platform_moderators
 * or community_platform_admins. Related content (posts/comments) and member
 * status may be updated as a side-effect depending on moderation result.
 *
 * Request body uses the ICommunityPlatformReport.IUpdate schema and must
 * include the report status, moderation_result, and identifier for the acting
 * user. Error handling details must follow platform error response standards
 * for insufficient permissions or invalid state transitions. This endpoint is
 * part of moderation/administrative workflows and should not be exposed to
 * regular end users.
 *
 * @param props.connection
 * @param props.reportId The UUID of the report to be updated.
 * @param props.body Information used to update the report status, moderation
 *   result, or assigned moderator/admin.
 * @path /communityPlatform/moderator/reports/:reportId
 * @accessor api.functional.communityPlatform.moderator.reports.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The UUID of the report to be updated. */
    reportId: string & tags.Format<"uuid">;

    /**
     * Information used to update the report status, moderation result, or
     * assigned moderator/admin.
     */
    body: ICommunityPlatformReport.IUpdate;
  };
  export type Body = ICommunityPlatformReport.IUpdate;
  export type Response = ICommunityPlatformReport;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/moderator/reports/:reportId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/moderator/reports/${encodeURIComponent(props.reportId ?? "null")}`;
  export const random = (): ICommunityPlatformReport =>
    typia.random<ICommunityPlatformReport>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reportId")(() => typia.assert(props.reportId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific report of inappropriate content from
 * community_platform_reports.
 *
 * This API endpoint enables a moderator or administrator to permanently delete
 * a report record from the platform, removing it from the
 * community_platform_reports table and clearing any moderation workflow history
 * associated with that report. Deleting a report may be allowed only for
 * resolved, dismissed, or clearly invalid/abusive reports, in line with
 * platform audit and compliance policy.
 *
 * Appropriate authorization (moderator or admin) is strictly enforced. Any
 * action is logged with actor, timestamp, and the specific reason for deletion,
 * as required for forensic audit. The operation may fail with an error if the
 * report is not eligible for deletion under business rules (e.g., if still
 * pending review or under escalation).
 *
 * No response body is returned on success. Proper error handling must be
 * implemented to inform the user of permission or state errors. This endpoint
 * should never be accessible by regular members or guests, and is only for
 * staff-level moderation usage.
 *
 * @param props.connection
 * @param props.reportId The UUID of the report to delete.
 * @path /communityPlatform/moderator/reports/:reportId
 * @accessor api.functional.communityPlatform.moderator.reports.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The UUID of the report to delete. */
    reportId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/moderator/reports/:reportId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/moderator/reports/${encodeURIComponent(props.reportId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reportId")(() => typia.assert(props.reportId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
