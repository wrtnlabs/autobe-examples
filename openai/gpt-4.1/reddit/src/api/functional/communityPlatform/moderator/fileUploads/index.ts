import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformFileUpload } from "../../../../structures/ICommunityPlatformFileUpload";

/**
 * Update metadata or logical status of an existing file upload in
 * community_platform_file_uploads.
 *
 * Authenticated members, moderators, or admins use this endpoint to update
 * non-binary metadata for a previously uploaded file. Allowed updates may
 * include renaming the file, updating the status ('active', 'deleted',
 * 'archived'), or changing the associated public URL when the file is moved in
 * storage. The file upload record is uniquely identified by fileUploadId
 * (UUID).
 *
 * This operation enforces strict permission checks: a member may only update
 * their own uploads; moderators and admins may update any file within their
 * scope. Attempting to update the status to 'deleted' marks the file as
 * soft-deleted and prevents further display/association but does not physically
 * remove stored content (to preserve integrity and audit). Updated file uploads
 * retain all prior relationships to posts, comments, communities, or profiles
 * unless deleted.
 *
 * Security requirements and audit protocols are enforced at every update,
 * ensuring the action is logged with member or role details. Related APIs
 * include endpoints for deleting file associations from posts or communities
 * and for retrieving file metadata by id.
 *
 * @param props.connection
 * @param props.fileUploadId Unique identifier of the file upload to update.
 * @param props.body Fields to update within the file upload metadata such as
 *   filename, status, or URL. Only non-binary changes allowed; actual
 *   storage/move/removal is out-of-band.
 * @path /communityPlatform/moderator/fileUploads/:fileUploadId
 * @accessor api.functional.communityPlatform.moderator.fileUploads.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the file upload to update. */
    fileUploadId: string & tags.Format<"uuid">;

    /**
     * Fields to update within the file upload metadata such as filename,
     * status, or URL. Only non-binary changes allowed; actual
     * storage/move/removal is out-of-band.
     */
    body: ICommunityPlatformFileUpload.IUpdate;
  };
  export type Body = ICommunityPlatformFileUpload.IUpdate;
  export type Response = ICommunityPlatformFileUpload;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/moderator/fileUploads/:fileUploadId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/moderator/fileUploads/${encodeURIComponent(props.fileUploadId ?? "null")}`;
  export const random = (): ICommunityPlatformFileUpload =>
    typia.random<ICommunityPlatformFileUpload>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("fileUploadId")(() => typia.assert(props.fileUploadId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently erase a file upload record from the platform database
 * (community_platform_file_uploads).
 *
 * The purpose of this operation is to delete a file upload entry from the
 * community_platform_file_uploads table, which tracks all files users have
 * uploaded to the platform (e.g., profile pictures, post images, community
 * banners/icons). The operation takes a fileUploadId as a path parameter and
 * will remove the associated row. This includes enforcing referential
 * integrity, meaning files used in banners, post images, or community images
 * are also removed if they lose their reference, according to onDelete:
 * Cascade.
 *
 * File records contain metadata for file location (storage_key, url), ownership
 * (uploaded_by_member_id), MIME type, and status (active, deleted). The field
 * 'deleted_at' is updated to the current timestamp when a soft deletion occurs;
 * for hard delete, the row is removed entirely. Deleting an upload is a
 * privileged action: only a moderator or admin may erase a file. The operation
 * ensures audit logging and may trigger further cleanups in related image or
 * post tables.
 *
 * Related operations include uploading a new file (POST), restoring (undelete)
 * a soft-deleted file, and listing files for a user or community. Validation
 * includes ensuring the fileUploadId exists, the user has correct role and
 * ownership or admin rights, and that the file is not currently required for
 * non-deletable key entities. Errors include attempting to delete files still
 * referenced as essential in the schema (e.g., a current banner image), lack of
 * permission, or not found (404).
 *
 * @param props.connection
 * @param props.fileUploadId Unique identifier for the file upload record to be
 *   deleted, must be UUID format.
 * @path /communityPlatform/moderator/fileUploads/:fileUploadId
 * @accessor api.functional.communityPlatform.moderator.fileUploads.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier for the file upload record to be deleted, must be
     * UUID format.
     */
    fileUploadId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/moderator/fileUploads/:fileUploadId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/moderator/fileUploads/${encodeURIComponent(props.fileUploadId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("fileUploadId")(() => typia.assert(props.fileUploadId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
