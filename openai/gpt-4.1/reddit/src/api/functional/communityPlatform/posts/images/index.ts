import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPostImage } from "../../../../structures/ICommunityPlatformPostImage";
import { IPageICommunityPlatformPostImage } from "../../../../structures/IPageICommunityPlatformPostImage";

/**
 * Retrieve the list of images attached to a specific post
 * (community_platform_post_images).
 *
 * Retrieve all images attached to a given post based on its unique identifier.
 * This operation allows users and clients to access the complete set of image
 * metadata for a post, supporting use cases such as gallery displays and
 * validating content limits.
 *
 * Access control is enforced so that only posts visible to the current user
 * will expose their images; if the post is private, restricted, or deleted,
 * appropriate error codes and messages are returned. Pagination parameters
 * allow for large posts with many images, and sorting by upload time or
 * ordering is supported for consistent rendering behavior.
 *
 * This operation cross-references the community_platform_post_images table and
 * includes relations to file uploads, including URLs, MIME types, and
 * user-attributed upload data. Error handling ensures that invalid post IDs,
 * non-existent posts, or access violations are treated with clear, actionable
 * messages. For each image, associated metadata—such as filename, order, and
 * file size—can be included in the response for rich client-side rendering.
 *
 * @param props.connection
 * @param props.postId The unique identifier of the post whose images are to be
 *   listed.
 * @param props.body Parameters for filtering and paginating image results for a
 *   given post.
 * @path /communityPlatform/posts/:postId/images
 * @accessor api.functional.communityPlatform.posts.images.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** The unique identifier of the post whose images are to be listed. */
    postId: string & tags.Format<"uuid">;

    /**
     * Parameters for filtering and paginating image results for a given
     * post.
     */
    body: ICommunityPlatformPostImage.IRequest;
  };
  export type Body = ICommunityPlatformPostImage.IRequest;
  export type Response = IPageICommunityPlatformPostImage;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/posts/:postId/images",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/posts/${encodeURIComponent(props.postId ?? "null")}/images`;
  export const random = (): IPageICommunityPlatformPostImage =>
    typia.random<IPageICommunityPlatformPostImage>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get complete metadata for a specific post image
 * (community_platform_post_images).
 *
 * Fetch details for a single image within a post by specifying both the post ID
 * and the image ID. The API retrieves metadata about the image, such as order,
 * stored file link, upload information, MIME type, file size, and original
 * filename.
 *
 * Permissions are handled by confirming that the requesting user is authorized
 * to view the associated post. If access is denied or if either the post or
 * image does not exist, the API will return a suitable error response. The
 * operation supports moderation and display workflows by returning all context
 * necessary for assessment, audit, or presentation.
 *
 * This endpoint directly references the community_platform_post_images table
 * and joins to community_platform_file_uploads for detailed file data. Error
 * handling provides clear outcomes for cases such as missing post, missing
 * image, or insufficient post access rights. The detailed information supports
 * both end-user viewing and background tasks like thumbnail generation or file
 * audits.
 *
 * @param props.connection
 * @param props.postId The UUID of the post containing the image.
 * @param props.imageId The UUID of the image to retrieve from the specified
 *   post.
 * @path /communityPlatform/posts/:postId/images/:imageId
 * @accessor api.functional.communityPlatform.posts.images.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The UUID of the post containing the image. */
    postId: string & tags.Format<"uuid">;

    /** The UUID of the image to retrieve from the specified post. */
    imageId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformPostImage;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/posts/:postId/images/:imageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/posts/${encodeURIComponent(props.postId ?? "null")}/images/${encodeURIComponent(props.imageId ?? "null")}`;
  export const random = (): ICommunityPlatformPostImage =>
    typia.random<ICommunityPlatformPostImage>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("imageId")(() => typia.assert(props.imageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
