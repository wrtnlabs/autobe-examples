import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformMember } from "../../../structures/ICommunityPlatformMember";

/**
 * Register a new platform member (community_platform_members table).
 *
 * This endpoint enables an unauthenticated user to register a new member
 * account in the Reddit-like community platform. The
 * 'community_platform_members' table is referenced, which has key fields:
 * 'email' (must be unique and valid for identification and contact),
 * 'password_hash' (only password hashes are stored for security),
 * 'email_verified' (initially set to false), and 'status' (such as 'active'
 * after verification).
 *
 * Upon receiving registration details, the platform will validate the email's
 * uniqueness—enforcing a one-user-per-email policy at the DB level to block
 * duplicates—and will require a password meeting policy. Passwords are hashed
 * (per the 'password_hash' field; plaintext passwords are never stored or
 * returned). The user's 'email_verified' is false after registration,
 * preventing all member-only actions until a separate verification operation
 * completes.
 *
 * Post-registration, a verification email workflow is triggered, and the
 * created member receives a verification link. Until verified, feature access
 * is restricted in accordance with the 'email_verified' boolean field and
 * business requirement. The 'status' field in the schema allows for additional
 * workflow enforcement if 'blocked' or 'pending' during specific business
 * cases.
 *
 * This registration ('join') endpoint is a prerequisite for all subsequent
 * authentication flows (login, refresh, etc.) and is referenced by business
 * policies for onboarding and security enforcement.
 *
 * Related security endpoints include login, refresh, email verification, and
 * password management, each using the base member schema for logic
 * enforcement.
 *
 * @param props.connection
 * @param props.body Payload for member registration (requires unique email and
 *   password hash)
 * @setHeader token.access Authorization
 *
 * @path /auth/member/join
 * @accessor api.functional.auth.member.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Payload for member registration (requires unique email and password
     * hash)
     */
    body: ICommunityPlatformMember.ICreate;
  };
  export type Body = ICommunityPlatformMember.ICreate;
  export type Response = ICommunityPlatformMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/join";
  export const random = (): ICommunityPlatformMember.IAuthorized =>
    typia.random<ICommunityPlatformMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate an existing platform member and issue authorization tokens
 * (community_platform_members table).
 *
 * This operation enables an existing platform member to log in by submitting
 * their registered email and password. The 'community_platform_members' table
 * schema is used, relying on these key fields: 'email' (to lookup user),
 * 'password_hash' (to securely verify the supplied password against the hash),
 * 'email_verified' (must be true for login), and 'status' (must be 'active' for
 * session establishment).
 *
 * Upon receiving credentials, the operation validates the email exists,
 * compares the provided password (after hashing) with the stored
 * 'password_hash', and checks the member's status and verification flag. If all
 * checks pass, the operation issues a JWT access token for immediate platform
 * activity and a refresh token (issued as per business session rules) so
 * clients can maintain authenticated state across sessions.
 *
 * If credentials do not match, the account is unverified, or 'status' is not
 * 'active', the login fails with appropriate error handling as per business
 * policy (including rate limiting on repeated failures, reference 'status'
 * field for blocks/suspensions). All tokens are generated using platform best
 * practices. Related authentication operations include registration ('join'),
 * token refresh, email verification, logout, and password recovery, all using
 * the 'community_platform_members' schema for logic enforcement.
 *
 * @param props.connection
 * @param props.body Payload for member login (email and password required)
 * @setHeader token.access Authorization
 *
 * @path /auth/member/login
 * @accessor api.functional.auth.member.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Payload for member login (email and password required) */
    body: ICommunityPlatformMember.ILogin;
  };
  export type Body = ICommunityPlatformMember.ILogin;
  export type Response = ICommunityPlatformMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/login";
  export const random = (): ICommunityPlatformMember.IAuthorized =>
    typia.random<ICommunityPlatformMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Renew member authentication tokens using valid refresh token
 * (community_platform_members table).
 *
 * This endpoint enables authenticated platform members to renew their session
 * tokens by presenting a valid refresh token. The operation works within the
 * security boundaries described by the 'community_platform_members' table,
 * referencing the member via session context, ensuring the 'status' field is
 * 'active' and the refresh token is valid, not expired, and not revoked (if
 * revocation logic is implemented outside the schema).
 *
 * If the refresh token is valid and the member's account status is acceptable,
 * the server issues a new JWT access token and a new refresh token, ensuring
 * ongoing authenticated platform interaction without repeated full logins. If
 * the operation detects a revoked/expired refresh token, or if the member is
 * blocked or deleted, it rejects the request and requires manual
 * re-authentication.
 *
 * The refresh endpoint is central for maintaining seamless authenticated user
 * flows, reducing friction from session expiration and increasing security. It
 * is referenced by all client session management logic and expected to comply
 * with session expiry, device tracking, and revocation business rules.
 *
 * All session logic is governed by platform-wide security policy but
 * fundamentally relies on the ongoing existence and status value of the
 * 'community_platform_members' schema for enforcement.
 *
 * @param props.connection
 * @param props.body Payload containing the refresh token for session
 *   continuation
 * @setHeader token.access Authorization
 *
 * @path /auth/member/refresh
 * @accessor api.functional.auth.member.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Payload containing the refresh token for session continuation */
    body: ICommunityPlatformMember.IRefresh;
  };
  export type Body = ICommunityPlatformMember.IRefresh;
  export type Response = ICommunityPlatformMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/refresh";
  export const random = (): ICommunityPlatformMember.IAuthorized =>
    typia.random<ICommunityPlatformMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
