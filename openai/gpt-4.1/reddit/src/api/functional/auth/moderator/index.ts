import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformModerator } from "../../../structures/ICommunityPlatformModerator";

/**
 * Register a new moderator (community_platform_moderators) account and issue
 * authorization tokens.
 *
 * This API operation enables the creation and registration of a new moderator
 * account on the platform, as defined by the 'community_platform_moderators'
 * table. It requires a unique email address—which is also verified at the
 * member layer—and a secure password. Community assignment and linkage to the
 * corresponding 'community_platform_members' record are enforced, validating
 * that the registering user qualifies as a member before they can become a
 * moderator. Upon successful creation, the moderator receives an initial
 * authorization token that allows them to access moderator-specific functions,
 * but only within their assigned communities.
 *
 * Implementation enforces email uniqueness, ensures linkage to both the member
 * and target community, and creates audit timestamps for registration and any
 * updates. The 'password_hash' is generated server-side from the provided
 * password using a secure hashing algorithm (e.g., bcrypt). The operation
 * enforces business rules confirming the user was previously verified as a
 * member.
 *
 * By restricting the operation to the moderator table and required
 * relationships, the API integrates seamlessly into the platform's role and
 * permissions structure. After registration, moderators are granted heightened
 * credentials and authorization to perform moderation actions within their
 * respective communities.
 *
 * Security is ensured by validating prior member status, unique email
 * assignment, and by securely handling password storage as specified in the
 * schema. All sensitive operations—such as creation and update—are logged for
 * audit purposes. Workflow ensures that no moderator account can be provisioned
 * without first passing membership requirements, preventing unauthorized
 * privilege escalation.
 *
 * Related operations include member registration, email verification, and
 * login. Upon successful registration, follow-up authentication and privileged
 * session management are expected to be performed according to the platform's
 * authorization flows.
 *
 * @param props.connection
 * @param props.body Moderator registration information (email, password,
 *   community assignment).
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/join
 * @accessor api.functional.auth.moderator.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Moderator registration information (email, password, community
     * assignment).
     */
    body: ICommunityPlatformModerator.IJoin;
  };
  export type Body = ICommunityPlatformModerator.IJoin;
  export type Response = ICommunityPlatformModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/join";
  export const random = (): ICommunityPlatformModerator.IAuthorized =>
    typia.random<ICommunityPlatformModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate an existing moderator account and issue new JWT tokens.
 *
 * This operation enables a moderator to authenticate using their email and
 * password, as referenced by the 'community_platform_moderators' table. Success
 * requires the moderator's status to be 'active' and linked to a valid,
 * verified member account. The supplied password is checked against the stored
 * server-side 'password_hash'. On valid authentication, the API issues JWT
 * access and refresh tokens, including role and permission scopes specific to
 * the moderator's assigned communities.
 *
 * The system checks for suspension, resignations, or deletions using the
 * 'status' and 'deleted_at' fields before allowing login or session creation,
 * denying access if any restrict the account. Accurate audit logs are mandatory
 * for all login attempts, successful or failed, to ensure traceability and
 * security compliance.
 *
 * Session management integrates with platform-wide authorization enforcement.
 * On login, the API returns a structured authentication DTO including current
 * moderator identity, session information, and role scope, as specified by the
 * authentication operation pattern.
 *
 * Security measures include rate limiting, secure comparison of stored and
 * entered passwords, and plain-language error reporting that avoids leaking
 * sensitive account states (e.g., distinguishing between non-existent email and
 * wrong password is not allowed in responses).
 *
 * Related flows: registration (join), token refresh, and logout. The login
 * outcome is prerequisite for any subsequent privileged moderator operations
 * within the platform.
 *
 * @param props.connection
 * @param props.body Moderator login information (email and password).
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/login
 * @accessor api.functional.auth.moderator.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Moderator login information (email and password). */
    body: ICommunityPlatformModerator.ILogin;
  };
  export type Body = ICommunityPlatformModerator.ILogin;
  export type Response = ICommunityPlatformModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/login";
  export const random = (): ICommunityPlatformModerator.IAuthorized =>
    typia.random<ICommunityPlatformModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh a moderator's JWT tokens using a valid refresh token
 * (community_platform_moderators).
 *
 * This API operation issues a fresh pair of JWT tokens for a moderator user,
 * provided that a valid, unexpired refresh token is supplied. The
 * 'community_platform_moderators' schema stores all credentials and status
 * flags necessary to determine the account's validity. The operation confirms
 * both the integrity of the refresh token and that the account has not been
 * suspended or deleted ('status', 'deleted_at'), preventing any privilege
 * escalation or reactivation of removed users.
 *
 * Tokens are generated based on the platform's security policy, such as
 * including moderator's unique ID, assigned community scope, the role
 * 'moderator', and explicit permissions in the JWT payload. This promotes
 * precise session scoping and execution of moderator-only platform operations.
 *
 * Security practices require all refresh attempts to be logged for auditing.
 * The endpoint must handle errors gracefully, never revealing whether failures
 * are due to an invalid token or an account restriction (to avoid information
 * leakage about moderator existence or status).
 *
 * After successful refresh, the returned DTO provides updated session and
 * authorization details. This operation is related to the moderator's initial
 * login, logout, and any privileged moderator workflow.
 *
 * @param props.connection
 * @param props.body Moderator refresh token submission for obtaining new JWT
 *   tokens.
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/refresh
 * @accessor api.functional.auth.moderator.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Moderator refresh token submission for obtaining new JWT tokens. */
    body: ICommunityPlatformModerator.IRefresh;
  };
  export type Body = ICommunityPlatformModerator.IRefresh;
  export type Response = ICommunityPlatformModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/refresh";
  export const random = (): ICommunityPlatformModerator.IAuthorized =>
    typia.random<ICommunityPlatformModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
