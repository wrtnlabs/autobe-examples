import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformGuest } from "../../../structures/ICommunityPlatformGuest";

/**
 * Create a new guest session (community_platform_guests table) for
 * unauthenticated users.
 *
 * This endpoint is intended for new unauthenticated visitors who wish to begin
 * exploring the platform under an anonymous session. The purpose is to
 * transparently create an ephemeral guest entity in the
 * 'community_platform_guests' table, with a unique 'session_key' for the
 * tracking session. No identity is established; it is for navigation and
 * anti-abuse traceability only.
 *
 * Implementation utilizes the minimal schema fields found in
 * 'community_platform_guests': 'session_key' (for tracking), auto-generated
 * 'id', 'created_at', and optional 'deleted_at' for respecting erasure or log
 * rotation requests. No authentication or credential validation is performed at
 * this stage, in accordance with the business requirements for guests.
 *
 * As guests are non-authenticated by design, there is no associated login or
 * protected operations, only anonymous browsing and metadata establishment.
 * Guests are not permitted to post, vote, comment, or report.
 *
 * Security: The endpoint is intentionally open-access, but must not create
 * overlapping session_keys; unique constraint is enforced for traceability and
 * anti-abuse.
 *
 * This operation is foundational for tracking site navigation, enforcing
 * anonymous participation quotas/limits, and supporting future upgrade
 * workflows to member accounts. Related flows: guests later registering as
 * members is a separate operation; session tracking/expiry and cleanup can be
 * managed via the 'deleted_at' field.
 *
 * @param props.connection
 * @param props.body Guest session initiation information for tracking and
 *   anonymous navigation (should minimally include session key, if supplied by
 *   frontend).
 * @setHeader token.access Authorization
 *
 * @path /auth/guest/join
 * @accessor api.functional.auth.guest.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Guest session initiation information for tracking and anonymous
     * navigation (should minimally include session key, if supplied by
     * frontend).
     */
    body: ICommunityPlatformGuest.ICreate;
  };
  export type Body = ICommunityPlatformGuest.ICreate;
  export type Response = ICommunityPlatformGuest.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guest/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guest/join";
  export const random = (): ICommunityPlatformGuest.IAuthorized =>
    typia.random<ICommunityPlatformGuest.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh a guest session token (community_platform_guests) to continue
 * anonymous site usage.
 *
 * This endpoint provides a way for anonymous users (platform guests) to refresh
 * their browsing session and continue using the platform without upgrading to
 * authenticated member status. The refresh mechanism operates strictly within
 * the constraints of the 'community_platform_guests' schema. The guest is
 * identified using 'session_key' or 'id', both of which must remain unique and
 * active (not pseudo-deleted).
 *
 * No privileged or personal fields exist in this schema; only ephemeral and
 * session metadata are used. The operation does not depend on credentials, but
 * solely on valid, non-expired guest records. If the session has been revoked
 * or guest record deleted (via 'deleted_at'), the operation must reject the
 * request and indicate session expiration.
 *
 * This operation is intended for session continuation and supports anti-abuse
 * measures (rate limits, etc.) via the tracked guest identity. Guests cannot
 * perform member actions (posting, voting, etc.) even with a refreshed
 * session.
 *
 * The operation is public, limited in scope, and should be strictly isolated
 * from member authentication and data flows. Related operations:
 * /auth/guest/join for initial session, /auth/member/join for upgrade to
 * member, and guest session cleanup on expiry or logout.
 *
 * @param props.connection
 * @param props.body Required context (session_key or id) for refreshing guest
 *   session token to maintain anonymous browsing context.
 * @setHeader token.access Authorization
 *
 * @path /auth/guest/refresh
 * @accessor api.functional.auth.guest.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Required context (session_key or id) for refreshing guest session
     * token to maintain anonymous browsing context.
     */
    body: ICommunityPlatformGuest.IRefresh;
  };
  export type Body = ICommunityPlatformGuest.IRefresh;
  export type Response = ICommunityPlatformGuest.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guest/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guest/refresh";
  export const random = (): ICommunityPlatformGuest.IAuthorized =>
    typia.random<ICommunityPlatformGuest.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
