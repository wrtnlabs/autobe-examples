import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformAdmin } from "../../../structures/ICommunityPlatformAdmin";

/**
 * Register a new admin in the community_platform_admins table with full
 * authentication onboarding.
 *
 * This endpoint facilitates registration of new platform administrators by
 * creating a record in the 'community_platform_admins' table. Administrators
 * must supply a unique email address, a secure password (hashed upon receipt),
 * a 'superuser' Boolean flag (if the registering actor has this capability),
 * and an initial status (typically set to 'active'). The operation relies
 * strictly on the email, password_hash, superuser, and status columns in the
 * table. All registration requests are thoroughly validated, and email
 * uniqueness is enforced to prevent duplication. Upon successful registration,
 * a JWT-based authorization response is issued that conveys the admin's access
 * token and refresh token, as required by the platform's session and token
 * rules. This endpoint forms the basis of the administrator onboarding and is a
 * prerequisite for all further admin authentication flows.
 *
 * Credentials are never stored in plaintext; password_hash is mandatory and
 * created via secure cryptographic hashing before storage. The endpoint will
 * reject registration attempts with duplicate emails, or in cases where
 * required information is missing. All registration and subsequent actions are
 * logged for auditability through the community_platform_audit_logs table.
 * Registration can only be performed through this endpoint; no alternative join
 * flows for platform admins are provided.
 *
 * Administrators who successfully register have platform-wide authority, but
 * actions may still be subject to status review or role-based access checks for
 * superuser-privileged APIs, ensuring platform security and administrative
 * separation of duties. The JWT token payload will reflect the admin role and
 * initial permissions per system configuration.
 *
 * Security reviews are required for all admin registration flows. Strong
 * validation and cryptographic policies are enforced at all stages. Duplicate,
 * weak, or compromised passwords are strictly disallowed per policy.
 *
 * Related operations: admin login (authentication), admin token refresh, and
 * status/suspension management. The join operation is the entry-point for all
 * admin authentication flows and must be executed first.
 *
 * @param props.connection
 * @param props.body Admin registration information for onboarding a new
 *   administrator account.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/join
 * @accessor api.functional.auth.admin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Admin registration information for onboarding a new administrator
     * account.
     */
    body: ICommunityPlatformAdmin.ICreate;
  };
  export type Body = ICommunityPlatformAdmin.ICreate;
  export type Response = ICommunityPlatformAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/join";
  export const random = (): ICommunityPlatformAdmin.IAuthorized =>
    typia.random<ICommunityPlatformAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate an admin with email and password; issue tokens if credentials
 * match community_platform_admins table.
 *
 * This endpoint authenticates an existing platform administrator by verifying
 * their credentials against the 'community_platform_admins' table. The admin
 * must supply a valid, unique email and password. The password is hashed on
 * receipt using secure algorithms and compared with the stored 'password_hash'
 * from the schema. Only active accounts with 'status' set to 'active' will be
 * permitted to log in, as specified by the status column.
 *
 * Upon successful authentication, the system issues a JWT access token (for
 * immediate use) and a refresh token (for session renewal). Both tokens are
 * embedded in a structured response object conforming to the platform's
 * authentication requirements and session/token rules. Credentials are never
 * exposed or stored in plaintext at any stage. Failed login attempts—including
 * attempts with invalid passwords or for suspended/deleted accounts—are logged
 * for audit, and repeated failed attempts may trigger account lockout as per
 * business rules.
 *
 * The login flow leverages the exact fields present in the schema: 'email',
 * 'password_hash', 'superuser', and 'status'. Invalid or locked accounts are
 * denied login and a generic authentication failure message is returned to
 * prevent information disclosure. This operation is a critical part of the
 * platform's administrator authentication suite and forms the basis of all
 * subsequent privileged admin sessions.
 *
 * The endpoint is implemented strictly to enforce administrative security,
 * logging, and credential isolation. It is paired with admin registration and
 * token refresh operations for a complete authentication flow.
 *
 * Security reviews and cryptographic audits are essential for this endpoint.
 * All tokens are issued following approved JWT/token management policies. Rate
 * limiting and brute force protections are in place for this endpoint to
 * protect against abuse and credential stuffing attacks.
 *
 * Related operations: /auth/admin/join for registration, /auth/admin/refresh
 * for token renewal. The login must precede all authenticated admin actions.
 *
 * @param props.connection
 * @param props.body Admin login credentials (email, password).
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/login
 * @accessor api.functional.auth.admin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Admin login credentials (email, password). */
    body: ICommunityPlatformAdmin.ILogin;
  };
  export type Body = ICommunityPlatformAdmin.ILogin;
  export type Response = ICommunityPlatformAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/login";
  export const random = (): ICommunityPlatformAdmin.IAuthorized =>
    typia.random<ICommunityPlatformAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh admin's JWT session tokens using a valid current refresh token
 * (community_platform_admins table).
 *
 * This endpoint allows an authenticated platform administrator to renew their
 * session by exchanging a valid refresh token for a new set of tokens. The
 * operation checks the validity and authenticity of the provided refresh token,
 * referencing active tokens tied to the admin in the
 * 'community_platform_admins' table. Only admins with 'status' set to 'active'
 * may successfully refresh their tokens. The system rejects requests using
 * expired, revoked, or invalid refresh tokens, or for accounts marked
 * 'suspended' or 'deleted' via the status and deleted_at columns.
 *
 * On successful validation, the system returns a new JWT access token
 * (short-lived) and a fresh refresh token (with original or truncated expiry).
 * The tokens' payload reflects the admin's access rights, current status, and
 * superuser setting. The refresh flow ensures that administrative session
 * continuity stays secure and self-contained, in line with platform
 * session/token renewal standards.
 *
 * All refresh token requests—whether accepted or rejected—are logged via the
 * 'community_platform_audit_logs' table to ensure complete traceability.
 * Attempts to refresh using a token associated with an inactive admin account
 * are strictly denied. Security policies ensure strong protections against
 * refresh token misuse, theft, or replay.
 *
 * This endpoint is a core element for administrative session management and is
 * mandatory for uninterrupted admin workflows requiring extended
 * authentication. It works together with /auth/admin/login and /auth/admin/join
 * for a secure admin session lifecycle.
 *
 * @param props.connection
 * @param props.body Refresh token payload for admin session renewal.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/refresh
 * @accessor api.functional.auth.admin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token payload for admin session renewal. */
    body: ICommunityPlatformAdmin.IRefresh;
  };
  export type Body = ICommunityPlatformAdmin.IRefresh;
  export type Response = ICommunityPlatformAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/refresh";
  export const random = (): ICommunityPlatformAdmin.IAuthorized =>
    typia.random<ICommunityPlatformAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
