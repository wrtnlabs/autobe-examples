[{"id":"0199bff8-f46c-7417-90c9-93ddeaee0633","type":"userMessage","contents":[{"type":"text","text":"I want to create a Todo list application.\r\n\r\nWhen I build an application, I only want the minimum functionality required for Todo list.\r\n\r\nSince I'm not familiar with programming, please write a requirements analysis report as you see fit."}],"created_at":"2025-10-07T18:39:47.820Z"},{"type":"analyze","id":"0199c000-a554-715c-b3a8-bb816eb205ff","instruction":"User request: build a Todo list application with only the minimum functionality required. The user is not familiar with programming and has explicitly delegated planning to the assistant: \"please write a requirements analysis report as you see fit.\" Produce a structured requirements analysis for a minimal Todo app. Requirements to include: system purpose and goals, core features (only essential features for a Todo list), user roles (if any) and permissions (keep minimal), main data entities and their attributes (high-level, not database schema), key business rules and constraints, acceptance criteria and simple user stories, basic API surface (high-level endpoints summary is acceptable but do NOT include detailed DTOs or implementation), minimal non-functional requirements (persistence, backups optional), and any assumptions made. Prioritize being minimal and avoid adding extra features not necessary for a basic Todo list. Highlight any open questions or decisions that should be confirmed by the user (e.g., authentication, multi-user support, due dates, priorities, sync). Keep language simple and suitable for a non-technical user. Include clear acceptance criteria so later phases can design DB and APIs from this analysis.","prefix":"todoApp","roles":[{"name":"guest","description":"Unauthenticated visitor who can view public landing information and help content but cannot create, view, modify, or delete todos. Guests cannot authenticate via API and have no persistent personal data.","kind":"guest"},{"name":"user","description":"Authenticated standard user who can register, authenticate via API, and manage their own todos (create, read, update, delete, mark complete/incomplete). Can set optional attributes such as due date and priority for each todo. Cannot access other users' data or administrative functions.","kind":"member"},{"name":"admin","description":"Authenticated administrator who can authenticate via API and perform elevated management tasks: view aggregate usage, manage user accounts (suspend/reactivate), and perform data maintenance operations. Admins may also act as a regular user for troubleshooting but must be audited when performing admin actions.","kind":"admin"}],"files":[{"reason":"Table of contents for the entire requirements document set. Lists every document and provides navigation.","filename":"00-toc.md","documentType":"service-overview","outline":["Table of contents listing all documents","Document index with short descriptions and intended audience","Navigation notes and ordering","Developer note about implementation autonomy (required by project guidelines)"],"audience":"All project stakeholders (product, development, QA, operations)","keyQuestions":["What documents are included in this requirements package?","Who is the intended audience for each document?"],"detailLevel":"high-level","relatedDocuments":[],"constraints":["Must include an index entry for every document in this files list","Developer note must be included at the end of this file per project rules"],"content":"# todoApp — Requirements Analysis (Minimal Todo List MVP)\n\n## Executive Summary\n\ntodoApp provides a minimal, single-user task list that enables quick task capture, reliable persistence for authenticated users, and a simple, auditable admin interface for maintenance. The MVP focuses on low friction for task entry and clear task lifecycle semantics: create → active → complete → deleted (soft-delete) → purge. Acceptance targets prioritize responsiveness (primary actions visible within 2 seconds) and data isolation (users only see their own todos).\n\n## Scope and Assumptions\n\nIn-scope (MVP):\n- Account authentication and per-user persistence (user role)\n- Create, read (list/detail), update, mark complete/uncomplete, soft-delete with recovery window, and permanent purge workflow\n- Basic optional attributes per todo: description (optional), due date (optional), priority (optional: low/medium/high)\n- Admin role with account suspend/reactivate and auditable maintenance actions\n\nOut-of-scope (MVP):\n- Collaboration or sharing, tags, subtasks, attachments, recurring tasks, push notifications, or integrations beyond optional email for account recovery\n\nAssumptions:\n- The product targets individual users who value a simple task list and privacy by default\n- Soft-delete retention default: 30 days (configurable by product)\n- Access to email for password reset is available in the deployment environment (product to confirm)\n\n## User Roles and Permission Matrix\n\nRoles (business terms):\n- guest — view public landing/help only; cannot create or persist todos\n- user — create, view, update, mark complete/uncomplete, delete (soft-delete) own todos; manage own account\n- admin — suspend/reactivate accounts; perform data maintenance; may read other users' data for support but such access SHALL be logged and auditable\n\nPermission matrix (high-level):\n- Create todo: guest ❌ | user ✅ | admin ✅ (audited)\n- Read own todos: guest ❌ | user ✅ | admin ✅ (audited)\n- Update own todos: guest ❌ | user ✅ | admin ✅ (audited)\n- Delete/soft-delete: guest ❌ | user ✅ | admin ✅ (audited)\n- Suspend/reactivate accounts: guest ❌ | user ❌ | admin ✅\n\n## Primary User Scenarios and Acceptance Criteria\n\nScenario: Register and sign in (if authentication is enabled)\n- WHEN a visitor registers with valid credentials, THE system SHALL create an account and allow authentication.\n- Acceptance: A new user can register, sign in, create a todo, sign out, sign in again, and see the previously created todo within 2 seconds in normal conditions.\n\nScenario: Quick task capture\n- WHEN an authenticated user enters a non-empty title and submits create, THE system SHALL persist a new todo with status \"active\" and CreatedAt timestamp.\n- Acceptance: Created todo appears in the default list (newest-first) within 2 seconds in 95% of typical cases.\n\nScenario: Edit a todo\n- WHEN an authenticated user updates fields for a todo they own, THE system SHALL apply changes and update UpdatedAt.\n- Acceptance: Changes are visible to the same user within 2 seconds.\n\nScenario: Mark complete/uncomplete\n- WHEN a user marks a todo complete, THE system SHALL set status \"completed\" and set CompletedAt; when uncomplete, THE system SHALL set status \"active\" and clear CompletedAt.\n- Acceptance: Completed items are distinguishable and can be toggled back to active within 2 seconds.\n\nScenario: Delete and recover\n- WHEN a user deletes a todo, THE system SHALL soft-delete the item (status \"deleted\") and retain it for 30 days for possible recovery; after 30 days THE system SHALL purge the item.\n- Acceptance: Deleted items are removed from active lists immediately and can be restored by owner within retention window.\n\nAdmin scenario: Suspend/reactivate\n- WHEN an admin suspends a user, THE system SHALL prevent that user from authenticating and SHALL retain the user's data for administrative review; admin action SHALL be recorded in audit logs.\n- Acceptance: Suspended users cannot authenticate and audit entries contain admin id, action, and timestamp.\n\n## Functional Requirements (EARS Format)\n\nAuthentication and account\n- WHEN a visitor registers with valid credentials, THE system SHALL create a new account and allow the user to authenticate.\n- WHEN a user submits valid credentials, THE system SHALL authenticate the user and grant a session.\n- IF an unauthenticated actor attempts a todo-management action, THEN THE system SHALL deny the request and return an authorization error.\n\nTodo lifecycle\n- WHEN an authenticated user submits a create-todo request with a non-empty title, THE system SHALL create a TodoItem with status \"active\", set CreatedAt to current timestamp, associate the item with the user's account, and return the created item in the response.\n- IF a create or update request contains an empty or whitespace-only title, THEN THE system SHALL reject the request and return a validation error stating \"Title is required and must be 1-250 characters.\" \n- WHEN a user marks a todo complete, THE system SHALL set status to \"completed\" and set CompletedAt to current timestamp; WHEN a user unmarks a completed todo, THE system SHALL set status back to \"active\" and clear CompletedAt.\n- WHEN a user updates a todo, THE system SHALL permit edits only on todos owned by that user and SHALL reject updates attempting to modify another user's todo.\n- WHEN a user deletes a todo, THE system SHALL set status to \"deleted\", set DeletedAt timestamp, and remove the item from default active list; THE system SHALL retain deleted items for 30 days before purge.\n\nAdmin and audit\n- WHEN an admin performs any action that accesses or modifies user data, THE system SHALL record an audit entry with admin identifier, target user, action type, timestamp, and (optionally) reason.\n- WHEN an admin suspends a user, THE system SHALL prevent new authentications for that account and invalidate refresh tokens.\n\nOptional (WHERE):\n- WHERE export is enabled, THE system SHALL provide a user-level export of todos in CSV format containing state timestamps.\n\n## Authentication and Session Management (Business Terms)\n\nAuthentication model: token-based sessions for API access (business guidance recommends JWTs).\n- Access token lifetime (recommended business default): 20 minutes.\n- Refresh token lifetime (recommended business default): 14 days.\n- WHEN a refresh token is revoked (user or admin action), THE system SHALL prevent issuance of new access tokens using that refresh token and shall require re-authentication for further access.\n- WHEN a user requests password reset, THE system SHALL send a time-limited reset link to the account email that expires after 24 hours.\n- WHEN an account is suspended by an admin, THE system SHALL invalidate active refresh tokens within 30 seconds and deny authentication attempts.\n\nSecurity & privacy (business-level):\n- All user-created todos are visible only to the owning user unless an admin accesses them for support; admin accesses SHALL be auditable.\n\n## Data Model (Conceptual, Non-technical)\n\nTodoItem (conceptual attributes): todoId, ownerId, title (required), description (optional), createdAt, updatedAt, dueDate (optional), priority (optional: low|medium|high), completedAt (optional), status (active|completed|deleted), deletedAt (optional).\n\nUserAccount (conceptual attributes): accountId, email, displayName, accountStatus (active|suspended), createdAt.\n\nAuditRecord (conceptual attributes): actorId, actorRole (admin|user), actionType, targetResource, timestamp, reason (optional).\n\n## Data Lifecycle and Retention\n\nLifecycle states: Active -> Completed -> Deleted (soft) -> Permanently Deleted\n\nMermaid lifecycle diagram:\n\n```mermaid\ngraph LR\n  A[\"Active\"] --> B[\"Completed\"]\n  B --> C[\"Deleted (Soft)\"]\n  A --> C\n  C --> D[\"Permanently Deleted\"]\n  C --> E[\"Restored\"]\n  E --> A\n```\n\nRetention rules (business defaults):\n- Deleted items retained for 30 days before eligible for permanent purge.\n- Audit records retained for 365 days.\n- Backups retained per operations policy; recommended RPO <= 1 hour and RTO <= 4 hours for critical incidents.\n\n## Non-Functional Requirements (Measurable)\n\nPerformance and responsiveness:\n- WHEN a user performs create/read/update/delete on individual todo, THE system SHALL reflect the result in the UI within 2 seconds for 95th percentile under typical MVP load.\n- WHEN a user requests their todo list (<= 50 items), THE system SHALL return results within 1 second median and <= 2 seconds at 95th percentile under typical load.\n\nAvailability:\n- Target availability for MVP: 99.9% monthly uptime excluding scheduled maintenance.\n\nScalability and rate limiting:\n- Recommend write limit of 10 write requests per minute per user for MVP; WHEN exceeded, THE system SHALL return a rate-limit error with Retry-After guidance.\n\nSecurity and compliance:\n- Account lockout after 10 failed attempts in 15 minutes; admin review or password reset required to restore.\n- Data subject export and deletion support: exports provided within 7 days, deletion processed within 30 days unless legal hold applies.\n\nMonitoring and operations:\n- WHEN production error rate exceeds 1% for 5 continuous minutes, THE system SHALL alert on-call and create an incident ticket.\n\n## Error Handling, Secondary Scenarios and Conflict Resolution\n\nOffline behavior (optional):\n- WHEN a client is offline and a user performs create/update actions, THE client SHALL queue actions and present \"pending sync\" indicators; WHEN connectivity is restored, THE client SHALL sync queued changes within 30 seconds and present any conflicts.\n\nConflict handling (business-level):\n- WHEN concurrent updates to the same field occur, THE system SHALL surface a conflict and provide the user options: \"Keep My Version\", \"Keep Server Version\", or \"Merge Manually\". For MVP, last-writer-wins is acceptable, but conflicts SHALL be detectable and surfaced.\n\nValidation error messaging:\n- IF a user submits invalid input (empty title, invalid date, invalid priority), THEN THE system SHALL return a clear field-level validation error and preserve user input for retry.\n\nUndo and recovery:\n- WHEN a user deletes a todo, THE system SHALL show an immediate \"Undo\" action for 30 seconds to restore the item to its previous state.\n\nAdmin recovery procedures (business-level):\n- Admins may restore soft-deleted items within retention window via an auditable restore action; restoration SHALL be logged with admin id and reason.\n\n## Acceptance Criteria and Test Checklist\n\n- Core actions (create/read/update/delete) shall pass functional acceptance tests 95% of the time under representative loads.\n- Security tests: account lockout, password reset flow, admin audit logging must be verified.\n- Data isolation tests: users cannot access other users' todos; admin access is audited.\n- Retention tests: delete -> restore within 30 days works; restore after 30 days is not possible.\n- Performance tests: list <=50 items returns within 1s median in staging tests.\n\n## KPIs and Success Metrics (90-day launch window)\n\n- Activation: >= 40% of new accounts create at least one todo within 7 days.\n- Retention: 7-day retention >= 25%; 30-day retention >= 10% (benchmarks to validate product-market fit).\n- Reliability: create request success rate >= 99.5% under typical load.\n- Performance: 95th percentile response times for primary actions <= 2 seconds.\n\n## Mermaid Diagrams (User Session Flow)\n\n```mermaid\ngraph LR\n  A[\"Visitor\"] --> B{\"Authenticated?\"}\n  B -->|\"No\"| C[\"Show Landing / Sign In / Register\"]\n  B -->|\"Yes\"| D[\"Show User Todo List\"]\n  D --> E[\"Create Todo (title required)\"]\n  E --> F[\"Todo Saved as 'active'\"]\n  F --> G[\"List shows task (newest-first)\"]\n  G --> H[\"User marks complete\"]\n  H --> I[\"Task status 'completed' and CompletedAt set\"]\n  I --> J[\"User deletes task (soft-delete)\"]\n  J --> K[\"Task status 'deleted' (recoverable for 30 days)\"]\n```\n\n## Open Decisions and Recommendations\n\n- Confirm whether email verification is mandatory at registration for MVP (recommended: optional with verification recommended for trustworthiness).\n- Confirm whether dueDate and priority are required in MVP or deferred to post-MVP (recommended: optional behind \"Add details\").\n- Confirm retention durations for soft-delete and archived items; recommended defaults: 30 days (deleted), 365 days (archived).\n- Clarify whether JWTs are mandated or if session cookies are acceptable; business guidance recommends JWT patterns with short-lived access tokens and refresh tokens as described above.\n\n## Appendices\n\nA: Glossary — definitions for terms used (Active, Completed, Deleted, Purge, RTO, RPO)\n\nB: Change Log Template\n- Document: todoApp Requirements Analysis\n- Version: 1.0\n- Date: YYYY-MM-DD\n- Author: [Name]\n- Summary: Initial MVP requirements\n\nC: QA Checklist (quick)\n- Register/login flows\n- Create/edit/delete/complete flows and validations\n- Soft-delete retention and restore\n- Admin suspend/reactivate and audit entries\n- Performance and rate-limit tests\n\n\n\n"},{"reason":"Establish the service vision, business justification, and high-level goals for the Todo app.","filename":"01-service-overview.md","documentType":"service-overview","outline":["Executive summary and purpose","Business justification and market context","Target users and user segments","Core value proposition and minimal differentiators","Success metrics and KPIs","High-level project goals and scope (minimal feature set)"],"audience":"Product owners, business stakeholders, and development leads","keyQuestions":["Why should this Todo app exist?","Who are the target users and what core problem does it solve?","What are the measurable success metrics for the MVP?"],"detailLevel":"moderate detail","relatedDocuments":["02-problem-definition.md","03-core-value-proposition.md"],"constraints":["Focus on minimal viable feature set","Avoid prescribing implementation details"],"content":"# todoApp — Requirements Analysis Report (Minimal MVP)\n\n## Executive Summary\n\ntodoApp delivers a minimal, reliable personal todo list for individuals who want fast task capture and simple lifecycle management. The MVP prioritizes: (1) frictionless task entry, (2) reliable per-user persistence, (3) clear task states (active/completed/deleted) with soft-delete recovery, and (4) basic administrative controls for support and data maintenance. The product is privacy-first: todos are private to their owner by default.\n\nPrimary success criteria for MVP:\n- Create/List/Update/Delete actions are reflected to the user within 2 seconds (95th percentile) under normal load.\n- Soft-delete retention window: 30 days; ability to recover during that period.\n- Authentication with session management and auditable admin actions.\n\n## Scope and Assumptions\n\nIn-scope for MVP:\n- Authenticated user accounts (user role) that persist todos across sessions\n- Core todo management: create, read (list/detail), update, mark complete/uncomplete, delete (soft-delete) and recover\n- Basic optional attributes: description (optional), due date (optional), priority (optional: low/medium/high)\n- Admin abilities: suspend/reactivate accounts, perform permanent purge, view audited admin actions\n\nOut-of-scope for MVP:\n- Collaboration/sharing, tags, subtasks, attachments, recurring tasks, push notifications, and third-party integrations (except optional email for password reset)\n\nAssumptions:\n- Users will primarily operate on single-user lists; sharing is deferred.\n- Email delivery for password reset is available via an external provider.\n\n## Audience and Goals\n\nPrimary audience: product owner (non-technical), backend developers (business rules), QA engineers, and operations. Goals: provide clear, testable requirements and acceptance criteria so developers can implement business logic and QA can validate behaviors.\n\n## User Roles and Permission Matrix\n\nRoles (business terms):\n- guest: view public landing and help content only. Cannot create or persist todos.\n- user: authenticated account holder; can create, view, update, complete/uncomplete, soft-delete and recover their own todos.\n- admin: operational role; can suspend/reactivate user accounts, permanently purge data, and perform maintenance. Admin actions must be auditable.\n\nPermission matrix (business view):\n- Create todo: guest ❌, user ✅, admin ✅ (audited)\n- Read own todos: guest ❌, user ✅, admin ✅ (audited for support)\n- Update own todos: guest ❌, user ✅, admin ✅ (audited)\n- Delete todo (soft): guest ❌, user ✅, admin ✅ (audited)\n- Permanent purge: guest ❌, user ❌, admin ✅ (audited)\n- Manage users: admin ✅\n\nEARS requirement (role separation):\n- WHEN a user is authenticated, THE system SHALL allow only that user to access their todos and SHALL deny access to other users' todos.\n\n## Personas\n\n- Quick-Capture Quinn: needs one-tap entry and immediate feedback. Primary metric: time-to-first-task <= 2 minutes.\n- Sync Sam: wants persistence across devices; expects create and later retrieval after sign-in.\n- Support Sam (admin): needs auditable actions and ability to suspend/reactivate accounts.\n\n## Primary User Scenarios (Happy Paths)\n\nScenario: Register and Sign In\n- WHEN a visitor registers with valid credentials, THE system SHALL create a new user account and allow authentication.\n- Acceptance: user can sign in and create a todo that persists across sign-outs.\n\nScenario: Create a Todo (Quick Capture)\n- WHEN an authenticated user submits a new todo with a non-empty title, THE system SHALL create the todo with state \"active\" and record createdAt timestamp.\n- Acceptance: new todo appears in the user's list within 2 seconds in typical conditions.\n\nScenario: Edit a Todo\n- WHEN an authenticated user updates a todo they own, THE system SHALL apply changes and set updatedAt to the time of change.\n- Acceptance: edits are visible to the user and subsequent reads within 2 seconds.\n\nScenario: Mark Complete / Uncomplete\n- WHEN a user marks a todo complete, THE system SHALL set state to \"completed\" and set completedAt.\n- WHEN a user marks a completed todo as incomplete, THE system SHALL set state back to \"active\" and clear completedAt.\n\nScenario: Delete and Recover\n- WHEN a user deletes a todo, THE system SHALL set state to \"deleted\" (soft-delete) and set deletedAt; THE item SHALL be recoverable for 30 days.\n- Acceptance: deleted items disappear from active lists immediately and can be restored within retention window.\n\nScenario: Admin Suspend\n- WHEN an admin suspends a user account, THE system SHALL prevent the user from authenticating and SHALL log the suspension action.\n\n## Secondary Scenarios and Exceptions\n\nOffline and Sync\n- WHEN a user performs actions while offline, THE client SHALL queue actions locally and THE system SHALL synchronize queued actions when connectivity is restored. The user SHALL see \"pending sync\" indicators for queued items.\n\nEARS: WHEN connectivity is lost, THE system SHALL allow queued local changes that will be synchronized upon reconnection and report conflicts if they occur.\n\nConcurrency and Conflicts\n- IF concurrent edits modify the same field, THEN THE system SHALL surface a conflict and provide options: keep local, keep remote, or merge manually. For MVP, last-writer-wins is acceptable for non-conflicting fields; same-field conflicts SHALL require user resolution.\n\nRate Limiting and Abuse Protection\n- WHEN a user exceeds 10 write requests per minute, THE system SHALL rate-limit further write attempts and return a retry-after guidance.\n\nPartial Failures and Retry\n- IF persistence fails due to transient storage errors, THEN THE system SHALL inform the user, preserve client-side input where possible, and allow retry.\n\n## Functional Requirements (EARS-format)\n\nAuthentication & Account\n- WHEN a visitor registers with a valid email and password, THE system SHALL create a user account and record createdAt.\n- WHEN a user requests a password reset, THE system SHALL send a time-limited reset mechanism to the user's email.\n- WHEN credentials are invalid during sign-in, THEN THE system SHALL deny access and return a generic authentication error message.\n\nTodo CRUD and Ownership\n- WHEN an authenticated user submits a create-todo with a non-empty title (<=250 chars), THE system SHALL create a todo in state \"active\" and return the created item.\n- IF a create/update request violates validation (empty title, title >250 chars, invalid due date format), THEN THE system SHALL return a field-level validation error explaining the rule.\n- WHEN a user requests their todo list, THE system SHALL return todos owned by that user, ordered newest-first by default, and support an optional filter by state (active/completed/deleted).\n- WHEN a user marks a todo complete, THE system SHALL set completedAt and state \"completed\".\n- WHEN a user requests delete, THE system SHALL set state to \"deleted\" and set deletedAt; THE system SHALL retain deleted items for 30 days before permanent purge.\n\nAdmin & Audit\n- WHEN an admin performs any action that affects user data or account state, THE system SHALL record an auditable event containing admin identifier, action type, target user, timestamp, and optional reason.\n\nExport (Optional)\n- WHERE export is enabled, THE system SHALL provide a user-initiated export of their todos including lifecycle timestamps in CSV format.\n\nValidation Summary\n- Title: required, non-empty after trimming, maxLength 250 characters.\n- Description: optional, maxLength 4000 characters.\n- Due date: optional, ISO 8601 date or date-time; if supplied, accept and validate format.\n- Priority: optional, allowed values {\"low\",\"medium\",\"high\"}.\n\n## Authentication and Session Management (Business-Level)\n\nSession model (business guidance):\n- Use JWT for access tokens (business guidance only). Defaults: access token expiry 20 minutes; refresh token expiry 14 days.\n- WHEN an access token expires and a valid refresh token is presented, THE system SHALL issue a new access token without user credential entry.\n- WHEN a user requests \"revoke all sessions\", THE system SHALL invalidate all refresh tokens for that user and require re-authentication across devices within 30 seconds.\n- WHEN an admin suspends a user, THE system SHALL invalidate active refresh tokens to prevent continued access.\n\nSecurity and audit\n- ALL admin elevated actions SHALL be auditable with actor id, timestamp, and action description.\n- Password policy (business default): minimum 8 characters with at least one letter and one number.\n\n## Data Flow and Lifecycle\n\nStates: Active -> Completed -> Deleted -> Purged\n\nMermaid (lifecycle):\n\n```mermaid\ngraph LR\n  A[\"Active\"] --> B[\"Completed\"]\n  B --> C[\"Deleted (Soft)\"]\n  A --> C\n  C --> D[\"Purged (Permanent)\"]\n  C --> E[\"Restored\"]\n  E --> A\n```\n\nRetention policy (business defaults):\n- Deleted items retained for 30 days then eligible for purge.\n- Audit logs retained for 365 days.\n- Backups retained per operations policy; business-level RPO <=1 hour, RTO <=4 hours for critical restores.\n\nEARS: WHEN a deleted item reaches 30 days since deletedAt, THE system SHALL mark the item eligible for permanent purge and schedule it for removal according to operations windows.\n\n## Non-Functional Requirements (Business-Level)\n\nPerformance\n- WHEN a typical user performs CRUD operations, THE system SHALL respond and reflect changes in the UI within 2 seconds for 95% of requests under normal load.\n- WHEN listing up to 50 items, THE system SHALL return results with median latency <=300 ms and 95th percentile <=2 seconds under normal load.\n\nAvailability and Monitoring\n- Target availability: 99.9% monthly for core user flows (subject to ops agreements).\n- THE system SHALL emit metrics for request rates, error rates, latency, backup success, and auth failures for operations monitoring.\n\nBackup and Recovery\n- Business RPO: <=1 hour. Business RTO: <=4 hours for critical restores.\n- THE system SHALL perform quarterly restore tests to validate backup integrity.\n\nSecurity & Privacy\n- User data is private by default and only accessible to the owner and authorized admins (audited). Data export and deletion flows SHALL honor user requests consistent with privacy obligations.\n\n## Error Handling and User-facing Messages\n\nStandard user messages (examples):\n- Validation error: \"Please enter a title (1–250 characters).\"\n- Auth required: \"Please sign in to manage your todos.\"\n- Session expired: \"Your session expired. Sign in again to continue; your changes are preserved for retry.\" \n- Offline save: \"You're offline. Your changes are saved locally and will sync when your connection returns.\" \n- Rate limit: \"You're making requests too quickly. Please wait and try again.\"\n- Permanent delete: \"This item has been permanently deleted and cannot be recovered. Contact support if you need assistance.\"\n\nEARS: IF a create/update fails due to transient storage error, THEN THE system SHALL inform the user and allow retry while preserving client-side input.\n\n## Acceptance Criteria and Test Cases\n\nAcceptance example: Create todo\n- GIVEN an authenticated user, WHEN they submit a todo with title \"Buy milk\", THEN the system SHALL return success and the todo SHALL appear in the user's list within 2 seconds.\n\nAcceptance example: Delete and recover\n- GIVEN an authenticated user with a todo, WHEN they delete it, THEN the item SHALL be in \"deleted\" state and recoverable for 30 days; AFTER 30 days the item SHALL be eligible for purge.\n\nQA checklist\n- Registration/login success and failure flows\n- Create validation: empty title, overlength title\n- Edit and ownership: cannot edit others' todos\n- Complete/uncomplete toggles and timestamps\n- Soft-delete, undo, and 30-day recovery\n- Admin suspend and audit record creation\n- Rate limit enforcement and messages\n\n## Mermaid Diagrams (user flow)\n\n```mermaid\ngraph LR\n  A[\"Visitor\"] --> B{\"Authenticated?\"}\n  B -->|\"No\"| C[\"Show Landing / Sign In / Register\"]\n  B -->|\"Yes\"| D[\"Show User Todo List\"]\n  D --> E[\"Create Todo\"]\n  E --> F[\"Validate Input\"]\n  F -->|\"Valid\"| G[\"Persist Todo (state: Active)\"]\n  F -->|\"Invalid\"| H[\"Show Validation Error\"]\n  G --> I[\"Show Updated List\"]\n```\n\n## Open Decisions\n\n- Confirm if email verification is mandatory at registration for MVP (recommended: optional to reduce friction).\n- Confirm whether due date and priority are included in MVP or deferred.\n- Confirm exact retention windows and RPO/RTO targets with operations.\n- Confirm whether offline-first (full client queuing) is required for MVP or can be deferred.\n\n## Appendix\n\nGlossary: todo item, active, completed, deleted, purged, audit log, RPO, RTO.\n\nKPIs (example):\n- Activation: % of new users creating at least one todo within 7 days (target >=40%).\n- Retention: Day-7 and Day-30 retention metrics for users who created a todo.\n- Reliability: Create/List/Update/Delete success rate >=99.5%.\n\n\n\n"},{"reason":"Describe the user problems and pain points the minimal Todo app will address.","filename":"02-problem-definition.md","documentType":"requirement","outline":["Problem statements and user frustrations","Scenarios illustrating current user pain","Business consequences of not solving the problem","Prioritization of problems for the MVP"],"audience":"Product managers and development team","keyQuestions":["What are the primary user pain points?","Which pain points must be solved in the minimal product?"],"detailLevel":"high-level","relatedDocuments":["01-service-overview.md","06-primary-user-scenarios.md"],"constraints":["Keep scope minimal and focused on essential user outcomes"],"content":"# todoApp — Requirements Analysis\n\n## Purpose and scope\nProvide concise, implementation-ready business requirements for the minimal todoApp MVP. Audience: backend developers, QA engineers, and product owners. The scope includes authenticated user task management (create, read, update, complete/uncomplete, soft-delete/restore), basic admin maintenance (suspend/reactivate accounts, audit), and measurable non-functional targets required to validate the MVP. Out of scope: collaboration, advanced recurrence, attachments, and complex project/task hierarchies.\n\n## In-scope (MVP)\n- Authenticated user accounts with per-user todo persistence\n- Todo CRUD: create (title required), read (list/detail), update (title, description, dueDate, priority), complete/uncomplete\n- Soft-delete with recoverability (30-day retention) and admin-initiated permanent purge\n- Admin functions: suspend/reactivate account, audit admin actions\n- Basic export (optional: CSV) as an optional feature\n\n## Out-of-scope\n- Sharing/collaboration, subtasks, tags, attachments, push/email reminders (deferred)\n\n## Roles and personas\nRoles (business definitions):\n- guest: reads public landing and help content only; cannot create or persist todos.\n- user: authenticated owner of their todos; can create/read/update/delete their todos and recover soft-deleted items within retention.\n- admin: operational role that may suspend/reactivate users, perform maintenance, and view audit logs; admin actions are auditable and time-stamped.\n\nPersonas:\n- \"Quick-Capture\" individual: needs one-tap capture and immediate persistence.\n- \"Sync\" user: wants cross-device persistence via simple account.\n- Support admin: needs audit trails and restore capability for support requests.\n\n### Permission matrix (business-level)\n- Create todo: user ✅, guest ❌, admin ✅ (audited)\n- Read own todos: user ✅, guest ❌, admin ✅ (audited support access)\n- Update own todos: user ✅, guest ❌, admin ✅ (audited)\n- Delete own todos: user ✅, guest ❌, admin ✅ (audited)\n- Suspend/reactivate accounts: admin ✅ only\n- View aggregate metrics: admin ✅ only\n\n## Authentication and session management (business-level)\n- WHEN a visitor registers with valid credentials, THE system SHALL create a new user account and allow sign-in according to verification policy.\n- WHEN a user authenticates, THE system SHALL issue short-lived access tokens and longer-lived refresh tokens for API access (business guidance: access token ~20 minutes, refresh token ~14 days).\n- WHEN a user logs out or requests session revocation, THE system SHALL invalidate the refresh token(s) associated with that session.\n- WHEN an admin suspends a user, THE system SHALL prevent authentication and SHALL invalidate active sessions for that user.\n- Password reset: WHEN a user requests a password reset, THE system SHALL send a time-limited reset mechanism to the user's verified email; reset tokens SHALL expire within 24 hours.\n\nNotes (business): Token formats and cryptographic choices are an implementation decision, but session revocation and auditability are mandatory.\n\n## Primary functional requirements (EARS format)\nAll requirements below are testable, measurable, and expressed in EARS style.\n\n1) WHEN an authenticated user submits a create-todo request with a non-empty title, THE system SHALL create a TodoItem with state \"active\", set createdAt to the current timestamp, and return the created item to the user.\n\n2) IF a create/update request contains an empty or whitespace-only title, THEN THE system SHALL reject the request and return a validation error that explains \"title is required\" and includes a machine-readable error code.\n\n3) WHEN an authenticated user marks a todo complete, THE system SHALL set state to \"completed\", set completedAt to the current timestamp, and preserve createdAt.\n\n4) WHEN an authenticated user marks a completed todo as uncompleted, THE system SHALL set state to \"active\" and clear completedAt.\n\n5) WHEN an authenticated user updates attributes (title, description, dueDate, priority) for a todo they own, THE system SHALL apply the changes and update updatedAt; THE system SHALL reject modifications to non-owned todos with an authorization error.\n\n6) WHEN an authenticated user deletes a todo, THE system SHALL set state to \"deleted\", set deletedAt to the current timestamp, and remove it from the default active list; THE system SHALL retain deleted todos for 30 days for user recovery.\n\n7) IF a deleted todo is not restored within 30 days, THEN THE system SHALL mark the todo eligible for permanent purge and SHALL remove it during a scheduled cleanup process.\n\n8) WHEN an admin performs any action that changes another user's data or account state, THE system SHALL create an audit record containing actorId, actorRole, actionType, targetResource, timestamp, and optional reason.\n\n9) WHILE a user is authenticated, THE system SHALL return only todos owned by that user for list and read operations; THE system SHALL never expose another user's todos in normal operations.\n\n10) WHEN a request fails due to a transient server error, THEN THE system SHALL return a clear retryable error message and preserve client-side input where possible to allow retry.\n\n### Input validation (business constraints)\n- Title: required, trimmed, min 1 character, max 250 characters.\n- Description: optional, max 4000 characters.\n- Due date: optional; accept ISO 8601 date or date-time; server validates well-formedness.\n- Priority: optional enum {\"low\",\"medium\",\"high\"}.\n\n## Secondary requirements and exceptions\n- WHEN a user performs operations while offline, THE client SHALL queue changes locally and mark them as \"pending sync\"; WHEN connectivity resumes, THE client SHALL synchronize queued changes and surface any conflicts to the user for resolution.\n- IF two conflicting edits occur to the same field, THEN THE system SHALL surface both versions and require user resolution. For MVP the system MAY implement last-write-wins for non-conflicting fields and explicit resolution for same-field conflicts.\n- WHEN a user exceeds write rate limits (business default: 10 writes/min), THEN THE system SHALL throttle requests and return a rate-limit error with a recommended retry-after interval.\n\n## Data lifecycle and retention\n- States: \"active\" -> \"completed\" -> \"deleted\" (soft) -> \"purged\".\n- WHEN a todo is deleted, THE system SHALL allow restore by owner for 30 days.\n- WHEN the 30-day retention elapses, THE system SHALL purge the item permanently; admin restore after purge requires backup restore processes and is not guaranteed.\n\nMermaid lifecycle diagram:\n\n```mermaid\ngraph LR\n  A[\"Active\"] --> B[\"Completed\"]\n  A --> C[\"Deleted (Soft)\"]\n  B --> C\n  C --> D[\"Purged (Permanent)\"]\n  C --> E[\"Restored\"]\n  E --> A\n```\n\n## Non-functional requirements (business-level)\n- Performance: WHEN a user performs core actions (create/read/update/delete), THE system SHALL reflect the result in the UI within 2 seconds for 95th percentile under typical MVP load. Median response targets: read <=300ms, write <=500ms.\n- Availability: Target monthly uptime 99.9% for core user flows.\n- Backup & Recovery: RTO <=4 hours, RPO <=1 hour (business guidance for MVP backups). Quarterly restore tests required.\n- Security & Privacy: User todos visible only to owner; admin access audited. Personal data deletion requests honored within 30 days.\n- Monitoring & Alerts: WHEN error rate for primary actions exceeds 1% for 5 continuous minutes, THE operations team SHALL be alerted and triage initiated.\n\n## Error handling and user messaging\nStandardized user-facing messages (examples):\n- Validation error (title): \"Title is required. Please add a short title and try again.\" \n- Offline queuing: \"You're offline. Your change is saved locally and will sync automatically when your connection returns.\" \n- Rate limit: \"Too many requests. Please wait <X> seconds and try again.\" \n- Authorization: \"You are not authorized to perform this action.\" \n- Delete undo: \"Todo deleted. Undo\" (visible for 30 seconds)\n\nUndo and recovery\n- WHEN a user deletes an item, THE system SHALL present an \"Undo\" affordance for 30 seconds that, if invoked, SHALL restore the item to its previous state.\n\n## Admin procedures and audit\n- Admin actions must be logged with actorId, timestamp, actionType, and reason.\n- Admins may restore soft-deleted items within the 30-day retention period; permanent purges require a documented admin request and are recorded.\n- Support playbook: collect userId, todoId, approximate timestamp, and action history for recovery requests.\n\n## Acceptance criteria and test cases\nPrimary acceptance criteria (measurable):\n- Create/List/Update/Delete actions complete and visible to the user within 2 seconds (95th percentile) under typical MVP load.\n- Validation: Attempts to create todos with empty titles are rejected with proper error messages and codes.\n- Isolation: Two users never see each other's todos in list or read operations.\n\nSimple QA test cases:\n- Register -> Create todo (title only) -> Logout -> Login -> Verify todo persists.\n- Create todo -> Mark complete -> Verify completedAt present -> Toggle incomplete -> Verify completedAt cleared.\n- Delete todo -> Verify removal from active list -> Use Undo within 30s -> Verify restore.\n- Attempt to edit another user's todo -> Expect authorization error.\n\n## Diagrams (primary flow)\n\n```mermaid\ngraph LR\n  Start[\"Visitor\"] --> Auth{\"Authenticated?\"}\n  Auth -->|\"No\"| Landing[\"Show Landing / Sign Up / Sign In\"]\n  Landing --> Register[\"Register or Sign In\"]\n  Auth -->|\"Yes\"| Session[\"Authenticated Session\"]\n  Session --> Create[\"Create Todo (title required)\"]\n  Create --> Save[\"Save as 'Active'\"]\n  Save --> List[\"Show in List (newest-first)\"]\n  List --> Complete[\"Mark Complete\"]\n  Complete --> CompletedState[\"Completed (completedAt set)\"]\n  List --> Delete[\"Delete (soft)\"]\n  Delete --> DeletedState[\"Deleted (recoverable 30d)\"]\n```\n\n## Open decisions and assumptions\n- Email verification on registration: optional; recommend requiring verification for production but may be optional for internal MVP testing.\n- Priority and dueDate: optional for MVP; include as optional fields if implementation effort is small.\n- Conflict resolution: recommend last-write-wins for non-overlapping fields and explicit user resolution for same-field edits.\n\n## Glossary and versioning\n- TodoItem: conceptual task record owned by a user.\n- Soft-delete: status where item is removed from primary lists but recoverable for retention window.\n- Purge: permanent irreversible deletion from user-visible storage.\n\nVersion: 1.0 — Initial requirements analysis for todoApp MVP."},{"reason":"Define the core value delivered by the service and the simplest set of features that deliver it.","filename":"03-core-value-proposition.md","documentType":"business-model","outline":["Core value proposition statement","Key features that realize the value","Assumptions about user behavior","Initial revenue/operational model assumptions (if any)","Go-to-market and growth basics for minimal launch"],"audience":"Business stakeholders and product team","keyQuestions":["What is the one-page value proposition for the Todo app?","What minimal features are required to realize that value?"],"detailLevel":"moderate detail","relatedDocuments":["01-service-overview.md","08-functional-requirements.md"],"constraints":["Revenue and growth strategies should be speculative and labeled as assumptions"],"content":"# 03 - Core Value Proposition for todoApp\n\n## Document purpose and scope\nThis document defines the core value proposition and the minimal set of features required to deliver the todoApp minimum viable product (MVP). It translates business intent into concise, testable business requirements and acceptance criteria so product owners and backend developers can align on scope and priorities. This document contains business-level requirements only; all technical implementation choices (architecture, APIs, database design, etc.) are left to the development team.\n\n## Executive one-line value proposition\nA simple, personal task list service that lets an authenticated individual capture, organize, and complete small tasks quickly and reliably.\n\n## Business justification (WHY)\n- Problem addressed: People need a frictionless, reliable place to capture short tasks and reminders; existing general-purpose tools are heavy or require setup. The todoApp fills the gap for users who want a fast, no-friction single-user task list that is immediately useful.\n- Market niche: Individuals (students, freelancers, professionals) seeking a minimal single-user todo experience without feature bloat.\n- Differentiation: Focus on minimalism, speed, and privacy for single-user workflows—no social features, no project/team collaboration in MVP.\n\n## Core value statement (WHAT the product delivers)\n- The core value for users: a trustworthy, always-available place to capture and manage short tasks so they can reduce cognitive load and track completion.\n- Minimal success metrics for validating the value: first-week retention of users who create at least one todo, number of active users creating and completing tasks daily, and low error rate on core actions (create/update/complete/delete).\n\n## Key minimal features that realize the value\nOnly features essential to delivering the core value are included. Optional/advanced features are explicitly excluded from MVP.\n\n1. Account and basic authentication (minimal): allow users to have a persisted personal list.\n2. Create a todo item with a mandatory short title and optional description.\n3. Read/list user's todos in one chronological or status-sorted view.\n4. Update a todo's title, description, due date (optional), priority (optional), and completion status.\n5. Delete (soft delete or archive) a todo.\n6. Mark todo as completed and unmark as incomplete.\n7. Persist user data reliably with basic backup/retention policy.\n8. Basic admin capabilities to inspect usage and manage user accounts (suspend/reactivate) for operation and support purposes.\n\nExplicit exclusions for MVP:\n- No sharing or multi-user collaboration\n- No complex tagging, search indexing, or bulk operations beyond per-item edit/delete\n- No email reminders, push notifications, or integrations (these are optional future features)\n\n## User roles and minimal permissions (business view)\nRoles are defined to keep scope minimal and map to operational responsibilities. Each role description describes WHAT they can and cannot do from a business perspective.\n\n- guest\n  - What they CAN do: view the public landing page and help content\n  - What they CANNOT do: create, view, modify, or delete todos; cannot authenticate or store persistent personal data\n\n- user\n  - What they CAN do: register, authenticate, and manage their own todos (create, read, update, delete, mark complete/incomplete); set optional due date and priority per todo\n  - What they CANNOT do: access other users' todos or administrative functions\n\n- admin\n  - What they CAN do: authenticate as an administrator, view aggregate usage metrics, suspend or reactivate user accounts, and perform data maintenance operations as needed.\n  - What they CANNOT do: bypass audit logging or invisibly alter user activity history without an auditable record\n\nPermission summary (business matrix):\n- Create todo: user ✅, guest ❌, admin ✅ (admin may act as a user but all admin actions audited)\n- Read own todos: user ✅, guest ❌, admin ✅ (for support only, audited)\n- Update own todos: user ✅, guest ❌, admin ✅ (audited)\n- Delete own todos: user ✅, guest ❌, admin ✅ (audited)\n- Manage users: admin ✅, user ❌, guest ❌\n\n## Conceptual data entities and attributes (business-level)\nThese are conceptual entities and attributes to clarify business behavior and acceptance criteria. This is not a database schema.\n\n- Todo item (conceptual attributes)\n  - owner: the user who owns this todo (business identifier)\n  - title: short text (required) — single-line summary of the task\n  - description: longer text (optional) — optional details or notes\n  - createdAt: timestamp when item was created\n  - updatedAt: timestamp when last modified\n  - dueDate: optional date/time for the task (optional feature)\n  - priority: optional enumeration (low, medium, high) (optional feature)\n  - completed: boolean flag indicating completion state\n  - archived: boolean flag for soft-deleted or archived items\n\n- User account (conceptual attributes)\n  - accountId: business identifier\n  - status: active|suspended|deleted\n  - createdAt: timestamp\n  - lastActiveAt: timestamp of last activity\n\n- Administrative audit record (conceptual attributes)\n  - actor: user or admin performing the action\n  - actionType: e.g., \"suspendUser\", \"deleteTodo\", \"adminLoginAsUser\"\n  - timestamp: when the action occurred\n  - details: short text explaining reason/context (for support)\n\n## Business rules and constraints (EARS-formatted where applicable)\nBelow are testable business rules written in EARS templates. EARS keywords remain in English; the rest is written in English (user locale).\n\n1. WHEN a registered user submits a create-todo request, THE todoApp SHALL create a new todo item that is visible only to that user and set createdAt to the time of creation.\n\n2. WHEN a user attempts to create a todo with an empty or whitespace-only title, THE todoApp SHALL reject the creation and present a validation message indicating \"Title is required\".\n\n3. WHEN a user updates a todo's completion flag from false to true, THE todoApp SHALL set completed to true and set updatedAt to the time of the change.\n\n4. WHEN a user requests their list of todos, THE todoApp SHALL return only the todos owned by that user sorted with incomplete items first and newest items first within each group.\n\n5. IF a user attempts to access a todo that they do not own, THEN THE todoApp SHALL deny access and present an authorization error message.\n\n6. THE todoApp SHALL retain soft-deleted (archived) todos for a configurable retention period; AFTER the retention period expires, THE todoApp SHALL permanently purge archived todos according to the retention policy.\n\n7. WHERE admin audit is enabled, THE todoApp SHALL record any admin action that affects user accounts or data along with the admin's identifier and timestamp.\n\n8. WHEN a user marks a todo as completed or modifies a todo, THE todoApp SHALL reflect the change within 2 seconds under normal operating conditions (response & persistence visible to the user).\n\n9. WHEN a user performs create/update/delete operations at low scale (single user usage), THE todoApp SHALL complete the operation within 2 seconds 95% of the time.\n\n10. IF data persistence fails during a create/update operation, THEN THE todoApp SHALL surface a clear user-facing error message and preserve client-side input where possible to allow retry.\n\n## Acceptance criteria and measurable success conditions\nEach acceptance criterion below is measurable and tied to core features.\n\n- Create todo acceptance:\n  - Given a registered user with a non-empty title, WHEN the user submits create, THEN a todo with that title is stored and visible in the user's list within 2 seconds.\n\n- Validation acceptance:\n  - Given a user submits a create or update with an empty title, THEN the system rejects the operation and returns a visible validation message; no todo is created or modified.\n\n- Isolation acceptance:\n  - WHEN a user lists todos, THEN only that user's todos are present; no todo owned by other users is visible.\n\n- Completion acceptance:\n  - WHEN a user marks a todo completed, THEN the completed flag is true and the item moves to the completed group in the list view within 2 seconds.\n\n- Admin audit acceptance:\n  - WHEN an admin performs an account suspension or acts as a user, THEN an auditable record exists with timestamp and actor identifier.\n\n## Primary user stories and example flows\nThe examples below are written as short, testable business stories.\n\n- User story: Register & create\n  - GIVEN an unauthenticated person who registers and confirms an account, WHEN they create their first todo with a title, THEN the todo appears in their list and is persisted.\n\n- User story: Quick capture\n  - GIVEN a logged-in user, WHEN they enter a short title and save, THEN the todo is created and visible immediately for quick capture use.\n\n- User story: Manage and complete\n  - GIVEN a logged-in user with existing todos, WHEN they toggle completion on a todo, THEN the todo's completed state updates and the updatedAt timestamp changes.\n\nMermaid flow for the primary happy path (left-to-right):\n\n```mermaid\ngraph LR\n  A[\"Landing Page\"] --> B{\"Authenticated?\"}\n  B -->|\"Yes\"| C[\"Show User Todo List\"]\n  B -->|\"No\"| D[\"Show Public Landing\"]\n  C --> E[\"Create Todo(title, optional description)\"]\n  E --> F[\"Validate Input\"]\n  F -->|\"Valid\"| G[\"Persist Todo\"]\n  F -->|\"Invalid\"| H[\"Show Validation Error\"]\n  G --> I[\"Show Updated Todo List\"]\n```\n\n## Minimal non-functional expectations (MVP level)\n- Performance: WHEN a user performs create/read/update/delete on an individual todo, THE todoApp SHALL reflect the change in the UI within 2 seconds 95% of the time under expected load for an MVP (small user base).\n- Availability: For MVP scale, the service SHALL be available during business hours with low acceptable downtime; target uptime for initial release: 99% monthly availability (subject to adjustment by operations).\n- Persistence & durability: THE todoApp SHALL persist user data so that created todos survive service restarts and standard operational events. Backups of user data SHALL be taken at least once per day (business-level requirement).\n- Security & privacy: Tasks are private by default and visible only to their owner. Admins may access data only for maintenance and must have actions recorded in audit logs.\n\n## Primary user stories and example flows\n\n- User story: Register & create\n  - GIVEN an unauthenticated person who registers and confirms an account, WHEN they create their first todo with a title, THEN the todo appears in their list and is persisted.\n\n- User story: Quick capture\n  - GIVEN a logged-in user, WHEN they enter a short title and save, THEN the todo is created and visible immediately for quick capture use.\n\n- User story: Manage and complete\n  - GIVEN a logged-in user with existing todos, WHEN they toggle completion on a todo, THEN the todo's completed state updates and the updatedAt timestamp changes.\n\n## Open decisions and recommended defaults\nThe following items should be explicitly confirmed by product stakeholders before development/implementation:\n\n- Authentication approach: Require email verification prior to first use or allow immediate use after registration? (impact: registration/verification acceptance criteria)\n- Priority enum: Use {\"low\",\"medium\",\"high\"} or a boolean \"important\" flag? (impact: data model, UI)\n- Soft-delete retention duration: Recommended default 30 days; confirm desired retention.\n- Export formats: Whether export is MVP or deferred.\n\n## Appendix: Business-level non-functional expectations\n- Persistence: User-created tasks SHALL persist across sessions and devices for authenticated users. Data durability expectations: user-visible changes shall survive service restarts and typical operational events.\n- Backups & retention (business-level): Backups are recommended per the retention policy: soft-deleted items retained for 30 days; backups retained for at least 90 days for recovery purposes (implementation detail left to operations team).\n- Availability: For MVP scale, THE todoApp SHALL target availability of 99% monthly uptime.\n- Security & privacy (business-level): Tasks are private by default and visible only to their owner. Admins may access data only for maintenance and must have actions recorded in audit logs.\n\n"},{"reason":"Describe how the service will operate from the user's perspective and list primary interactions.","filename":"04-service-operation-overview.md","documentType":"service-overview","outline":["Top-level user journeys for a single-user Todo experience","Day-to-day operations and common flows","Account lifecycle in business terms","High-level integration points (e.g., optional email for password reset) described conceptually"],"audience":"Development team, QA, and product managers","keyQuestions":["What are the main user journeys (create todo, complete todo, manage account)?","What operations must the service handle reliably?"],"detailLevel":"detailed","relatedDocuments":["05-user-roles-and-personas.md","06-primary-user-scenarios.md","08-functional-requirements.md"],"constraints":["Do not include technical API or database descriptions"],"content":"# 04 - Service Operation Overview for todoApp\n\n## Purpose and scope\n\ntodoApp is a single-user-focused, lightweight todo list service intended to provide the essential capability to capture, track, and manage short-lived personal tasks. The minimal product allows an authenticated user to create, view, update, and delete their own todos and includes a basic account lifecycle (register, authenticate, reset password). Admins exist for operational control (account suspension/reactivation and audits). The service prioritizes clarity, reliability, and minimal complexity.\n\nThis file prescribes business-level operational behavior and acceptance criteria for backend implementation. It does not include database schemas or API contracts; developers are free to design technical interfaces that satisfy the business rules and acceptance tests specified here.\n\n## Audience and how to use this document\n\nThis document is intended for backend developers, QA engineers, support staff, and product managers. Use this document to:\n- Derive API behaviors and acceptable response semantics for user-visible operations.\n- Create acceptance tests and QA plans for primary and secondary user scenarios.\n- Inform operational runbooks for backups, retention, and admin maintenance.\n\nRead the functional requirements and user roles documents first when designing access controls and authentication flows.\n\n## Top-level user journeys (happy paths)\n\nEach journey below describes the user's steps, expected system behavior, and clear acceptance criteria expressed in business terms.\n\n### Create a todo (quick capture)\n\nNarrative: A registered user captures a single task quickly with optional fields for due date and priority.\n\nEARS requirements:\n- WHEN a registered user submits a new todo with at least a title, THE todoApp SHALL create a todo item owned by that user with status \"active\", set createdAt to the current timestamp, and return the created item for the user's view within 2 seconds in normal conditions.\n- IF the submitted todo title is empty or exceeds 250 characters, THEN THE todoApp SHALL reject the creation and return a user-facing validation error specifying the constraint.\n\nBusiness details:\n- Minimal required field: title (short text, non-empty, trimmed).\n- Optional fields: description (optional text), dueDate (optional ISO date), priority (optional enum: \"low\",\"medium\",\"high\").\n- Creation is immediate and visible in the user's active list. The default sort is newest-first among active items.\n\nAcceptance criteria:\n- GIVEN an authenticated user who submits a valid title, WHEN the request completes, THEN the created todo is visible in the user's list within 2 seconds.\n\n### Read / List todos\n\nNarrative: A user opens the app and sees their active todos.\n\nEARS requirements:\n- WHEN a registered user requests their todo list, THE todoApp SHALL return the user's active todos ordered newest-first by createdAt by default and support optional filters by state and pagination at a configurable page size (default page size = 50).\n\nBusiness details:\n- Default list shows active items. Completed items may be shown in a separate view accessible through a filter. Deleted (soft-deleted) items are not shown in default lists.\n\nAcceptance criteria:\n- GIVEN a user with existing todos, WHEN they request the list, THEN the list response contains only those todos owned by the user and is returned within 2 seconds for up to 50 items.\n\n### Update a todo (edit content, mark complete/incomplete)\n\nNarrative: A user edits a todo's text, due date, or priority and can mark it complete or incomplete.\n\nEARS requirements:\n- WHEN a registered user edits a todo they own, THE todoApp SHALL apply the permitted changes and set updatedAt to the current timestamp; THE todoApp SHALL return the updated item within 2 seconds.\n- WHEN a registered user marks a todo as complete, THE todoApp SHALL set status to \"completed\", set completedAt to the current timestamp, and retain createdAt unchanged.\n- WHEN a registered user marks a completed todo as incomplete, THE todoApp SHALL set status to \"active\" and clear completedAt.\n\nBusiness details:\n- Users can edit their own todos without an enforced time window for edits in the MVP.\n- Only the owner may modify a todo; admin actions that affect user data must be audited.\n\nAcceptance criteria:\n- GIVEN ownership and valid input, WHEN the user updates, THEN the changes are present in subsequent reads within 2 seconds.\n\n### Delete a todo (soft-delete and recovery)\n\nNarrative: A user deletes a todo; deletion is non-permanent for a configurable retention period to allow recovery.\n\nEARS requirements:\n- WHEN a registered user deletes a todo they own, THE todoApp SHALL set status to \"deleted\", set deletedAt to the current timestamp, remove the item from the default active list immediately, and make the item recoverable by the owner for 30 calendar days.\n- IF the owner does not restore the deleted todo within the retention window, THEN THE todoApp SHALL make the item eligible for permanent purge by a scheduled admin process.\n\nBusiness details:\n- Soft-delete protects against accidental loss and supports an undo affordance in the UI.\n- Permanent purge is performed as a scheduled background operation; admins may perform targeted purges subject to audit rules.\n\nAcceptance criteria:\n- GIVEN the deletion action, WHEN it completes, THEN the item is absent from the active list and appears in a recoverable deleted list for 30 days.\n\n### Basic account management (register, login, password reset)\n\nNarrative: A user registers and authenticates with the system and can recover access via email when necessary.\n\nEARS requirements:\n- WHEN a visitor registers an account with valid credentials, THE todoApp SHALL create an account record with accountStatus \"active\" (or \"unverified\" if email verification is required by policy) and record createdAt.\n- WHEN a user requests password reset, THE todoApp SHALL issue a time-limited reset token via the user's registered email and SHALL accept the token to complete password change within the token validity window.\n\nBusiness details:\n- Email verification may be required by product policy; if required, account must be verified before the user can create todos.\n- Admins can suspend/reactivate accounts; suspended accounts cannot authenticate nor perform write actions but their data is retained for review.\n\nAcceptance criteria:\n- GIVEN a registered user, WHEN the user requests password reset, THEN the reset email is delivered within expected provider latency (business-level expectation: within 60 minutes) and the reset token validity is enforced (e.g., 24 hours).\n\n## Day-to-day operations and common flows\n\n### Typical user session flow\n\n- User opens the app.\n- If unauthenticated and the product requires authentication for todo management, the user is presented with login/register choices.\n- After authentication, the user's active todo list is displayed.\n- User creates, updates, marks complete, or deletes tasks as needed.\n- User logs out to end the session.\n\nEARS requirements:\n- WHEN a user completes authentication, THE todoApp SHALL present the user's current active todo list within 2 seconds in normal conditions.\n\nPerformance expectation:\n- Core operations (create, list, update, delete) shall be visible to the user within 2 seconds at MVP scale in normal conditions (95th percentile constraint for typical load).\n\n### Background processes and scheduled operations (business-level)\n\n- Retention cleanup: schedule background job to permanently purge soft-deleted items older than retention window.\n- Backup snapshot creation: perform regular backups to meet RPO objectives.\n- Admin audit and maintenance operations: periodic maintenance processes for orphaned data and system hygiene.\n\nEARS requirements:\n- WHEN a deleted item passes the retention period, THEN THE todoApp SHALL schedule the item for permanent purge during the next maintenance window and record the purge action for audit.\n\n## Account lifecycle and user data lifecycle\n\n### Account states (business-level)\n- active: Account may perform normal operations.\n- suspended: Account is disabled from authenticating and performing write operations; data is preserved.\n- deleted: Account is scheduled for removal subject to retention policy and legal holds.\n\nEARS requirements:\n- WHEN an admin suspends a user account, THE todoApp SHALL reject subsequent authentication attempts for that account and SHALL invalidate refresh tokens associated with the account to prevent further API access within 30 seconds of suspension.\n- WHEN a user requests account deletion, THE todoApp SHALL mark the account for deletion and initiate data removal per retention policy.\n\n### Todo item lifecycle (business states)\n\n```mermaid\ngraph LR\n  A[\"Active\"] --> B[\"Completed\"]\n  B --> C[\"Deleted(Soft)\"]\n  A --> C\n  C --> D[\"Permanently Deleted\"]\n  C --> E[\"Restored\"]\n  E --> A\n```\n\nBusiness notes:\n- Completion is reversible. Deleted state is recoverable within retention window. Permanent deletion removes the item from user view and backups per retention rules.\n\n## Business rules and validation (detailed)\n\n### Ownership and access\n- WHEN a user attempts an action on a todo item, THE todoApp SHALL permit the action only if the user is the owner of the todo or if an admin performs an authenticated audited maintenance action.\n- IF a non-owner attempts access, THEN THE todoApp SHALL deny the request and return an authorization error without revealing private details about the resource.\n\n### Input validation rules\n- WHEN a user submits a title, THE todoApp SHALL require a non-empty title trimmed of whitespace and SHALL accept titles up to 250 characters; THE todoApp SHALL reject titles longer than 250 characters.\n- WHEN a user submits a description, THE todoApp SHALL accept strings up to 4,000 characters and shall trim leading/trailing whitespace for presentation.\n- WHEN a user supplies a dueDate, THE todoApp SHALL accept ISO 8601 date-only or date-time values and shall validate that the value parses; the system shall warn on past dates but not prevent them by default.\n- WHEN a user supplies a priority, THE todoApp SHALL accept only \"low\",\"medium\", or \"high\".\n\n### Concurrency and conflict handling (business-level)\n- IF two updates for the same todo are submitted concurrently, THEN THE todoApp SHALL apply deterministic resolution and shall surface conflict information to users where overwrites would cause data loss. For MVP, last-write-wins is an acceptable default but the system SHALL record modification timestamps to help users and support resolve conflicts.\n\n### Audit and admin behavior\n- WHEN an admin performs any action that affects user data or accounts, THE todoApp SHALL record an audit entry including admin identifier, action type, target resource, timestamp, and optional reason.\n- IF an admin uses impersonation to act on behalf of a user, THEN THE todoApp SHALL annotate the audit entry to indicate admin-originated action.\n\n## Authentication and session management (business-level)\n\n### Token guidance and session behavior\n- THE todoApp SHALL use token-based sessions for authenticated API access. JSON Web Tokens (JWT) are recommended for representing access tokens in the API model.\n- THE todoApp SHALL use short-lived access tokens and longer-lived refresh tokens to balance usability and security.\n\nEARS requirements:\n- WHEN the system issues tokens, THE todoApp SHALL issue access tokens with a recommended default expiration of 20 minutes and refresh tokens with a recommended default expiration of 14 days (product-configurable).\n- WHEN a user logs out or requests session revocation, THE todoApp SHALL invalidate the associated refresh token and prevent further token refresh operations. Token revocation SHALL propagate to other sessions within 30 seconds where possible.\n- WHEN an admin suspends an account, THE todoApp SHALL invalidate refresh tokens for the account to prevent further authenticated requests and SHALL record the suspension in audit logs.\n\n### Registration, verification, and password reset\n- WHEN a visitor registers with email and password, THE todoApp SHALL create an account in a pending or active state per product policy and SHALL send a verification email if verification is required.\n- WHEN a user requests password reset, THE todoApp SHALL send a time-limited reset token to the registered email address and SHALL reject expired tokens.\n\nAcceptance criteria:\n- GIVEN valid credentials, WHEN a user authenticates, THEN the system SHALL return access and refresh tokens within 2 seconds under normal conditions.\n- GIVEN a password reset request, WHEN the reset token is valid, THEN the system SHALL accept the token and allow password change within the token validity window.\n\n## Error handling and user-facing recovery scenarios\n\n### Validation errors\n- IF a request contains invalid fields (empty title, exceeding length limits, invalid date format), THEN THE todoApp SHALL return a validation error with a user-friendly message explaining the correction.\n\n### Authorization errors\n- IF an actor attempts an action they are not authorized to perform, THEN THE todoApp SHALL return an authorization error and log the attempt for security monitoring.\n\n### Transient operational errors\n- IF an operation fails due to transient backend errors (storage unavailable, timeout), THEN THE todoApp SHALL surface a retryable error message and the client SHOULD preserve user input where possible for retry.\n\n### Offline and sync behavior\n- WHEN a client performs actions while offline, THE todoApp SHALL allow the client to queue changes locally and synchronize when connectivity returns; queued changes SHALL be sent in order and the client SHALL handle conflict notifications if server-side conflicts arise.\n- WHEN connectivity is restored, THE todoApp SHALL synchronize queued operations within 30 seconds and SHALL notify the user of sync success or conflicts.\n\n### Conflict resolution\n- IF a conflict occurs for the same field from multiple concurrent edits, THEN THE todoApp SHALL present both versions in the client and allow the user to choose which version to keep or perform an edit; for MVP, last-write-wins may be used as a default but the conflict SHALL be recorded in logs for support.\n\nUser-facing messages (examples):\n- \"Please add a title to your todo before saving.\" (validation empty title)\n- \"Your change could not be saved right now. Try again in a few moments.\" (transient error)\n- \"You must be signed in to manage todos. Sign in or create an account to continue.\" (authorization)\n- \"This todo was changed elsewhere. Review changes and choose which version to keep.\" (conflict)\n\n## Performance and operational expectations (user-facing SLAs)\n\nEARS performance requirements:\n- WHEN a registered user performs a create, update, delete, or list operation under typical load, THE todoApp SHALL reflect the result and show updated data to the user within 2 seconds for 95% of requests measured over a rolling 1-hour window.\n- WHEN scheduled cleanup runs for permanent deletion, THE todoApp SHALL complete the cleanup batches within the agreed maintenance window.\n\nAvailability and backup expectations:\n- THE todoApp SHALL target 99.9% monthly availability for core user flows for the MVP and SHALL implement backups sufficient to meet RPO <= 1 hour and RTO <= 4 hours for critical failures.\n\nRate limiting and abuse protection:\n- THE todoApp SHALL enforce per-user rate limits to protect service health; default MVP limit: 10 write requests per minute per user. Exceeding the limit SHALL return a rate-limit error with a suggested retry time.\n\n## Administrative and maintenance processes\n\n### Admin roles and audit\n- Admins may view aggregated usage metrics and perform user account management functions such as suspension and reactivation.\n- WHEN an admin performs data-affecting operations, THE todoApp SHALL record detailed audit entries including admin id, action, target resource, timestamp, and reason.\n\n### Manual recovery steps (business-level)\n- TO recover a soft-deleted item within the retention window, an admin or the owner may restore the item via the restore flow; THE todoApp SHALL record the restore action in audit logs.\n- TO recover items beyond retention windows, THE todoApp SHALL rely on backups; the recovery SHALL be coordinated per incident response procedures and documented in a post-incident report.\n\n### Maintenance and scheduled tasks\n- THE todoApp SHALL run scheduled maintenance tasks (backup, retention purge) during defined maintenance windows to minimize user impact.\n- Maintenance windows SHALL be communicated to stakeholders in advance.\n\n## Acceptance criteria and success metrics\n\nPrimary acceptance criteria:\n- Core flows (create/list/update/delete) must function for authenticated users and meet the 2-second visibility requirement in 95% of normal requests.\n- Users must not be able to access other users' todos in any normal or edge-case scenario tested by QA.\n- Deleted items must be recoverable by their owner within the 30-day retention window.\n- Admin actions that affect user data must be auditable with sufficient detail.\n\nKPIs for MVP launch:\n- Activation: percent of new accounts that create at least one todo within 7 days (target >= 40%).\n- Retention: percent of users who return and create tasks in 7-day and 30-day windows (7-day >= 25%, 30-day >= 10%).\n- Reliability: create success rate >= 99.5% under normal load.\n\n## Diagrams and flows (Mermaid syntax validated)\n\nUser session and primary operations:\n\n```mermaid\ngraph LR\n  A[\"Start\"] --> B{\"User Authenticated?\"}\n  B -->|\"No\"| C[\"Show Login/Register\"]\n  B -->|\"Yes\"| D[\"Show Active Todo List\"]\n  D --> E[\"Create Todo\"]\n  D --> F[\"Edit Todo\"]\n  D --> G[\"Mark Complete/Incomplete\"]\n  D --> H[\"Delete Todo(Soft)\"]\n  H --> I[\"Deleted List/Restore Option\"]\n  E --> D\n  F --> D\n  G --> D\n  I --> D\n```\n\nLifecycle diagram:\n\n```mermaid\ngraph LR\n  A[\"Active\"] --> B[\"Completed\"]\n  B --> C[\"Deleted(Soft)\"]\n  A --> C\n  C --> D[\"Permanently Deleted\"]\n  C --> E[\"Restored\"]\n  E --> A\n```\n\nConflict resolution flow:\n\n```mermaid\ngraph LR\n  A[\"Update from Device A\"] --> B[\"Server Receive\"]\n  C[\"Update from Device B\"] --> B\n  B --> D{\"Conflicting Fields?\"}\n  D -->|\"No\"| E[\"Merge Updates\"]\n  D -->|\"Yes\"| F[\"Create Conflict Record and Notify User\"]\n  F --> G[\"Present Conflict Resolution Options\"]\n  G --> H[\"User Chooses Version or Edits\"]\n  H --> I[\"Apply Chosen Version and Notify All Sessions\"]\n```\n\n## Open decisions and assumptions\n\n- Confirm whether email verification is required for account creation in MVP or optional.\n- Confirm retention windows for deleted and archived items; default: 30 days (deleted), 365 days (archived).\n- Confirm whether offline-first synchronization with complex conflict resolution is required, or whether last-write-wins is acceptable for MVP.\n- Confirm exact SLAs and availability targets with operations; defaults suggested above are for MVP planning only.\n\n## Appendix: Contact points and change log template\n\n- Product Owner: [name placeholder]\n- Engineering Lead: [name placeholder]\n- QA Lead: [name placeholder]\n\nChange log template:\n- Document: 04-service-operation-overview.md\n- Version: 1.0\n- Date: YYYY-MM-DD\n- Author: [name]\n- Summary of change: [one-paragraph description]\n\n\n"},{"reason":"Define all user roles, authentication expectations, and persona-driven needs for the minimal app.","filename":"05-user-roles-and-personas.md","documentType":"user-story","outline":["Role definitions and business-level permissions (guest, user, admin)","Authentication requirements and flows in business terms","Persona descriptions for the primary users","Permission matrix mapping roles to actions","Acceptance criteria for authentication-related features"],"audience":"Backend developers, security reviewers, product managers","keyQuestions":["Which roles must exist and what can each role do?","Which roles must authenticate via API and what are the expected behaviors?"],"detailLevel":"detailed","relatedDocuments":["04-service-operation-overview.md","08-functional-requirements.md"],"constraints":["Include authentication requirements conceptually but do not provide implementation specifics","Ensure roles align with the roles array provided to the project"],"content":"# 05-user-roles-and-personas.md — User Roles and Personas for todoApp\n\n## Executive summary and document purpose\nThis document defines the business-level user roles, authentication expectations, and persona-driven needs for the minimal todoApp. It describes who will use the system, what each role is allowed to do, the authentication lifecycle from a user's viewpoint, and precise, testable business requirements (using EARS syntax) that guide backend implementation. This document does not prescribe implementation details such as database schemas, API contracts, or deployment architectures; it prescribes WHAT the system must do in business terms.\n\n## Scope and assumptions\n- Scope: Minimal single-user Todo application that supports account registration and per-user todos. The scope intentionally excludes collaboration features (shared lists), complex tagging, attachments, and integrations beyond optional email for account recovery.\n- Multi-user support: The system will support multiple distinct user accounts; each user's todos are private to that user unless an administrative action is taken.\n- Authentication: Authenticated access is required for creating, modifying, and deleting todos. Guests can view public landing pages and help content only.\n- Minimal feature set for todo items: title (required), description (optional), completed flag, created timestamp, optional due date, optional priority (low/medium/high). These item attributes are described conceptually in other documents; here we reference them only as inputs to role and permission rules.\n- Security assumptions: Basic account security measures (passwords stored safely, account verification) are required; implementation specifics are left to developers.\n\n## Business model context (concise)\n- Why this service exists: Provide individuals with a lightweight, reliable place to record and manage simple tasks. The minimal app targets users who want an uncluttered task list with basic reminders and persistence across devices.\n- How the service supports value: By providing reliable per-user storage, quick task capture, and simple task lifecycle management (create → complete → delete/archived).\n- Success metric (relevant to roles/auth): Successful authentication and task operations should enable users to complete their primary task flows with high reliability (see Acceptance Criteria section).\n\n## User roles: definitions and business permissions\nThree roles are defined for the minimal todoApp and must be implemented in the system: guest, user, and admin. Each role is described in business terms and mapped to actions in the Permission Matrix section.\n\nRole: guest\n- Business description: Unauthenticated visitor who can view public landing information, help content, and FAQ. Guests cannot create or access any todo data and cannot call authenticated APIs.\n- Persistence: Guests have no persistent personal data in the app.\n- High-level permissions (business terms): read-only access to public content; no todo-related privileges.\n\nRole: user\n- Business description: Authenticated account holder who can create and manage their own todos. The user owns personal todos and optionally sets due dates and priorities.\n- High-level permissions: create, read, update, delete, and toggle complete/incomplete only for todos they own.\n- Limitations: Cannot access other users' todos or perform administrative functions.\n\nRole: admin\n- Business description: Elevated account for operational tasks. Admins can view aggregate usage metrics and manage user accounts (suspend/reactivate). Admins may also act as a regular user for troubleshooting but such admin-initiated user actions must be audited.\n- High-level permissions: All user actions (on their own account) plus elevated abilities to manage user accounts and perform data maintenance operations as needed.\n- Audit requirement: Administrative actions that affect user data or account state must be logged and attributable to the admin performing them.\n\n## Authentication requirements and flows (business-level)\nThis section describes the required authentication lifecycle in business terms. Implementation choices (e.g., how tokens are stored client-side, which hashing algorithm to use for passwords) are left to the development team, except where explicitly mandated by project-level rules.\n\nAuthentication features (conceptual list):\n- User registration with email and password\n- Email verification for new accounts (recommended minimal flow)\n- Login (credential validation)\n- Logout (session termination)\n- Password reset (email-based recovery)\n- Password change (authenticated)\n- Revoke access from all devices (session revocation)\n- Token-based session model (business guidance requires JWT usage; see Token Management)\n\n### Token management (business guidance)\n- Token type: THE system SHALL use JSON Web Tokens (JWT) to represent authenticated sessions for API access.\n- Token expiry guidance: Access tokens should be short-lived and refresh tokens longer-lived to balance security and usability. The following business-level default values are recommended and must be considered authoritative unless product leadership decides otherwise:\n  - Access token expiration: 20 minutes (business default; acceptable range 15–30 minutes)\n  - Refresh token expiration: 14 days (business default; acceptable range 7–30 days)\n- Token payload (business-level): THE JWT SHALL include an identifier for the user, the user's role, and a permissions indicator sufficient to enforce the Permission Matrix. Exact token fields and cryptography are implementation details for developers.\n- Session revocation: THE system SHALL support revoking refresh tokens so that an admin or a user may force sign-out across devices. The user-facing behavior is described in Error and Recovery Scenarios.\n\n## Personas and primary user needs\nPersona 1: Solo Organizer (primary user)\n- Profile: Individual who tracks a small number of tasks for personal productivity.\n- Goals: Quickly add tasks, mark tasks complete, and remove tasks when no longer needed. Minimal friction in authentication—wants reliable access across devices.\n- Expectations: Stable account persistence, quick create/complete actions, ability to recover account when password is forgotten.\n\nPersona 2: Casual Visitor (guest)\n- Profile: Browsing user evaluating the service or seeking help content.\n- Goals: Understand what the app does and sign up if it meets needs.\n- Expectations: Clear sign-up CTA and explanation of privacy and data rules.\n\nPersona 3: Support Administrator (admin)\n- Profile: Support or operations staff who manage accounts and investigate issues.\n- Goals: Suspend/reactivate accounts, audit admin actions, and assist users in recovery scenarios.\n- Expectations: Clear audit trails and role-based separation between admin and user activities.\n\n## Permission matrix mapping roles to actions\nThe following table maps business actions in the minimal Todo app to the three roles. '✅' means the role is permitted to perform the action; '❌' means the role is not permitted.\n\n| Action | guest | user | admin |\n|--------|-------|------|-------|\n| View public landing/help | ✅ | ✅ | ✅ |\n| Register account | ✅ | ❌ | ❌ |\n| Authenticate (login) | ❌ | ✅ | ✅ |\n| Create todo (own) | ❌ | ✅ | ✅ |\n| Read todo (own) | ❌ | ✅ | ✅ |\n| Update todo (own) | ❌ | ✅ | ✅ |\n| Delete todo (own) | ❌ | ✅ | ✅ |\n| Toggle complete/incomplete (own) | ❌ | ✅ | ✅ |\n| View other user's todos | ❌ | ❌ | ✅ (only for admin maintenance/audit) |\n| Suspend/reactivate user account | ❌ | ❌ | ✅ |\n| Revoke user sessions | ❌ | ✅ (self) | ✅ (admin) |\n| View aggregate usage metrics | ❌ | ❌ | ✅ |\n\nNotes on admin \"view other user's todos\": Admins may access other users' data strictly for maintenance or support and such access MUST be auditable (see EARS business rules below).\n\n## EARS-formatted business requirements for roles and authentication\nAll requirements that can be expressed in EARS are written below. Each requirement is specific, measurable, and testable.\n\n1) Core access rules\n- THE system SHALL restrict unauthenticated users to public pages and help content only.\n- WHEN a user successfully authenticates, THE system SHALL allow the user to perform create/read/update/delete operations on todos that the user owns.\n- WHEN an admin authenticates, THE system SHALL allow the admin to perform user account management actions and to perform read-only or maintenance access on other users' todos for troubleshooting subject to audit logging.\n\n2) Registration and verification\n- WHEN a visitor completes registration with an email and password, THE system SHALL create a new user account in an unverified state.\n- WHEN a new user account is created in an unverified state, THE system SHALL send a verification email that allows the user to confirm the account.\n- IF email verification is not completed within 14 days, THEN THE system SHALL mark the account as unverified and restrict todo creation until verification is performed.\n\n3) Authentication lifecycle\n- WHEN a user submits credentials to sign in, THE system SHALL validate credentials and, ON SUCCESS, issue an access token and refresh token to enable authenticated actions.\n- IF a user presents an expired access token and a valid refresh token, THEN THE system SHALL allow token renewal to provide a new access token without requiring credential entry.\n- WHEN a user logs out from an interface, THE system SHALL invalidate the refresh token used by that interface such that continued use of that refresh token is disallowed.\n\n4) Password reset and recovery\n- WHEN a user requests a password reset, THE system SHALL send a time-limited password reset link to the email address on file.\n- IF the password reset token is expired or invalid, THEN THE system SHALL reject the reset attempt and instruct the user to request a new reset.\n\n5) Session and token revocation\n- WHEN a user requests to revoke all sessions, THE system SHALL invalidate all refresh tokens associated with the user's account and require re-authentication on all devices.\n- WHEN an admin suspends a user account, THE system SHALL prevent new logins for that user and SHALL invalidate active refresh tokens so that existing sessions cannot continue.\n\n6) Admin audit requirements\n- WHEN an admin performs any action that accesses or modifies user data, THE system SHALL create an audit record containing: admin identifier, timestamp, target user identifier, action type, and reason (if provided).\n- IF an admin acts as a regular user for troubleshooting, THEN THE system SHALL clearly annotate the audit entry so that admin-originated user actions are distinguishable from normal user activity.\n\n7) Privacy and data separation\n- THE system SHALL ensure that user data is logically private; users SHALL not see other users' todos except as allowed to admins for maintenance as described above.\n\n8) Error handling (EARS for common failures)\n- IF a user provides invalid credentials during sign-in, THEN THE system SHALL deny access and present the user-facing message \"Invalid email or password\" and log the attempt for rate-limiting analysis.\n- IF a user attempts to use an expired refresh token, THEN THE system SHALL deny token renewal and require the user to authenticate with credentials.\n\n9) Optional features (WHERE)\n- WHERE users opt in to email notifications, THE system SHALL send optional task reminder emails according to user-set preference. (This is optional and not required for the minimal product.)\n\n## Acceptance criteria for authentication-related features\nEach acceptance criterion below is written to be measurable and testable.\n\nRegistration and account creation\n- AC-REG-01: GIVEN a visitor submits a valid email and password, WHEN the registration request completes, THEN the system SHALL create a user record in an unverified state and SHALL send a verification email within 30 seconds.\n- AC-REG-02: GIVEN a user clicks the verification link within 14 days, WHEN the link is valid, THEN the system SHALL mark the account as verified and allow todo creation.\n\nAuthentication (login/logout)\n- AC-AUTH-01: GIVEN valid credentials, WHEN the user submits them, THEN the system SHALL respond with a valid access token within 2 seconds (business-level expectation) and allow the user to create a todo.\n- AC-AUTH-02: GIVEN invalid credentials, WHEN attempted more than 5 times within 10 minutes, THEN the system SHALL enforce throttling measures that prevent further attempts for a cooldown period (business default: 15 minutes).\n- AC-AUTH-03: GIVEN an authenticated user, WHEN the user chooses to logout, THEN the system SHALL invalidate the refresh token used by that session within 5 seconds.\n\nToken renewal and revocation\n- AC-TOK-01: GIVEN an expired access token and a valid refresh token, WHEN renewal is attempted, THEN the system SHALL issue a new access token within 2 seconds.\n- AC-TOK-02: GIVEN a request to revoke all sessions, WHEN completed by the user, THEN all refresh tokens SHALL be invalidated within 30 seconds and subsequent attempts to use those tokens SHALL fail.\n\nAdmin actions and audit\n- AC-ADM-01: GIVEN an admin suspends a user, WHEN the action completes, THEN new authentication attempts by the target user SHALL be rejected immediately and an audit record SHALL be created.\n- AC-ADM-02: GIVEN an admin views another user's todos for support, WHEN such an access occurs, THEN the action SHALL be recorded with an \"admin_access\" audit flag and admin identifier.\n\n## Error and recovery scenarios (user-facing)\nDescribe user-visible failure modes and recovery behavior.\n\n1) Forgot password\n- User-facing behavior: WHEN a user requests a password reset, THE system SHALL send a reset link to the user's email. The link SHALL expire after 24 hours. If the user does not receive the email, the help page SHALL provide steps to request a new reset.\n\n2) Unverified account trying to create todos\n- User-facing behavior: IF an unverified user attempts to create a todo, THEN THE system SHALL prevent creation, inform the user that email verification is required, and provide a simple retry action to re-send the verification email.\n\n3) Suspended account\n- User-facing behavior: IF a suspended user attempts to authenticate, THEN THE system SHALL deny access and show a message that the account is suspended with directions to contact support. The system SHALL log suspension attempts for support review.\n\n4) Concurrent login conflict (simple rule)\n- User-facing behavior: WHEN a user logs in from a new device, THE system SHALL allow the new login and maintain existing sessions unless the user explicitly requests revocation of other sessions.\n\n## Performance and non-functional expectations (business-level)\n- THE system SHALL respond to common authentication actions (login, token refresh, logout) within 2 seconds under normal load (business expectation for user experience).\n- THE system SHALL process account creation and send verification email within 30 seconds of registration completion in typical conditions.\n- THE system SHALL invalidate revoked sessions within 30 seconds of revocation action.\n- THE system SHALL store audit records in a manner that supports retrieval for support investigations; retention policy is specified in Non-Functional Requirements document.\n\n## Diagrams\nAuthentication flow (high-level)\n\n```mermaid\ngraph LR\n  A[\"Visitor\"] --> B{\"Registers?\"}\n  B -->|\"Yes\"| C[\"Create Unverified Account\"]\n  C --> D[\"Send Verification Email\"]\n  D --> E{\"Email Verified?\"}\n  E -->|\"Yes\"| F[\"Mark Account Verified\"]\n  E -->|\"No\"| G[\"Restrict Todo Creation\"]\n  A -->|\"No\"| H[\"View Public Content\"]\n  F --> I[\"Login -> Issue Tokens\"]\n  I --> J[\"Use Access Token to Manage Own Todos\"]\n  J --> K{\"Admin Action?\"}\n  K -->|\"Yes\"| L[\"Audit Admin Access\"]\n  K -->|\"No\"| M[\"Normal User Activity\"]\n```\n\nRole-permission overview (stateful view)\n\n```mermaid\ngraph LR\n  U[\"guest\"] -->|\"View Public\"| P[\"Public Landing\"]\n  V[\"user\"] -->|\"Manage Own Todos\"| T[\"Todo Set (own)\"]\n  W[\"admin\"] -->|\"Manage Users\"| A2[\"User Accounts\"]\n  W -->|\"Access For Support\"| T\n  A2 -->|\"Suspend/Reactivate\"| V\n```\n\nNote: Diagrams are conceptual; nodes and arrows use double-quoted labels per documentation rules.\n\n## Open decisions and recommended defaults\nThe following items are business choices that must be confirmed by product stakeholders before development begins. Recommended defaults are provided to avoid blocking initial development.\n\n1) Email verification strictness\n- Recommendation (default): Require email verification before allowing todo creation. Rationale: reduces spam accounts and supports account recovery.\n\n2) Password complexity policy\n- Recommendation (default): Minimum 8 characters with at least one letter and one number. Rationale: balance between user friction and basic security for a minimal app.\n\n3) Session concurrency policy\n- Recommendation (default): Permit multiple concurrent sessions and provide a \"Revoke all sessions\" action for users who wish to sign out everywhere.\n\n4) Optional notification features\n- Recommendation (default): Do not implement in MVP; flag as optional feature (WHERE requirement above).\n\n## Related documents\n- For overall operation flows and primary scenarios, see the Service Operation Overview document (\"Top-level user journeys for a single-user Todo experience\" at ./04-service-operation-overview.md).\n- For EARS-formatted functional requirements across the product, see the Functional Requirements document (\"High-priority functional requirements in EARS format\" at ./08-functional-requirements.md).\n- For non-functional details such as retention, backup, and compliance, see the Non-Functional Requirements document (\"Performance expectations and availability targets\" at ./09-non-functional-requirements.md).\n\n## Final statements (scope and developer autonomy)\nThis document provides business requirements only. All technical implementation decisions — including architecture, APIs, database design, and operational tooling — are the responsibility of the development team and are not prescribed here.\n"},{"reason":"Map out common user success paths (happy paths) for the minimal Todo features.","filename":"06-primary-user-scenarios.md","documentType":"user-story","outline":["Primary user stories (register/login, create todo, mark complete, edit, delete)","Step-by-step journeys for each story","Acceptance criteria and success conditions","Simple test cases that validate the business behavior"],"audience":"QA, backend developers, product owners","keyQuestions":["What are the must-have user stories for the MVP?","What are the acceptance criteria for each story?"],"detailLevel":"detailed","relatedDocuments":["05-user-roles-and-personas.md","08-functional-requirements.md"],"constraints":["Stories should focus strictly on the minimal essential flow"],"content":"# 06 - Primary User Scenarios for todoApp\n\n## Scope and Purpose\nThis file describes the required primary user scenarios for the todoApp MVP in business terms. It defines happy-path flows, EARS-formatted requirements, acceptance criteria, user-visible error handling, QA test cases, and measurable non-functional expectations. The content is written for product owners, backend developers, and QA teams to derive test cases and implementation behavior.\n\n## Table of contents\n- Assumptions and audience\n- Roles and permissions\n- Primary user stories\n  - Register & Login\n  - Create a todo\n  - View/List todos\n  - Edit a todo\n  - Mark complete / incomplete\n  - Delete and recover a todo\n- EARS-formatted requirements (mapped)\n- Acceptance criteria and measurable targets\n- QA checklist and simple test cases\n- Secondary flows and exceptions\n- User-facing error messages and recovery steps\n- Performance and non-functional expectations\n- Mermaid diagrams\n- Open decisions and glossary\n\n## Assumptions and audience\n- Audience: Product owners, backend developers, QA, support.\n- Assumptions:\n  - Authenticated accounts are required for persistence across devices (guest cannot persist todos).\n  - Each todo is owned by exactly one user; no sharing in MVP.\n  - Minimal attributes: title (required), description (optional), dueDate (optional), priority (optional: low/medium/high), createdAt, completedAt, status.\n  - Soft-delete retention window: default 30 days (business default, confirmable).\n\n## Roles and permissions (business-level)\n- guest: view public landing and help. Cannot create or persist todos.\n- user: registered authenticated user. Can create, read, update, mark complete/incomplete, soft-delete and recover their own todos.\n- admin: operational role. Can suspend/reactivate accounts, view aggregated metrics, perform audited maintenance, and assist users; admin actions must be recorded in audit logs.\n\n## Primary user stories and detailed happy-paths\n\n### 1) Register & Login (Authentication)\nHappy path:\n- Visitor provides email and password and submits registration.\n- System validates inputs, creates an account, optionally sends verification email, and allows authentication.\n- User logs in, receives authenticated session enabling todo management.\n\nEARS requirements:\n- WHEN a visitor submits valid registration information, THE system SHALL create a new user account and allow authentication according to configured verification policy.\n- WHEN a user submits valid login credentials, THE system SHALL authenticate the user and establish a session enabling CRUD operations on their todos.\n\nAcceptance criteria:\n- Registration with unused email and valid password returns success within 3 seconds.\n- Login with correct credentials returns authenticated session within 2 seconds.\n- Duplicate-email registration attempts return a clear error immediately.\n\nSimple test cases:\n- Register with fresh email → success, can login and create todo.\n- Register with existing email → duplicate error.\n- Login with wrong password → authentication error shown.\n\n### 2) Create a todo (Quick Capture)\nHappy path:\n- Authenticated user enters a title (required) and optional fields and saves.\n- System validates title (non-empty, max 250 chars), creates a todo with status \"active\", sets createdAt, and returns the created item.\n\nEARS requirements:\n- WHEN an authenticated user submits a new todo with a non-empty title, THE system SHALL create a TodoItem with status \"active\", set createdAt to the current timestamp, and return the created item to the caller.\n- IF the submitted title is empty or whitespace-only, THEN THE system SHALL reject the create request and return a user-facing validation error specifying that \"title\" is required.\n\nAcceptance criteria:\n- Valid create: created todo appears in the user's default list within 2 seconds (95th percentile under normal conditions).\n- Invalid title: user sees validation error and the item is not created.\n\nSimple test cases:\n- Create with title only (expect success)\n- Create with empty title (expect validation error)\n- Create with title length 300 (expect validation error for >250)\n\n### 3) View / List todos\nHappy path:\n- Authenticated user requests their todo list.\n- System returns user's active todos ordered newest-first by default, supporting optional filters for completed or deleted states.\n\nEARS requirements:\n- WHEN an authenticated user requests their todo list, THE system SHALL return only todos owned by that user ordered newest-first and will paginate results for large lists.\n\nAcceptance criteria:\n- First page (up to 50 items) returns within 1 second median and within 2 seconds at 95th percentile in normal conditions.\n- Users never see other users' todos.\n\nTest cases:\n- User with 3 todos sees them newest-first.\n- User with zero todos receives an empty-state message.\n\n### 4) Edit a todo\nHappy path:\n- User opens their todo, edits fields (title, description, dueDate, priority), and saves.\n- System validates and persists updates, updates updatedAt, and returns the updated item.\n\nEARS requirements:\n- WHEN an authenticated user updates a todo they own with valid values, THE system SHALL apply the changes and update the modification timestamp.\n- IF a user attempts to edit a todo they do not own, THEN THE system SHALL deny the request and return an authorization error.\n\nAcceptance criteria:\n- Valid edits appear within 2 seconds for P95 under normal load.\n- Unauthorized edits are rejected with clear message.\n\nTest cases:\n- Edit title successfully.\n- Attempt to edit another user's todo → authorization error.\n\n### 5) Mark complete / incomplete\nHappy path:\n- User toggles completion; system sets status to \"completed\" and records completedAt; uncomplete clears completedAt and returns to \"active\".\n\nEARS requirements:\n- WHEN an authenticated user marks a todo as completed, THE system SHALL set status to \"completed\", set completedAt to the current timestamp, and persist the change.\n- WHEN an authenticated user marks a completed todo as incomplete, THE system SHALL set status to \"active\" and clear completedAt.\n\nAcceptance criteria:\n- Toggle actions reflected in UI within 1 second under typical conditions.\n\nTest cases:\n- Mark todo complete and verify completedAt exists.\n- Mark complete then uncomplete and verify completedAt is cleared.\n\n### 6) Delete and recover a todo\nHappy path:\n- User deletes a todo; system soft-deletes it, sets status \"deleted\" and DeletedAt, removes it from active list, and allows restore within retention window (30 days).\n\nEARS requirements:\n- WHEN an authenticated user deletes a todo they own, THE system SHALL mark the todo as \"deleted\", set DeletedAt to timestamp, and remove it from default active lists. THE system SHALL allow recovery within 30 days.\n- WHEN a user requests restore of a deleted todo within retention period, THE system SHALL set status back to \"active\" (or \"completed\" if CompletedAt exists) and clear DeletedAt.\n\nAcceptance criteria:\n- Deleted items do not appear in active lists and are recoverable within retention window.\n- Permanent purge happens only after retention window elapses (administrative purge accepted).\n\nTest cases:\n- Delete todo and verify absence from active list.\n- Restore within 30 days → todo present.\n- Attempt restore after 30 days → not recoverable.\n\n## EARS-formatted requirements (summary mapping)\n- WHEN a visitor registers with valid information, THE system SHALL create a user account and allow authentication.\n- WHEN a user creates a todo with a valid title, THE system SHALL create a TodoItem with status \"active\" and set createdAt.\n- IF a create/update request contains invalid input (empty title, invalid due date, invalid priority), THEN THE system SHALL return field-level validation errors describing the failure.\n- WHEN a user attempts to access or modify a todo they do not own, THEN THE system SHALL deny the request and return an authorization error.\n- WHEN a user deletes a todo, THE system SHALL soft-delete and preserve it for 30 days for recovery, and THE system SHALL permit admins to permanently purge per policy.\n\n## Acceptance criteria and measurable targets\n- Response time: primary actions (create/read/update/delete/toggle) SHALL reflect changes to the user within 2 seconds at the 95th percentile under normal load.\n- List retrieval: first page (<=50 items) SHALL return within 1 second median and 2 seconds P95 under normal load.\n- Validation: title SHALL be required and max 250 characters.\n- Retention: deleted items SHALL be recoverable for 30 days.\n- Auth: registration and login SHALL complete within 3 seconds and 2 seconds respectively under typical conditions.\n\n## QA checklist and simple test cases\nFor each primary story, QA must validate: happy path success, common validation failures, unauthorized access, performance targets, and recovery behavior.\n\nExample checklist entries:\n- Registration success and duplicate-email rejection\n- Login success and wrong-password handling\n- Create todo with valid and invalid titles\n- Edit todo owned vs not owned\n- Mark complete/uncomplete state transitions and timestamps\n- Delete → restore within retention window\n- Deleted items purge after retention window (operational test)\n\n## Secondary flows and exceptions\n\n### Offline & Sync\n- WHEN a user acts while offline, THE client SHALL queue changes locally and present a \"pending sync\" indicator. WHEN connectivity is restored, THE client SHALL attempt to sync queued changes and present success or conflict prompts.\n\n### Concurrent edits and conflict handling\n- IF two updates to the same field occur concurrently, THEN THE system SHALL surface a conflict to the user indicating both versions and choices to resolve (Keep Mine, Keep Other, Edit). For MVP a last-write-wins may be used with an operational log; however, user-visible conflict prompts are recommended.\n\n### Rate limiting and abusive behavior\n- WHEN a user exceeds write rate limits (e.g., 10 writes/min by default), THEN THE system SHALL return a rate-limit error with retry-after guidance.\n\n## User-facing error messages and recovery steps\n- Validation error: \"Please enter a title. Title must be 1-250 characters.\" [Focus title input]\n- Auth required: \"Please sign in to manage your todos.\" [Sign In]\n- Session expired: \"Your session expired. Sign in again to continue. Your changes are preserved for retry.\" [Sign In]\n- Offline pending: \"You're offline. Changes are saved locally and will sync when you reconnect.\" [Retry Sync]\n- Rate limit: \"You're making requests too quickly. Please wait X seconds and try again.\" [Retry Later]\n- Permanent delete: \"This item has been permanently deleted and cannot be recovered.\" [Contact Support]\n\n## Performance and non-functional expectations\n- User-facing performance: P95 for primary actions <= 2 seconds; median list retrieval <= 300 ms for <=50 items.\n- Availability: target 99.9% uptime for MVP; operations to define scheduled maintenance windows.\n- Backup & retention: backups executed to meet RPO <= 1 hour and RTO <= 4 hours at business level; deleted-item retention 30 days.\n\n## Mermaid diagrams\nCreate flow:\n```mermaid\ngraph LR\n  A[\"Start (User)\"] --> B{\"Authenticated?\"}\n  B -->|\"No\"| C[\"Prompt Sign In/Register\"]\n  C --> D[\"Authenticate\"]\n  B -->|\"Yes\"| E[\"Show Create Input\"]\n  E --> F[\"Validate Title\"]\n  F -->|\"Valid\"| G[\"Persist Todo (status 'active')\"]\n  F -->|\"Invalid\"| H[\"Return Validation Error\"]\n  G --> I[\"Return Created Todo & Update List\"]\n```\n\nLifecycle flow:\n```mermaid\ngraph LR\n  A[\"Active\"] --> B{\"Mark Complete?\"}\n  B -->|\"Yes\"| C[\"Completed\"]\n  C --> D{\"Archive or Delete?\"}\n  D -->|\"Archive\"| E[\"Archived\"]\n  D -->|\"Delete\"| F[\"Deleted (soft)\"]\n  F --> G{\"Within 30 days?\"}\n  G -->|\"Yes\"| H[\"Recover to Active/Completed\"]\n  G -->|\"No\"| I[\"Permanently Purged\"]\n```\n\n## Open decisions (to confirm with product)\n- Confirm whether email verification is mandatory before enabling todo creation for new accounts.\n- Confirm soft-delete retention window (default 30 days recommended).\n- Decide whether conflict resolution for concurrent edits must offer interactive UI (recommended) or rely on server-side last-write-wins for MVP.\n- Confirm exact rate-limit thresholds and account lockout policy for authentication failures.\n\n## Glossary\n- P95: 95th percentile\n- Active: todo is visible in primary list and editable\n- Completed: todo has been marked done; CompletedAt timestamp set\n- Deleted: todo is soft-deleted and recoverable during retention window\n\n\n\n"},{"reason":"Cover alternative flows and error conditions that must be handled from the user's perspective.","filename":"07-secondary-scenarios-and-exceptions.md","documentType":"requirement","outline":["Alternative user flows (e.g., offline, concurrent edits)","Error conditions and user-facing recovery steps","Data loss prevention and basic recovery expectations","Manual admin recovery procedures for critical failures"],"audience":"Development team, QA, support staff","keyQuestions":["What errors should be handled gracefully for the MVP?","What user-facing messages and recovery options are required?"],"detailLevel":"moderate detail","relatedDocuments":["06-primary-user-scenarios.md","09-non-functional-requirements.md"],"constraints":["Avoid technical implementation details; describe user-visible behavior only"],"content":"# todoApp — Requirements Analysis Report\n\n## Executive Overview\n\ntodoApp provides a minimal, single-user-focused Todo list experience that enables fast capture, reliable persistence, and predictable task lifecycle management. The target audience for this report is product owners, backend developers, QA, and operations. The goal is to define the business-level requirements necessary to build an MVP that supports authenticated personal task lists with soft-delete recovery and basic administrative controls.\n\n## Scope and Assumptions\n\n- In scope (MVP): authenticated user accounts, create/read/update/delete (CRUD) for personal todos, mark complete/uncomplete, soft-delete with 30-day recovery window, optional fields (description, dueDate, priority), admin suspend/reactivate and audit logging.\n- Out of scope (MVP): collaboration/sharing, tags/projects, complex recurrence, attachments, push/email reminders (deferred).\n- Assumptions: authenticated persistence is required for cross-device sync; guests can view landing content only and cannot persist todos.\n\n## Goals and Success Metrics (KPIs)\n\n- Activation: >= 40% of new accounts create at least one todo within 7 days.\n- Retention: 7-day retention >= 25%, 30-day retention >= 10% among users who created a todo.\n- Time-to-first-task: median <= 2 minutes from registration.\n- Reliability: create/update/delete success rate >= 99.5% under normal load.\n- Performance: 95th percentile for common operations (create/list/update/delete) <= 2 seconds.\n\n## User Roles and Personas\n\nRoles (business-level):\n- guest: view public content only. Cannot persist todos.\n- user: authenticated person; owns todos; can create/read/update/delete/complete/recover their own todos.\n- admin: operational role; can suspend/reactivate users, view aggregated metrics, and perform recovery/maintenance actions. Admin actions MUST be auditable.\n\nPersonas:\n- Quick-Capture Carla: needs instant entry and simple completion toggles.\n- Sync Sam: needs persistence across devices and reliable sign-in.\n- Support Admin: needs audit trails and ability to suspend/reactivate accounts.\n\nPermission matrix (business view):\n- Create todo: guest ❌, user ✅, admin ✅ (audited)\n- Read own todos: guest ❌, user ✅, admin ✅ (for support/audit)\n- Update own todos: guest ❌, user ✅, admin ✅ (audited)\n- Delete own todos: guest ❌, user ✅, admin ✅ (audited)\n- Manage users: guest ❌, user ❌, admin ✅\n\n## Primary User Scenarios (Happy Paths)\n\nScenario 1 — Register & Login\n- WHEN a visitor registers with a valid email and password, THE system SHALL create an account (unverified or verified per business policy) and allow authentication.\n- Acceptance: new user can sign in and persist todos.\n\nScenario 2 — Create Todo (Quick Capture)\n- WHEN an authenticated user submits a new todo with a non-empty title, THE system SHALL persist a TodoItem with state \"active\" and createdAt timestamp and return it for immediate display.\n- Acceptance: created todo appears in the list within 2 seconds for 95% of requests.\n\nScenario 3 — Edit Todo\n- WHEN an authenticated user edits fields of a todo they own, THE system SHALL apply the changes and set updatedAt.\n- Acceptance: updated fields are visible within 2 seconds.\n\nScenario 4 — Complete/Uncomplete\n- WHEN an authenticated user toggles completion, THE system SHALL set the completed flag and completedAt (or clear it when uncompleting).\n- Acceptance: toggles reflect in the UI and persistence within 2 seconds.\n\nScenario 5 — Delete and Recover\n- WHEN an authenticated user deletes a todo, THE system SHALL mark it as \"deleted\" (soft-delete) and retain it for 30 days for recovery; within that window the user SHALL be able to restore the todo.\n- Acceptance: deleted items are removed from active lists and appear in a recoverable view until permanence.\n\nScenario 6 — Admin Maintenance\n- WHEN an admin suspends a user, THE system SHALL prevent the suspended user from authenticating and record the admin action in audit logs.\n- Acceptance: suspended user cannot log in and action is auditable.\n\n## Functional Requirements (EARS format)\n\nAccounts & Authentication\n\n- WHEN a visitor submits registration with valid credentials, THE system SHALL create a new user account and allow authentication according to the account verification policy.\n\n- WHEN a user submits valid login credentials, THE system SHALL authenticate the user and issue session tokens to enable account-scoped operations.\n\n- IF an unauthenticated actor attempts a todo-management action, THEN THE system SHALL deny the request and present an authentication-required message.\n\nTodo Lifecycle\n\n- WHEN an authenticated user creates a todo with a valid title, THE system SHALL persist a TodoItem with status \"active\", set createdAt to the current timestamp, and return the created item to the user.\n\n- IF a create or update request contains an empty title, THEN THE system SHALL reject the request and return a validation error stating \"Title is required\".\n\n- WHEN an authenticated user marks a todo complete, THE system SHALL set status to \"completed\" and set completedAt to the current timestamp.\n\n- WHEN an authenticated user marks a completed todo as uncomplete, THE system SHALL set status to \"active\" and clear completedAt.\n\n- WHEN an authenticated user deletes a todo, THE system SHALL mark it as \"deleted\" and retain it for a 30-day recovery window; after the retention window, THE system SHALL consider it eligible for permanent purge.\n\n- WHEN a user requests a list of todos, THE system SHALL return only todos owned by that user, ordered newest-first by default, and SHALL support optional filtering by state (active/completed/deleted).\n\nAdministrative\n\n- WHEN an admin performs an action that affects user data or account state, THE system SHALL record an audit entry including admin identifier, action type, target user, timestamp, and optional reason.\n\nValidation & Input Constraints\n\n- WHEN a title is provided, THE system SHALL accept non-empty strings up to 250 characters. Titles exceeding the limit SHALL be rejected with a validation error.\n\n- WHEN a dueDate is provided, THE system SHALL accept ISO 8601 date-only or date-time values and SHALL validate the format.\n\nSecurity & Privacy (business-level)\n\n- WHEN a user requests account deletion, THE system SHALL follow the retention and deletion policy and remove or anonymize personal data within the stated business timeframe unless legal hold applies.\n\n- WHILE a user is authenticated, THE system SHALL ensure that the user only sees todos they own.\n\n## Authentication & Session Management (Business Guidance)\n\n- Token model (business-level): THE system SHALL use access tokens for short-lived API access and refresh tokens for session continuation. Recommended business defaults: access token ~20 minutes, refresh token ~14 days. Exact implementation details (storage, signing) are left to implementers.\n\n- WHEN a user requests to revoke all sessions, THE system SHALL invalidate refresh tokens and require re-authentication on all devices.\n\n- WHEN an admin suspends an account, THE system SHALL invalidate active refresh tokens for that account.\n\n## Non-Functional Requirements (Business Targets)\n\nPerformance\n- WHEN a user performs a common operation (create/list/update/delete), THE system SHALL reflect the result and make it visible within 2 seconds for 95% of requests under normal load.\n\nAvailability & Reliability\n- THE service SHALL target 99.9% uptime (monthly) for core user flows, excluding scheduled maintenance.\n\nBackup & Recovery\n- THE system SHALL maintain backups with an RPO <= 1 hour and an RTO <= 4 hours for critical data recovery for MVP-scale incidents.\n\nSecurity & Compliance\n- Admin audit logs SHALL be retained for at least 365 days.\n- Passwords and secrets SHALL be protected per industry best practices (implementation detail to engineering).\n\nScalability & Rate Limiting\n- THE system SHALL rate-limit write operations to protect service health; recommended MVP rate: 10 writes/min per user with clear errors and retry guidance.\n\n## Data Flow & Lifecycle (Conceptual)\n\nStates: Active -> Completed -> Deleted(soft) -> Purged\n\n```mermaid\ngraph LR\n  A[\"Active\"] --> B[\"Completed\"]\n  B --> C[\"Deleted(Soft)\"]\n  A --> C\n  C --> D[\"Permanently Deleted\"]\n  C --> E[\"Restored\"]\n  E --> A\n```\n\nBusiness rules:\n- Soft-deleted items are recoverable for 30 days. After 30 days they become eligible for permanent purge.\n- Archived behavior is optional and deferred to post-MVP decisions.\n\n## Secondary Scenarios & Error Handling\n\nOffline and Sync\n- WHEN a user attempts to create/update while offline, THE system (or client) SHALL queue changes and attempt automatic synchronization when connectivity returns; the UI SHALL show a pending-sync indicator.\n\nConflict Resolution\n- WHEN concurrent edits occur, THE system SHALL prefer last-writer-wins for MVP but SHALL surface conflicts to the user where an overwrite would lose visible work; future iterations should add explicit conflict resolution UI.\n\nValidation Errors\n- IF input validation fails, THEN THE system SHALL present a clear field-level message (e.g., \"Title is required\", \"Due date format invalid\").\n\nTransient Failures\n- IF a transient persistence error occurs, THEN THE system SHALL notify the user, preserve client-side input where possible, and advise retry.\n\nRate Limiting & Abuse\n- WHEN rate limits are exceeded, THE system SHALL return a clear rate-limit error including a suggested retry delay.\n\nDelete Undo\n- WHEN a user deletes a todo, THE UI SHALL present an immediate undo affordance for 30 seconds to restore the item to Active.\n\n## Acceptance Criteria and QA Mapping\n\nFor each primary scenario provide a concise acceptance test:\n- Create Todo: Given authenticated user and valid title, when create is submitted, then the item appears in the list within 2 seconds.\n- Edit Todo: Given ownership and valid edits, when edit submitted, then updated fields appear within 2 seconds.\n- Complete Toggle: Given ownership, when toggled complete, then completedAt exists and item moves to completed view.\n- Delete & Recover: Given ownership, when delete performed, then item removed from active list and recoverable within 30 days.\n- Auth: Given valid credentials, when login performed, then user receives tokens and may perform CRUD.\n\n## Open Decisions and Stakeholder Confirmations\n\n- Email verification at sign-up: REQUIRED or OPTIONAL? Recommendation: require verification for production, optional for early testing.\n- Soft-delete retention: default 30 days recommended; confirm with operations/legal.\n- DueDate and Priority: include as optional in MVP or defer? Recommendation: include them as optional fields hidden behind \"Add details\".\n- Undo window for delete: recommended 30 seconds; confirm desired UX.\n\n## Appendix\n\nGlossary: TodoItem, ownerId, active/completed/deleted, RPO, RTO, KPI definitions.\n\nChange log template:\n- Version: 1.0\n- Date: YYYY-MM-DD\n- Author: [product]\n- Summary: Initial requirements analysis for todoApp MVP.\n\nContact points: Product Owner, Engineering Lead, QA Lead (placeholders to be filled by project team).\n\n\n"},{"reason":"List all functional requirements in business language using EARS format where applicable.","filename":"08-functional-requirements.md","documentType":"requirement","outline":["High-priority functional requirements in EARS format","Lower-priority optional features flagged as optional","Input validation rules and business validation (conceptual)","Acceptance criteria and measurable success conditions"],"audience":"Backend developers, product managers, QA","keyQuestions":["What must the system do for the MVP in explicit, testable terms?","Which requirements are mandatory versus optional?"],"detailLevel":"detailed","relatedDocuments":["05-user-roles-and-personas.md","06-primary-user-scenarios.md"],"constraints":["All EARS-formattable requirements must use EARS syntax","No API or database schema details are to be included"],"content":"# 08 - Functional Requirements for todoApp (Enhanced)\n\n## 1. Scope and purpose\n\nThis file defines the mandatory functional requirements for the minimal todoApp MVP. The primary focus is a single-user-per-account model where authenticated users can create, view, update, complete/uncomplete, soft-delete, and export personal todo items. Requirements are stated in business language and use EARS phrasing for testability. Implementation details such as database schemas, API endpoint signatures, or specific cryptographic libraries are intentionally omitted.\n\n## 2. Audience and related documents\n\nPrimary audience: backend developers, QA engineers, product owners, and operations. Related artifacts:\n- Service Overview (01-service-overview.md) — business goals and KPIs\n- User Roles and Personas (05-user-roles-and-personas.md) — role definitions and authentication expectations\n- Primary User Scenarios (06-primary-user-scenarios.md) — happy paths and user stories\n- Data Flow and Lifecycle (10-data-flow-and-lifecycle.md) — lifecycle states and retention\n- Non-Functional Requirements (09-non-functional-requirements.md) — performance and availability targets\n\n## 3. MVP boundaries and non-goals\n\n- In scope: authenticated user accounts, per-user todo CRUD, completion toggles, soft-delete with recoverability, basic admin maintenance (suspend/reactivate), audit logging for admin actions, optional export (CSV/plain text).\n- Out of scope for MVP: sharing/collaboration, attachments, complex recurrence, advanced search and tags, push/email reminders (optional later), project/group features.\n\n## 4. Roles and permission matrix (business-level)\n\nRoles: guest, user, admin. Permission mapping (business view):\n\n- Create todo: guest ❌ | user ✅ | admin ✅ (audited)\n- Read own todos: guest ❌ | user ✅ | admin ✅ (audited, for support)\n- Update own todos: guest ❌ | user ✅ | admin ✅ (audited)\n- Delete (soft) own todos: guest ❌ | user ✅ | admin ✅ (audited)\n- Hard purge permanently: guest ❌ | user ❌ | admin ✅ (audited)\n- Suspend/reactivate account: guest ❌ | user ❌ | admin ✅\n\nEARS enforcement: WHEN a user attempts an action, THE system SHALL enforce ownership and role-based permissions and SHALL deny unauthorized attempts with a clear authorization error.\n\n## 5. Authentication and session management (business-level)\n\n- WHEN a user registers, THE system SHALL create a user account record with accountStatus \"active\" unless business policy requires verification.\n- WHEN a user authenticates successfully, THE system SHALL issue an access token (short-lived) and a refresh token (longer-lived) to enable the authenticated session.\n- Token guidance (business-level): access token expiry recommended 15-30 minutes; refresh token expiry recommended 7-30 days. THE system SHALL support refresh token revocation to enable \"sign out everywhere\" semantics.\n- WHEN an admin suspends an account, THE system SHALL reject new authentication attempts for that account and SHALL invalidate or deny refresh token renewals for the suspended account.\n- WHEN a refresh token is revoked or expired, THE system SHALL require credentials re-entry to obtain new refresh tokens.\n\nAcceptance metric: issuance/renewal failures and session revocations SHALL be visible to support logs and return user-facing messages within 2 seconds.\n\n## 6. EARS-Formatted Functional Requirements\n\nAccount lifecycle\n\n1. WHEN a visitor provides required registration fields and submits registration, THE system SHALL create a user account, set accountStatus to \"active\" (or \"unverified\" if email verification is required), record createdAt timestamp, and return a success acknowledgement.\n\n2. IF a registration request uses an email already associated with an active account, THEN THE system SHALL reject the registration and return a duplicate-account validation error with a machine-readable error code (e.g., ERR_ACCOUNT_EXISTS).\n\n3. WHEN a user requests password reset, THE system SHALL send a time-limited reset mechanism to the registered email address and SHALL expire the reset mechanism after 24 hours.\n\nAuthentication and authorization\n\n4. WHEN a user submits valid credentials, THE system SHALL authenticate the user and issue tokens as described in Section 5; failure to authenticate SHALL result in an authentication error and increment local rate-limiting counters.\n\n5. IF a user submits invalid credentials more than 10 times within a 15-minute window, THEN THE system SHALL apply a cooldown or temporary lockout policy and provide a user-facing message advising how to recover access.\n\nTodo CRUD and lifecycle\n\n6. WHEN an authenticated user submits a create-todo request with a non-empty title, THE system SHALL persist a new TodoItem with state \"active\", set createdAt to the current timestamp, associate ownerId to the requesting user, and return the created item for immediate display.\n\n7. IF a create-todo request contains an empty or whitespace-only title or a title exceeding 250 characters, THEN THE system SHALL reject the request and return a validation error containing the human-friendly message \"Title is required and must be 1-250 characters\" and machine error code ERR_INVALID_TITLE.\n\n8. WHEN an authenticated user requests a list of todos, THE system SHALL return only todos owned by that user, ordered newest-first by default, and SHALL provide optional query parameters to filter by state (active, completed, deleted) and to paginate results.\n\n9. WHEN an authenticated user requests to update fields of a todo they own (title, description, dueDate, priority), THE system SHALL validate inputs and apply the permitted changes, updating updatedAt to the time of change. THE system SHALL reject attempts to update another user's todo with an authorization error.\n\n10. WHEN an authenticated user marks an active todo as completed, THE system SHALL set state to \"completed\", set completedAt to the current timestamp, and record the action for potential audit/history purposes.\n\n11. WHEN an authenticated user marks a completed todo as incomplete, THE system SHALL set state to \"active\" and clear completedAt.\n\n12. WHEN an authenticated user deletes a todo, THE system SHALL set state to \"deleted\" (soft-delete), set deletedAt timestamp, remove it from the default active/completed lists immediately, and allow restoration by the owner within the retention window.\n\n13. IF a deleted todo reaches the retention window expiration (business default 30 days), THEN THE system SHALL mark the item eligible for permanent purge and SHALL allow administrators to perform purges per policy. Permanent purge SHALL remove the item from general recovery paths.\n\nOwnership and access control\n\n14. WHEN any request attempts to access or modify a todo, THE system SHALL verify that the requestor is the owner or an administrator with auditable justification. THE system SHALL deny unauthorized access and return an authorization error.\n\nAdmin operations and auditing\n\n15. WHEN an admin performs elevated actions (suspend/reactivate account, hard purge, act-as-user for troubleshooting), THE system SHALL record an audit entry containing adminId, timestamp, actionType, targetResource, and optional reason. Audit entries SHALL be retained for at least 365 days.\n\n16. IF an admin performs user-data restore or manual purge, THEN THE system SHALL require an explicit reason in the admin interface and SHALL record the reason in the audit trail.\n\nOptional and WHERE requirements\n\n17. WHERE export is enabled, THE system SHALL allow a user to request an export of their todo items in CSV or newline-delimited text including CreatedAt, CompletedAt, DeletedAt timestamps; the export SHALL be generated within a reasonable time window (business default: within 1 hour) and be available for download with an expiry link.\n\n18. WHERE priority or dueDate fields are used, THE system SHALL accept only allowed values and formats defined in Section 7 Input Validation.\n\n## 7. Input validation rules (field-level)\n\nTitle\n- WHEN a title is submitted, THE system SHALL require a trimmed string with length >=1 and <=250 characters. Error response: ERR_INVALID_TITLE with message \"Title is required and must be 1-250 characters.\".\n\nDescription\n- WHEN a description is provided, THE system SHALL accept up to 4,000 characters. If longer, THE system SHALL reject with ERR_INVALID_DESCRIPTION and message \"Description exceeds maximum length (4000 characters).\".\n\nDueDate\n- WHEN a dueDate is provided, THE system SHALL accept ISO 8601 date or date-time (YYYY-MM-DD or YYYY-MM-DDThh:mm:ssZ) and SHALL validate business semantics (for example, optional warning if dueDate < createdAt). If format invalid, return ERR_INVALID_DUEDATE.\n\nPriority\n- WHEN a priority value is provided, THE system SHALL accept only the enumerated values \"low\", \"medium\", or \"high\". Invalid values return ERR_INVALID_PRIORITY.\n\nOwnership fields\n- ownerId SHALL be set by the system at create time and SHALL NOT be accepted from client input for create/update operations.\n\nError payload guidance (business-level)\n- Error responses SHALL include: machine error code, human-friendly message, and optionally a field-level error map when relevant (e.g., { field: \"title\", code: \"ERR_INVALID_TITLE\" }).\n\n## 8. Concurrency, conflict handling and offline considerations\n\nConcurrency model (MVP)\n- WHEN concurrent updates occur to the same todo, THE system SHALL use last-write-wins semantics at the attribute level for MVP and SHALL include updatedAt timestamps on responses so clients can detect potential overwrites.\n\nConflict detection\n- WHERE feasible, THE system SHALL use optimistic concurrency control: if an update includes a client-provided version or updatedAt and the server detects a mismatch, THEN THE system SHALL reject the update with ERR_CONFLICT and include the latest server-side representation.\n\nOffline/queued edits (client responsibility, MVP guidance)\n- WHEN a client queues edits offline, THE system SHALL accept queued edits on reconnection and THE system SHALL surface any conflicts per the conflict detection rule above. Clients SHALL be instructed to surface merge/conflict resolution to users when ERR_CONFLICT is returned.\n\nUser-facing conflict messages\n- \"Your changes conflict with a more recent update. Review the latest version and reapply changes or choose to overwrite.\" Provide buttons: \"View Latest\", \"Overwrite\", \"Cancel\" (UI-level guidance).\n\n## 9. Error handling, user-facing messages, and recovery\n\nValidation errors\n- WHEN validation fails, THE system SHALL return a 4xx response with machine error code and friendly message targeted to the failing field.\n\nAuthorization errors\n- WHEN an unauthorized access is attempted, THE system SHALL return an authorization error message: \"You are not authorized to perform this action.\" Include error code ERR_UNAUTHORIZED.\n\nTransient operational failures\n- IF an operation fails for transient reasons (storage unavailability, downstream error), THEN THE system SHALL return a retryable error and recommend client retry strategies with exponential backoff. User-facing message: \"We couldn't save your changes right now. Please try again.\".\n\nRate limiting\n- WHEN a user exceeds write rate limits (business default: 10 writes/minute), THEN THE system SHALL return ERR_RATE_LIMIT and include Retry-After seconds; user-facing message: \"You're making requests too quickly. Please wait X seconds and try again.\".\n\nDelete/undo\n- WHEN a user deletes a todo, THE system SHALL provide an immediate undo affordance in the client for 30 seconds and SHALL retain the item in state \"deleted\" for the full retention window.\n\n## 10. Non-functional acceptance criteria mapped to functional requirements\n\n- Latency: WHEN a user performs create/update/delete/list requests under normal load, THE system SHALL present confirmation to the user within 2 seconds for 95% of requests and within 500 ms median for small operations.\n- Durability: WHEN the system reports success for a create/update/delete, THEN that change SHALL survive service restarts and shall be included in backups per backup RPO described in the Non-Functional Requirements document.\n- Auditability: WHEN an admin performs an elevated action, THEN an audit event shall be recorded and retained for 365 days.\n\nTest assertions for acceptance tests\n- CreateTodo performance test: 95th-percentile <= 2s for single create operation under typical MVP load.\n- Data isolation test: two distinct users' lists do not include each other's todos in any tested scenario.\n- Retention test: deleted item recoverable by owner within 30 days and irrecoverable after purge.\n\n## 11. Acceptance tests and example test cases\n\nTest Case: Create Todo (positive)\n- Setup: Authenticate as user A.\n- Steps: Submit create with title \"Buy milk\".\n- Expect: Response success; todo appears in list within 2 seconds; createdAt timestamp present; ownerId equals user A.\n\nTest Case: Create Todo (validation)\n- Steps: Submit create with empty title.\n- Expect: Validation error ERR_INVALID_TITLE returned; no todo created.\n\nTest Case: Unauthorized access\n- Steps: User A attempts to update User B's todo id.\n- Expect: Authorization error ERR_UNAUTHORIZED and no modification applied.\n\nTest Case: Soft-delete and restore\n- Steps: Delete todo; use restore within 30 days.\n- Expect: Item removed from active list immediately; restore returns item to active state and clears deletedAt.\n\nTest Case: Conflict detection\n- Steps: Load same todo in two clients; client1 updates title; client2 attempts to update based on stale updatedAt.\n- Expect: Server returns ERR_CONFLICT to client2 with latest representation.\n\n## 12. Data lifecycle and retention mapping (concise)\n\n- WHEN a todo is soft-deleted, THE system SHALL mark deletedAt and retain the record for 30 days (business default) enabling owner restore.\n- AFTER retention window, THE system SHALL make the item eligible for permanent purge by admin processes; permanent purge removes the item from general recovery and visible user paths.\n\n## 13. Mermaid diagrams (corrected syntax)\n\nPrimary happy-path: Create -> Complete -> Delete\n\n```mermaid\ngraph LR\n  A[\"Visitor\"] --> B{\"\"Authenticated?\"\"}\n  B -->|\"No\"| C[\"Show Landing / Sign In\"]\n  B -->|\"Yes\"| D[\"Authenticated Session\"]\n  D --> E[\"Create Todo (title required)\"]\n  E --> F[\"Persist as 'active'\"]\n  F --> G[\"List shows todo (newest-first)\"]\n  G --> H[\"User marks complete\"]\n  H --> I[\"State 'completed' and completedAt set\"]\n  I --> J[\"User deletes (soft-delete)\"]\n  J --> K[\"State 'deleted' and DeletedAt set (recoverable)\"]\n```\n\nTodo lifecycle states diagram\n\n```mermaid\ngraph LR\n  A[\"Active\"] --> B[\"Completed\"]\n  B --> C[\"Archived\"]\n  A --> C\n  A --> D[\"Deleted (soft)\"]\n  B --> D\n  C --> D\n  D --> E[\"Purged (permanent)\"]\n  D --> F[\"Restored\"]\n  F --> A\n```\n\nNote: All labels use double quotes and nodes contain no extra spaces between bracket and opening quote.\n\n## 14. Traceability and mapping to other documents\n\n- Requirements referencing authentication and role behavior trace to 05-user-roles-and-personas.md.\n- Lifecycle and retention requirements map to 10-data-flow-and-lifecycle.md.\n- Non-functional acceptance criteria map to 09-non-functional-requirements.md.\n\n## 15. Glossary and definitions\n\n- TodoItem: conceptual task entity with mandatory title and optional description, dueDate, priority, and ownership.\n- ownerId: system-assigned identifier referring to the owning user account.\n- active/completed/deleted/archived: lifecycle states described throughout the package.\n- ERR_*: machine-readable error code prefix for validation and operational errors.\n\n## 16. Open decisions and assumptions (to confirm before implementation)\n\n- Confirm whether email verification is mandatory at registration for MVP or optional.\n- Confirm retention windows for deleted/archived items (defaults provided: 30 days deleted, 365 days archived).\n- Confirm whether dueDate and priority are required for MVP or deferred to post-MVP.\n- Confirm exact rate-limiting thresholds for write operations in production beyond MVP defaults.\n\n## 17. Acceptance checklist\n\n- [ ] All EARS-formatted requirements are present and testable\n- [ ] Input validation rules are explicit and include machine error codes\n- [ ] Admin actions are auditable and audit retention is defined\n- [ ] Mermaid diagrams use correct syntax and quoted labels\n- [ ] Performance acceptance criteria mapped to functional operations\n- [ ] Example acceptance tests included for key flows\n\n\n-- End of functional requirements --\n"},{"reason":"Define non-functional expectations: performance, availability, security, privacy, backup expectations at a business level.","filename":"09-non-functional-requirements.md","documentType":"requirement","outline":["Performance expectations from a user perspective","Availability and basic reliability targets","Security and privacy requirements (data handling, user privacy)","Backup and retention expectations in business terms","Compliance considerations (e.g., GDPR notes if applicable)"],"audience":"Operations, security, development leads","keyQuestions":["What performance and availability levels are expected for the MVP?","What privacy and backup practices does the product require?"],"detailLevel":"moderate detail","relatedDocuments":["07-secondary-scenarios-and-exceptions.md","10-data-flow-and-lifecycle.md"],"constraints":["State requirements in measurable user-facing terms (e.g., response within 2 seconds for common actions)","Do not prescribe implementation technologies"],"content":"# 09-non-functional-requirements.md — Non-functional requirements for todoApp\n\nThis document provides business-level non-functional requirements for the minimal todoApp MVP. It defines measurable expectations for performance, availability, security, privacy, backup and recovery, monitoring, and compliance. This document provides business requirements only. All technical implementation decisions belong to the development team; developers retain autonomy over architecture, APIs, and data storage.\n\n## 1. Purpose and scope\n\nThis document specifies the non-functional expectations (NFE) the todoApp must satisfy for the minimal viable product. The aim is to ensure users can reliably create, view, update, and delete their todo items with predictable performance and data protection guarantees. The scope covers user-facing performance, system availability, security and privacy obligations, backup and retention expectations, monitoring and incident response, capacity and rate-limiting, and compliance-related obligations.\n\nOut of scope: low-level technical choices (programming languages, database engines, cloud providers), API endpoint specifications, or UI/UX behavior details.\n\n## 2. Audience and related documents\n\nIntended readers: operations, security, development leads, QA, and product owners. This document should be read together with the functional requirements (08-functional-requirements.md), the data lifecycle description (10-data-flow-and-lifecycle.md), and the primary and secondary user scenarios (06-primary-user-scenarios.md and 07-secondary-scenarios-and-exceptions.md).\n\n## 3. Summary of measurable non-functional objectives\n\n- WHEN a typical authenticated user performs a CRUD action on their todo list, THE todoApp SHALL return a user-visible success confirmation within 2 seconds. More specific targets:\n  - Median response time for list requests (page size = 50): <= 300 ms (Recommended)\n  - 95th percentile response time for common actions (create/read/update/delete): <= 2 seconds\n  - Median acknowledgement for writes (create/update/delete): <= 500 ms\n- THE todoApp SHALL meet availability target: 99.9% uptime per calendar month (Recommended)\n- Backup/Recovery objectives (Recommended business defaults): RTO <= 4 hours; RPO <= 1 hour\n- THE todoApp SHALL retain audit logs of administrative actions for 365 days\n- THE todoApp SHALL provide a documented restore test cadence (quarterly recommended)\n\nThese objectives are measurable and intended to guide implementation and verification for MVP operations.\n\n## 4. Performance requirements\n\nWHEN a signed-in user performs a CRUD operation on a todo, THE todoApp SHALL process and reflect the change to the user within measurable latency targets:\n- WHEN a user requests a paginated list of todos (page size = 50), THE todoApp SHALL return results with a median latency <= 300 ms and 95th percentile <= 2 seconds under normal load.\n- WHEN a user creates, updates, or deletes a single todo, THE todoApp SHALL acknowledge success with median latency <= 500 ms and 95th percentile <= 2 seconds under normal load.\n- WHEN a user toggles completion for a todo, THE todoApp SHALL reflect the change within 1 second under normal load.\n\nVerification and test scenarios:\n- Synthetic read test: 100 concurrent users performing 80% list requests and 20% writes; measure median and 95th percentile latencies for list and write operations.\n- Synthetic write test: 50 concurrent users performing creates/updates/deletes; measure acknowledgement latencies.\n- End-to-end user test: under representative network conditions (mobile 4G), create and list operations shall complete within 2 seconds 95% of the time.\n\nPerformance boundary conditions and graceful degradation:\n- WHEN sustained load exceeds capacity, THE system SHALL degrade gracefully by prioritizing reads for authenticated users and queuing or throttling non-critical write operations.\n- WHEN a graceful degradation is in effect, THE system SHALL surface a user-facing message that indicates degraded mode and suggest retry behavior.\n\n## 5. Availability and reliability\n\nWHEN the system is in normal operation, THE todoApp SHALL meet an availability target of 99.9% monthly uptime (Recommended). Scheduled maintenance SHALL be excluded from uptime calculations if communicated at least 24 hours in advance.\n\nWHEN the service experiences an outage that affects user-facing operations, THE operations team SHALL classify incident severity and follow incident response targets in the Monitoring and Incident section.\n\nReliability and durability expectations:\n- WHEN the system confirms a successful write, THE system SHALL ensure that write is durable subject to the RPO value defined in Backup and Recovery.\n- WHEN scheduled maintenance is required, THE system SHALL minimize user disruption and provide advance notice.\n\n## 6. Authentication & account protection (business-level)\n\nEARS-formatted authentication and account protection requirements:\n- WHEN a user attempts to authenticate with valid credentials, THE system SHALL successfully authenticate the user and issue session tokens per token management policy.\n- WHEN a user fails authentication 10 times within a 15-minute window, THEN THE system SHALL place the account into a lockout state for a configurable cooldown period (Recommended default: 15 minutes) and SHALL provide a user-facing message explaining the lockout and recovery options.\n- WHEN an admin suspends a user account, THE system SHALL prevent the suspended user from authenticating and SHALL invalidate active refresh tokens associated with that account within 30 seconds.\n- WHEN a user requests to revoke all sessions, THE system SHALL invalidate all refresh tokens associated with that user within 30 seconds and require re-authentication for new sessions.\n\nToken and session guidance (business defaults):\n- Access token expiration: 20 minutes (Recommended)\n- Refresh token expiration: 14 days (Recommended)\n- The exact cryptographic and storage mechanisms are implementation details; the business requirement is that tokens support session revocation and server-side invalidation of refresh tokens.\n\nAcceptance criteria:\n- AC-AUTH-01: Given valid credentials, when the user authenticates, then the system issues tokens and the user can perform todo operations within 2 seconds.\n- AC-AUTH-02: Given 10 failed login attempts within 15 minutes, when the threshold is exceeded, then the system locks the account and the user receives an explanatory message.\n- AC-AUTH-03: Given an admin suspension, when the action is executed, then the user's active sessions are invalidated within 30 seconds.\n\n## 7. Security & privacy (business-level)\n\nWHEN user personal data is collected, THE system SHALL treat it as personal data and protect it accordingly. Specific business-level requirements:\n- WHEN a user requests account deletion, THE system SHALL delete or irreversibly anonymize personal data within 30 calendar days of a validated request, subject to legal holds.\n- WHEN admin actions affect user data, THE system SHALL record an auditable event containing at minimum: admin identifier, target user identifier, action type, timestamp, and optional reason. Audit logs SHALL be tamper-evident and retained for at least 365 days.\n- THE system SHALL protect data in transit and at rest using industry-accepted cryptographic measures (implementation detail left to engineers), and SHALL ensure that backup copies are encrypted.\n\nPassword and credential policies (business defaults):\n- Minimum password length: 8 characters with at least one letter and one number (Recommended).\n- Multi-factor authentication (MFA): WHERE MFA is required by policy, THE system SHALL support MFA; MFA may be optional for MVP but shall be supported in design.\n\nPrivacy notices and DSARs:\n- WHEN a user requests a copy of their data (DSAR), THE system SHALL provide a machine-readable export of their todos and associated metadata within 7 calendar days.\n\nAcceptance criteria:\n- AC-SEC-01: Given an admin action, when executed, then an audit entry with required fields is present and retrievable within 5 seconds for recent events.\n- AC-SEC-02: Given a valid deletion request, when processed, then personal data is removed or anonymized within 30 days.\n\n## 8. Backup, retention, and recovery\n\nBusiness-level backup and recovery requirements:\n- WHEN backups are configured, THE system SHALL capture backups at least hourly or capture transaction logs enabling an RPO of <= 1 hour (Recommended).\n- WHEN a critical incident requires restore, THE system SHALL meet an RTO <= 4 hours (Recommended) for the minimal recoverable service that supports read and limited write operations.\n- WHEN backups are successful, THE system SHALL log the backup results and surface failures to operations for remediation.\n- THE system SHALL retain backups for at least 30 days for user data and retain audit logs for 365 days.\n\nRestore testing and validation:\n- THE operations team SHALL perform a restore test at least once per quarter and document the test results, including durations and any data gaps.\n\nData purge and retention rules (business defaults):\n- WHEN a user deletes a todo, THEN THE system SHALL retain the todo in a \"deleted\" state for 30 days for possible user-initiated restore; after 30 days THE system SHALL permanently purge the data subject to legal holds.\n- WHEN retention policies are adjusted, THEN THE system SHALL record the effective date and apply the new policy prospectively.\n\nAcceptance criteria:\n- AC-BACK-01: Given a backup schedule, when backups complete, then operations can provide evidence of hourly backups for the previous 30 days.\n- AC-BACK-02: Given a restore test, when executed in a non-production environment, then the team demonstrates restore meets RTO <= 4 hours (recommended target) and documents any data loss relative to RPO.\n\n## 9. Monitoring, logging & alerting, and incident response\n\nMetrics and observability (business-level):\n- WHEN monitoring is configured, THE system SHALL emit metrics for request rates, error rates, latency percentiles (p50/p95/p99), backup success/failure, authentication failures, and queue backlogs (if any).\n- THE system SHALL expose dashboards for operations with 1-minute granularity for recent data and 5-minute aggregations for historic views.\n\nAlerting and thresholds (business defaults):\n- WHEN error rate for core user flows exceeds 1% for a rolling 5-minute window, THEN an alert SHALL be raised to the on-call operations team.\n- WHEN median response time for core flows (create/list/update/delete) exceeds 2 seconds for 5 continuous minutes, THEN an alert SHALL be raised.\n- WHEN backup failure occurs or restore test fails, THEN an alert SHALL be raised to operations immediately.\n\nIncident classification and response targets:\n- P1 (service-impacting): core todo operations are unavailable or erroring for >10% of users — initial response target <= 30 minutes; mitigation plan within 4 hours.\n- P2 (degraded performance): core operations are slower than targets or >1% error rate for multiple minutes — initial response target <= 2 hours; mitigation plan within 24 hours.\n\nPost-incident review:\n- AFTER a P1 or P2 incident, THE operations team SHALL produce a post-incident report within 7 business days describing timeline, root cause, impact, and corrective actions.\n\nAcceptance criteria and verification:\n- AC-MON-01: Given configured alerts, when thresholds are crossed, then alerts are delivered to the on-call channel and acknowledged within the defined initial response targets.\n- AC-MON-02: Given a quarterly restore test, when executed, then monitoring shows backup and restore metrics and any issues are recorded in the post-test report.\n\n## 10. Capacity, rate limiting & scalability\n\nBusiness-level capacity expectations for MVP:\n- The service SHALL be designed to support an expected MVP baseline: 10,000 monthly active users (recommended planning figure) with headroom to scale to 2x expected peak traffic.\n\nRate limiting and abuse mitigation:\n- WHEN a single user exceeds 10 write requests per minute, THEN the system SHALL throttle additional write requests for that user and return a rate-limit response indicating retry-after seconds.\n- WHEN automated abuse is detected (e.g., 1,000 create requests in one minute from a single account), THEN the system SHALL temporarily suspend write privileges for that account pending review and notify support.\n\nScaling and graceful degradation:\n- WHEN sustained load growth exceeds capacity, THEN THE system SHALL prioritize read operations for authenticated users and throttle non-critical background tasks (analytics, exports) until capacity is restored.\n\nAcceptance criteria:\n- AC-CAP-01: Given simulated traffic at 2x expected peak, when tests run, then system continues to serve reads with acceptable latency while writes are throttled according to policies.\n\n## 11. Compliance and legal considerations\n\nData subject rights and export:\n- WHEN a user requests export of their data for portability, THEN THE system SHALL provide a machine-readable export of their todos and associated metadata within 7 calendar days.\n- WHEN a user requests deletion under applicable laws (e.g., GDPR), THEN THE system SHALL remove or anonymize personal data within 30 calendar days unless a legal hold applies.\n\nJurisdiction and data residency:\n- FOR the MVP, THE system SHALL operate under a single default data jurisdiction chosen by stakeholders; any multi-region residency requirement SHALL be addressed in future work and documented as a separate project.\n\nRecord keeping:\n- THE system SHALL maintain records of processing activities and consent where applicable sufficient to respond to regulatory inquiries.\n\nAcceptance criteria:\n- AC-COMP-01: Given a DSAR request, when processed, then the user receives a complete export of their data within 7 days.\n- AC-COMP-02: Given a verified deletion request, when processed, then personal data is removed or anonymized within 30 days.\n\n## 12. Error handling and user-facing failure modes\n\nCatalog of key user-facing failure messages and recovery guidance (business-level):\n- Offline save: \"You're offline. Your change is saved locally and will sync automatically when your connection returns.\" Action: \"Retry sync\".\n- Sync conflict: \"A conflict occurred while syncing this todo. Review changes and choose which version to keep.\" Action: \"Review conflict\".\n- Validation error: \"There was a problem with your input: <reason>. Please correct and try again.\" Action: \"Edit\".\n- Auth required: \"Please sign in to continue.\" Action: \"Sign In\".\n- Session expired: \"Your session expired. Sign in to continue and resubmit your changes.\" Action: \"Sign In\".\n- Rate limit: \"You're making requests too quickly. Please wait <seconds> and try again.\" Action: \"Retry later\".\n- Storage failure: \"We couldn't save your change right now. Please try again.\" Action: \"Retry\".\n- Delete undo: \"Todo deleted. Undo\" Action: \"Undo\".\n- Permanent delete: \"This item has been permanently deleted and cannot be recovered.\" Action: \"Contact support\".\n\nEARS-formatted error handling requirements:\n- IF a transient storage failure occurs during a create or update, THEN THE system SHALL inform the user within 2 seconds and preserve client-side input for retry.\n- WHEN a user's session expires while they have in-progress edits, THEN THE system SHALL preserve the edit client-side and prompt the user to re-authenticate, allowing re-submission of the preserved edits.\n\nAcceptance criteria:\n- AC-ERR-01: Given a simulated storage error, when a user attempts to save, then the UI shows the storage failure message and preserves the input for retry.\n- AC-ERR-02: Given session expiry mid-edit, when the user re-authenticates, then their preserved edits are available for resubmission.\n\n## 13. Acceptance criteria and verification methods\n\nMapping key NFRs to verification approaches:\n- Performance: Run synthetic load tests (see Performance section) and produce telemetry showing median and 95th percentile latencies meet targets.\n- Availability: Monitor production uptime over rolling 30-day windows; verify availability meets the 99.9% target excluding scheduled maintenance.\n- Backup/Restore: Execute quarterly restore tests and document RTO/RPO outcomes; demonstrate ability to recover user data and identify any data gaps.\n- Security: Validate account lockout after failed attempts and audit logging for admin actions; conduct a baseline security scan.\n- Compliance: Process sample DSAR and deletion requests and document timelines and outputs.\n\n## 14. Diagrams (business-level)\n\nMermaid: Backup and restore workflow (business view)\n\n```mermaid\ngraph LR\n  A[\"Scheduled Backup Trigger\"] --> B[\"Create Backup Snapshot\"]\n  B --> C[\"Store Encrypted Backup\"]\n  C --> D[\"Backup Catalog Updated\"]\n  D --> E{\"Backup Integrity?\"}\n  E -->|\"Yes\"| F[\"Mark Backup Successful\"]\n  E -->|\"No\"| G[\"Mark Backup Failed and Alert Ops\"]\n  F --> H[\"Retain Backup per Retention Policy\"]\n  G --> H\n```\n\nMermaid: Incident detection and response (business flow)\n\n```mermaid\ngraph LR\n  A[\"Monitoring Alert\"] --> B{\"Severity?\"}\n  B -->|\"P1\"| C[\"Notify On-call & Open Incident\"]\n  B -->|\"P2\"| D[\"Create Incident Ticket\"]\n  C --> E[\"Initial Response <=30min\"]\n  D --> F[\"Triage and Schedule Work\"]\n  E --> G[\"Mitigation/Workaround Applied\"]\n  G --> H[\"Recovery and Restore Service\"]\n  H --> I[\"Post-Incident Report within 7 days\"]\n  F --> I\n```\n\n(Notes: All labels use double quotes for mermaid compatibility.)\n\n## 15. Glossary and definitions\n- RTO: Recovery Time Objective — maximum acceptable time to restore service after an outage.\n- RPO: Recovery Point Objective — maximum acceptable age of data loss measured in time.\n- P1/P2: Priority 1/2 incidents — classification used by operations.\n- Median/95th percentile: statistical latency measures used to quantify performance.\n\n## 16. Open decisions and assumptions\n\nList of business choices requiring stakeholder confirmation (recommended defaults provided):\n1. Email verification at registration: Recommended default — require verification before first todo creation.\n2. Retention windows: Recommended default — 30 days for soft-deleted items, 365 days for archived items.\n3. Token expiry defaults: Access token 20 minutes, Refresh token 14 days (recommended).\n4. Backup frequency and RPO: Recommended default — hourly backups or transaction log capture to meet RPO <= 1 hour.\n5. MVP capacity planning baseline: 10,000 monthly active users (recommended planning figure).\n\nThese recommendations can be overridden by stakeholders; changes must be versioned and recorded in document change log.\n\n## 17. Change log and ownership\n- Document owner: Product Manager (to be assigned)\n- Change log template:\n  - Version: X.Y\n  - Date: YYYY-MM-DD\n  - Author: [Name]\n  - Summary: One-line summary of change\n\n\n"},{"reason":"Explain the conceptual data flow, lifecycle of todo items, and how user interactions translate into state changes (conceptual only, not database design).","filename":"10-data-flow-and-lifecycle.md","documentType":"service-overview","outline":["Conceptual data lifecycle for a todo item (creation → active → completed → archived/deleted)","User-driven events and resulting state transitions","Retention and deletion policy in business terms","External integration considerations (optional email reminders, exports) described at high level"],"audience":"Backend developers, product managers","keyQuestions":["What are the lifecycle states of a todo item?","How should the system conceptually handle transitions and retention?"],"detailLevel":"detailed","relatedDocuments":["08-functional-requirements.md","09-non-functional-requirements.md"],"constraints":["No database schema, ERD, or API specification included","Focus on business rules and state transitions only"],"content":"# 10 - Data Flow and Lifecycle — todoApp\n\n## 1. Purpose and scope\n\nDefine the conceptual lifecycle of a todo item for todoApp and describe the user-driven events and system-driven transitions that move items through lifecycle states. The content is business-level and intended for backend developers, QA, product owners, and operations teams. No database schemas or detailed API contracts are included; the behavior described here is implementation-ready from a business rules perspective.\n\nAudience: backend developers, QA engineers, product managers, and operations.\n\n## 2. Conceptual entities and key attributes\n\nTodoItem (conceptual attributes):\n- todoId: stable business identifier for the item\n- ownerId: reference to the owning user account (business concept)\n- title: mandatory short text (non-empty)\n- description: optional longer text\n- createdAt: system timestamp when created\n- updatedAt: system timestamp when last modified\n- state: enumerated business state {\"active\",\"completed\",\"archived\",\"deleted\"}\n- dueDate: optional ISO 8601 date or date-time\n- priority: optional enumeration {\"low\",\"medium\",\"high\"}\n- completedAt: system timestamp when the item was completed (optional)\n- archivedAt: timestamp when archived (optional)\n- deletedAt: timestamp when soft-deleted (optional)\n- auditMetadata: business-level audit stub (actorRole, actorId, actionType, timestamp, reason)\n\nAuditRecord (conceptual attributes):\n- actorRole: {\"user\",\"admin\"}\n- actorId: identifier of the acting account\n- actionType: textual action descriptor (e.g., \"delete\",\"restore\",\"suspendAccount\")\n- targetId: business identifier of affected resource (e.g., todoId)\n- timestamp: when action occurred\n- reason: optional short rationale provided by actor\n\nNotes: These are conceptual attributes meant to make lifecycle rules unambiguous for implementation and QA; they are not a database schema.\n\n## 3. Lifecycle overview\n\nPrimary states and the canonical flow for a todo item:\n- Active → Completed → Archived/Deleted → Purged\n- Active may transition directly to Deleted or Archived depending on user/admin action or automated policy.\n- Completed items may be Archived or Deleted.\n\nMermaid state diagram of primary lifecycle:\n\n```mermaid\ngraph LR\n  A[\"Active\"] --> B[\"Completed\"]\n  B --> C[\"Archived\"]\n  A --> C\n  A --> D[\"Deleted\"]\n  B --> D\n  C --> D\n  D --> E[\"Purged\"]\n  D --> F[\"Restored\"]\n  F --> A\n```\n\n## 4. State definitions (business terms)\n\n- Active: The item is visible in the user's primary list and may be edited, completed, archived, or deleted by the owner.\n- Completed: The owner marked the item done. Completed items remain visible in a completed view and may be reopened or archived.\n- Archived: The item is intentionally moved out of the primary active/completed views for long-term retention. Archived items are recoverable within the archive retention window.\n- Deleted: The item is soft-deleted; it is removed from normal user lists but retained for a configurable retention period for recovery or audit.\n- Purged: The item has been permanently removed from user-visible storage and ordinary recovery is not available. Purged items may only be restored via documented backup/restore operational procedures if backups exist.\n\n## 5. Allowed transitions and triggers (who/what can trigger)\n\n- Create: Visitor with an authenticated account triggers creation → state becomes \"active\". (Owner: user)\n- Complete: Owner toggles completion → \"active\" to \"completed\" (or vice versa for reopen)\n- Archive: Owner or automated retention process moves item to \"archived\"\n- Delete (soft-delete): Owner or admin moves item to \"deleted\"; removal from primary lists is immediate\n- Restore: Owner or admin restores item from \"deleted\" within retention window → back to \"active\" or \"completed\" depending on completedAt\n- Purge: Automated scheduled purge process or admin-initiated permanent delete moves \"deleted\" → \"purged\"\n\n## 6. EARS-formatted business rules (core lifecycle events)\n\nCreation and ownership\n- WHEN an authenticated user submits a create-todo request with a non-empty title, THE system SHALL create a TodoItem with state \"active\", set createdAt to the current server timestamp, associate ownerId to the requesting user, and return the created item for the user's view.\n\n- IF a create request omits title or provides a title that is only whitespace, THEN THE system SHALL reject the request and return a validation error indicating \"title is required\" and a machine-usable error code.\n\nValidation rules (business-level)\n- WHEN a user submits a title for creation or update, THE system SHALL accept titles up to 250 characters and SHALL reject longer titles with a validation error that identifies the field and maximum length.\n\n- WHEN a user submits a description, THE system SHALL accept descriptions up to 4,000 characters; if the description exceeds 4,000 characters, THEN THE system SHALL reject the request and return a field-level validation error.\n\n- WHEN a user provides a dueDate, THE system SHALL accept ISO 8601 date or date-time values and SHALL reject malformed date strings with a descriptive validation error.\n\nCompletion and reopen\n- WHEN an authenticated owner marks an \"active\" item as complete, THE system SHALL set state to \"completed\", set completedAt to the current timestamp, and persist the change so it is visible to the owner within 2 seconds in normal operating conditions.\n\n- WHEN an authenticated owner marks a \"completed\" item as incomplete, THE system SHALL set state to \"active\" and clear completedAt.\n\nDelete and restore\n- WHEN an authenticated owner requests deletion of a todo, THE system SHALL mark the item state as \"deleted\", set deletedAt to the current timestamp, immediately remove the item from default active/completed lists, and retain the item in deleted state for the configured retention window (default: 30 days).\n\n- WHEN an authenticated owner requests restore of a todo that is in \"deleted\" state within the retention window, THE system SHALL set the item's state to \"active\" (or \"completed\" if completedAt is present) and clear deletedAt. THE system SHALL return confirmation to the owner within 2 seconds in typical conditions.\n\nPurge policy\n- IF a todo remains in \"deleted\" state after the retention window expires, THEN THE system SHALL schedule the item for purge and permanently remove it from ordinary user-visible storage according to the scheduled purge job. AFTER purge, the item SHALL be considered unrecoverable via standard user flows.\n\nAdmin actions and audit\n- WHEN an admin performs any action that modifies the state or data of another user's todo (including restore and purge), THE system SHALL record an AuditRecord including actorRole=\"admin\", actorId, actionType, targetId, timestamp, and reason, and SHALL retain audit records for at least 365 days.\n\nOwnership enforcement\n- WHEN any request attempts to read, modify, or delete a todo, THE system SHALL permit the action only if the requesting actor is the owner or an admin performing an auditable maintenance action; otherwise, THE system SHALL deny the request with an authorization error.\n\n## 7. Conflict resolution and offline synchronization (business rules)\n\nConflict strategy overview (MVP default): last-writer-wins at the field level with explicit conflict notification to clients when concurrent changes would overwrite a more recent change. Where an offline client may queue changes, the server SHALL detect concurrent edits by comparing updatedAt timestamps and SHALL return a conflict response when the server-side updatedAt is newer than the client's base timestamp.\n\nEARS rules:\n- WHEN two updates for the same todo are submitted concurrently that modify the same field(s), THEN THE system SHALL detect the concurrency conflict and return a conflict response that includes the current server-side values and a conflict flag; the client SHALL present the user with options: \"Keep Mine\", \"Keep Server\", or \"Merge Manually\".\n\n- WHEN updates affect disjoint fields, THEN THE system SHALL merge the updates automatically and record merged updatedAt; THE system SHALL notify the user that a merge occurred but shall not block the updates.\n\nOffline sync behavior:\n- WHEN a client queues changes locally due to lack of connectivity, THE client SHALL persist queued actions and mark them as \"pending sync\" in the UI. WHEN connectivity is restored, THE client SHALL attempt to synchronize queued actions in chronological order.\n\n- WHEN queued changes are sent after reconnection, THE system SHALL apply non-conflicting changes immediately and SHALL return conflict responses for conflicting changes. THE client SHALL surface conflict resolution options to the user within 30 seconds of sync attempt.\n\nSync timing expectation (business-level):\n- WHEN connectivity resumes, THE system SHALL accept queued changes and attempt to apply them; THE client should expect that queued changes will be accepted or a conflict will be surfaced within 30 seconds of reconnection in normal conditions.\n\nUser-facing indicators:\n- WHEN an item has pending local changes not yet confirmed by the server, THE UI SHALL indicate \"Pending Sync\" and prevent silent data loss. The UI SHALL provide a \"Retry Sync\" control and an informative explanation for the pending state.\n\n## 8. Input validation and error semantics\n\nValidation rules (consolidated):\n- Title: required, trimmed, 1..250 characters. Error message: \"Title is required and must be 1-250 characters.\" Error code: ERR_VALIDATION_TITLE\n- Description: optional, 0..4000 characters. Error code: ERR_VALIDATION_DESCRIPTION\n- DueDate: optional, must be ISO 8601 date or date-time. Error code: ERR_VALIDATION_DUEDATE\n- Priority: optional, allowed values {\"low\",\"medium\",\"high\"}. Error code: ERR_VALIDATION_PRIORITY\n\nError handling rules:\n- IF an input validation fails, THEN THE system SHALL return a 4xx-style validation response including field-level messages and machine-usable error codes suitable for client display and automated testing.\n\n- IF a transient server error prevents persistence, THEN THE system SHALL return a retryable error with guidance to retry and SHALL ensure the client can preserve unsaved input for resubmission.\n\n## 9. Retention, backups, and recovery objectives\n\nRetention defaults (recommendations for MVP):\n- Deleted retention: 30 calendar days (soft-deleted items recoverable within this period).\n- Archived retention: 365 calendar days before eligibility for purge (configurable by product).\n- Audit log retention: 365 calendar days.\n\nBackup and recovery objectives (business-level):\n- RPO (Recovery Point Objective): <= 1 hour for user data during MVP operations.\n- RTO (Recovery Time Objective): <= 4 hours for critical restore scenarios affecting user data availability.\n- Backup cadence: create snapshots or transaction-log-based backups sufficient to meet RPO every hour; perform a full backup daily.\n- Restore validation: perform a quarterly restore test in a non-production environment and document the result.\n\nEARS statements for purge and backup:\n- WHEN a scheduled purge job runs for items exceeding retention, THE system SHALL permanently remove the items from ordinary user-visible storage and SHALL log purge actions in the audit log with actorRole=\"system\" and actionType=\"purge\".\n\n- WHEN a user requests account deletion, THE system SHALL mark user data for deletion and begin data removal according to retention and legal hold policies; where legal hold applies, THE system SHALL suspend automated purge until the hold is resolved.\n\n## 10. Admin recovery and operational procedures (business steps)\n\nAdmin restore process (business-level steps):\n1. Identify affected user and the approximate time window of the missing or deleted item.\n2. Query audit logs for operations related to the item and confirm the item was soft-deleted and within retention.\n3. IF the item is within retention (Deleted state and deletedAt within retention window), THEN the admin SHALL execute a restore action that sets state back to Active or Completed and SHALL record an AuditRecord with reason.\n4. Notify the user: send a templated message describing the restore action and any potential data loss if partial.\n5. IF the item is beyond retention, THEN the admin SHALL consult backups and attempt an operational restore per backup policies; IF restore is possible, admin SHALL inform user of partial recovery possibility and record the action in audit logs. IF restore is not possible, admin SHALL inform user and close the support ticket.\n\nAudit requirements for admin actions:\n- AuditRecord must include: admin identifier, timestamp, targetId, actionType, reason, and optionally a reference to backup snapshot if restored from backup.\n- Audit log retention: 365 days minimum.\n\nUser communication templates (business-level):\n- Successful restore: \"We restored your todo from backup dated YYYY-MM-DD. Some recent changes may be missing. Contact support if you need further help.\"\n- Cannot restore: \"We were unable to restore the requested todo. It appears to be beyond the retention window. We recommend recreating the item; contact support if you believe this is an error.\"\n\n## 11. Error handling and common recovery scenarios (user-facing)\n\nStandard messages and recommended actions:\n- Offline/Queued: \"You're offline. Your change is saved locally and will sync when your connection returns. [Retry Sync]\"\n- Validation error: \"There was a problem with your input: <field> - <reason>. Please correct and try again.\" (show field-level guidance)\n- Authorization error: \"You are not authorized to perform that action. You may only modify your own todos.\" (provide sign-in or contact support actions)\n- Conflict detected: \"A conflict occurred while saving this todo. Review the server version or keep your changes. [Keep Mine] [Keep Server] [Edit]\"\n- Permanent delete notice: \"This item has been permanently deleted and cannot be recovered through the UI. Contact support for assistance.\" (support may attempt operational restore if backups exist)\n\n## 12. Acceptance criteria and QA test matrix\n\nPerformance acceptance (business-level):\n- GIVEN normal MVP load, WHEN an owner creates/updates/deletes/completes a todo, THEN the change SHALL be visible to the owner within 2 seconds in 95% of tests.\n\nFunctional acceptance cases (representative):\n- Create success:\n  - Steps: authenticate -> create todo(title=\"Buy milk\") -> list todos\n  - Expected: new todo appears with state \"active\", createdAt present\n- Create validation:\n  - Steps: authenticate -> create todo(title=\"\")\n  - Expected: validation error ERR_VALIDATION_TITLE returned\n- Complete & reopen:\n  - Steps: authenticate -> create todo -> mark complete -> list completed -> mark incomplete\n  - Expected: completedAt recorded after complete, cleared after reopen\n- Delete & restore:\n  - Steps: authenticate -> create todo -> delete -> list active -> restore within retention\n  - Expected: item removed from active list after delete; restored item reappears after restore\n- Purge after retention:\n  - Steps: create todo -> delete -> simulate passage > retention -> run purge job\n  - Expected: item is purged and cannot be restored via standard UI\n- Concurrency conflict:\n  - Steps: simulate two clients loading same todo -> client A edits title -> client B edits title -> both submit\n  - Expected: the second submit returns conflict response including server values and conflict flag\n\nQA checklist: validate audit logging for admin restores, validate backup and restore test results, validate mermaid diagrams rendering in documentation, and ensure EARS requirements are fully automatable as acceptance tests.\n\n## 13. Sequence diagrams (Mermaid)\n\nMark Complete sequence:\n\n```mermaid\nsequenceDiagram\n  participant U as \"User\"\n  participant C as \"Client\"\n  participant S as \"todoApp\"\n  U->>C: \"User taps 'Complete' on todoId\"\n  C->>S: \"POST /todos/{id}/complete\"\n  S-->>S: \"Validate ownership and current state\"\n  alt ownership valid\n    S-->>S: \"Set state to \\\"completed\\\"; set completedAt\"\n    S-->>C: \"200 OK with updated todo\"\n    C-->>U: \"Show completed state\"\n  else ownership invalid\n    S-->>C: \"403 Forbidden\"\n    C-->>U: \"Show authorization error\"\n  end\n```\n\nDelete and Restore sequence:\n\n```mermaid\nsequenceDiagram\n  participant U as \"User\"\n  participant C as \"Client\"\n  participant S as \"todoApp\"\n  U->>C: \"User requests delete on todoId\"\n  C->>S: \"DELETE /todos/{id}\"\n  S-->>S: \"Validate ownership; set state='deleted' and deletedAt\"\n  S-->>C: \"200 OK\"\n  C-->>U: \"Show 'Deleted' and Offer 'Undo'\"\n  Note over C,S: \"If user selects Undo within 30s\"\n  U->>C: \"User taps 'Undo'\"\n  C->>S: \"POST /todos/{id}/restore\"\n  S-->>S: \"Validate within retention; set state='active' and clear deletedAt\"\n  S-->>C: \"200 OK with restored todo\"\n  C-->>U: \"Show restored item\"\n```\n\n## 14. Open decisions and recommended defaults (to confirm with stakeholders)\n\n- Email verification at registration: Recommended default = require email verification before enabling cross-device sync. Rationale: reduces account abuse and supports password recovery.\n- Retention windows: Recommended defaults used above (deleted: 30 days; archived: 365 days). Confirm if legal/regulatory requirements require different values.\n- Conflict resolution model: Recommended default = last-writer-wins with explicit conflict responses for same-field edits. Consider interactive merge only if product requires richer UX.\n- Offline behavior: Recommended default = support queued changes with server-side conflict detection; full offline-first is optional and deferred.\n- Priority and dueDate in MVP: Recommended to include dueDate (optional) and priority (optional) as user-provided metadata; both may be hidden behind \"Add details\" in UI to preserve quick-entry.\n\n## 15. Glossary\n- Owner: the authenticated user who owns the todo\n- Deleted: soft-delete state where item is recoverable within retention\n- Purged: permanent removal beyond ordinary recovery\n- RPO: Recovery Point Objective\n- RTO: Recovery Time Objective\n\n## 16. Appendix — Example audit record (business-level)\n\nExample audit record fields for admin or system actions:\n- actorRole: \"admin\" or \"system\"\n- actorId: \"admin-123\"\n- actionType: \"purge\" | \"restore\" | \"suspendAccount\"\n- targetId: \"todo-98765\"\n- timestamp: \"2025-10-07T00:00:00Z\"\n- reason: \"User requested removal\" (optional)\n\n\n## 17. Final notes for implementation teams\n\nAll lifecycle behaviors above are specified in business terms and are intended to be directly implementable by backend teams. Developers retain implementation autonomy for technology choices (storage, queuing, token formats) but MUST implement the EARS-formatted rules, retention and audit obligations, validation rules, and conflict/restore flows as specified above so that QA can verify compliance and product stakeholders can accept the MVP.\n\n"}],"created_at":"2025-10-07T18:40:07.156Z","completed_at":"2025-10-07T18:48:11.860Z","step":0},{"id":"0199c000-a79b-77bb-8faf-d4273af78498","type":"userMessage","contents":[{"type":"text","text":"Design the database schema."}],"created_at":"2025-10-07T18:48:12.443Z"},{"type":"prisma","id":"0199c004-8692-70af-bcbf-fada6eaa922d","instruction":"Design a minimal database schema for a Todo list application. Use only the minimum necessary data model for a single-user Todo app (no authentication or multi-user features required). Produce a Prisma schema and ERD documentation that are simple and easy to understand.\n\nRequirements for the schema design (ONLY database-focused instructions):\n\n- Primary model: Todo\n  - Fields:\n    - id: UUID primary key (string with default uuid)\n    - title: required string (the task title)\n    - description: optional text/string (task details)\n    - isCompleted: boolean, default false\n    - createdAt: DateTime, default now\n    - updatedAt: DateTime, updatedAt timestamp\n    - position: optional integer for manual ordering (nullable)\n  - Indexes:\n    - index on isCompleted (for fast queries of pending/completed tasks)\n    - index on createdAt (for sorting by creation time)\n\n- Keep relationships minimal: no User model or relations by default. \n  - Include a short commented suggestion in the ERD/schema for an optional User model and a one-to-many relation (User has many Todos) for future multi-user support, but do NOT add the User model as a required part of this initial schema.\n\n- Constraints & considerations:\n  - Keep fields simple; avoid enforcing text length limits in the schema (leave to application validation).\n  - Use UUIDs for portability.\n  - Make schema compatible with lightweight databases (SQLite) for local/small deployments and compatible with Postgres/MySQL for easy migration.\n\n- Deliverables the Prisma agent should produce:\n  - A complete Prisma schema file (schema.prisma) implementing the Todo model and datasource/provider placeholders suitable for local development.\n  - A short ERD diagram or markdown description explaining the Todo model and its fields, indexes, and the optional extension for a User model.\n  - Brief rationale (2–3 sentences) explaining chosen fields and indexes and why they suit a minimal Todo app.\n\nDo NOT include API design, DTOs, or implementation logic—this instruction is strictly for database schema design.","schemas":{"schema-01-todos.prisma":"/// Primary Todo items for the minimal Todo app. Stores raw task data for\n/// quick capture and lifecycle management (active, completed, deleted). Each\n/// todo is owned by a user (owner) to ensure data isolation. Temporal fields\n/// support audit and soft-delete semantics. Related snapshots are captured\n/// in {@\\link todo_app_todo_snapshots.id}.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_app_todos {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Owner user. {@\\link todo_app_user.id}.\n  user_id String @db.Uuid\n  \n  /// Short task title. Required business field used for display and quick\n  /// capture.\n  title String\n  \n  /// Optional longer description or notes for the todo item.\n  description String?\n  \n  /// Whether the todo is completed. Used for filtering and UI state.\n  is_completed Boolean\n  \n  /// Timestamp when the todo was marked completed. Null if not completed.\n  completed_at DateTime? @db.Timestamptz\n  \n  /// Optional manual ordering position used by client for custom sort orders.\n  position Int? @db.Integer\n  \n  /// Record creation timestamp.\n  created_at DateTime @db.Timestamptz\n  \n  /// Record last modification timestamp.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Soft-delete timestamp. Null when item is active or completed.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  user todo_app_user @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  \n  todo_app_todo_snapshots todo_app_todo_snapshots[]\n  \n  @@index([user_id, created_at])\n  @@index([is_completed])\n}\n\n/// Snapshot history for todos. Captures point-in-time copies of a todo item\n/// for audit and historical queries. Each snapshot references the source\n/// {@\\link todo_app_todos.id} and records snapshot_at when the snapshot was\n/// taken.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_app_todo_snapshots {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Referenced todo item. {@\\link todo_app_todos.id}.\n  todo_app_todo_id String @db.Uuid\n  \n  /// Snapshot of todo.title at snapshot time.\n  title String\n  \n  /// Snapshot of todo.description at snapshot time.\n  description String?\n  \n  /// Snapshot of completion flag at snapshot time.\n  is_completed Boolean\n  \n  /// Snapshot of completed_at (if set on source).\n  completed_at DateTime? @db.Timestamptz\n  \n  /// Snapshot of position for ordering.\n  position Int? @db.Integer\n  \n  /// Original created_at from source todo at snapshot time.\n  created_at DateTime @db.Timestamptz\n  \n  /// Original updated_at from source todo at snapshot time.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Original deleted_at from source todo at snapshot time.\n  deleted_at DateTime? @db.Timestamptz\n  \n  /// Timestamp when this snapshot was created.\n  snapshot_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  todo todo_app_todos @relation(fields: [todo_app_todo_id], references: [id], onDelete: Cascade)\n  \n  @@index([todo_app_todo_id, snapshot_at])\n}\n\n/// Append-only audit records for administrative and system actions. Records\n/// actor (admin or system), action type, target resource, optional reason,\n/// and timestamp for forensic and compliance purposes. Actor references are\n/// nullable to preserve system-initiated events. Foreign-key delete behavior\n/// must not cascade to preserve audit history.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_app_audit_records {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Acting admin's {@\\link todo_app_admin.id}. Nullable for system actions.\n  admin_id String? @db.Uuid\n  \n  /// Referenced user affected by the action. {@\\link todo_app_user.id}.\n  /// Nullable when not applicable.\n  user_id String? @db.Uuid\n  \n  /// Role of the actor performing the action (e.g., 'admin','system').\n  actor_role String\n  \n  /// Type of action performed (e.g., 'suspend_user','restore_todo','purge').\n  action_type String\n  \n  /// Logical resource type affected by the action (e.g., 'todo','user').\n  target_resource String\n  \n  /// Optional identifier of the target resource (e.g., todo id) for quick\n  /// lookup.\n  target_id String? @db.Uuid\n  \n  /// Optional reason provided by the actor for the action.\n  reason String?\n  \n  /// Timestamp when the audit record was created.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  admin todo_app_admin? @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  user todo_app_user? @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  \n  @@index([admin_id])\n  @@index([user_id])\n  \n  @@index([target_resource, target_id])\n  @@index([created_at])\n}\n\n/// Lightweight record for unauthenticated or ephemeral visitors. Kept\n/// minimal per component guidance; useful for analytics or short-term\n/// session tracking. Managed as a subsidiary support table.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_app_guest {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Optional visitor-provided email address (nullable).\n  email String?\n  \n  /// Record creation timestamp for the guest entry.\n  created_at DateTime @db.Timestamptz\n  \n  /// Last observed activity for the guest (nullable).\n  last_active_at DateTime? @db.Timestamptz\n  \n  /// Optional status for administrative housekeeping (e.g.,\n  /// 'active','bounced').\n  status String?\n  \n  //----\n  // RELATIONS\n  //----\n  @@index([created_at])\n}\n\n/// User accounts for the application. Users are independently managed\n/// business entities (registration, authentication, profile). This model is\n/// intentionally included but todos do not require a mandatory user relation\n/// in this MVP shape.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_app_user {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Primary email for the user account. Used for login and communication.\n  email String\n  \n  /// Optional display name for the user.\n  display_name String?\n  \n  /// Password hash for authentication (nullable if external auth used).\n  password_hash String?\n  \n  /// Account lifecycle status (e.g., 'active','suspended').\n  account_status String\n  \n  /// Account creation timestamp.\n  created_at DateTime @db.Timestamptz\n  \n  /// Last update timestamp for the account.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Last activity timestamp (nullable).\n  last_active_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  todo_app_todos todo_app_todos[]\n  todo_app_audit_records todo_app_audit_records[]\n  \n  @@unique([email])\n  @@index([created_at])\n}\n\n/// Administrative accounts with elevated privileges used for support and\n/// maintenance. Admin actions are audited in {@\\link\n/// todo_app_audit_records.id}. This model is primary since admins require\n/// independent management and auditability.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_app_admin {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Admin account email used for login and notifications.\n  email String\n  \n  /// Password hash for admin authentication (nullable if external SSO used).\n  password_hash String?\n  \n  /// Flag indicating super-admin privileges.\n  is_super Boolean\n  \n  /// Admin account creation timestamp.\n  created_at DateTime @db.Timestamptz\n  \n  /// Last activity timestamp for the admin (nullable).\n  last_active_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  todo_app_audit_records todo_app_audit_records[]\n  \n  @@unique([email])\n  @@index([created_at])\n}","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}"},"result":{"success":true,"data":{"files":[{"filename":"schema-01-todos.prisma","namespace":"Todos","models":[{"name":"todo_app_todos","description":"Primary Todo items for the minimal Todo app. Stores raw task data for quick capture and lifecycle management (active, completed, deleted). Each todo is owned by a user (owner) to ensure data isolation. Temporal fields support audit and soft-delete semantics. Related snapshots are captured in {@\\link todo_app_todo_snapshots.id}.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"user_id","type":"uuid","description":"Owner user. {@\\link todo_app_user.id}.","relation":{"name":"user","targetModel":"todo_app_user"},"unique":false,"nullable":false}],"plainFields":[{"name":"title","type":"string","nullable":false,"description":"Short task title. Required business field used for display and quick capture."},{"name":"description","type":"string","nullable":true,"description":"Optional longer description or notes for the todo item."},{"name":"is_completed","type":"boolean","nullable":false,"description":"Whether the todo is completed. Used for filtering and UI state."},{"name":"completed_at","type":"datetime","nullable":true,"description":"Timestamp when the todo was marked completed. Null if not completed."},{"name":"position","type":"int","nullable":true,"description":"Optional manual ordering position used by client for custom sort orders."},{"name":"created_at","type":"datetime","nullable":false,"description":"Record creation timestamp."},{"name":"updated_at","type":"datetime","nullable":false,"description":"Record last modification timestamp."},{"name":"deleted_at","type":"datetime","nullable":true,"description":"Soft-delete timestamp. Null when item is active or completed."}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["user_id","created_at"]},{"fieldNames":["is_completed"]}],"ginIndexes":[]},{"name":"todo_app_todo_snapshots","description":"Snapshot history for todos. Captures point-in-time copies of a todo item for audit and historical queries. Each snapshot references the source {@\\link todo_app_todos.id} and records snapshot_at when the snapshot was taken.","material":false,"stance":"snapshot","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"todo_app_todo_id","type":"uuid","description":"Referenced todo item. {@\\link todo_app_todos.id}.","relation":{"name":"todo","targetModel":"todo_app_todos"},"unique":false,"nullable":false}],"plainFields":[{"name":"title","type":"string","nullable":false,"description":"Snapshot of todo.title at snapshot time."},{"name":"description","type":"string","nullable":true,"description":"Snapshot of todo.description at snapshot time."},{"name":"is_completed","type":"boolean","nullable":false,"description":"Snapshot of completion flag at snapshot time."},{"name":"completed_at","type":"datetime","nullable":true,"description":"Snapshot of completed_at (if set on source)."},{"name":"position","type":"int","nullable":true,"description":"Snapshot of position for ordering."},{"name":"created_at","type":"datetime","nullable":false,"description":"Original created_at from source todo at snapshot time."},{"name":"updated_at","type":"datetime","nullable":false,"description":"Original updated_at from source todo at snapshot time."},{"name":"deleted_at","type":"datetime","nullable":true,"description":"Original deleted_at from source todo at snapshot time."},{"name":"snapshot_at","type":"datetime","nullable":false,"description":"Timestamp when this snapshot was created."}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["todo_app_todo_id","snapshot_at"]}],"ginIndexes":[]},{"name":"todo_app_audit_records","description":"Append-only audit records for administrative and system actions. Records actor (admin or system), action type, target resource, optional reason, and timestamp for forensic and compliance purposes. Actor references are nullable to preserve system-initiated events. Foreign-key delete behavior must not cascade to preserve audit history.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"admin_id","type":"uuid","description":"Acting admin's {@\\link todo_app_admin.id}. Nullable for system actions.","relation":{"name":"admin","targetModel":"todo_app_admin"},"unique":false,"nullable":true},{"name":"user_id","type":"uuid","description":"Referenced user affected by the action. {@\\link todo_app_user.id}. Nullable when not applicable.","relation":{"name":"user","targetModel":"todo_app_user"},"unique":false,"nullable":true}],"plainFields":[{"name":"actor_role","type":"string","nullable":false,"description":"Role of the actor performing the action (e.g., 'admin','system')."},{"name":"action_type","type":"string","nullable":false,"description":"Type of action performed (e.g., 'suspend_user','restore_todo','purge')."},{"name":"target_resource","type":"string","nullable":false,"description":"Logical resource type affected by the action (e.g., 'todo','user')."},{"name":"target_id","type":"uuid","nullable":true,"description":"Optional identifier of the target resource (e.g., todo id) for quick lookup."},{"name":"reason","type":"string","nullable":true,"description":"Optional reason provided by the actor for the action."},{"name":"created_at","type":"datetime","nullable":false,"description":"Timestamp when the audit record was created."}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["target_resource","target_id"]},{"fieldNames":["created_at"]}],"ginIndexes":[]},{"name":"todo_app_guest","description":"Lightweight record for unauthenticated or ephemeral visitors. Kept minimal per component guidance; useful for analytics or short-term session tracking. Managed as a subsidiary support table.","material":false,"stance":"subsidiary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","nullable":true,"description":"Optional visitor-provided email address (nullable)."},{"name":"created_at","type":"datetime","nullable":false,"description":"Record creation timestamp for the guest entry."},{"name":"last_active_at","type":"datetime","nullable":true,"description":"Last observed activity for the guest (nullable)."},{"name":"status","type":"string","nullable":true,"description":"Optional status for administrative housekeeping (e.g., 'active','bounced')."}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]},{"name":"todo_app_user","description":"User accounts for the application. Users are independently managed business entities (registration, authentication, profile). This model is intentionally included but todos do not require a mandatory user relation in this MVP shape.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","nullable":false,"description":"Primary email for the user account. Used for login and communication."},{"name":"display_name","type":"string","nullable":true,"description":"Optional display name for the user."},{"name":"password_hash","type":"string","nullable":true,"description":"Password hash for authentication (nullable if external auth used)."},{"name":"account_status","type":"string","nullable":false,"description":"Account lifecycle status (e.g., 'active','suspended')."},{"name":"created_at","type":"datetime","nullable":false,"description":"Account creation timestamp."},{"name":"updated_at","type":"datetime","nullable":false,"description":"Last update timestamp for the account."},{"name":"last_active_at","type":"datetime","nullable":true,"description":"Last activity timestamp (nullable)."}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]},{"name":"todo_app_admin","description":"Administrative accounts with elevated privileges used for support and maintenance. Admin actions are audited in {@\\link todo_app_audit_records.id}. This model is primary since admins require independent management and auditability.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","nullable":false,"description":"Admin account email used for login and notifications."},{"name":"password_hash","type":"string","nullable":true,"description":"Password hash for admin authentication (nullable if external SSO used)."},{"name":"is_super","type":"boolean","nullable":false,"description":"Flag indicating super-admin privileges."},{"name":"created_at","type":"datetime","nullable":false,"description":"Admin account creation timestamp."},{"name":"last_active_at","type":"datetime","nullable":true,"description":"Last activity timestamp for the admin (nullable)."}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]}]}]}},"compiled":{"type":"success","schemas":{"schema-01-todos.prisma":"/// Primary Todo items for the minimal Todo app. Stores raw task data for\n/// quick capture and lifecycle management (active, completed, deleted). Each\n/// todo is owned by a user (owner) to ensure data isolation. Temporal fields\n/// support audit and soft-delete semantics. Related snapshots are captured\n/// in {@\\link todo_app_todo_snapshots.id}.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_app_todos {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Owner user. {@\\link todo_app_user.id}.\n  user_id String @db.Uuid\n\n  /// Short task title. Required business field used for display and quick\n  /// capture.\n  title String\n\n  /// Optional longer description or notes for the todo item.\n  description String?\n\n  /// Whether the todo is completed. Used for filtering and UI state.\n  is_completed Boolean\n\n  /// Timestamp when the todo was marked completed. Null if not completed.\n  completed_at DateTime? @db.Timestamptz\n\n  /// Optional manual ordering position used by client for custom sort orders.\n  position Int? @db.Integer\n\n  /// Record creation timestamp.\n  created_at DateTime @db.Timestamptz\n\n  /// Record last modification timestamp.\n  updated_at DateTime @db.Timestamptz\n\n  /// Soft-delete timestamp. Null when item is active or completed.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  user todo_app_user @relation(fields: [user_id], references: [id], onDelete: Cascade)\n\n  todo_app_todo_snapshots todo_app_todo_snapshots[]\n\n  @@index([user_id, created_at])\n  @@index([is_completed])\n}\n\n/// Snapshot history for todos. Captures point-in-time copies of a todo item\n/// for audit and historical queries. Each snapshot references the source\n/// {@\\link todo_app_todos.id} and records snapshot_at when the snapshot was\n/// taken.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_app_todo_snapshots {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Referenced todo item. {@\\link todo_app_todos.id}.\n  todo_app_todo_id String @db.Uuid\n\n  /// Snapshot of todo.title at snapshot time.\n  title String\n\n  /// Snapshot of todo.description at snapshot time.\n  description String?\n\n  /// Snapshot of completion flag at snapshot time.\n  is_completed Boolean\n\n  /// Snapshot of completed_at (if set on source).\n  completed_at DateTime? @db.Timestamptz\n\n  /// Snapshot of position for ordering.\n  position Int? @db.Integer\n\n  /// Original created_at from source todo at snapshot time.\n  created_at DateTime @db.Timestamptz\n\n  /// Original updated_at from source todo at snapshot time.\n  updated_at DateTime @db.Timestamptz\n\n  /// Original deleted_at from source todo at snapshot time.\n  deleted_at DateTime? @db.Timestamptz\n\n  /// Timestamp when this snapshot was created.\n  snapshot_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  todo todo_app_todos @relation(fields: [todo_app_todo_id], references: [id], onDelete: Cascade)\n\n  @@index([todo_app_todo_id, snapshot_at])\n}\n\n/// Append-only audit records for administrative and system actions. Records\n/// actor (admin or system), action type, target resource, optional reason,\n/// and timestamp for forensic and compliance purposes. Actor references are\n/// nullable to preserve system-initiated events. Foreign-key delete behavior\n/// must not cascade to preserve audit history.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_app_audit_records {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Acting admin's {@\\link todo_app_admin.id}. Nullable for system actions.\n  admin_id String? @db.Uuid\n\n  /// Referenced user affected by the action. {@\\link todo_app_user.id}.\n  /// Nullable when not applicable.\n  user_id String? @db.Uuid\n\n  /// Role of the actor performing the action (e.g., 'admin','system').\n  actor_role String\n\n  /// Type of action performed (e.g., 'suspend_user','restore_todo','purge').\n  action_type String\n\n  /// Logical resource type affected by the action (e.g., 'todo','user').\n  target_resource String\n\n  /// Optional identifier of the target resource (e.g., todo id) for quick\n  /// lookup.\n  target_id String? @db.Uuid\n\n  /// Optional reason provided by the actor for the action.\n  reason String?\n\n  /// Timestamp when the audit record was created.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  admin todo_app_admin? @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  user  todo_app_user?  @relation(fields: [user_id], references: [id], onDelete: Cascade)\n\n  @@index([admin_id])\n  @@index([user_id])\n  @@index([target_resource, target_id])\n  @@index([created_at])\n}\n\n/// Lightweight record for unauthenticated or ephemeral visitors. Kept\n/// minimal per component guidance; useful for analytics or short-term\n/// session tracking. Managed as a subsidiary support table.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_app_guest {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Optional visitor-provided email address (nullable).\n  email String?\n\n  /// Record creation timestamp for the guest entry.\n  created_at DateTime @db.Timestamptz\n\n  /// Last observed activity for the guest (nullable).\n  last_active_at DateTime? @db.Timestamptz\n\n  /// Optional status for administrative housekeeping (e.g.,\n  /// 'active','bounced').\n  status String?\n\n  //----\n  // RELATIONS\n  //----\n  @@index([created_at])\n}\n\n/// User accounts for the application. Users are independently managed\n/// business entities (registration, authentication, profile). This model is\n/// intentionally included but todos do not require a mandatory user relation\n/// in this MVP shape.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_app_user {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Primary email for the user account. Used for login and communication.\n  email String\n\n  /// Optional display name for the user.\n  display_name String?\n\n  /// Password hash for authentication (nullable if external auth used).\n  password_hash String?\n\n  /// Account lifecycle status (e.g., 'active','suspended').\n  account_status String\n\n  /// Account creation timestamp.\n  created_at DateTime @db.Timestamptz\n\n  /// Last update timestamp for the account.\n  updated_at DateTime @db.Timestamptz\n\n  /// Last activity timestamp (nullable).\n  last_active_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  todo_app_todos         todo_app_todos[]\n  todo_app_audit_records todo_app_audit_records[]\n\n  @@unique([email])\n  @@index([created_at])\n}\n\n/// Administrative accounts with elevated privileges used for support and\n/// maintenance. Admin actions are audited in {@\\link\n/// todo_app_audit_records.id}. This model is primary since admins require\n/// independent management and auditability.\n///\n/// @namespace Todos\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_app_admin {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Admin account email used for login and notifications.\n  email String\n\n  /// Password hash for admin authentication (nullable if external SSO used).\n  password_hash String?\n\n  /// Flag indicating super-admin privileges.\n  is_super Boolean\n\n  /// Admin account creation timestamp.\n  created_at DateTime @db.Timestamptz\n\n  /// Last activity timestamp for the admin (nullable).\n  last_active_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  todo_app_audit_records todo_app_audit_records[]\n\n  @@unique([email])\n  @@index([created_at])\n}\n","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\n\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\n\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}\n"},"nodeModules":{"node_modules/.prisma/client/client.d.ts":"export * from \"./index\"","node_modules/.prisma/client/default.d.ts":"export * from \"./index\"","node_modules/.prisma/client/edge.d.ts":"export * from \"./default\"","node_modules/.prisma/client/index.d.ts":"\n/**\n * Client\n**/\n\nimport * as runtime from './runtime/client.js';\nimport $Types = runtime.Types // general types\nimport $Public = runtime.Types.Public\nimport $Utils = runtime.Types.Utils\nimport $Extensions = runtime.Types.Extensions\nimport $Result = runtime.Types.Result\n\nexport type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n\n/**\n * Model todo_app_todos\n * Primary Todo items for the minimal Todo app. Stores raw task data for\n * quick capture and lifecycle management (active, completed, deleted). Each\n * todo is owned by a user (owner) to ensure data isolation. Temporal fields\n * support audit and soft-delete semantics. Related snapshots are captured\n * in {@\\link todo_app_todo_snapshots.id}.\n * \n * @namespace Todos\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_app_todos = $Result.DefaultSelection<Prisma.$todo_app_todosPayload>\n/**\n * Model todo_app_todo_snapshots\n * Snapshot history for todos. Captures point-in-time copies of a todo item\n * for audit and historical queries. Each snapshot references the source\n * {@\\link todo_app_todos.id} and records snapshot_at when the snapshot was\n * taken.\n * \n * @namespace Todos\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_app_todo_snapshots = $Result.DefaultSelection<Prisma.$todo_app_todo_snapshotsPayload>\n/**\n * Model todo_app_audit_records\n * Append-only audit records for administrative and system actions. Records\n * actor (admin or system), action type, target resource, optional reason,\n * and timestamp for forensic and compliance purposes. Actor references are\n * nullable to preserve system-initiated events. Foreign-key delete behavior\n * must not cascade to preserve audit history.\n * \n * @namespace Todos\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_app_audit_records = $Result.DefaultSelection<Prisma.$todo_app_audit_recordsPayload>\n/**\n * Model todo_app_guest\n * Lightweight record for unauthenticated or ephemeral visitors. Kept\n * minimal per component guidance; useful for analytics or short-term\n * session tracking. Managed as a subsidiary support table.\n * \n * @namespace Todos\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_app_guest = $Result.DefaultSelection<Prisma.$todo_app_guestPayload>\n/**\n * Model todo_app_user\n * User accounts for the application. Users are independently managed\n * business entities (registration, authentication, profile). This model is\n * intentionally included but todos do not require a mandatory user relation\n * in this MVP shape.\n * \n * @namespace Todos\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_app_user = $Result.DefaultSelection<Prisma.$todo_app_userPayload>\n/**\n * Model todo_app_admin\n * Administrative accounts with elevated privileges used for support and\n * maintenance. Admin actions are audited in {@\\link\n * todo_app_audit_records.id}. This model is primary since admins require\n * independent management and auditability.\n * \n * @namespace Todos\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_app_admin = $Result.DefaultSelection<Prisma.$todo_app_adminPayload>\n\n/**\n * ##  Prisma Client ʲˢ\n *\n * Type-safe database client for TypeScript & Node.js\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Todo_app_todos\n * const todo_app_todos = await prisma.todo_app_todos.findMany()\n * ```\n *\n *\n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\nexport class PrismaClient<\n  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,\n  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n    /**\n   * ##  Prisma Client ʲˢ\n   *\n   * Type-safe database client for TypeScript & Node.js\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Todo_app_todos\n   * const todo_app_todos = await prisma.todo_app_todos.findMany()\n   * ```\n   *\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n   */\n\n  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);\n  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): $Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): $Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>\n\n\n  $extends: $Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.todo_app_todos`: Exposes CRUD operations for the **todo_app_todos** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_app_todos\n    * const todo_app_todos = await prisma.todo_app_todos.findMany()\n    * ```\n    */\n  get todo_app_todos(): Prisma.todo_app_todosDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.todo_app_todo_snapshots`: Exposes CRUD operations for the **todo_app_todo_snapshots** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_app_todo_snapshots\n    * const todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.findMany()\n    * ```\n    */\n  get todo_app_todo_snapshots(): Prisma.todo_app_todo_snapshotsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.todo_app_audit_records`: Exposes CRUD operations for the **todo_app_audit_records** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_app_audit_records\n    * const todo_app_audit_records = await prisma.todo_app_audit_records.findMany()\n    * ```\n    */\n  get todo_app_audit_records(): Prisma.todo_app_audit_recordsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.todo_app_guest`: Exposes CRUD operations for the **todo_app_guest** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_app_guests\n    * const todo_app_guests = await prisma.todo_app_guest.findMany()\n    * ```\n    */\n  get todo_app_guest(): Prisma.todo_app_guestDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.todo_app_user`: Exposes CRUD operations for the **todo_app_user** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_app_users\n    * const todo_app_users = await prisma.todo_app_user.findMany()\n    * ```\n    */\n  get todo_app_user(): Prisma.todo_app_userDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.todo_app_admin`: Exposes CRUD operations for the **todo_app_admin** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_app_admins\n    * const todo_app_admins = await prisma.todo_app_admin.findMany()\n    * ```\n    */\n  get todo_app_admin(): Prisma.todo_app_adminDelegate<ExtArgs, ClientOptions>;\n}\n\nexport namespace Prisma {\n  export import DMMF = runtime.DMMF\n\n  export type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n  /**\n   * Validator\n   */\n  export import validator = runtime.Public.validator\n\n  /**\n   * Prisma Errors\n   */\n  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError\n  export import PrismaClientValidationError = runtime.PrismaClientValidationError\n\n  /**\n   * Re-export of sql-template-tag\n   */\n  export import sql = runtime.sqltag\n  export import empty = runtime.empty\n  export import join = runtime.join\n  export import raw = runtime.raw\n  export import Sql = runtime.Sql\n\n\n\n  /**\n   * Decimal.js\n   */\n  export import Decimal = runtime.Decimal\n\n  export type DecimalJsLike = runtime.DecimalJsLike\n\n  /**\n   * Metrics\n   */\n  export type Metrics = runtime.Metrics\n  export type Metric<T> = runtime.Metric<T>\n  export type MetricHistogram = runtime.MetricHistogram\n  export type MetricHistogramBucket = runtime.MetricHistogramBucket\n\n  /**\n  * Extensions\n  */\n  export import Extension = $Extensions.UserArgs\n  export import getExtensionContext = runtime.Extensions.getExtensionContext\n  export import Args = $Public.Args\n  export import Payload = $Public.Payload\n  export import Result = $Public.Result\n  export import Exact = $Public.Exact\n\n  /**\n   * Prisma Client JS version: local\n   * Query Engine version: local\n   */\n  export type PrismaVersion = {\n    client: string\n  }\n\n  export const prismaVersion: PrismaVersion\n\n  /**\n   * Utility Types\n   */\n\n\n  export import JsonObject = runtime.JsonObject\n  export import JsonArray = runtime.JsonArray\n  export import JsonValue = runtime.JsonValue\n  export import InputJsonObject = runtime.InputJsonObject\n  export import InputJsonArray = runtime.InputJsonArray\n  export import InputJsonValue = runtime.InputJsonValue\n\n  /**\n   * Types of the values used to represent different kinds of `null` values when working with JSON fields.\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  namespace NullTypes {\n    /**\n    * Type of `Prisma.DbNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class DbNull {\n      private DbNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.JsonNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class JsonNull {\n      private JsonNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.AnyNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class AnyNull {\n      private AnyNull: never\n      private constructor()\n    }\n  }\n\n  /**\n   * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const DbNull: NullTypes.DbNull\n\n  /**\n   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const JsonNull: NullTypes.JsonNull\n\n  /**\n   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const AnyNull: NullTypes.AnyNull\n\n  type SelectAndInclude = {\n    select: any\n    include: any\n  }\n\n  type SelectAndOmit = {\n    select: any\n    omit: any\n  }\n\n  /**\n   * Get the type of the value, that the Promise holds.\n   */\n  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;\n\n  /**\n   * Get the return type of a function which returns a Promise.\n   */\n  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>\n\n  /**\n   * From T, pick a set of properties whose keys are in the union K\n   */\n  type Prisma__Pick<T, K extends keyof T> = {\n      [P in K]: T[P];\n  };\n\n\n  export type Enumerable<T> = T | Array<T>;\n\n  export type RequiredKeys<T> = {\n    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K\n  }[keyof T]\n\n  export type TruthyKeys<T> = keyof {\n    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K\n  }\n\n  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>\n\n  /**\n   * Subset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n   */\n  export type Subset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never;\n  };\n\n  /**\n   * SelectSubset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n   * Additionally, it validates, if both select and include are present. If the case, it errors.\n   */\n  export type SelectSubset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    (T extends SelectAndInclude\n      ? 'Please either choose `select` or `include`.'\n      : T extends SelectAndOmit\n        ? 'Please either choose `select` or `omit`.'\n        : {})\n\n  /**\n   * Subset + Intersection\n   * @desc From `T` pick properties that exist in `U` and intersect `K`\n   */\n  export type SubsetIntersection<T, U, K> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    K\n\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n  /**\n   * XOR is needed to have a real mutually exclusive union type\n   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n   */\n  type XOR<T, U> =\n    T extends object ?\n    U extends object ?\n      (Without<T, U> & U) | (Without<U, T> & T)\n    : U : T\n\n\n  /**\n   * Is T a Record?\n   */\n  type IsObject<T extends any> = T extends Array<any>\n  ? False\n  : T extends Date\n  ? False\n  : T extends Uint8Array\n  ? False\n  : T extends BigInt\n  ? False\n  : T extends object\n  ? True\n  : False\n\n\n  /**\n   * If it's T[], return T\n   */\n  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n  /**\n   * From ts-toolbelt\n   */\n\n  type __Either<O extends object, K extends Key> = Omit<O, K> &\n    {\n      // Merge all but K\n      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n    }[K]\n\n  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\n  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\n  type _Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean\n  > = {\n    1: EitherStrict<O, K>\n    0: EitherLoose<O, K>\n  }[strict]\n\n  type Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean = 1\n  > = O extends unknown ? _Either<O, K, strict> : never\n\n  export type Union = any\n\n  type PatchUndefined<O extends object, O1 extends object> = {\n    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n  } & {}\n\n  /** Helper Types for \"Merge\" **/\n  export type IntersectOf<U extends Union> = (\n    U extends unknown ? (k: U) => void : never\n  ) extends (k: infer I) => void\n    ? I\n    : never\n\n  export type Overwrite<O extends object, O1 extends object> = {\n      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n  } & {};\n\n  type _Merge<U extends object> = IntersectOf<Overwrite<U, {\n      [K in keyof U]-?: At<U, K>;\n  }>>;\n\n  type Key = string | number | symbol;\n  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;\n  type AtStrict<O extends object, K extends Key> = O[K & keyof O];\n  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\n  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n      1: AtStrict<O, K>;\n      0: AtLoose<O, K>;\n  }[strict];\n\n  export type ComputeRaw<A extends any> = A extends Function ? A : {\n    [K in keyof A]: A[K];\n  } & {};\n\n  export type OptionalFlat<O> = {\n    [K in keyof O]?: O[K];\n  } & {};\n\n  type _Record<K extends keyof any, T> = {\n    [P in K]: T;\n  };\n\n  // cause typescript not to expand types and preserve names\n  type NoExpand<T> = T extends unknown ? T : never;\n\n  // this type assumes the passed object is entirely optional\n  type AtLeast<O extends object, K extends string> = NoExpand<\n    O extends unknown\n    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n    : never>;\n\n  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\n  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n  /** End Helper Types for \"Merge\" **/\n\n  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\n  /**\n  A [[Boolean]]\n  */\n  export type Boolean = True | False\n\n  // /**\n  // 1\n  // */\n  export type True = 1\n\n  /**\n  0\n  */\n  export type False = 0\n\n  export type Not<B extends Boolean> = {\n    0: 1\n    1: 0\n  }[B]\n\n  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n    ? 0 // anything `never` is false\n    : A1 extends A2\n    ? 1\n    : 0\n\n  export type Has<U extends Union, U1 extends Union> = Not<\n    Extends<Exclude<U1, U>, U1>\n  >\n\n  export type Or<B1 extends Boolean, B2 extends Boolean> = {\n    0: {\n      0: 0\n      1: 1\n    }\n    1: {\n      0: 1\n      1: 1\n    }\n  }[B1][B2]\n\n  export type Keys<U extends Union> = U extends unknown ? keyof U : never\n\n  type Cast<A, B> = A extends B ? A : B;\n\n  export const type: unique symbol;\n\n\n\n  /**\n   * Used by group by\n   */\n\n  export type GetScalarType<T, O> = O extends object ? {\n    [P in keyof T]: P extends keyof O\n      ? O[P]\n      : never\n  } : never\n\n  type FieldPaths<\n    T,\n    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n  > = IsObject<T> extends True ? U : T\n\n  type GetHavingFields<T> = {\n    [K in keyof T]: Or<\n      Or<Extends<'OR', K>, Extends<'AND', K>>,\n      Extends<'NOT', K>\n    > extends True\n      ? // infer is only needed to not hit TS limit\n        // based on the brilliant idea of Pierre-Antoine Mills\n        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n        T[K] extends infer TK\n        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n        : never\n      : {} extends FieldPaths<T[K]>\n      ? never\n      : K\n  }[keyof T]\n\n  /**\n   * Convert tuple to union\n   */\n  type _TupleToUnion<T> = T extends (infer E)[] ? E : never\n  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\n  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n  /**\n   * Like `Pick`, but additionally can also accept an array of keys\n   */\n  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n  /**\n   * Exclude all keys with underscores\n   */\n  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\n  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\n  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\n  export const ModelName: {\n    todo_app_todos: 'todo_app_todos',\n    todo_app_todo_snapshots: 'todo_app_todo_snapshots',\n    todo_app_audit_records: 'todo_app_audit_records',\n    todo_app_guest: 'todo_app_guest',\n    todo_app_user: 'todo_app_user',\n    todo_app_admin: 'todo_app_admin'\n  };\n\n  export type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n  export type Datasources = {\n    db?: Datasource\n  }\n\n  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {\n    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>\n  }\n\n  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n    globalOmitOptions: {\n      omit: GlobalOmitOptions\n    }\n    meta: {\n      modelProps: \"todo_app_todos\" | \"todo_app_todo_snapshots\" | \"todo_app_audit_records\" | \"todo_app_guest\" | \"todo_app_user\" | \"todo_app_admin\"\n      txIsolationLevel: Prisma.TransactionIsolationLevel\n    }\n    model: {\n      todo_app_todos: {\n        payload: Prisma.$todo_app_todosPayload<ExtArgs>\n        fields: Prisma.todo_app_todosFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_app_todosFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todosPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_app_todosFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todosPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_app_todosFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todosPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_app_todosFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todosPayload>\n          }\n          findMany: {\n            args: Prisma.todo_app_todosFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todosPayload>[]\n          }\n          create: {\n            args: Prisma.todo_app_todosCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todosPayload>\n          }\n          createMany: {\n            args: Prisma.todo_app_todosCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_app_todosCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todosPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_app_todosDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todosPayload>\n          }\n          update: {\n            args: Prisma.todo_app_todosUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todosPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_app_todosDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_app_todosUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_app_todosUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todosPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_app_todosUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todosPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_app_todosAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_app_todos>\n          }\n          groupBy: {\n            args: Prisma.todo_app_todosGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_app_todosGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_app_todosCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_app_todosCountAggregateOutputType> | number\n          }\n        }\n      }\n      todo_app_todo_snapshots: {\n        payload: Prisma.$todo_app_todo_snapshotsPayload<ExtArgs>\n        fields: Prisma.todo_app_todo_snapshotsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_app_todo_snapshotsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todo_snapshotsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_app_todo_snapshotsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todo_snapshotsPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_app_todo_snapshotsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todo_snapshotsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_app_todo_snapshotsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todo_snapshotsPayload>\n          }\n          findMany: {\n            args: Prisma.todo_app_todo_snapshotsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todo_snapshotsPayload>[]\n          }\n          create: {\n            args: Prisma.todo_app_todo_snapshotsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todo_snapshotsPayload>\n          }\n          createMany: {\n            args: Prisma.todo_app_todo_snapshotsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_app_todo_snapshotsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todo_snapshotsPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_app_todo_snapshotsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todo_snapshotsPayload>\n          }\n          update: {\n            args: Prisma.todo_app_todo_snapshotsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todo_snapshotsPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_app_todo_snapshotsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_app_todo_snapshotsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_app_todo_snapshotsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todo_snapshotsPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_app_todo_snapshotsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_todo_snapshotsPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_app_todo_snapshotsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_app_todo_snapshots>\n          }\n          groupBy: {\n            args: Prisma.todo_app_todo_snapshotsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_app_todo_snapshotsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_app_todo_snapshotsCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_app_todo_snapshotsCountAggregateOutputType> | number\n          }\n        }\n      }\n      todo_app_audit_records: {\n        payload: Prisma.$todo_app_audit_recordsPayload<ExtArgs>\n        fields: Prisma.todo_app_audit_recordsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_app_audit_recordsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_audit_recordsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_app_audit_recordsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_audit_recordsPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_app_audit_recordsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_audit_recordsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_app_audit_recordsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_audit_recordsPayload>\n          }\n          findMany: {\n            args: Prisma.todo_app_audit_recordsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_audit_recordsPayload>[]\n          }\n          create: {\n            args: Prisma.todo_app_audit_recordsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_audit_recordsPayload>\n          }\n          createMany: {\n            args: Prisma.todo_app_audit_recordsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_app_audit_recordsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_audit_recordsPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_app_audit_recordsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_audit_recordsPayload>\n          }\n          update: {\n            args: Prisma.todo_app_audit_recordsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_audit_recordsPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_app_audit_recordsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_app_audit_recordsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_app_audit_recordsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_audit_recordsPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_app_audit_recordsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_audit_recordsPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_app_audit_recordsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_app_audit_records>\n          }\n          groupBy: {\n            args: Prisma.todo_app_audit_recordsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_app_audit_recordsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_app_audit_recordsCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_app_audit_recordsCountAggregateOutputType> | number\n          }\n        }\n      }\n      todo_app_guest: {\n        payload: Prisma.$todo_app_guestPayload<ExtArgs>\n        fields: Prisma.todo_app_guestFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_app_guestFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_guestPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_app_guestFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_guestPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_app_guestFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_guestPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_app_guestFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_guestPayload>\n          }\n          findMany: {\n            args: Prisma.todo_app_guestFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_guestPayload>[]\n          }\n          create: {\n            args: Prisma.todo_app_guestCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_guestPayload>\n          }\n          createMany: {\n            args: Prisma.todo_app_guestCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_app_guestCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_guestPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_app_guestDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_guestPayload>\n          }\n          update: {\n            args: Prisma.todo_app_guestUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_guestPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_app_guestDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_app_guestUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_app_guestUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_guestPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_app_guestUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_guestPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_app_guestAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_app_guest>\n          }\n          groupBy: {\n            args: Prisma.todo_app_guestGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_app_guestGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_app_guestCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_app_guestCountAggregateOutputType> | number\n          }\n        }\n      }\n      todo_app_user: {\n        payload: Prisma.$todo_app_userPayload<ExtArgs>\n        fields: Prisma.todo_app_userFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_app_userFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_userPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_app_userFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_userPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_app_userFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_userPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_app_userFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_userPayload>\n          }\n          findMany: {\n            args: Prisma.todo_app_userFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_userPayload>[]\n          }\n          create: {\n            args: Prisma.todo_app_userCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_userPayload>\n          }\n          createMany: {\n            args: Prisma.todo_app_userCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_app_userCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_userPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_app_userDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_userPayload>\n          }\n          update: {\n            args: Prisma.todo_app_userUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_userPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_app_userDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_app_userUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_app_userUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_userPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_app_userUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_userPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_app_userAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_app_user>\n          }\n          groupBy: {\n            args: Prisma.todo_app_userGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_app_userGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_app_userCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_app_userCountAggregateOutputType> | number\n          }\n        }\n      }\n      todo_app_admin: {\n        payload: Prisma.$todo_app_adminPayload<ExtArgs>\n        fields: Prisma.todo_app_adminFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_app_adminFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_adminPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_app_adminFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_adminPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_app_adminFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_adminPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_app_adminFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_adminPayload>\n          }\n          findMany: {\n            args: Prisma.todo_app_adminFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_adminPayload>[]\n          }\n          create: {\n            args: Prisma.todo_app_adminCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_adminPayload>\n          }\n          createMany: {\n            args: Prisma.todo_app_adminCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_app_adminCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_adminPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_app_adminDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_adminPayload>\n          }\n          update: {\n            args: Prisma.todo_app_adminUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_adminPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_app_adminDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_app_adminUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_app_adminUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_adminPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_app_adminUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_app_adminPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_app_adminAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_app_admin>\n          }\n          groupBy: {\n            args: Prisma.todo_app_adminGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_app_adminGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_app_adminCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_app_adminCountAggregateOutputType> | number\n          }\n        }\n      }\n    }\n  } & {\n    other: {\n      payload: any\n      operations: {\n        $executeRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $executeRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n        $queryRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $queryRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n      }\n    }\n  }\n  export const defineExtension: $Extensions.ExtendsHook<\"define\", Prisma.TypeMapCb, $Extensions.DefaultArgs>\n  export type DefaultPrismaClient = PrismaClient\n  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n  export interface PrismaClientOptions {\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasources?: Datasources\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasourceUrl?: string\n    /**\n     * @default \"colorless\"\n     */\n    errorFormat?: ErrorFormat\n    /**\n     * @example\n     * ```\n     * // Shorthand for `emit: 'stdout'`\n     * log: ['query', 'info', 'warn', 'error']\n     * \n     * // Emit as events only\n     * log: [\n     *   { emit: 'event', level: 'query' },\n     *   { emit: 'event', level: 'info' },\n     *   { emit: 'event', level: 'warn' }\n     *   { emit: 'event', level: 'error' }\n     * ]\n     * \n     * / Emit as events and log to stdout\n     * og: [\n     *  { emit: 'stdout', level: 'query' },\n     *  { emit: 'stdout', level: 'info' },\n     *  { emit: 'stdout', level: 'warn' }\n     *  { emit: 'stdout', level: 'error' }\n     * \n     * ```\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n     */\n    log?: (LogLevel | LogDefinition)[]\n    /**\n     * The default values for transactionOptions\n     * maxWait ?= 2000\n     * timeout ?= 5000\n     */\n    transactionOptions?: {\n      maxWait?: number\n      timeout?: number\n      isolationLevel?: Prisma.TransactionIsolationLevel\n    }\n    /**\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`\n     */\n    adapter?: runtime.SqlDriverAdapterFactory | null\n    /**\n     * Global configuration for omitting model fields by default.\n     * \n     * @example\n     * ```\n     * const prisma = new PrismaClient({\n     *   omit: {\n     *     user: {\n     *       password: true\n     *     }\n     *   }\n     * })\n     * ```\n     */\n    omit?: Prisma.GlobalOmitConfig\n  }\n  export type GlobalOmitConfig = {\n    todo_app_todos?: todo_app_todosOmit\n    todo_app_todo_snapshots?: todo_app_todo_snapshotsOmit\n    todo_app_audit_records?: todo_app_audit_recordsOmit\n    todo_app_guest?: todo_app_guestOmit\n    todo_app_user?: todo_app_userOmit\n    todo_app_admin?: todo_app_adminOmit\n  }\n\n  /* Types for Logging */\n  export type LogLevel = 'info' | 'query' | 'warn' | 'error'\n  export type LogDefinition = {\n    level: LogLevel\n    emit: 'stdout' | 'event'\n  }\n\n  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\n  export type GetLogType<T> = CheckIsLogLevel<\n    T extends LogDefinition ? T['level'] : T\n  >;\n\n  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n    ? GetLogType<T[number]>\n    : never;\n\n  export type QueryEvent = {\n    timestamp: Date\n    query: string\n    params: string\n    duration: number\n    target: string\n  }\n\n  export type LogEvent = {\n    timestamp: Date\n    message: string\n    target: string\n  }\n  /* End Types for Logging */\n\n\n  export type PrismaAction =\n    | 'findUnique'\n    | 'findUniqueOrThrow'\n    | 'findMany'\n    | 'findFirst'\n    | 'findFirstOrThrow'\n    | 'create'\n    | 'createMany'\n    | 'createManyAndReturn'\n    | 'update'\n    | 'updateMany'\n    | 'updateManyAndReturn'\n    | 'upsert'\n    | 'delete'\n    | 'deleteMany'\n    | 'executeRaw'\n    | 'queryRaw'\n    | 'aggregate'\n    | 'count'\n    | 'runCommandRaw'\n    | 'findRaw'\n    | 'groupBy'\n\n  // tested in getLogLevel.test.ts\n  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;\n\n  /**\n   * `PrismaClient` proxy available in interactive transactions.\n   */\n  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>\n\n  export type Datasource = {\n    url?: string\n  }\n\n  /**\n   * Count Types\n   */\n\n\n  /**\n   * Count Type Todo_app_todosCountOutputType\n   */\n\n  export type Todo_app_todosCountOutputType = {\n    todo_app_todo_snapshots: number\n  }\n\n  export type Todo_app_todosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_app_todo_snapshots?: boolean | Todo_app_todosCountOutputTypeCountTodo_app_todo_snapshotsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Todo_app_todosCountOutputType without action\n   */\n  export type Todo_app_todosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Todo_app_todosCountOutputType\n     */\n    select?: Todo_app_todosCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Todo_app_todosCountOutputType without action\n   */\n  export type Todo_app_todosCountOutputTypeCountTodo_app_todo_snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_app_todo_snapshotsWhereInput\n  }\n\n\n  /**\n   * Count Type Todo_app_userCountOutputType\n   */\n\n  export type Todo_app_userCountOutputType = {\n    todo_app_todos: number\n    todo_app_audit_records: number\n  }\n\n  export type Todo_app_userCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_app_todos?: boolean | Todo_app_userCountOutputTypeCountTodo_app_todosArgs\n    todo_app_audit_records?: boolean | Todo_app_userCountOutputTypeCountTodo_app_audit_recordsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Todo_app_userCountOutputType without action\n   */\n  export type Todo_app_userCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Todo_app_userCountOutputType\n     */\n    select?: Todo_app_userCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Todo_app_userCountOutputType without action\n   */\n  export type Todo_app_userCountOutputTypeCountTodo_app_todosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_app_todosWhereInput\n  }\n\n  /**\n   * Todo_app_userCountOutputType without action\n   */\n  export type Todo_app_userCountOutputTypeCountTodo_app_audit_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_app_audit_recordsWhereInput\n  }\n\n\n  /**\n   * Count Type Todo_app_adminCountOutputType\n   */\n\n  export type Todo_app_adminCountOutputType = {\n    todo_app_audit_records: number\n  }\n\n  export type Todo_app_adminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_app_audit_records?: boolean | Todo_app_adminCountOutputTypeCountTodo_app_audit_recordsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Todo_app_adminCountOutputType without action\n   */\n  export type Todo_app_adminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Todo_app_adminCountOutputType\n     */\n    select?: Todo_app_adminCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Todo_app_adminCountOutputType without action\n   */\n  export type Todo_app_adminCountOutputTypeCountTodo_app_audit_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_app_audit_recordsWhereInput\n  }\n\n\n  /**\n   * Models\n   */\n\n  /**\n   * Model todo_app_todos\n   */\n\n  export type AggregateTodo_app_todos = {\n    _count: Todo_app_todosCountAggregateOutputType | null\n    _avg: Todo_app_todosAvgAggregateOutputType | null\n    _sum: Todo_app_todosSumAggregateOutputType | null\n    _min: Todo_app_todosMinAggregateOutputType | null\n    _max: Todo_app_todosMaxAggregateOutputType | null\n  }\n\n  export type Todo_app_todosAvgAggregateOutputType = {\n    position: number | null\n  }\n\n  export type Todo_app_todosSumAggregateOutputType = {\n    position: number | null\n  }\n\n  export type Todo_app_todosMinAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    title: string | null\n    description: string | null\n    is_completed: boolean | null\n    completed_at: Date | null\n    position: number | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Todo_app_todosMaxAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    title: string | null\n    description: string | null\n    is_completed: boolean | null\n    completed_at: Date | null\n    position: number | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Todo_app_todosCountAggregateOutputType = {\n    id: number\n    user_id: number\n    title: number\n    description: number\n    is_completed: number\n    completed_at: number\n    position: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Todo_app_todosAvgAggregateInputType = {\n    position?: true\n  }\n\n  export type Todo_app_todosSumAggregateInputType = {\n    position?: true\n  }\n\n  export type Todo_app_todosMinAggregateInputType = {\n    id?: true\n    user_id?: true\n    title?: true\n    description?: true\n    is_completed?: true\n    completed_at?: true\n    position?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Todo_app_todosMaxAggregateInputType = {\n    id?: true\n    user_id?: true\n    title?: true\n    description?: true\n    is_completed?: true\n    completed_at?: true\n    position?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Todo_app_todosCountAggregateInputType = {\n    id?: true\n    user_id?: true\n    title?: true\n    description?: true\n    is_completed?: true\n    completed_at?: true\n    position?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Todo_app_todosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_app_todos to aggregate.\n     */\n    where?: todo_app_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_todos to fetch.\n     */\n    orderBy?: todo_app_todosOrderByWithRelationInput | todo_app_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_app_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_todos.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_app_todos\n    **/\n    _count?: true | Todo_app_todosCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Todo_app_todosAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Todo_app_todosSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_app_todosMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_app_todosMaxAggregateInputType\n  }\n\n  export type GetTodo_app_todosAggregateType<T extends Todo_app_todosAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_app_todos]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_app_todos[P]>\n      : GetScalarType<T[P], AggregateTodo_app_todos[P]>\n  }\n\n\n\n\n  export type todo_app_todosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_app_todosWhereInput\n    orderBy?: todo_app_todosOrderByWithAggregationInput | todo_app_todosOrderByWithAggregationInput[]\n    by: Todo_app_todosScalarFieldEnum[] | Todo_app_todosScalarFieldEnum\n    having?: todo_app_todosScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_app_todosCountAggregateInputType | true\n    _avg?: Todo_app_todosAvgAggregateInputType\n    _sum?: Todo_app_todosSumAggregateInputType\n    _min?: Todo_app_todosMinAggregateInputType\n    _max?: Todo_app_todosMaxAggregateInputType\n  }\n\n  export type Todo_app_todosGroupByOutputType = {\n    id: string\n    user_id: string\n    title: string\n    description: string | null\n    is_completed: boolean\n    completed_at: Date | null\n    position: number | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Todo_app_todosCountAggregateOutputType | null\n    _avg: Todo_app_todosAvgAggregateOutputType | null\n    _sum: Todo_app_todosSumAggregateOutputType | null\n    _min: Todo_app_todosMinAggregateOutputType | null\n    _max: Todo_app_todosMaxAggregateOutputType | null\n  }\n\n  type GetTodo_app_todosGroupByPayload<T extends todo_app_todosGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_app_todosGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_app_todosGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_app_todosGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_app_todosGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_app_todosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    title?: boolean\n    description?: boolean\n    is_completed?: boolean\n    completed_at?: boolean\n    position?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    user?: boolean | todo_app_userDefaultArgs<ExtArgs>\n    todo_app_todo_snapshots?: boolean | todo_app_todos$todo_app_todo_snapshotsArgs<ExtArgs>\n    _count?: boolean | Todo_app_todosCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_app_todos\"]>\n\n  export type todo_app_todosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    title?: boolean\n    description?: boolean\n    is_completed?: boolean\n    completed_at?: boolean\n    position?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    user?: boolean | todo_app_userDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_app_todos\"]>\n\n  export type todo_app_todosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    title?: boolean\n    description?: boolean\n    is_completed?: boolean\n    completed_at?: boolean\n    position?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    user?: boolean | todo_app_userDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_app_todos\"]>\n\n  export type todo_app_todosSelectScalar = {\n    id?: boolean\n    user_id?: boolean\n    title?: boolean\n    description?: boolean\n    is_completed?: boolean\n    completed_at?: boolean\n    position?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type todo_app_todosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"user_id\" | \"title\" | \"description\" | \"is_completed\" | \"completed_at\" | \"position\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"todo_app_todos\"]>\n  export type todo_app_todosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_app_userDefaultArgs<ExtArgs>\n    todo_app_todo_snapshots?: boolean | todo_app_todos$todo_app_todo_snapshotsArgs<ExtArgs>\n    _count?: boolean | Todo_app_todosCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type todo_app_todosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_app_userDefaultArgs<ExtArgs>\n  }\n  export type todo_app_todosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_app_userDefaultArgs<ExtArgs>\n  }\n\n  export type $todo_app_todosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_app_todos\"\n    objects: {\n      user: Prisma.$todo_app_userPayload<ExtArgs>\n      todo_app_todo_snapshots: Prisma.$todo_app_todo_snapshotsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Owner user. {@\\link todo_app_user.id}.\n       */\n      user_id: string\n      /**\n       * Short task title. Required business field used for display and quick\n       * capture.\n       */\n      title: string\n      /**\n       * Optional longer description or notes for the todo item.\n       */\n      description: string | null\n      /**\n       * Whether the todo is completed. Used for filtering and UI state.\n       */\n      is_completed: boolean\n      /**\n       * Timestamp when the todo was marked completed. Null if not completed.\n       */\n      completed_at: Date | null\n      /**\n       * Optional manual ordering position used by client for custom sort orders.\n       */\n      position: number | null\n      /**\n       * Record creation timestamp.\n       */\n      created_at: Date\n      /**\n       * Record last modification timestamp.\n       */\n      updated_at: Date\n      /**\n       * Soft-delete timestamp. Null when item is active or completed.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"todo_app_todos\"]>\n    composites: {}\n  }\n\n  type todo_app_todosGetPayload<S extends boolean | null | undefined | todo_app_todosDefaultArgs> = $Result.GetResult<Prisma.$todo_app_todosPayload, S>\n\n  type todo_app_todosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_app_todosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_app_todosCountAggregateInputType | true\n    }\n\n  export interface todo_app_todosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_app_todos'], meta: { name: 'todo_app_todos' } }\n    /**\n     * Find zero or one Todo_app_todos that matches the filter.\n     * @param {todo_app_todosFindUniqueArgs} args - Arguments to find a Todo_app_todos\n     * @example\n     * // Get one Todo_app_todos\n     * const todo_app_todos = await prisma.todo_app_todos.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_app_todosFindUniqueArgs>(args: SelectSubset<T, todo_app_todosFindUniqueArgs<ExtArgs>>): Prisma__todo_app_todosClient<$Result.GetResult<Prisma.$todo_app_todosPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_app_todos that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_app_todosFindUniqueOrThrowArgs} args - Arguments to find a Todo_app_todos\n     * @example\n     * // Get one Todo_app_todos\n     * const todo_app_todos = await prisma.todo_app_todos.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_app_todosFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_app_todosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_app_todosClient<$Result.GetResult<Prisma.$todo_app_todosPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_app_todos that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_todosFindFirstArgs} args - Arguments to find a Todo_app_todos\n     * @example\n     * // Get one Todo_app_todos\n     * const todo_app_todos = await prisma.todo_app_todos.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_app_todosFindFirstArgs>(args?: SelectSubset<T, todo_app_todosFindFirstArgs<ExtArgs>>): Prisma__todo_app_todosClient<$Result.GetResult<Prisma.$todo_app_todosPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_app_todos that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_todosFindFirstOrThrowArgs} args - Arguments to find a Todo_app_todos\n     * @example\n     * // Get one Todo_app_todos\n     * const todo_app_todos = await prisma.todo_app_todos.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_app_todosFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_app_todosFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_app_todosClient<$Result.GetResult<Prisma.$todo_app_todosPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_app_todos that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_todosFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_app_todos\n     * const todo_app_todos = await prisma.todo_app_todos.findMany()\n     * \n     * // Get first 10 Todo_app_todos\n     * const todo_app_todos = await prisma.todo_app_todos.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_app_todosWithIdOnly = await prisma.todo_app_todos.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_app_todosFindManyArgs>(args?: SelectSubset<T, todo_app_todosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_todosPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_app_todos.\n     * @param {todo_app_todosCreateArgs} args - Arguments to create a Todo_app_todos.\n     * @example\n     * // Create one Todo_app_todos\n     * const Todo_app_todos = await prisma.todo_app_todos.create({\n     *   data: {\n     *     // ... data to create a Todo_app_todos\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_app_todosCreateArgs>(args: SelectSubset<T, todo_app_todosCreateArgs<ExtArgs>>): Prisma__todo_app_todosClient<$Result.GetResult<Prisma.$todo_app_todosPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_app_todos.\n     * @param {todo_app_todosCreateManyArgs} args - Arguments to create many Todo_app_todos.\n     * @example\n     * // Create many Todo_app_todos\n     * const todo_app_todos = await prisma.todo_app_todos.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_app_todosCreateManyArgs>(args?: SelectSubset<T, todo_app_todosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_app_todos and returns the data saved in the database.\n     * @param {todo_app_todosCreateManyAndReturnArgs} args - Arguments to create many Todo_app_todos.\n     * @example\n     * // Create many Todo_app_todos\n     * const todo_app_todos = await prisma.todo_app_todos.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_app_todos and only return the `id`\n     * const todo_app_todosWithIdOnly = await prisma.todo_app_todos.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_app_todosCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_app_todosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_todosPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_app_todos.\n     * @param {todo_app_todosDeleteArgs} args - Arguments to delete one Todo_app_todos.\n     * @example\n     * // Delete one Todo_app_todos\n     * const Todo_app_todos = await prisma.todo_app_todos.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_app_todos\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_app_todosDeleteArgs>(args: SelectSubset<T, todo_app_todosDeleteArgs<ExtArgs>>): Prisma__todo_app_todosClient<$Result.GetResult<Prisma.$todo_app_todosPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_app_todos.\n     * @param {todo_app_todosUpdateArgs} args - Arguments to update one Todo_app_todos.\n     * @example\n     * // Update one Todo_app_todos\n     * const todo_app_todos = await prisma.todo_app_todos.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_app_todosUpdateArgs>(args: SelectSubset<T, todo_app_todosUpdateArgs<ExtArgs>>): Prisma__todo_app_todosClient<$Result.GetResult<Prisma.$todo_app_todosPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_app_todos.\n     * @param {todo_app_todosDeleteManyArgs} args - Arguments to filter Todo_app_todos to delete.\n     * @example\n     * // Delete a few Todo_app_todos\n     * const { count } = await prisma.todo_app_todos.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_app_todosDeleteManyArgs>(args?: SelectSubset<T, todo_app_todosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_app_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_todosUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_app_todos\n     * const todo_app_todos = await prisma.todo_app_todos.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_app_todosUpdateManyArgs>(args: SelectSubset<T, todo_app_todosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_app_todos and returns the data updated in the database.\n     * @param {todo_app_todosUpdateManyAndReturnArgs} args - Arguments to update many Todo_app_todos.\n     * @example\n     * // Update many Todo_app_todos\n     * const todo_app_todos = await prisma.todo_app_todos.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_app_todos and only return the `id`\n     * const todo_app_todosWithIdOnly = await prisma.todo_app_todos.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_app_todosUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_app_todosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_todosPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_app_todos.\n     * @param {todo_app_todosUpsertArgs} args - Arguments to update or create a Todo_app_todos.\n     * @example\n     * // Update or create a Todo_app_todos\n     * const todo_app_todos = await prisma.todo_app_todos.upsert({\n     *   create: {\n     *     // ... data to create a Todo_app_todos\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_app_todos we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_app_todosUpsertArgs>(args: SelectSubset<T, todo_app_todosUpsertArgs<ExtArgs>>): Prisma__todo_app_todosClient<$Result.GetResult<Prisma.$todo_app_todosPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_app_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_todosCountArgs} args - Arguments to filter Todo_app_todos to count.\n     * @example\n     * // Count the number of Todo_app_todos\n     * const count = await prisma.todo_app_todos.count({\n     *   where: {\n     *     // ... the filter for the Todo_app_todos we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_app_todosCountArgs>(\n      args?: Subset<T, todo_app_todosCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_app_todosCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_app_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_app_todosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_app_todosAggregateArgs>(args: Subset<T, Todo_app_todosAggregateArgs>): Prisma.PrismaPromise<GetTodo_app_todosAggregateType<T>>\n\n    /**\n     * Group by Todo_app_todos.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_todosGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_app_todosGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_app_todosGroupByArgs['orderBy'] }\n        : { orderBy?: todo_app_todosGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_app_todosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_app_todosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_app_todos model\n   */\n  readonly fields: todo_app_todosFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_app_todos.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_app_todosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    user<T extends todo_app_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, todo_app_userDefaultArgs<ExtArgs>>): Prisma__todo_app_userClient<$Result.GetResult<Prisma.$todo_app_userPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    todo_app_todo_snapshots<T extends todo_app_todos$todo_app_todo_snapshotsArgs<ExtArgs> = {}>(args?: Subset<T, todo_app_todos$todo_app_todo_snapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_todo_snapshotsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_app_todos model\n   */\n  interface todo_app_todosFieldRefs {\n    readonly id: FieldRef<\"todo_app_todos\", 'String'>\n    readonly user_id: FieldRef<\"todo_app_todos\", 'String'>\n    readonly title: FieldRef<\"todo_app_todos\", 'String'>\n    readonly description: FieldRef<\"todo_app_todos\", 'String'>\n    readonly is_completed: FieldRef<\"todo_app_todos\", 'Boolean'>\n    readonly completed_at: FieldRef<\"todo_app_todos\", 'DateTime'>\n    readonly position: FieldRef<\"todo_app_todos\", 'Int'>\n    readonly created_at: FieldRef<\"todo_app_todos\", 'DateTime'>\n    readonly updated_at: FieldRef<\"todo_app_todos\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"todo_app_todos\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_app_todos findUnique\n   */\n  export type todo_app_todosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todos\n     */\n    select?: todo_app_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todos\n     */\n    omit?: todo_app_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_todos to fetch.\n     */\n    where: todo_app_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_app_todos findUniqueOrThrow\n   */\n  export type todo_app_todosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todos\n     */\n    select?: todo_app_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todos\n     */\n    omit?: todo_app_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_todos to fetch.\n     */\n    where: todo_app_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_app_todos findFirst\n   */\n  export type todo_app_todosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todos\n     */\n    select?: todo_app_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todos\n     */\n    omit?: todo_app_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_todos to fetch.\n     */\n    where?: todo_app_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_todos to fetch.\n     */\n    orderBy?: todo_app_todosOrderByWithRelationInput | todo_app_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_app_todos.\n     */\n    cursor?: todo_app_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_todos.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_app_todos.\n     */\n    distinct?: Todo_app_todosScalarFieldEnum | Todo_app_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_todos findFirstOrThrow\n   */\n  export type todo_app_todosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todos\n     */\n    select?: todo_app_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todos\n     */\n    omit?: todo_app_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_todos to fetch.\n     */\n    where?: todo_app_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_todos to fetch.\n     */\n    orderBy?: todo_app_todosOrderByWithRelationInput | todo_app_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_app_todos.\n     */\n    cursor?: todo_app_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_todos.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_app_todos.\n     */\n    distinct?: Todo_app_todosScalarFieldEnum | Todo_app_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_todos findMany\n   */\n  export type todo_app_todosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todos\n     */\n    select?: todo_app_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todos\n     */\n    omit?: todo_app_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todosInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_todos to fetch.\n     */\n    where?: todo_app_todosWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_todos to fetch.\n     */\n    orderBy?: todo_app_todosOrderByWithRelationInput | todo_app_todosOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_app_todos.\n     */\n    cursor?: todo_app_todosWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_todos from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_todos.\n     */\n    skip?: number\n    distinct?: Todo_app_todosScalarFieldEnum | Todo_app_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_todos create\n   */\n  export type todo_app_todosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todos\n     */\n    select?: todo_app_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todos\n     */\n    omit?: todo_app_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todosInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_app_todos.\n     */\n    data: XOR<todo_app_todosCreateInput, todo_app_todosUncheckedCreateInput>\n  }\n\n  /**\n   * todo_app_todos createMany\n   */\n  export type todo_app_todosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_app_todos.\n     */\n    data: todo_app_todosCreateManyInput | todo_app_todosCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_app_todos createManyAndReturn\n   */\n  export type todo_app_todosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todos\n     */\n    select?: todo_app_todosSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todos\n     */\n    omit?: todo_app_todosOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_app_todos.\n     */\n    data: todo_app_todosCreateManyInput | todo_app_todosCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todosIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_app_todos update\n   */\n  export type todo_app_todosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todos\n     */\n    select?: todo_app_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todos\n     */\n    omit?: todo_app_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todosInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_app_todos.\n     */\n    data: XOR<todo_app_todosUpdateInput, todo_app_todosUncheckedUpdateInput>\n    /**\n     * Choose, which todo_app_todos to update.\n     */\n    where: todo_app_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_app_todos updateMany\n   */\n  export type todo_app_todosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_app_todos.\n     */\n    data: XOR<todo_app_todosUpdateManyMutationInput, todo_app_todosUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_app_todos to update\n     */\n    where?: todo_app_todosWhereInput\n    /**\n     * Limit how many todo_app_todos to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_todos updateManyAndReturn\n   */\n  export type todo_app_todosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todos\n     */\n    select?: todo_app_todosSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todos\n     */\n    omit?: todo_app_todosOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_app_todos.\n     */\n    data: XOR<todo_app_todosUpdateManyMutationInput, todo_app_todosUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_app_todos to update\n     */\n    where?: todo_app_todosWhereInput\n    /**\n     * Limit how many todo_app_todos to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todosIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_app_todos upsert\n   */\n  export type todo_app_todosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todos\n     */\n    select?: todo_app_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todos\n     */\n    omit?: todo_app_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todosInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_app_todos to update in case it exists.\n     */\n    where: todo_app_todosWhereUniqueInput\n    /**\n     * In case the todo_app_todos found by the `where` argument doesn't exist, create a new todo_app_todos with this data.\n     */\n    create: XOR<todo_app_todosCreateInput, todo_app_todosUncheckedCreateInput>\n    /**\n     * In case the todo_app_todos was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_app_todosUpdateInput, todo_app_todosUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_app_todos delete\n   */\n  export type todo_app_todosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todos\n     */\n    select?: todo_app_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todos\n     */\n    omit?: todo_app_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todosInclude<ExtArgs> | null\n    /**\n     * Filter which todo_app_todos to delete.\n     */\n    where: todo_app_todosWhereUniqueInput\n  }\n\n  /**\n   * todo_app_todos deleteMany\n   */\n  export type todo_app_todosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_app_todos to delete\n     */\n    where?: todo_app_todosWhereInput\n    /**\n     * Limit how many todo_app_todos to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_todos.todo_app_todo_snapshots\n   */\n  export type todo_app_todos$todo_app_todo_snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todo_snapshots\n     */\n    select?: todo_app_todo_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todo_snapshots\n     */\n    omit?: todo_app_todo_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todo_snapshotsInclude<ExtArgs> | null\n    where?: todo_app_todo_snapshotsWhereInput\n    orderBy?: todo_app_todo_snapshotsOrderByWithRelationInput | todo_app_todo_snapshotsOrderByWithRelationInput[]\n    cursor?: todo_app_todo_snapshotsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Todo_app_todo_snapshotsScalarFieldEnum | Todo_app_todo_snapshotsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_todos without action\n   */\n  export type todo_app_todosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todos\n     */\n    select?: todo_app_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todos\n     */\n    omit?: todo_app_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todosInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model todo_app_todo_snapshots\n   */\n\n  export type AggregateTodo_app_todo_snapshots = {\n    _count: Todo_app_todo_snapshotsCountAggregateOutputType | null\n    _avg: Todo_app_todo_snapshotsAvgAggregateOutputType | null\n    _sum: Todo_app_todo_snapshotsSumAggregateOutputType | null\n    _min: Todo_app_todo_snapshotsMinAggregateOutputType | null\n    _max: Todo_app_todo_snapshotsMaxAggregateOutputType | null\n  }\n\n  export type Todo_app_todo_snapshotsAvgAggregateOutputType = {\n    position: number | null\n  }\n\n  export type Todo_app_todo_snapshotsSumAggregateOutputType = {\n    position: number | null\n  }\n\n  export type Todo_app_todo_snapshotsMinAggregateOutputType = {\n    id: string | null\n    todo_app_todo_id: string | null\n    title: string | null\n    description: string | null\n    is_completed: boolean | null\n    completed_at: Date | null\n    position: number | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n    snapshot_at: Date | null\n  }\n\n  export type Todo_app_todo_snapshotsMaxAggregateOutputType = {\n    id: string | null\n    todo_app_todo_id: string | null\n    title: string | null\n    description: string | null\n    is_completed: boolean | null\n    completed_at: Date | null\n    position: number | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n    snapshot_at: Date | null\n  }\n\n  export type Todo_app_todo_snapshotsCountAggregateOutputType = {\n    id: number\n    todo_app_todo_id: number\n    title: number\n    description: number\n    is_completed: number\n    completed_at: number\n    position: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    snapshot_at: number\n    _all: number\n  }\n\n\n  export type Todo_app_todo_snapshotsAvgAggregateInputType = {\n    position?: true\n  }\n\n  export type Todo_app_todo_snapshotsSumAggregateInputType = {\n    position?: true\n  }\n\n  export type Todo_app_todo_snapshotsMinAggregateInputType = {\n    id?: true\n    todo_app_todo_id?: true\n    title?: true\n    description?: true\n    is_completed?: true\n    completed_at?: true\n    position?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    snapshot_at?: true\n  }\n\n  export type Todo_app_todo_snapshotsMaxAggregateInputType = {\n    id?: true\n    todo_app_todo_id?: true\n    title?: true\n    description?: true\n    is_completed?: true\n    completed_at?: true\n    position?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    snapshot_at?: true\n  }\n\n  export type Todo_app_todo_snapshotsCountAggregateInputType = {\n    id?: true\n    todo_app_todo_id?: true\n    title?: true\n    description?: true\n    is_completed?: true\n    completed_at?: true\n    position?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    snapshot_at?: true\n    _all?: true\n  }\n\n  export type Todo_app_todo_snapshotsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_app_todo_snapshots to aggregate.\n     */\n    where?: todo_app_todo_snapshotsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_todo_snapshots to fetch.\n     */\n    orderBy?: todo_app_todo_snapshotsOrderByWithRelationInput | todo_app_todo_snapshotsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_app_todo_snapshotsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_todo_snapshots from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_todo_snapshots.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_app_todo_snapshots\n    **/\n    _count?: true | Todo_app_todo_snapshotsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: Todo_app_todo_snapshotsAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: Todo_app_todo_snapshotsSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_app_todo_snapshotsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_app_todo_snapshotsMaxAggregateInputType\n  }\n\n  export type GetTodo_app_todo_snapshotsAggregateType<T extends Todo_app_todo_snapshotsAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_app_todo_snapshots]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_app_todo_snapshots[P]>\n      : GetScalarType<T[P], AggregateTodo_app_todo_snapshots[P]>\n  }\n\n\n\n\n  export type todo_app_todo_snapshotsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_app_todo_snapshotsWhereInput\n    orderBy?: todo_app_todo_snapshotsOrderByWithAggregationInput | todo_app_todo_snapshotsOrderByWithAggregationInput[]\n    by: Todo_app_todo_snapshotsScalarFieldEnum[] | Todo_app_todo_snapshotsScalarFieldEnum\n    having?: todo_app_todo_snapshotsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_app_todo_snapshotsCountAggregateInputType | true\n    _avg?: Todo_app_todo_snapshotsAvgAggregateInputType\n    _sum?: Todo_app_todo_snapshotsSumAggregateInputType\n    _min?: Todo_app_todo_snapshotsMinAggregateInputType\n    _max?: Todo_app_todo_snapshotsMaxAggregateInputType\n  }\n\n  export type Todo_app_todo_snapshotsGroupByOutputType = {\n    id: string\n    todo_app_todo_id: string\n    title: string\n    description: string | null\n    is_completed: boolean\n    completed_at: Date | null\n    position: number | null\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    snapshot_at: Date\n    _count: Todo_app_todo_snapshotsCountAggregateOutputType | null\n    _avg: Todo_app_todo_snapshotsAvgAggregateOutputType | null\n    _sum: Todo_app_todo_snapshotsSumAggregateOutputType | null\n    _min: Todo_app_todo_snapshotsMinAggregateOutputType | null\n    _max: Todo_app_todo_snapshotsMaxAggregateOutputType | null\n  }\n\n  type GetTodo_app_todo_snapshotsGroupByPayload<T extends todo_app_todo_snapshotsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_app_todo_snapshotsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_app_todo_snapshotsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_app_todo_snapshotsGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_app_todo_snapshotsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_app_todo_snapshotsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_app_todo_id?: boolean\n    title?: boolean\n    description?: boolean\n    is_completed?: boolean\n    completed_at?: boolean\n    position?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    snapshot_at?: boolean\n    todo?: boolean | todo_app_todosDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_app_todo_snapshots\"]>\n\n  export type todo_app_todo_snapshotsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_app_todo_id?: boolean\n    title?: boolean\n    description?: boolean\n    is_completed?: boolean\n    completed_at?: boolean\n    position?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    snapshot_at?: boolean\n    todo?: boolean | todo_app_todosDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_app_todo_snapshots\"]>\n\n  export type todo_app_todo_snapshotsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_app_todo_id?: boolean\n    title?: boolean\n    description?: boolean\n    is_completed?: boolean\n    completed_at?: boolean\n    position?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    snapshot_at?: boolean\n    todo?: boolean | todo_app_todosDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_app_todo_snapshots\"]>\n\n  export type todo_app_todo_snapshotsSelectScalar = {\n    id?: boolean\n    todo_app_todo_id?: boolean\n    title?: boolean\n    description?: boolean\n    is_completed?: boolean\n    completed_at?: boolean\n    position?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    snapshot_at?: boolean\n  }\n\n  export type todo_app_todo_snapshotsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"todo_app_todo_id\" | \"title\" | \"description\" | \"is_completed\" | \"completed_at\" | \"position\" | \"created_at\" | \"updated_at\" | \"deleted_at\" | \"snapshot_at\", ExtArgs[\"result\"][\"todo_app_todo_snapshots\"]>\n  export type todo_app_todo_snapshotsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo?: boolean | todo_app_todosDefaultArgs<ExtArgs>\n  }\n  export type todo_app_todo_snapshotsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo?: boolean | todo_app_todosDefaultArgs<ExtArgs>\n  }\n  export type todo_app_todo_snapshotsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo?: boolean | todo_app_todosDefaultArgs<ExtArgs>\n  }\n\n  export type $todo_app_todo_snapshotsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_app_todo_snapshots\"\n    objects: {\n      todo: Prisma.$todo_app_todosPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Referenced todo item. {@\\link todo_app_todos.id}.\n       */\n      todo_app_todo_id: string\n      /**\n       * Snapshot of todo.title at snapshot time.\n       */\n      title: string\n      /**\n       * Snapshot of todo.description at snapshot time.\n       */\n      description: string | null\n      /**\n       * Snapshot of completion flag at snapshot time.\n       */\n      is_completed: boolean\n      /**\n       * Snapshot of completed_at (if set on source).\n       */\n      completed_at: Date | null\n      /**\n       * Snapshot of position for ordering.\n       */\n      position: number | null\n      /**\n       * Original created_at from source todo at snapshot time.\n       */\n      created_at: Date\n      /**\n       * Original updated_at from source todo at snapshot time.\n       */\n      updated_at: Date\n      /**\n       * Original deleted_at from source todo at snapshot time.\n       */\n      deleted_at: Date | null\n      /**\n       * Timestamp when this snapshot was created.\n       */\n      snapshot_at: Date\n    }, ExtArgs[\"result\"][\"todo_app_todo_snapshots\"]>\n    composites: {}\n  }\n\n  type todo_app_todo_snapshotsGetPayload<S extends boolean | null | undefined | todo_app_todo_snapshotsDefaultArgs> = $Result.GetResult<Prisma.$todo_app_todo_snapshotsPayload, S>\n\n  type todo_app_todo_snapshotsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_app_todo_snapshotsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_app_todo_snapshotsCountAggregateInputType | true\n    }\n\n  export interface todo_app_todo_snapshotsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_app_todo_snapshots'], meta: { name: 'todo_app_todo_snapshots' } }\n    /**\n     * Find zero or one Todo_app_todo_snapshots that matches the filter.\n     * @param {todo_app_todo_snapshotsFindUniqueArgs} args - Arguments to find a Todo_app_todo_snapshots\n     * @example\n     * // Get one Todo_app_todo_snapshots\n     * const todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_app_todo_snapshotsFindUniqueArgs>(args: SelectSubset<T, todo_app_todo_snapshotsFindUniqueArgs<ExtArgs>>): Prisma__todo_app_todo_snapshotsClient<$Result.GetResult<Prisma.$todo_app_todo_snapshotsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_app_todo_snapshots that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_app_todo_snapshotsFindUniqueOrThrowArgs} args - Arguments to find a Todo_app_todo_snapshots\n     * @example\n     * // Get one Todo_app_todo_snapshots\n     * const todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_app_todo_snapshotsFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_app_todo_snapshotsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_app_todo_snapshotsClient<$Result.GetResult<Prisma.$todo_app_todo_snapshotsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_app_todo_snapshots that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_todo_snapshotsFindFirstArgs} args - Arguments to find a Todo_app_todo_snapshots\n     * @example\n     * // Get one Todo_app_todo_snapshots\n     * const todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_app_todo_snapshotsFindFirstArgs>(args?: SelectSubset<T, todo_app_todo_snapshotsFindFirstArgs<ExtArgs>>): Prisma__todo_app_todo_snapshotsClient<$Result.GetResult<Prisma.$todo_app_todo_snapshotsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_app_todo_snapshots that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_todo_snapshotsFindFirstOrThrowArgs} args - Arguments to find a Todo_app_todo_snapshots\n     * @example\n     * // Get one Todo_app_todo_snapshots\n     * const todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_app_todo_snapshotsFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_app_todo_snapshotsFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_app_todo_snapshotsClient<$Result.GetResult<Prisma.$todo_app_todo_snapshotsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_app_todo_snapshots that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_todo_snapshotsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_app_todo_snapshots\n     * const todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.findMany()\n     * \n     * // Get first 10 Todo_app_todo_snapshots\n     * const todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_app_todo_snapshotsWithIdOnly = await prisma.todo_app_todo_snapshots.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_app_todo_snapshotsFindManyArgs>(args?: SelectSubset<T, todo_app_todo_snapshotsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_todo_snapshotsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_app_todo_snapshots.\n     * @param {todo_app_todo_snapshotsCreateArgs} args - Arguments to create a Todo_app_todo_snapshots.\n     * @example\n     * // Create one Todo_app_todo_snapshots\n     * const Todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.create({\n     *   data: {\n     *     // ... data to create a Todo_app_todo_snapshots\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_app_todo_snapshotsCreateArgs>(args: SelectSubset<T, todo_app_todo_snapshotsCreateArgs<ExtArgs>>): Prisma__todo_app_todo_snapshotsClient<$Result.GetResult<Prisma.$todo_app_todo_snapshotsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_app_todo_snapshots.\n     * @param {todo_app_todo_snapshotsCreateManyArgs} args - Arguments to create many Todo_app_todo_snapshots.\n     * @example\n     * // Create many Todo_app_todo_snapshots\n     * const todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_app_todo_snapshotsCreateManyArgs>(args?: SelectSubset<T, todo_app_todo_snapshotsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_app_todo_snapshots and returns the data saved in the database.\n     * @param {todo_app_todo_snapshotsCreateManyAndReturnArgs} args - Arguments to create many Todo_app_todo_snapshots.\n     * @example\n     * // Create many Todo_app_todo_snapshots\n     * const todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_app_todo_snapshots and only return the `id`\n     * const todo_app_todo_snapshotsWithIdOnly = await prisma.todo_app_todo_snapshots.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_app_todo_snapshotsCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_app_todo_snapshotsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_todo_snapshotsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_app_todo_snapshots.\n     * @param {todo_app_todo_snapshotsDeleteArgs} args - Arguments to delete one Todo_app_todo_snapshots.\n     * @example\n     * // Delete one Todo_app_todo_snapshots\n     * const Todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_app_todo_snapshots\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_app_todo_snapshotsDeleteArgs>(args: SelectSubset<T, todo_app_todo_snapshotsDeleteArgs<ExtArgs>>): Prisma__todo_app_todo_snapshotsClient<$Result.GetResult<Prisma.$todo_app_todo_snapshotsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_app_todo_snapshots.\n     * @param {todo_app_todo_snapshotsUpdateArgs} args - Arguments to update one Todo_app_todo_snapshots.\n     * @example\n     * // Update one Todo_app_todo_snapshots\n     * const todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_app_todo_snapshotsUpdateArgs>(args: SelectSubset<T, todo_app_todo_snapshotsUpdateArgs<ExtArgs>>): Prisma__todo_app_todo_snapshotsClient<$Result.GetResult<Prisma.$todo_app_todo_snapshotsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_app_todo_snapshots.\n     * @param {todo_app_todo_snapshotsDeleteManyArgs} args - Arguments to filter Todo_app_todo_snapshots to delete.\n     * @example\n     * // Delete a few Todo_app_todo_snapshots\n     * const { count } = await prisma.todo_app_todo_snapshots.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_app_todo_snapshotsDeleteManyArgs>(args?: SelectSubset<T, todo_app_todo_snapshotsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_app_todo_snapshots.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_todo_snapshotsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_app_todo_snapshots\n     * const todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_app_todo_snapshotsUpdateManyArgs>(args: SelectSubset<T, todo_app_todo_snapshotsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_app_todo_snapshots and returns the data updated in the database.\n     * @param {todo_app_todo_snapshotsUpdateManyAndReturnArgs} args - Arguments to update many Todo_app_todo_snapshots.\n     * @example\n     * // Update many Todo_app_todo_snapshots\n     * const todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_app_todo_snapshots and only return the `id`\n     * const todo_app_todo_snapshotsWithIdOnly = await prisma.todo_app_todo_snapshots.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_app_todo_snapshotsUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_app_todo_snapshotsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_todo_snapshotsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_app_todo_snapshots.\n     * @param {todo_app_todo_snapshotsUpsertArgs} args - Arguments to update or create a Todo_app_todo_snapshots.\n     * @example\n     * // Update or create a Todo_app_todo_snapshots\n     * const todo_app_todo_snapshots = await prisma.todo_app_todo_snapshots.upsert({\n     *   create: {\n     *     // ... data to create a Todo_app_todo_snapshots\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_app_todo_snapshots we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_app_todo_snapshotsUpsertArgs>(args: SelectSubset<T, todo_app_todo_snapshotsUpsertArgs<ExtArgs>>): Prisma__todo_app_todo_snapshotsClient<$Result.GetResult<Prisma.$todo_app_todo_snapshotsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_app_todo_snapshots.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_todo_snapshotsCountArgs} args - Arguments to filter Todo_app_todo_snapshots to count.\n     * @example\n     * // Count the number of Todo_app_todo_snapshots\n     * const count = await prisma.todo_app_todo_snapshots.count({\n     *   where: {\n     *     // ... the filter for the Todo_app_todo_snapshots we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_app_todo_snapshotsCountArgs>(\n      args?: Subset<T, todo_app_todo_snapshotsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_app_todo_snapshotsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_app_todo_snapshots.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_app_todo_snapshotsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_app_todo_snapshotsAggregateArgs>(args: Subset<T, Todo_app_todo_snapshotsAggregateArgs>): Prisma.PrismaPromise<GetTodo_app_todo_snapshotsAggregateType<T>>\n\n    /**\n     * Group by Todo_app_todo_snapshots.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_todo_snapshotsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_app_todo_snapshotsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_app_todo_snapshotsGroupByArgs['orderBy'] }\n        : { orderBy?: todo_app_todo_snapshotsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_app_todo_snapshotsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_app_todo_snapshotsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_app_todo_snapshots model\n   */\n  readonly fields: todo_app_todo_snapshotsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_app_todo_snapshots.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_app_todo_snapshotsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    todo<T extends todo_app_todosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, todo_app_todosDefaultArgs<ExtArgs>>): Prisma__todo_app_todosClient<$Result.GetResult<Prisma.$todo_app_todosPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_app_todo_snapshots model\n   */\n  interface todo_app_todo_snapshotsFieldRefs {\n    readonly id: FieldRef<\"todo_app_todo_snapshots\", 'String'>\n    readonly todo_app_todo_id: FieldRef<\"todo_app_todo_snapshots\", 'String'>\n    readonly title: FieldRef<\"todo_app_todo_snapshots\", 'String'>\n    readonly description: FieldRef<\"todo_app_todo_snapshots\", 'String'>\n    readonly is_completed: FieldRef<\"todo_app_todo_snapshots\", 'Boolean'>\n    readonly completed_at: FieldRef<\"todo_app_todo_snapshots\", 'DateTime'>\n    readonly position: FieldRef<\"todo_app_todo_snapshots\", 'Int'>\n    readonly created_at: FieldRef<\"todo_app_todo_snapshots\", 'DateTime'>\n    readonly updated_at: FieldRef<\"todo_app_todo_snapshots\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"todo_app_todo_snapshots\", 'DateTime'>\n    readonly snapshot_at: FieldRef<\"todo_app_todo_snapshots\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_app_todo_snapshots findUnique\n   */\n  export type todo_app_todo_snapshotsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todo_snapshots\n     */\n    select?: todo_app_todo_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todo_snapshots\n     */\n    omit?: todo_app_todo_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todo_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_todo_snapshots to fetch.\n     */\n    where: todo_app_todo_snapshotsWhereUniqueInput\n  }\n\n  /**\n   * todo_app_todo_snapshots findUniqueOrThrow\n   */\n  export type todo_app_todo_snapshotsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todo_snapshots\n     */\n    select?: todo_app_todo_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todo_snapshots\n     */\n    omit?: todo_app_todo_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todo_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_todo_snapshots to fetch.\n     */\n    where: todo_app_todo_snapshotsWhereUniqueInput\n  }\n\n  /**\n   * todo_app_todo_snapshots findFirst\n   */\n  export type todo_app_todo_snapshotsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todo_snapshots\n     */\n    select?: todo_app_todo_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todo_snapshots\n     */\n    omit?: todo_app_todo_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todo_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_todo_snapshots to fetch.\n     */\n    where?: todo_app_todo_snapshotsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_todo_snapshots to fetch.\n     */\n    orderBy?: todo_app_todo_snapshotsOrderByWithRelationInput | todo_app_todo_snapshotsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_app_todo_snapshots.\n     */\n    cursor?: todo_app_todo_snapshotsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_todo_snapshots from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_todo_snapshots.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_app_todo_snapshots.\n     */\n    distinct?: Todo_app_todo_snapshotsScalarFieldEnum | Todo_app_todo_snapshotsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_todo_snapshots findFirstOrThrow\n   */\n  export type todo_app_todo_snapshotsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todo_snapshots\n     */\n    select?: todo_app_todo_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todo_snapshots\n     */\n    omit?: todo_app_todo_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todo_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_todo_snapshots to fetch.\n     */\n    where?: todo_app_todo_snapshotsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_todo_snapshots to fetch.\n     */\n    orderBy?: todo_app_todo_snapshotsOrderByWithRelationInput | todo_app_todo_snapshotsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_app_todo_snapshots.\n     */\n    cursor?: todo_app_todo_snapshotsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_todo_snapshots from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_todo_snapshots.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_app_todo_snapshots.\n     */\n    distinct?: Todo_app_todo_snapshotsScalarFieldEnum | Todo_app_todo_snapshotsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_todo_snapshots findMany\n   */\n  export type todo_app_todo_snapshotsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todo_snapshots\n     */\n    select?: todo_app_todo_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todo_snapshots\n     */\n    omit?: todo_app_todo_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todo_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_todo_snapshots to fetch.\n     */\n    where?: todo_app_todo_snapshotsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_todo_snapshots to fetch.\n     */\n    orderBy?: todo_app_todo_snapshotsOrderByWithRelationInput | todo_app_todo_snapshotsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_app_todo_snapshots.\n     */\n    cursor?: todo_app_todo_snapshotsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_todo_snapshots from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_todo_snapshots.\n     */\n    skip?: number\n    distinct?: Todo_app_todo_snapshotsScalarFieldEnum | Todo_app_todo_snapshotsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_todo_snapshots create\n   */\n  export type todo_app_todo_snapshotsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todo_snapshots\n     */\n    select?: todo_app_todo_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todo_snapshots\n     */\n    omit?: todo_app_todo_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todo_snapshotsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_app_todo_snapshots.\n     */\n    data: XOR<todo_app_todo_snapshotsCreateInput, todo_app_todo_snapshotsUncheckedCreateInput>\n  }\n\n  /**\n   * todo_app_todo_snapshots createMany\n   */\n  export type todo_app_todo_snapshotsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_app_todo_snapshots.\n     */\n    data: todo_app_todo_snapshotsCreateManyInput | todo_app_todo_snapshotsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_app_todo_snapshots createManyAndReturn\n   */\n  export type todo_app_todo_snapshotsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todo_snapshots\n     */\n    select?: todo_app_todo_snapshotsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todo_snapshots\n     */\n    omit?: todo_app_todo_snapshotsOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_app_todo_snapshots.\n     */\n    data: todo_app_todo_snapshotsCreateManyInput | todo_app_todo_snapshotsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todo_snapshotsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_app_todo_snapshots update\n   */\n  export type todo_app_todo_snapshotsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todo_snapshots\n     */\n    select?: todo_app_todo_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todo_snapshots\n     */\n    omit?: todo_app_todo_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todo_snapshotsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_app_todo_snapshots.\n     */\n    data: XOR<todo_app_todo_snapshotsUpdateInput, todo_app_todo_snapshotsUncheckedUpdateInput>\n    /**\n     * Choose, which todo_app_todo_snapshots to update.\n     */\n    where: todo_app_todo_snapshotsWhereUniqueInput\n  }\n\n  /**\n   * todo_app_todo_snapshots updateMany\n   */\n  export type todo_app_todo_snapshotsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_app_todo_snapshots.\n     */\n    data: XOR<todo_app_todo_snapshotsUpdateManyMutationInput, todo_app_todo_snapshotsUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_app_todo_snapshots to update\n     */\n    where?: todo_app_todo_snapshotsWhereInput\n    /**\n     * Limit how many todo_app_todo_snapshots to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_todo_snapshots updateManyAndReturn\n   */\n  export type todo_app_todo_snapshotsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todo_snapshots\n     */\n    select?: todo_app_todo_snapshotsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todo_snapshots\n     */\n    omit?: todo_app_todo_snapshotsOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_app_todo_snapshots.\n     */\n    data: XOR<todo_app_todo_snapshotsUpdateManyMutationInput, todo_app_todo_snapshotsUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_app_todo_snapshots to update\n     */\n    where?: todo_app_todo_snapshotsWhereInput\n    /**\n     * Limit how many todo_app_todo_snapshots to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todo_snapshotsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_app_todo_snapshots upsert\n   */\n  export type todo_app_todo_snapshotsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todo_snapshots\n     */\n    select?: todo_app_todo_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todo_snapshots\n     */\n    omit?: todo_app_todo_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todo_snapshotsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_app_todo_snapshots to update in case it exists.\n     */\n    where: todo_app_todo_snapshotsWhereUniqueInput\n    /**\n     * In case the todo_app_todo_snapshots found by the `where` argument doesn't exist, create a new todo_app_todo_snapshots with this data.\n     */\n    create: XOR<todo_app_todo_snapshotsCreateInput, todo_app_todo_snapshotsUncheckedCreateInput>\n    /**\n     * In case the todo_app_todo_snapshots was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_app_todo_snapshotsUpdateInput, todo_app_todo_snapshotsUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_app_todo_snapshots delete\n   */\n  export type todo_app_todo_snapshotsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todo_snapshots\n     */\n    select?: todo_app_todo_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todo_snapshots\n     */\n    omit?: todo_app_todo_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todo_snapshotsInclude<ExtArgs> | null\n    /**\n     * Filter which todo_app_todo_snapshots to delete.\n     */\n    where: todo_app_todo_snapshotsWhereUniqueInput\n  }\n\n  /**\n   * todo_app_todo_snapshots deleteMany\n   */\n  export type todo_app_todo_snapshotsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_app_todo_snapshots to delete\n     */\n    where?: todo_app_todo_snapshotsWhereInput\n    /**\n     * Limit how many todo_app_todo_snapshots to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_todo_snapshots without action\n   */\n  export type todo_app_todo_snapshotsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todo_snapshots\n     */\n    select?: todo_app_todo_snapshotsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todo_snapshots\n     */\n    omit?: todo_app_todo_snapshotsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todo_snapshotsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model todo_app_audit_records\n   */\n\n  export type AggregateTodo_app_audit_records = {\n    _count: Todo_app_audit_recordsCountAggregateOutputType | null\n    _min: Todo_app_audit_recordsMinAggregateOutputType | null\n    _max: Todo_app_audit_recordsMaxAggregateOutputType | null\n  }\n\n  export type Todo_app_audit_recordsMinAggregateOutputType = {\n    id: string | null\n    admin_id: string | null\n    user_id: string | null\n    actor_role: string | null\n    action_type: string | null\n    target_resource: string | null\n    target_id: string | null\n    reason: string | null\n    created_at: Date | null\n  }\n\n  export type Todo_app_audit_recordsMaxAggregateOutputType = {\n    id: string | null\n    admin_id: string | null\n    user_id: string | null\n    actor_role: string | null\n    action_type: string | null\n    target_resource: string | null\n    target_id: string | null\n    reason: string | null\n    created_at: Date | null\n  }\n\n  export type Todo_app_audit_recordsCountAggregateOutputType = {\n    id: number\n    admin_id: number\n    user_id: number\n    actor_role: number\n    action_type: number\n    target_resource: number\n    target_id: number\n    reason: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type Todo_app_audit_recordsMinAggregateInputType = {\n    id?: true\n    admin_id?: true\n    user_id?: true\n    actor_role?: true\n    action_type?: true\n    target_resource?: true\n    target_id?: true\n    reason?: true\n    created_at?: true\n  }\n\n  export type Todo_app_audit_recordsMaxAggregateInputType = {\n    id?: true\n    admin_id?: true\n    user_id?: true\n    actor_role?: true\n    action_type?: true\n    target_resource?: true\n    target_id?: true\n    reason?: true\n    created_at?: true\n  }\n\n  export type Todo_app_audit_recordsCountAggregateInputType = {\n    id?: true\n    admin_id?: true\n    user_id?: true\n    actor_role?: true\n    action_type?: true\n    target_resource?: true\n    target_id?: true\n    reason?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type Todo_app_audit_recordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_app_audit_records to aggregate.\n     */\n    where?: todo_app_audit_recordsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_audit_records to fetch.\n     */\n    orderBy?: todo_app_audit_recordsOrderByWithRelationInput | todo_app_audit_recordsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_app_audit_recordsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_audit_records from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_audit_records.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_app_audit_records\n    **/\n    _count?: true | Todo_app_audit_recordsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_app_audit_recordsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_app_audit_recordsMaxAggregateInputType\n  }\n\n  export type GetTodo_app_audit_recordsAggregateType<T extends Todo_app_audit_recordsAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_app_audit_records]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_app_audit_records[P]>\n      : GetScalarType<T[P], AggregateTodo_app_audit_records[P]>\n  }\n\n\n\n\n  export type todo_app_audit_recordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_app_audit_recordsWhereInput\n    orderBy?: todo_app_audit_recordsOrderByWithAggregationInput | todo_app_audit_recordsOrderByWithAggregationInput[]\n    by: Todo_app_audit_recordsScalarFieldEnum[] | Todo_app_audit_recordsScalarFieldEnum\n    having?: todo_app_audit_recordsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_app_audit_recordsCountAggregateInputType | true\n    _min?: Todo_app_audit_recordsMinAggregateInputType\n    _max?: Todo_app_audit_recordsMaxAggregateInputType\n  }\n\n  export type Todo_app_audit_recordsGroupByOutputType = {\n    id: string\n    admin_id: string | null\n    user_id: string | null\n    actor_role: string\n    action_type: string\n    target_resource: string\n    target_id: string | null\n    reason: string | null\n    created_at: Date\n    _count: Todo_app_audit_recordsCountAggregateOutputType | null\n    _min: Todo_app_audit_recordsMinAggregateOutputType | null\n    _max: Todo_app_audit_recordsMaxAggregateOutputType | null\n  }\n\n  type GetTodo_app_audit_recordsGroupByPayload<T extends todo_app_audit_recordsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_app_audit_recordsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_app_audit_recordsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_app_audit_recordsGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_app_audit_recordsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_app_audit_recordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    admin_id?: boolean\n    user_id?: boolean\n    actor_role?: boolean\n    action_type?: boolean\n    target_resource?: boolean\n    target_id?: boolean\n    reason?: boolean\n    created_at?: boolean\n    admin?: boolean | todo_app_audit_records$adminArgs<ExtArgs>\n    user?: boolean | todo_app_audit_records$userArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_app_audit_records\"]>\n\n  export type todo_app_audit_recordsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    admin_id?: boolean\n    user_id?: boolean\n    actor_role?: boolean\n    action_type?: boolean\n    target_resource?: boolean\n    target_id?: boolean\n    reason?: boolean\n    created_at?: boolean\n    admin?: boolean | todo_app_audit_records$adminArgs<ExtArgs>\n    user?: boolean | todo_app_audit_records$userArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_app_audit_records\"]>\n\n  export type todo_app_audit_recordsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    admin_id?: boolean\n    user_id?: boolean\n    actor_role?: boolean\n    action_type?: boolean\n    target_resource?: boolean\n    target_id?: boolean\n    reason?: boolean\n    created_at?: boolean\n    admin?: boolean | todo_app_audit_records$adminArgs<ExtArgs>\n    user?: boolean | todo_app_audit_records$userArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_app_audit_records\"]>\n\n  export type todo_app_audit_recordsSelectScalar = {\n    id?: boolean\n    admin_id?: boolean\n    user_id?: boolean\n    actor_role?: boolean\n    action_type?: boolean\n    target_resource?: boolean\n    target_id?: boolean\n    reason?: boolean\n    created_at?: boolean\n  }\n\n  export type todo_app_audit_recordsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"admin_id\" | \"user_id\" | \"actor_role\" | \"action_type\" | \"target_resource\" | \"target_id\" | \"reason\" | \"created_at\", ExtArgs[\"result\"][\"todo_app_audit_records\"]>\n  export type todo_app_audit_recordsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    admin?: boolean | todo_app_audit_records$adminArgs<ExtArgs>\n    user?: boolean | todo_app_audit_records$userArgs<ExtArgs>\n  }\n  export type todo_app_audit_recordsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    admin?: boolean | todo_app_audit_records$adminArgs<ExtArgs>\n    user?: boolean | todo_app_audit_records$userArgs<ExtArgs>\n  }\n  export type todo_app_audit_recordsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    admin?: boolean | todo_app_audit_records$adminArgs<ExtArgs>\n    user?: boolean | todo_app_audit_records$userArgs<ExtArgs>\n  }\n\n  export type $todo_app_audit_recordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_app_audit_records\"\n    objects: {\n      admin: Prisma.$todo_app_adminPayload<ExtArgs> | null\n      user: Prisma.$todo_app_userPayload<ExtArgs> | null\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Acting admin's {@\\link todo_app_admin.id}. Nullable for system actions.\n       */\n      admin_id: string | null\n      /**\n       * Referenced user affected by the action. {@\\link todo_app_user.id}.\n       * Nullable when not applicable.\n       */\n      user_id: string | null\n      /**\n       * Role of the actor performing the action (e.g., 'admin','system').\n       */\n      actor_role: string\n      /**\n       * Type of action performed (e.g., 'suspend_user','restore_todo','purge').\n       */\n      action_type: string\n      /**\n       * Logical resource type affected by the action (e.g., 'todo','user').\n       */\n      target_resource: string\n      /**\n       * Optional identifier of the target resource (e.g., todo id) for quick\n       * lookup.\n       */\n      target_id: string | null\n      /**\n       * Optional reason provided by the actor for the action.\n       */\n      reason: string | null\n      /**\n       * Timestamp when the audit record was created.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"todo_app_audit_records\"]>\n    composites: {}\n  }\n\n  type todo_app_audit_recordsGetPayload<S extends boolean | null | undefined | todo_app_audit_recordsDefaultArgs> = $Result.GetResult<Prisma.$todo_app_audit_recordsPayload, S>\n\n  type todo_app_audit_recordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_app_audit_recordsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_app_audit_recordsCountAggregateInputType | true\n    }\n\n  export interface todo_app_audit_recordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_app_audit_records'], meta: { name: 'todo_app_audit_records' } }\n    /**\n     * Find zero or one Todo_app_audit_records that matches the filter.\n     * @param {todo_app_audit_recordsFindUniqueArgs} args - Arguments to find a Todo_app_audit_records\n     * @example\n     * // Get one Todo_app_audit_records\n     * const todo_app_audit_records = await prisma.todo_app_audit_records.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_app_audit_recordsFindUniqueArgs>(args: SelectSubset<T, todo_app_audit_recordsFindUniqueArgs<ExtArgs>>): Prisma__todo_app_audit_recordsClient<$Result.GetResult<Prisma.$todo_app_audit_recordsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_app_audit_records that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_app_audit_recordsFindUniqueOrThrowArgs} args - Arguments to find a Todo_app_audit_records\n     * @example\n     * // Get one Todo_app_audit_records\n     * const todo_app_audit_records = await prisma.todo_app_audit_records.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_app_audit_recordsFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_app_audit_recordsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_app_audit_recordsClient<$Result.GetResult<Prisma.$todo_app_audit_recordsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_app_audit_records that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_audit_recordsFindFirstArgs} args - Arguments to find a Todo_app_audit_records\n     * @example\n     * // Get one Todo_app_audit_records\n     * const todo_app_audit_records = await prisma.todo_app_audit_records.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_app_audit_recordsFindFirstArgs>(args?: SelectSubset<T, todo_app_audit_recordsFindFirstArgs<ExtArgs>>): Prisma__todo_app_audit_recordsClient<$Result.GetResult<Prisma.$todo_app_audit_recordsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_app_audit_records that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_audit_recordsFindFirstOrThrowArgs} args - Arguments to find a Todo_app_audit_records\n     * @example\n     * // Get one Todo_app_audit_records\n     * const todo_app_audit_records = await prisma.todo_app_audit_records.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_app_audit_recordsFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_app_audit_recordsFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_app_audit_recordsClient<$Result.GetResult<Prisma.$todo_app_audit_recordsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_app_audit_records that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_audit_recordsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_app_audit_records\n     * const todo_app_audit_records = await prisma.todo_app_audit_records.findMany()\n     * \n     * // Get first 10 Todo_app_audit_records\n     * const todo_app_audit_records = await prisma.todo_app_audit_records.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_app_audit_recordsWithIdOnly = await prisma.todo_app_audit_records.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_app_audit_recordsFindManyArgs>(args?: SelectSubset<T, todo_app_audit_recordsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_audit_recordsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_app_audit_records.\n     * @param {todo_app_audit_recordsCreateArgs} args - Arguments to create a Todo_app_audit_records.\n     * @example\n     * // Create one Todo_app_audit_records\n     * const Todo_app_audit_records = await prisma.todo_app_audit_records.create({\n     *   data: {\n     *     // ... data to create a Todo_app_audit_records\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_app_audit_recordsCreateArgs>(args: SelectSubset<T, todo_app_audit_recordsCreateArgs<ExtArgs>>): Prisma__todo_app_audit_recordsClient<$Result.GetResult<Prisma.$todo_app_audit_recordsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_app_audit_records.\n     * @param {todo_app_audit_recordsCreateManyArgs} args - Arguments to create many Todo_app_audit_records.\n     * @example\n     * // Create many Todo_app_audit_records\n     * const todo_app_audit_records = await prisma.todo_app_audit_records.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_app_audit_recordsCreateManyArgs>(args?: SelectSubset<T, todo_app_audit_recordsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_app_audit_records and returns the data saved in the database.\n     * @param {todo_app_audit_recordsCreateManyAndReturnArgs} args - Arguments to create many Todo_app_audit_records.\n     * @example\n     * // Create many Todo_app_audit_records\n     * const todo_app_audit_records = await prisma.todo_app_audit_records.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_app_audit_records and only return the `id`\n     * const todo_app_audit_recordsWithIdOnly = await prisma.todo_app_audit_records.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_app_audit_recordsCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_app_audit_recordsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_audit_recordsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_app_audit_records.\n     * @param {todo_app_audit_recordsDeleteArgs} args - Arguments to delete one Todo_app_audit_records.\n     * @example\n     * // Delete one Todo_app_audit_records\n     * const Todo_app_audit_records = await prisma.todo_app_audit_records.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_app_audit_records\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_app_audit_recordsDeleteArgs>(args: SelectSubset<T, todo_app_audit_recordsDeleteArgs<ExtArgs>>): Prisma__todo_app_audit_recordsClient<$Result.GetResult<Prisma.$todo_app_audit_recordsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_app_audit_records.\n     * @param {todo_app_audit_recordsUpdateArgs} args - Arguments to update one Todo_app_audit_records.\n     * @example\n     * // Update one Todo_app_audit_records\n     * const todo_app_audit_records = await prisma.todo_app_audit_records.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_app_audit_recordsUpdateArgs>(args: SelectSubset<T, todo_app_audit_recordsUpdateArgs<ExtArgs>>): Prisma__todo_app_audit_recordsClient<$Result.GetResult<Prisma.$todo_app_audit_recordsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_app_audit_records.\n     * @param {todo_app_audit_recordsDeleteManyArgs} args - Arguments to filter Todo_app_audit_records to delete.\n     * @example\n     * // Delete a few Todo_app_audit_records\n     * const { count } = await prisma.todo_app_audit_records.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_app_audit_recordsDeleteManyArgs>(args?: SelectSubset<T, todo_app_audit_recordsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_app_audit_records.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_audit_recordsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_app_audit_records\n     * const todo_app_audit_records = await prisma.todo_app_audit_records.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_app_audit_recordsUpdateManyArgs>(args: SelectSubset<T, todo_app_audit_recordsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_app_audit_records and returns the data updated in the database.\n     * @param {todo_app_audit_recordsUpdateManyAndReturnArgs} args - Arguments to update many Todo_app_audit_records.\n     * @example\n     * // Update many Todo_app_audit_records\n     * const todo_app_audit_records = await prisma.todo_app_audit_records.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_app_audit_records and only return the `id`\n     * const todo_app_audit_recordsWithIdOnly = await prisma.todo_app_audit_records.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_app_audit_recordsUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_app_audit_recordsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_audit_recordsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_app_audit_records.\n     * @param {todo_app_audit_recordsUpsertArgs} args - Arguments to update or create a Todo_app_audit_records.\n     * @example\n     * // Update or create a Todo_app_audit_records\n     * const todo_app_audit_records = await prisma.todo_app_audit_records.upsert({\n     *   create: {\n     *     // ... data to create a Todo_app_audit_records\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_app_audit_records we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_app_audit_recordsUpsertArgs>(args: SelectSubset<T, todo_app_audit_recordsUpsertArgs<ExtArgs>>): Prisma__todo_app_audit_recordsClient<$Result.GetResult<Prisma.$todo_app_audit_recordsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_app_audit_records.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_audit_recordsCountArgs} args - Arguments to filter Todo_app_audit_records to count.\n     * @example\n     * // Count the number of Todo_app_audit_records\n     * const count = await prisma.todo_app_audit_records.count({\n     *   where: {\n     *     // ... the filter for the Todo_app_audit_records we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_app_audit_recordsCountArgs>(\n      args?: Subset<T, todo_app_audit_recordsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_app_audit_recordsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_app_audit_records.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_app_audit_recordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_app_audit_recordsAggregateArgs>(args: Subset<T, Todo_app_audit_recordsAggregateArgs>): Prisma.PrismaPromise<GetTodo_app_audit_recordsAggregateType<T>>\n\n    /**\n     * Group by Todo_app_audit_records.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_audit_recordsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_app_audit_recordsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_app_audit_recordsGroupByArgs['orderBy'] }\n        : { orderBy?: todo_app_audit_recordsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_app_audit_recordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_app_audit_recordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_app_audit_records model\n   */\n  readonly fields: todo_app_audit_recordsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_app_audit_records.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_app_audit_recordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    admin<T extends todo_app_audit_records$adminArgs<ExtArgs> = {}>(args?: Subset<T, todo_app_audit_records$adminArgs<ExtArgs>>): Prisma__todo_app_adminClient<$Result.GetResult<Prisma.$todo_app_adminPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    user<T extends todo_app_audit_records$userArgs<ExtArgs> = {}>(args?: Subset<T, todo_app_audit_records$userArgs<ExtArgs>>): Prisma__todo_app_userClient<$Result.GetResult<Prisma.$todo_app_userPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_app_audit_records model\n   */\n  interface todo_app_audit_recordsFieldRefs {\n    readonly id: FieldRef<\"todo_app_audit_records\", 'String'>\n    readonly admin_id: FieldRef<\"todo_app_audit_records\", 'String'>\n    readonly user_id: FieldRef<\"todo_app_audit_records\", 'String'>\n    readonly actor_role: FieldRef<\"todo_app_audit_records\", 'String'>\n    readonly action_type: FieldRef<\"todo_app_audit_records\", 'String'>\n    readonly target_resource: FieldRef<\"todo_app_audit_records\", 'String'>\n    readonly target_id: FieldRef<\"todo_app_audit_records\", 'String'>\n    readonly reason: FieldRef<\"todo_app_audit_records\", 'String'>\n    readonly created_at: FieldRef<\"todo_app_audit_records\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_app_audit_records findUnique\n   */\n  export type todo_app_audit_recordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_audit_records\n     */\n    select?: todo_app_audit_recordsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_audit_records\n     */\n    omit?: todo_app_audit_recordsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_audit_recordsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_audit_records to fetch.\n     */\n    where: todo_app_audit_recordsWhereUniqueInput\n  }\n\n  /**\n   * todo_app_audit_records findUniqueOrThrow\n   */\n  export type todo_app_audit_recordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_audit_records\n     */\n    select?: todo_app_audit_recordsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_audit_records\n     */\n    omit?: todo_app_audit_recordsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_audit_recordsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_audit_records to fetch.\n     */\n    where: todo_app_audit_recordsWhereUniqueInput\n  }\n\n  /**\n   * todo_app_audit_records findFirst\n   */\n  export type todo_app_audit_recordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_audit_records\n     */\n    select?: todo_app_audit_recordsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_audit_records\n     */\n    omit?: todo_app_audit_recordsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_audit_recordsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_audit_records to fetch.\n     */\n    where?: todo_app_audit_recordsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_audit_records to fetch.\n     */\n    orderBy?: todo_app_audit_recordsOrderByWithRelationInput | todo_app_audit_recordsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_app_audit_records.\n     */\n    cursor?: todo_app_audit_recordsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_audit_records from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_audit_records.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_app_audit_records.\n     */\n    distinct?: Todo_app_audit_recordsScalarFieldEnum | Todo_app_audit_recordsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_audit_records findFirstOrThrow\n   */\n  export type todo_app_audit_recordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_audit_records\n     */\n    select?: todo_app_audit_recordsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_audit_records\n     */\n    omit?: todo_app_audit_recordsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_audit_recordsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_audit_records to fetch.\n     */\n    where?: todo_app_audit_recordsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_audit_records to fetch.\n     */\n    orderBy?: todo_app_audit_recordsOrderByWithRelationInput | todo_app_audit_recordsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_app_audit_records.\n     */\n    cursor?: todo_app_audit_recordsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_audit_records from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_audit_records.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_app_audit_records.\n     */\n    distinct?: Todo_app_audit_recordsScalarFieldEnum | Todo_app_audit_recordsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_audit_records findMany\n   */\n  export type todo_app_audit_recordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_audit_records\n     */\n    select?: todo_app_audit_recordsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_audit_records\n     */\n    omit?: todo_app_audit_recordsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_audit_recordsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_audit_records to fetch.\n     */\n    where?: todo_app_audit_recordsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_audit_records to fetch.\n     */\n    orderBy?: todo_app_audit_recordsOrderByWithRelationInput | todo_app_audit_recordsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_app_audit_records.\n     */\n    cursor?: todo_app_audit_recordsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_audit_records from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_audit_records.\n     */\n    skip?: number\n    distinct?: Todo_app_audit_recordsScalarFieldEnum | Todo_app_audit_recordsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_audit_records create\n   */\n  export type todo_app_audit_recordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_audit_records\n     */\n    select?: todo_app_audit_recordsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_audit_records\n     */\n    omit?: todo_app_audit_recordsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_audit_recordsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_app_audit_records.\n     */\n    data: XOR<todo_app_audit_recordsCreateInput, todo_app_audit_recordsUncheckedCreateInput>\n  }\n\n  /**\n   * todo_app_audit_records createMany\n   */\n  export type todo_app_audit_recordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_app_audit_records.\n     */\n    data: todo_app_audit_recordsCreateManyInput | todo_app_audit_recordsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_app_audit_records createManyAndReturn\n   */\n  export type todo_app_audit_recordsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_audit_records\n     */\n    select?: todo_app_audit_recordsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_audit_records\n     */\n    omit?: todo_app_audit_recordsOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_app_audit_records.\n     */\n    data: todo_app_audit_recordsCreateManyInput | todo_app_audit_recordsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_audit_recordsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_app_audit_records update\n   */\n  export type todo_app_audit_recordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_audit_records\n     */\n    select?: todo_app_audit_recordsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_audit_records\n     */\n    omit?: todo_app_audit_recordsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_audit_recordsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_app_audit_records.\n     */\n    data: XOR<todo_app_audit_recordsUpdateInput, todo_app_audit_recordsUncheckedUpdateInput>\n    /**\n     * Choose, which todo_app_audit_records to update.\n     */\n    where: todo_app_audit_recordsWhereUniqueInput\n  }\n\n  /**\n   * todo_app_audit_records updateMany\n   */\n  export type todo_app_audit_recordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_app_audit_records.\n     */\n    data: XOR<todo_app_audit_recordsUpdateManyMutationInput, todo_app_audit_recordsUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_app_audit_records to update\n     */\n    where?: todo_app_audit_recordsWhereInput\n    /**\n     * Limit how many todo_app_audit_records to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_audit_records updateManyAndReturn\n   */\n  export type todo_app_audit_recordsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_audit_records\n     */\n    select?: todo_app_audit_recordsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_audit_records\n     */\n    omit?: todo_app_audit_recordsOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_app_audit_records.\n     */\n    data: XOR<todo_app_audit_recordsUpdateManyMutationInput, todo_app_audit_recordsUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_app_audit_records to update\n     */\n    where?: todo_app_audit_recordsWhereInput\n    /**\n     * Limit how many todo_app_audit_records to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_audit_recordsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_app_audit_records upsert\n   */\n  export type todo_app_audit_recordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_audit_records\n     */\n    select?: todo_app_audit_recordsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_audit_records\n     */\n    omit?: todo_app_audit_recordsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_audit_recordsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_app_audit_records to update in case it exists.\n     */\n    where: todo_app_audit_recordsWhereUniqueInput\n    /**\n     * In case the todo_app_audit_records found by the `where` argument doesn't exist, create a new todo_app_audit_records with this data.\n     */\n    create: XOR<todo_app_audit_recordsCreateInput, todo_app_audit_recordsUncheckedCreateInput>\n    /**\n     * In case the todo_app_audit_records was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_app_audit_recordsUpdateInput, todo_app_audit_recordsUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_app_audit_records delete\n   */\n  export type todo_app_audit_recordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_audit_records\n     */\n    select?: todo_app_audit_recordsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_audit_records\n     */\n    omit?: todo_app_audit_recordsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_audit_recordsInclude<ExtArgs> | null\n    /**\n     * Filter which todo_app_audit_records to delete.\n     */\n    where: todo_app_audit_recordsWhereUniqueInput\n  }\n\n  /**\n   * todo_app_audit_records deleteMany\n   */\n  export type todo_app_audit_recordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_app_audit_records to delete\n     */\n    where?: todo_app_audit_recordsWhereInput\n    /**\n     * Limit how many todo_app_audit_records to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_audit_records.admin\n   */\n  export type todo_app_audit_records$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_admin\n     */\n    select?: todo_app_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_admin\n     */\n    omit?: todo_app_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_adminInclude<ExtArgs> | null\n    where?: todo_app_adminWhereInput\n  }\n\n  /**\n   * todo_app_audit_records.user\n   */\n  export type todo_app_audit_records$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_user\n     */\n    select?: todo_app_userSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_user\n     */\n    omit?: todo_app_userOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_userInclude<ExtArgs> | null\n    where?: todo_app_userWhereInput\n  }\n\n  /**\n   * todo_app_audit_records without action\n   */\n  export type todo_app_audit_recordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_audit_records\n     */\n    select?: todo_app_audit_recordsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_audit_records\n     */\n    omit?: todo_app_audit_recordsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_audit_recordsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model todo_app_guest\n   */\n\n  export type AggregateTodo_app_guest = {\n    _count: Todo_app_guestCountAggregateOutputType | null\n    _min: Todo_app_guestMinAggregateOutputType | null\n    _max: Todo_app_guestMaxAggregateOutputType | null\n  }\n\n  export type Todo_app_guestMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    created_at: Date | null\n    last_active_at: Date | null\n    status: string | null\n  }\n\n  export type Todo_app_guestMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    created_at: Date | null\n    last_active_at: Date | null\n    status: string | null\n  }\n\n  export type Todo_app_guestCountAggregateOutputType = {\n    id: number\n    email: number\n    created_at: number\n    last_active_at: number\n    status: number\n    _all: number\n  }\n\n\n  export type Todo_app_guestMinAggregateInputType = {\n    id?: true\n    email?: true\n    created_at?: true\n    last_active_at?: true\n    status?: true\n  }\n\n  export type Todo_app_guestMaxAggregateInputType = {\n    id?: true\n    email?: true\n    created_at?: true\n    last_active_at?: true\n    status?: true\n  }\n\n  export type Todo_app_guestCountAggregateInputType = {\n    id?: true\n    email?: true\n    created_at?: true\n    last_active_at?: true\n    status?: true\n    _all?: true\n  }\n\n  export type Todo_app_guestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_app_guest to aggregate.\n     */\n    where?: todo_app_guestWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_guests to fetch.\n     */\n    orderBy?: todo_app_guestOrderByWithRelationInput | todo_app_guestOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_app_guestWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_guests from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_guests.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_app_guests\n    **/\n    _count?: true | Todo_app_guestCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_app_guestMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_app_guestMaxAggregateInputType\n  }\n\n  export type GetTodo_app_guestAggregateType<T extends Todo_app_guestAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_app_guest]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_app_guest[P]>\n      : GetScalarType<T[P], AggregateTodo_app_guest[P]>\n  }\n\n\n\n\n  export type todo_app_guestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_app_guestWhereInput\n    orderBy?: todo_app_guestOrderByWithAggregationInput | todo_app_guestOrderByWithAggregationInput[]\n    by: Todo_app_guestScalarFieldEnum[] | Todo_app_guestScalarFieldEnum\n    having?: todo_app_guestScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_app_guestCountAggregateInputType | true\n    _min?: Todo_app_guestMinAggregateInputType\n    _max?: Todo_app_guestMaxAggregateInputType\n  }\n\n  export type Todo_app_guestGroupByOutputType = {\n    id: string\n    email: string | null\n    created_at: Date\n    last_active_at: Date | null\n    status: string | null\n    _count: Todo_app_guestCountAggregateOutputType | null\n    _min: Todo_app_guestMinAggregateOutputType | null\n    _max: Todo_app_guestMaxAggregateOutputType | null\n  }\n\n  type GetTodo_app_guestGroupByPayload<T extends todo_app_guestGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_app_guestGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_app_guestGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_app_guestGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_app_guestGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_app_guestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    created_at?: boolean\n    last_active_at?: boolean\n    status?: boolean\n  }, ExtArgs[\"result\"][\"todo_app_guest\"]>\n\n  export type todo_app_guestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    created_at?: boolean\n    last_active_at?: boolean\n    status?: boolean\n  }, ExtArgs[\"result\"][\"todo_app_guest\"]>\n\n  export type todo_app_guestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    created_at?: boolean\n    last_active_at?: boolean\n    status?: boolean\n  }, ExtArgs[\"result\"][\"todo_app_guest\"]>\n\n  export type todo_app_guestSelectScalar = {\n    id?: boolean\n    email?: boolean\n    created_at?: boolean\n    last_active_at?: boolean\n    status?: boolean\n  }\n\n  export type todo_app_guestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"created_at\" | \"last_active_at\" | \"status\", ExtArgs[\"result\"][\"todo_app_guest\"]>\n\n  export type $todo_app_guestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_app_guest\"\n    objects: {}\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Optional visitor-provided email address (nullable).\n       */\n      email: string | null\n      /**\n       * Record creation timestamp for the guest entry.\n       */\n      created_at: Date\n      /**\n       * Last observed activity for the guest (nullable).\n       */\n      last_active_at: Date | null\n      /**\n       * Optional status for administrative housekeeping (e.g.,\n       * 'active','bounced').\n       */\n      status: string | null\n    }, ExtArgs[\"result\"][\"todo_app_guest\"]>\n    composites: {}\n  }\n\n  type todo_app_guestGetPayload<S extends boolean | null | undefined | todo_app_guestDefaultArgs> = $Result.GetResult<Prisma.$todo_app_guestPayload, S>\n\n  type todo_app_guestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_app_guestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_app_guestCountAggregateInputType | true\n    }\n\n  export interface todo_app_guestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_app_guest'], meta: { name: 'todo_app_guest' } }\n    /**\n     * Find zero or one Todo_app_guest that matches the filter.\n     * @param {todo_app_guestFindUniqueArgs} args - Arguments to find a Todo_app_guest\n     * @example\n     * // Get one Todo_app_guest\n     * const todo_app_guest = await prisma.todo_app_guest.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_app_guestFindUniqueArgs>(args: SelectSubset<T, todo_app_guestFindUniqueArgs<ExtArgs>>): Prisma__todo_app_guestClient<$Result.GetResult<Prisma.$todo_app_guestPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_app_guest that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_app_guestFindUniqueOrThrowArgs} args - Arguments to find a Todo_app_guest\n     * @example\n     * // Get one Todo_app_guest\n     * const todo_app_guest = await prisma.todo_app_guest.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_app_guestFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_app_guestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_app_guestClient<$Result.GetResult<Prisma.$todo_app_guestPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_app_guest that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_guestFindFirstArgs} args - Arguments to find a Todo_app_guest\n     * @example\n     * // Get one Todo_app_guest\n     * const todo_app_guest = await prisma.todo_app_guest.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_app_guestFindFirstArgs>(args?: SelectSubset<T, todo_app_guestFindFirstArgs<ExtArgs>>): Prisma__todo_app_guestClient<$Result.GetResult<Prisma.$todo_app_guestPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_app_guest that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_guestFindFirstOrThrowArgs} args - Arguments to find a Todo_app_guest\n     * @example\n     * // Get one Todo_app_guest\n     * const todo_app_guest = await prisma.todo_app_guest.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_app_guestFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_app_guestFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_app_guestClient<$Result.GetResult<Prisma.$todo_app_guestPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_app_guests that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_guestFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_app_guests\n     * const todo_app_guests = await prisma.todo_app_guest.findMany()\n     * \n     * // Get first 10 Todo_app_guests\n     * const todo_app_guests = await prisma.todo_app_guest.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_app_guestWithIdOnly = await prisma.todo_app_guest.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_app_guestFindManyArgs>(args?: SelectSubset<T, todo_app_guestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_guestPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_app_guest.\n     * @param {todo_app_guestCreateArgs} args - Arguments to create a Todo_app_guest.\n     * @example\n     * // Create one Todo_app_guest\n     * const Todo_app_guest = await prisma.todo_app_guest.create({\n     *   data: {\n     *     // ... data to create a Todo_app_guest\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_app_guestCreateArgs>(args: SelectSubset<T, todo_app_guestCreateArgs<ExtArgs>>): Prisma__todo_app_guestClient<$Result.GetResult<Prisma.$todo_app_guestPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_app_guests.\n     * @param {todo_app_guestCreateManyArgs} args - Arguments to create many Todo_app_guests.\n     * @example\n     * // Create many Todo_app_guests\n     * const todo_app_guest = await prisma.todo_app_guest.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_app_guestCreateManyArgs>(args?: SelectSubset<T, todo_app_guestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_app_guests and returns the data saved in the database.\n     * @param {todo_app_guestCreateManyAndReturnArgs} args - Arguments to create many Todo_app_guests.\n     * @example\n     * // Create many Todo_app_guests\n     * const todo_app_guest = await prisma.todo_app_guest.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_app_guests and only return the `id`\n     * const todo_app_guestWithIdOnly = await prisma.todo_app_guest.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_app_guestCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_app_guestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_guestPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_app_guest.\n     * @param {todo_app_guestDeleteArgs} args - Arguments to delete one Todo_app_guest.\n     * @example\n     * // Delete one Todo_app_guest\n     * const Todo_app_guest = await prisma.todo_app_guest.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_app_guest\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_app_guestDeleteArgs>(args: SelectSubset<T, todo_app_guestDeleteArgs<ExtArgs>>): Prisma__todo_app_guestClient<$Result.GetResult<Prisma.$todo_app_guestPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_app_guest.\n     * @param {todo_app_guestUpdateArgs} args - Arguments to update one Todo_app_guest.\n     * @example\n     * // Update one Todo_app_guest\n     * const todo_app_guest = await prisma.todo_app_guest.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_app_guestUpdateArgs>(args: SelectSubset<T, todo_app_guestUpdateArgs<ExtArgs>>): Prisma__todo_app_guestClient<$Result.GetResult<Prisma.$todo_app_guestPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_app_guests.\n     * @param {todo_app_guestDeleteManyArgs} args - Arguments to filter Todo_app_guests to delete.\n     * @example\n     * // Delete a few Todo_app_guests\n     * const { count } = await prisma.todo_app_guest.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_app_guestDeleteManyArgs>(args?: SelectSubset<T, todo_app_guestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_app_guests.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_guestUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_app_guests\n     * const todo_app_guest = await prisma.todo_app_guest.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_app_guestUpdateManyArgs>(args: SelectSubset<T, todo_app_guestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_app_guests and returns the data updated in the database.\n     * @param {todo_app_guestUpdateManyAndReturnArgs} args - Arguments to update many Todo_app_guests.\n     * @example\n     * // Update many Todo_app_guests\n     * const todo_app_guest = await prisma.todo_app_guest.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_app_guests and only return the `id`\n     * const todo_app_guestWithIdOnly = await prisma.todo_app_guest.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_app_guestUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_app_guestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_guestPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_app_guest.\n     * @param {todo_app_guestUpsertArgs} args - Arguments to update or create a Todo_app_guest.\n     * @example\n     * // Update or create a Todo_app_guest\n     * const todo_app_guest = await prisma.todo_app_guest.upsert({\n     *   create: {\n     *     // ... data to create a Todo_app_guest\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_app_guest we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_app_guestUpsertArgs>(args: SelectSubset<T, todo_app_guestUpsertArgs<ExtArgs>>): Prisma__todo_app_guestClient<$Result.GetResult<Prisma.$todo_app_guestPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_app_guests.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_guestCountArgs} args - Arguments to filter Todo_app_guests to count.\n     * @example\n     * // Count the number of Todo_app_guests\n     * const count = await prisma.todo_app_guest.count({\n     *   where: {\n     *     // ... the filter for the Todo_app_guests we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_app_guestCountArgs>(\n      args?: Subset<T, todo_app_guestCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_app_guestCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_app_guest.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_app_guestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_app_guestAggregateArgs>(args: Subset<T, Todo_app_guestAggregateArgs>): Prisma.PrismaPromise<GetTodo_app_guestAggregateType<T>>\n\n    /**\n     * Group by Todo_app_guest.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_guestGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_app_guestGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_app_guestGroupByArgs['orderBy'] }\n        : { orderBy?: todo_app_guestGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_app_guestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_app_guestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_app_guest model\n   */\n  readonly fields: todo_app_guestFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_app_guest.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_app_guestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_app_guest model\n   */\n  interface todo_app_guestFieldRefs {\n    readonly id: FieldRef<\"todo_app_guest\", 'String'>\n    readonly email: FieldRef<\"todo_app_guest\", 'String'>\n    readonly created_at: FieldRef<\"todo_app_guest\", 'DateTime'>\n    readonly last_active_at: FieldRef<\"todo_app_guest\", 'DateTime'>\n    readonly status: FieldRef<\"todo_app_guest\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_app_guest findUnique\n   */\n  export type todo_app_guestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_guest\n     */\n    select?: todo_app_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_guest\n     */\n    omit?: todo_app_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which todo_app_guest to fetch.\n     */\n    where: todo_app_guestWhereUniqueInput\n  }\n\n  /**\n   * todo_app_guest findUniqueOrThrow\n   */\n  export type todo_app_guestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_guest\n     */\n    select?: todo_app_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_guest\n     */\n    omit?: todo_app_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which todo_app_guest to fetch.\n     */\n    where: todo_app_guestWhereUniqueInput\n  }\n\n  /**\n   * todo_app_guest findFirst\n   */\n  export type todo_app_guestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_guest\n     */\n    select?: todo_app_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_guest\n     */\n    omit?: todo_app_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which todo_app_guest to fetch.\n     */\n    where?: todo_app_guestWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_guests to fetch.\n     */\n    orderBy?: todo_app_guestOrderByWithRelationInput | todo_app_guestOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_app_guests.\n     */\n    cursor?: todo_app_guestWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_guests from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_guests.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_app_guests.\n     */\n    distinct?: Todo_app_guestScalarFieldEnum | Todo_app_guestScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_guest findFirstOrThrow\n   */\n  export type todo_app_guestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_guest\n     */\n    select?: todo_app_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_guest\n     */\n    omit?: todo_app_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which todo_app_guest to fetch.\n     */\n    where?: todo_app_guestWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_guests to fetch.\n     */\n    orderBy?: todo_app_guestOrderByWithRelationInput | todo_app_guestOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_app_guests.\n     */\n    cursor?: todo_app_guestWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_guests from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_guests.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_app_guests.\n     */\n    distinct?: Todo_app_guestScalarFieldEnum | Todo_app_guestScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_guest findMany\n   */\n  export type todo_app_guestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_guest\n     */\n    select?: todo_app_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_guest\n     */\n    omit?: todo_app_guestOmit<ExtArgs> | null\n    /**\n     * Filter, which todo_app_guests to fetch.\n     */\n    where?: todo_app_guestWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_guests to fetch.\n     */\n    orderBy?: todo_app_guestOrderByWithRelationInput | todo_app_guestOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_app_guests.\n     */\n    cursor?: todo_app_guestWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_guests from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_guests.\n     */\n    skip?: number\n    distinct?: Todo_app_guestScalarFieldEnum | Todo_app_guestScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_guest create\n   */\n  export type todo_app_guestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_guest\n     */\n    select?: todo_app_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_guest\n     */\n    omit?: todo_app_guestOmit<ExtArgs> | null\n    /**\n     * The data needed to create a todo_app_guest.\n     */\n    data: XOR<todo_app_guestCreateInput, todo_app_guestUncheckedCreateInput>\n  }\n\n  /**\n   * todo_app_guest createMany\n   */\n  export type todo_app_guestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_app_guests.\n     */\n    data: todo_app_guestCreateManyInput | todo_app_guestCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_app_guest createManyAndReturn\n   */\n  export type todo_app_guestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_guest\n     */\n    select?: todo_app_guestSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_guest\n     */\n    omit?: todo_app_guestOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_app_guests.\n     */\n    data: todo_app_guestCreateManyInput | todo_app_guestCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_app_guest update\n   */\n  export type todo_app_guestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_guest\n     */\n    select?: todo_app_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_guest\n     */\n    omit?: todo_app_guestOmit<ExtArgs> | null\n    /**\n     * The data needed to update a todo_app_guest.\n     */\n    data: XOR<todo_app_guestUpdateInput, todo_app_guestUncheckedUpdateInput>\n    /**\n     * Choose, which todo_app_guest to update.\n     */\n    where: todo_app_guestWhereUniqueInput\n  }\n\n  /**\n   * todo_app_guest updateMany\n   */\n  export type todo_app_guestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_app_guests.\n     */\n    data: XOR<todo_app_guestUpdateManyMutationInput, todo_app_guestUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_app_guests to update\n     */\n    where?: todo_app_guestWhereInput\n    /**\n     * Limit how many todo_app_guests to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_guest updateManyAndReturn\n   */\n  export type todo_app_guestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_guest\n     */\n    select?: todo_app_guestSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_guest\n     */\n    omit?: todo_app_guestOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_app_guests.\n     */\n    data: XOR<todo_app_guestUpdateManyMutationInput, todo_app_guestUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_app_guests to update\n     */\n    where?: todo_app_guestWhereInput\n    /**\n     * Limit how many todo_app_guests to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_guest upsert\n   */\n  export type todo_app_guestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_guest\n     */\n    select?: todo_app_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_guest\n     */\n    omit?: todo_app_guestOmit<ExtArgs> | null\n    /**\n     * The filter to search for the todo_app_guest to update in case it exists.\n     */\n    where: todo_app_guestWhereUniqueInput\n    /**\n     * In case the todo_app_guest found by the `where` argument doesn't exist, create a new todo_app_guest with this data.\n     */\n    create: XOR<todo_app_guestCreateInput, todo_app_guestUncheckedCreateInput>\n    /**\n     * In case the todo_app_guest was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_app_guestUpdateInput, todo_app_guestUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_app_guest delete\n   */\n  export type todo_app_guestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_guest\n     */\n    select?: todo_app_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_guest\n     */\n    omit?: todo_app_guestOmit<ExtArgs> | null\n    /**\n     * Filter which todo_app_guest to delete.\n     */\n    where: todo_app_guestWhereUniqueInput\n  }\n\n  /**\n   * todo_app_guest deleteMany\n   */\n  export type todo_app_guestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_app_guests to delete\n     */\n    where?: todo_app_guestWhereInput\n    /**\n     * Limit how many todo_app_guests to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_guest without action\n   */\n  export type todo_app_guestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_guest\n     */\n    select?: todo_app_guestSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_guest\n     */\n    omit?: todo_app_guestOmit<ExtArgs> | null\n  }\n\n\n  /**\n   * Model todo_app_user\n   */\n\n  export type AggregateTodo_app_user = {\n    _count: Todo_app_userCountAggregateOutputType | null\n    _min: Todo_app_userMinAggregateOutputType | null\n    _max: Todo_app_userMaxAggregateOutputType | null\n  }\n\n  export type Todo_app_userMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    display_name: string | null\n    password_hash: string | null\n    account_status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    last_active_at: Date | null\n  }\n\n  export type Todo_app_userMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    display_name: string | null\n    password_hash: string | null\n    account_status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    last_active_at: Date | null\n  }\n\n  export type Todo_app_userCountAggregateOutputType = {\n    id: number\n    email: number\n    display_name: number\n    password_hash: number\n    account_status: number\n    created_at: number\n    updated_at: number\n    last_active_at: number\n    _all: number\n  }\n\n\n  export type Todo_app_userMinAggregateInputType = {\n    id?: true\n    email?: true\n    display_name?: true\n    password_hash?: true\n    account_status?: true\n    created_at?: true\n    updated_at?: true\n    last_active_at?: true\n  }\n\n  export type Todo_app_userMaxAggregateInputType = {\n    id?: true\n    email?: true\n    display_name?: true\n    password_hash?: true\n    account_status?: true\n    created_at?: true\n    updated_at?: true\n    last_active_at?: true\n  }\n\n  export type Todo_app_userCountAggregateInputType = {\n    id?: true\n    email?: true\n    display_name?: true\n    password_hash?: true\n    account_status?: true\n    created_at?: true\n    updated_at?: true\n    last_active_at?: true\n    _all?: true\n  }\n\n  export type Todo_app_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_app_user to aggregate.\n     */\n    where?: todo_app_userWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_users to fetch.\n     */\n    orderBy?: todo_app_userOrderByWithRelationInput | todo_app_userOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_app_userWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_app_users\n    **/\n    _count?: true | Todo_app_userCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_app_userMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_app_userMaxAggregateInputType\n  }\n\n  export type GetTodo_app_userAggregateType<T extends Todo_app_userAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_app_user]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_app_user[P]>\n      : GetScalarType<T[P], AggregateTodo_app_user[P]>\n  }\n\n\n\n\n  export type todo_app_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_app_userWhereInput\n    orderBy?: todo_app_userOrderByWithAggregationInput | todo_app_userOrderByWithAggregationInput[]\n    by: Todo_app_userScalarFieldEnum[] | Todo_app_userScalarFieldEnum\n    having?: todo_app_userScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_app_userCountAggregateInputType | true\n    _min?: Todo_app_userMinAggregateInputType\n    _max?: Todo_app_userMaxAggregateInputType\n  }\n\n  export type Todo_app_userGroupByOutputType = {\n    id: string\n    email: string\n    display_name: string | null\n    password_hash: string | null\n    account_status: string\n    created_at: Date\n    updated_at: Date\n    last_active_at: Date | null\n    _count: Todo_app_userCountAggregateOutputType | null\n    _min: Todo_app_userMinAggregateOutputType | null\n    _max: Todo_app_userMaxAggregateOutputType | null\n  }\n\n  type GetTodo_app_userGroupByPayload<T extends todo_app_userGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_app_userGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_app_userGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_app_userGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_app_userGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_app_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    display_name?: boolean\n    password_hash?: boolean\n    account_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    last_active_at?: boolean\n    todo_app_todos?: boolean | todo_app_user$todo_app_todosArgs<ExtArgs>\n    todo_app_audit_records?: boolean | todo_app_user$todo_app_audit_recordsArgs<ExtArgs>\n    _count?: boolean | Todo_app_userCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_app_user\"]>\n\n  export type todo_app_userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    display_name?: boolean\n    password_hash?: boolean\n    account_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    last_active_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_app_user\"]>\n\n  export type todo_app_userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    display_name?: boolean\n    password_hash?: boolean\n    account_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    last_active_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_app_user\"]>\n\n  export type todo_app_userSelectScalar = {\n    id?: boolean\n    email?: boolean\n    display_name?: boolean\n    password_hash?: boolean\n    account_status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    last_active_at?: boolean\n  }\n\n  export type todo_app_userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"display_name\" | \"password_hash\" | \"account_status\" | \"created_at\" | \"updated_at\" | \"last_active_at\", ExtArgs[\"result\"][\"todo_app_user\"]>\n  export type todo_app_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_app_todos?: boolean | todo_app_user$todo_app_todosArgs<ExtArgs>\n    todo_app_audit_records?: boolean | todo_app_user$todo_app_audit_recordsArgs<ExtArgs>\n    _count?: boolean | Todo_app_userCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type todo_app_userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type todo_app_userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $todo_app_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_app_user\"\n    objects: {\n      todo_app_todos: Prisma.$todo_app_todosPayload<ExtArgs>[]\n      todo_app_audit_records: Prisma.$todo_app_audit_recordsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Primary email for the user account. Used for login and communication.\n       */\n      email: string\n      /**\n       * Optional display name for the user.\n       */\n      display_name: string | null\n      /**\n       * Password hash for authentication (nullable if external auth used).\n       */\n      password_hash: string | null\n      /**\n       * Account lifecycle status (e.g., 'active','suspended').\n       */\n      account_status: string\n      /**\n       * Account creation timestamp.\n       */\n      created_at: Date\n      /**\n       * Last update timestamp for the account.\n       */\n      updated_at: Date\n      /**\n       * Last activity timestamp (nullable).\n       */\n      last_active_at: Date | null\n    }, ExtArgs[\"result\"][\"todo_app_user\"]>\n    composites: {}\n  }\n\n  type todo_app_userGetPayload<S extends boolean | null | undefined | todo_app_userDefaultArgs> = $Result.GetResult<Prisma.$todo_app_userPayload, S>\n\n  type todo_app_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_app_userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_app_userCountAggregateInputType | true\n    }\n\n  export interface todo_app_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_app_user'], meta: { name: 'todo_app_user' } }\n    /**\n     * Find zero or one Todo_app_user that matches the filter.\n     * @param {todo_app_userFindUniqueArgs} args - Arguments to find a Todo_app_user\n     * @example\n     * // Get one Todo_app_user\n     * const todo_app_user = await prisma.todo_app_user.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_app_userFindUniqueArgs>(args: SelectSubset<T, todo_app_userFindUniqueArgs<ExtArgs>>): Prisma__todo_app_userClient<$Result.GetResult<Prisma.$todo_app_userPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_app_user that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_app_userFindUniqueOrThrowArgs} args - Arguments to find a Todo_app_user\n     * @example\n     * // Get one Todo_app_user\n     * const todo_app_user = await prisma.todo_app_user.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_app_userFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_app_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_app_userClient<$Result.GetResult<Prisma.$todo_app_userPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_app_user that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_userFindFirstArgs} args - Arguments to find a Todo_app_user\n     * @example\n     * // Get one Todo_app_user\n     * const todo_app_user = await prisma.todo_app_user.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_app_userFindFirstArgs>(args?: SelectSubset<T, todo_app_userFindFirstArgs<ExtArgs>>): Prisma__todo_app_userClient<$Result.GetResult<Prisma.$todo_app_userPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_app_user that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_userFindFirstOrThrowArgs} args - Arguments to find a Todo_app_user\n     * @example\n     * // Get one Todo_app_user\n     * const todo_app_user = await prisma.todo_app_user.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_app_userFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_app_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_app_userClient<$Result.GetResult<Prisma.$todo_app_userPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_app_users that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_userFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_app_users\n     * const todo_app_users = await prisma.todo_app_user.findMany()\n     * \n     * // Get first 10 Todo_app_users\n     * const todo_app_users = await prisma.todo_app_user.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_app_userWithIdOnly = await prisma.todo_app_user.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_app_userFindManyArgs>(args?: SelectSubset<T, todo_app_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_userPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_app_user.\n     * @param {todo_app_userCreateArgs} args - Arguments to create a Todo_app_user.\n     * @example\n     * // Create one Todo_app_user\n     * const Todo_app_user = await prisma.todo_app_user.create({\n     *   data: {\n     *     // ... data to create a Todo_app_user\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_app_userCreateArgs>(args: SelectSubset<T, todo_app_userCreateArgs<ExtArgs>>): Prisma__todo_app_userClient<$Result.GetResult<Prisma.$todo_app_userPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_app_users.\n     * @param {todo_app_userCreateManyArgs} args - Arguments to create many Todo_app_users.\n     * @example\n     * // Create many Todo_app_users\n     * const todo_app_user = await prisma.todo_app_user.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_app_userCreateManyArgs>(args?: SelectSubset<T, todo_app_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_app_users and returns the data saved in the database.\n     * @param {todo_app_userCreateManyAndReturnArgs} args - Arguments to create many Todo_app_users.\n     * @example\n     * // Create many Todo_app_users\n     * const todo_app_user = await prisma.todo_app_user.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_app_users and only return the `id`\n     * const todo_app_userWithIdOnly = await prisma.todo_app_user.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_app_userCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_app_userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_userPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_app_user.\n     * @param {todo_app_userDeleteArgs} args - Arguments to delete one Todo_app_user.\n     * @example\n     * // Delete one Todo_app_user\n     * const Todo_app_user = await prisma.todo_app_user.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_app_user\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_app_userDeleteArgs>(args: SelectSubset<T, todo_app_userDeleteArgs<ExtArgs>>): Prisma__todo_app_userClient<$Result.GetResult<Prisma.$todo_app_userPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_app_user.\n     * @param {todo_app_userUpdateArgs} args - Arguments to update one Todo_app_user.\n     * @example\n     * // Update one Todo_app_user\n     * const todo_app_user = await prisma.todo_app_user.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_app_userUpdateArgs>(args: SelectSubset<T, todo_app_userUpdateArgs<ExtArgs>>): Prisma__todo_app_userClient<$Result.GetResult<Prisma.$todo_app_userPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_app_users.\n     * @param {todo_app_userDeleteManyArgs} args - Arguments to filter Todo_app_users to delete.\n     * @example\n     * // Delete a few Todo_app_users\n     * const { count } = await prisma.todo_app_user.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_app_userDeleteManyArgs>(args?: SelectSubset<T, todo_app_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_app_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_userUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_app_users\n     * const todo_app_user = await prisma.todo_app_user.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_app_userUpdateManyArgs>(args: SelectSubset<T, todo_app_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_app_users and returns the data updated in the database.\n     * @param {todo_app_userUpdateManyAndReturnArgs} args - Arguments to update many Todo_app_users.\n     * @example\n     * // Update many Todo_app_users\n     * const todo_app_user = await prisma.todo_app_user.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_app_users and only return the `id`\n     * const todo_app_userWithIdOnly = await prisma.todo_app_user.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_app_userUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_app_userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_userPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_app_user.\n     * @param {todo_app_userUpsertArgs} args - Arguments to update or create a Todo_app_user.\n     * @example\n     * // Update or create a Todo_app_user\n     * const todo_app_user = await prisma.todo_app_user.upsert({\n     *   create: {\n     *     // ... data to create a Todo_app_user\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_app_user we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_app_userUpsertArgs>(args: SelectSubset<T, todo_app_userUpsertArgs<ExtArgs>>): Prisma__todo_app_userClient<$Result.GetResult<Prisma.$todo_app_userPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_app_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_userCountArgs} args - Arguments to filter Todo_app_users to count.\n     * @example\n     * // Count the number of Todo_app_users\n     * const count = await prisma.todo_app_user.count({\n     *   where: {\n     *     // ... the filter for the Todo_app_users we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_app_userCountArgs>(\n      args?: Subset<T, todo_app_userCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_app_userCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_app_user.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_app_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_app_userAggregateArgs>(args: Subset<T, Todo_app_userAggregateArgs>): Prisma.PrismaPromise<GetTodo_app_userAggregateType<T>>\n\n    /**\n     * Group by Todo_app_user.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_userGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_app_userGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_app_userGroupByArgs['orderBy'] }\n        : { orderBy?: todo_app_userGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_app_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_app_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_app_user model\n   */\n  readonly fields: todo_app_userFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_app_user.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_app_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    todo_app_todos<T extends todo_app_user$todo_app_todosArgs<ExtArgs> = {}>(args?: Subset<T, todo_app_user$todo_app_todosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_todosPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    todo_app_audit_records<T extends todo_app_user$todo_app_audit_recordsArgs<ExtArgs> = {}>(args?: Subset<T, todo_app_user$todo_app_audit_recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_audit_recordsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_app_user model\n   */\n  interface todo_app_userFieldRefs {\n    readonly id: FieldRef<\"todo_app_user\", 'String'>\n    readonly email: FieldRef<\"todo_app_user\", 'String'>\n    readonly display_name: FieldRef<\"todo_app_user\", 'String'>\n    readonly password_hash: FieldRef<\"todo_app_user\", 'String'>\n    readonly account_status: FieldRef<\"todo_app_user\", 'String'>\n    readonly created_at: FieldRef<\"todo_app_user\", 'DateTime'>\n    readonly updated_at: FieldRef<\"todo_app_user\", 'DateTime'>\n    readonly last_active_at: FieldRef<\"todo_app_user\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_app_user findUnique\n   */\n  export type todo_app_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_user\n     */\n    select?: todo_app_userSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_user\n     */\n    omit?: todo_app_userOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_userInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_user to fetch.\n     */\n    where: todo_app_userWhereUniqueInput\n  }\n\n  /**\n   * todo_app_user findUniqueOrThrow\n   */\n  export type todo_app_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_user\n     */\n    select?: todo_app_userSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_user\n     */\n    omit?: todo_app_userOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_userInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_user to fetch.\n     */\n    where: todo_app_userWhereUniqueInput\n  }\n\n  /**\n   * todo_app_user findFirst\n   */\n  export type todo_app_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_user\n     */\n    select?: todo_app_userSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_user\n     */\n    omit?: todo_app_userOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_userInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_user to fetch.\n     */\n    where?: todo_app_userWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_users to fetch.\n     */\n    orderBy?: todo_app_userOrderByWithRelationInput | todo_app_userOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_app_users.\n     */\n    cursor?: todo_app_userWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_app_users.\n     */\n    distinct?: Todo_app_userScalarFieldEnum | Todo_app_userScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_user findFirstOrThrow\n   */\n  export type todo_app_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_user\n     */\n    select?: todo_app_userSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_user\n     */\n    omit?: todo_app_userOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_userInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_user to fetch.\n     */\n    where?: todo_app_userWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_users to fetch.\n     */\n    orderBy?: todo_app_userOrderByWithRelationInput | todo_app_userOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_app_users.\n     */\n    cursor?: todo_app_userWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_app_users.\n     */\n    distinct?: Todo_app_userScalarFieldEnum | Todo_app_userScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_user findMany\n   */\n  export type todo_app_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_user\n     */\n    select?: todo_app_userSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_user\n     */\n    omit?: todo_app_userOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_userInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_users to fetch.\n     */\n    where?: todo_app_userWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_users to fetch.\n     */\n    orderBy?: todo_app_userOrderByWithRelationInput | todo_app_userOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_app_users.\n     */\n    cursor?: todo_app_userWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_users.\n     */\n    skip?: number\n    distinct?: Todo_app_userScalarFieldEnum | Todo_app_userScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_user create\n   */\n  export type todo_app_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_user\n     */\n    select?: todo_app_userSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_user\n     */\n    omit?: todo_app_userOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_userInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_app_user.\n     */\n    data: XOR<todo_app_userCreateInput, todo_app_userUncheckedCreateInput>\n  }\n\n  /**\n   * todo_app_user createMany\n   */\n  export type todo_app_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_app_users.\n     */\n    data: todo_app_userCreateManyInput | todo_app_userCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_app_user createManyAndReturn\n   */\n  export type todo_app_userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_user\n     */\n    select?: todo_app_userSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_user\n     */\n    omit?: todo_app_userOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_app_users.\n     */\n    data: todo_app_userCreateManyInput | todo_app_userCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_app_user update\n   */\n  export type todo_app_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_user\n     */\n    select?: todo_app_userSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_user\n     */\n    omit?: todo_app_userOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_userInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_app_user.\n     */\n    data: XOR<todo_app_userUpdateInput, todo_app_userUncheckedUpdateInput>\n    /**\n     * Choose, which todo_app_user to update.\n     */\n    where: todo_app_userWhereUniqueInput\n  }\n\n  /**\n   * todo_app_user updateMany\n   */\n  export type todo_app_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_app_users.\n     */\n    data: XOR<todo_app_userUpdateManyMutationInput, todo_app_userUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_app_users to update\n     */\n    where?: todo_app_userWhereInput\n    /**\n     * Limit how many todo_app_users to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_user updateManyAndReturn\n   */\n  export type todo_app_userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_user\n     */\n    select?: todo_app_userSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_user\n     */\n    omit?: todo_app_userOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_app_users.\n     */\n    data: XOR<todo_app_userUpdateManyMutationInput, todo_app_userUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_app_users to update\n     */\n    where?: todo_app_userWhereInput\n    /**\n     * Limit how many todo_app_users to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_user upsert\n   */\n  export type todo_app_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_user\n     */\n    select?: todo_app_userSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_user\n     */\n    omit?: todo_app_userOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_userInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_app_user to update in case it exists.\n     */\n    where: todo_app_userWhereUniqueInput\n    /**\n     * In case the todo_app_user found by the `where` argument doesn't exist, create a new todo_app_user with this data.\n     */\n    create: XOR<todo_app_userCreateInput, todo_app_userUncheckedCreateInput>\n    /**\n     * In case the todo_app_user was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_app_userUpdateInput, todo_app_userUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_app_user delete\n   */\n  export type todo_app_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_user\n     */\n    select?: todo_app_userSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_user\n     */\n    omit?: todo_app_userOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_userInclude<ExtArgs> | null\n    /**\n     * Filter which todo_app_user to delete.\n     */\n    where: todo_app_userWhereUniqueInput\n  }\n\n  /**\n   * todo_app_user deleteMany\n   */\n  export type todo_app_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_app_users to delete\n     */\n    where?: todo_app_userWhereInput\n    /**\n     * Limit how many todo_app_users to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_user.todo_app_todos\n   */\n  export type todo_app_user$todo_app_todosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_todos\n     */\n    select?: todo_app_todosSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_todos\n     */\n    omit?: todo_app_todosOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_todosInclude<ExtArgs> | null\n    where?: todo_app_todosWhereInput\n    orderBy?: todo_app_todosOrderByWithRelationInput | todo_app_todosOrderByWithRelationInput[]\n    cursor?: todo_app_todosWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Todo_app_todosScalarFieldEnum | Todo_app_todosScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_user.todo_app_audit_records\n   */\n  export type todo_app_user$todo_app_audit_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_audit_records\n     */\n    select?: todo_app_audit_recordsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_audit_records\n     */\n    omit?: todo_app_audit_recordsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_audit_recordsInclude<ExtArgs> | null\n    where?: todo_app_audit_recordsWhereInput\n    orderBy?: todo_app_audit_recordsOrderByWithRelationInput | todo_app_audit_recordsOrderByWithRelationInput[]\n    cursor?: todo_app_audit_recordsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Todo_app_audit_recordsScalarFieldEnum | Todo_app_audit_recordsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_user without action\n   */\n  export type todo_app_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_user\n     */\n    select?: todo_app_userSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_user\n     */\n    omit?: todo_app_userOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_userInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model todo_app_admin\n   */\n\n  export type AggregateTodo_app_admin = {\n    _count: Todo_app_adminCountAggregateOutputType | null\n    _min: Todo_app_adminMinAggregateOutputType | null\n    _max: Todo_app_adminMaxAggregateOutputType | null\n  }\n\n  export type Todo_app_adminMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    is_super: boolean | null\n    created_at: Date | null\n    last_active_at: Date | null\n  }\n\n  export type Todo_app_adminMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    is_super: boolean | null\n    created_at: Date | null\n    last_active_at: Date | null\n  }\n\n  export type Todo_app_adminCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    is_super: number\n    created_at: number\n    last_active_at: number\n    _all: number\n  }\n\n\n  export type Todo_app_adminMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    is_super?: true\n    created_at?: true\n    last_active_at?: true\n  }\n\n  export type Todo_app_adminMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    is_super?: true\n    created_at?: true\n    last_active_at?: true\n  }\n\n  export type Todo_app_adminCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    is_super?: true\n    created_at?: true\n    last_active_at?: true\n    _all?: true\n  }\n\n  export type Todo_app_adminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_app_admin to aggregate.\n     */\n    where?: todo_app_adminWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_admins to fetch.\n     */\n    orderBy?: todo_app_adminOrderByWithRelationInput | todo_app_adminOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_app_adminWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_app_admins\n    **/\n    _count?: true | Todo_app_adminCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_app_adminMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_app_adminMaxAggregateInputType\n  }\n\n  export type GetTodo_app_adminAggregateType<T extends Todo_app_adminAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_app_admin]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_app_admin[P]>\n      : GetScalarType<T[P], AggregateTodo_app_admin[P]>\n  }\n\n\n\n\n  export type todo_app_adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_app_adminWhereInput\n    orderBy?: todo_app_adminOrderByWithAggregationInput | todo_app_adminOrderByWithAggregationInput[]\n    by: Todo_app_adminScalarFieldEnum[] | Todo_app_adminScalarFieldEnum\n    having?: todo_app_adminScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_app_adminCountAggregateInputType | true\n    _min?: Todo_app_adminMinAggregateInputType\n    _max?: Todo_app_adminMaxAggregateInputType\n  }\n\n  export type Todo_app_adminGroupByOutputType = {\n    id: string\n    email: string\n    password_hash: string | null\n    is_super: boolean\n    created_at: Date\n    last_active_at: Date | null\n    _count: Todo_app_adminCountAggregateOutputType | null\n    _min: Todo_app_adminMinAggregateOutputType | null\n    _max: Todo_app_adminMaxAggregateOutputType | null\n  }\n\n  type GetTodo_app_adminGroupByPayload<T extends todo_app_adminGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_app_adminGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_app_adminGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_app_adminGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_app_adminGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_app_adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    is_super?: boolean\n    created_at?: boolean\n    last_active_at?: boolean\n    todo_app_audit_records?: boolean | todo_app_admin$todo_app_audit_recordsArgs<ExtArgs>\n    _count?: boolean | Todo_app_adminCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_app_admin\"]>\n\n  export type todo_app_adminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    is_super?: boolean\n    created_at?: boolean\n    last_active_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_app_admin\"]>\n\n  export type todo_app_adminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    is_super?: boolean\n    created_at?: boolean\n    last_active_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_app_admin\"]>\n\n  export type todo_app_adminSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    is_super?: boolean\n    created_at?: boolean\n    last_active_at?: boolean\n  }\n\n  export type todo_app_adminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"is_super\" | \"created_at\" | \"last_active_at\", ExtArgs[\"result\"][\"todo_app_admin\"]>\n  export type todo_app_adminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_app_audit_records?: boolean | todo_app_admin$todo_app_audit_recordsArgs<ExtArgs>\n    _count?: boolean | Todo_app_adminCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type todo_app_adminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type todo_app_adminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $todo_app_adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_app_admin\"\n    objects: {\n      todo_app_audit_records: Prisma.$todo_app_audit_recordsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Admin account email used for login and notifications.\n       */\n      email: string\n      /**\n       * Password hash for admin authentication (nullable if external SSO used).\n       */\n      password_hash: string | null\n      /**\n       * Flag indicating super-admin privileges.\n       */\n      is_super: boolean\n      /**\n       * Admin account creation timestamp.\n       */\n      created_at: Date\n      /**\n       * Last activity timestamp for the admin (nullable).\n       */\n      last_active_at: Date | null\n    }, ExtArgs[\"result\"][\"todo_app_admin\"]>\n    composites: {}\n  }\n\n  type todo_app_adminGetPayload<S extends boolean | null | undefined | todo_app_adminDefaultArgs> = $Result.GetResult<Prisma.$todo_app_adminPayload, S>\n\n  type todo_app_adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_app_adminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_app_adminCountAggregateInputType | true\n    }\n\n  export interface todo_app_adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_app_admin'], meta: { name: 'todo_app_admin' } }\n    /**\n     * Find zero or one Todo_app_admin that matches the filter.\n     * @param {todo_app_adminFindUniqueArgs} args - Arguments to find a Todo_app_admin\n     * @example\n     * // Get one Todo_app_admin\n     * const todo_app_admin = await prisma.todo_app_admin.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_app_adminFindUniqueArgs>(args: SelectSubset<T, todo_app_adminFindUniqueArgs<ExtArgs>>): Prisma__todo_app_adminClient<$Result.GetResult<Prisma.$todo_app_adminPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_app_admin that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_app_adminFindUniqueOrThrowArgs} args - Arguments to find a Todo_app_admin\n     * @example\n     * // Get one Todo_app_admin\n     * const todo_app_admin = await prisma.todo_app_admin.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_app_adminFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_app_adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_app_adminClient<$Result.GetResult<Prisma.$todo_app_adminPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_app_admin that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_adminFindFirstArgs} args - Arguments to find a Todo_app_admin\n     * @example\n     * // Get one Todo_app_admin\n     * const todo_app_admin = await prisma.todo_app_admin.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_app_adminFindFirstArgs>(args?: SelectSubset<T, todo_app_adminFindFirstArgs<ExtArgs>>): Prisma__todo_app_adminClient<$Result.GetResult<Prisma.$todo_app_adminPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_app_admin that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_adminFindFirstOrThrowArgs} args - Arguments to find a Todo_app_admin\n     * @example\n     * // Get one Todo_app_admin\n     * const todo_app_admin = await prisma.todo_app_admin.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_app_adminFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_app_adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_app_adminClient<$Result.GetResult<Prisma.$todo_app_adminPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_app_admins that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_adminFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_app_admins\n     * const todo_app_admins = await prisma.todo_app_admin.findMany()\n     * \n     * // Get first 10 Todo_app_admins\n     * const todo_app_admins = await prisma.todo_app_admin.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_app_adminWithIdOnly = await prisma.todo_app_admin.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_app_adminFindManyArgs>(args?: SelectSubset<T, todo_app_adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_adminPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_app_admin.\n     * @param {todo_app_adminCreateArgs} args - Arguments to create a Todo_app_admin.\n     * @example\n     * // Create one Todo_app_admin\n     * const Todo_app_admin = await prisma.todo_app_admin.create({\n     *   data: {\n     *     // ... data to create a Todo_app_admin\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_app_adminCreateArgs>(args: SelectSubset<T, todo_app_adminCreateArgs<ExtArgs>>): Prisma__todo_app_adminClient<$Result.GetResult<Prisma.$todo_app_adminPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_app_admins.\n     * @param {todo_app_adminCreateManyArgs} args - Arguments to create many Todo_app_admins.\n     * @example\n     * // Create many Todo_app_admins\n     * const todo_app_admin = await prisma.todo_app_admin.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_app_adminCreateManyArgs>(args?: SelectSubset<T, todo_app_adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_app_admins and returns the data saved in the database.\n     * @param {todo_app_adminCreateManyAndReturnArgs} args - Arguments to create many Todo_app_admins.\n     * @example\n     * // Create many Todo_app_admins\n     * const todo_app_admin = await prisma.todo_app_admin.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_app_admins and only return the `id`\n     * const todo_app_adminWithIdOnly = await prisma.todo_app_admin.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_app_adminCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_app_adminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_adminPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_app_admin.\n     * @param {todo_app_adminDeleteArgs} args - Arguments to delete one Todo_app_admin.\n     * @example\n     * // Delete one Todo_app_admin\n     * const Todo_app_admin = await prisma.todo_app_admin.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_app_admin\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_app_adminDeleteArgs>(args: SelectSubset<T, todo_app_adminDeleteArgs<ExtArgs>>): Prisma__todo_app_adminClient<$Result.GetResult<Prisma.$todo_app_adminPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_app_admin.\n     * @param {todo_app_adminUpdateArgs} args - Arguments to update one Todo_app_admin.\n     * @example\n     * // Update one Todo_app_admin\n     * const todo_app_admin = await prisma.todo_app_admin.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_app_adminUpdateArgs>(args: SelectSubset<T, todo_app_adminUpdateArgs<ExtArgs>>): Prisma__todo_app_adminClient<$Result.GetResult<Prisma.$todo_app_adminPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_app_admins.\n     * @param {todo_app_adminDeleteManyArgs} args - Arguments to filter Todo_app_admins to delete.\n     * @example\n     * // Delete a few Todo_app_admins\n     * const { count } = await prisma.todo_app_admin.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_app_adminDeleteManyArgs>(args?: SelectSubset<T, todo_app_adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_app_admins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_adminUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_app_admins\n     * const todo_app_admin = await prisma.todo_app_admin.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_app_adminUpdateManyArgs>(args: SelectSubset<T, todo_app_adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_app_admins and returns the data updated in the database.\n     * @param {todo_app_adminUpdateManyAndReturnArgs} args - Arguments to update many Todo_app_admins.\n     * @example\n     * // Update many Todo_app_admins\n     * const todo_app_admin = await prisma.todo_app_admin.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_app_admins and only return the `id`\n     * const todo_app_adminWithIdOnly = await prisma.todo_app_admin.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_app_adminUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_app_adminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_adminPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_app_admin.\n     * @param {todo_app_adminUpsertArgs} args - Arguments to update or create a Todo_app_admin.\n     * @example\n     * // Update or create a Todo_app_admin\n     * const todo_app_admin = await prisma.todo_app_admin.upsert({\n     *   create: {\n     *     // ... data to create a Todo_app_admin\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_app_admin we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_app_adminUpsertArgs>(args: SelectSubset<T, todo_app_adminUpsertArgs<ExtArgs>>): Prisma__todo_app_adminClient<$Result.GetResult<Prisma.$todo_app_adminPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_app_admins.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_adminCountArgs} args - Arguments to filter Todo_app_admins to count.\n     * @example\n     * // Count the number of Todo_app_admins\n     * const count = await prisma.todo_app_admin.count({\n     *   where: {\n     *     // ... the filter for the Todo_app_admins we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_app_adminCountArgs>(\n      args?: Subset<T, todo_app_adminCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_app_adminCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_app_admin.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_app_adminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_app_adminAggregateArgs>(args: Subset<T, Todo_app_adminAggregateArgs>): Prisma.PrismaPromise<GetTodo_app_adminAggregateType<T>>\n\n    /**\n     * Group by Todo_app_admin.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_app_adminGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_app_adminGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_app_adminGroupByArgs['orderBy'] }\n        : { orderBy?: todo_app_adminGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_app_adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_app_adminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_app_admin model\n   */\n  readonly fields: todo_app_adminFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_app_admin.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_app_adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    todo_app_audit_records<T extends todo_app_admin$todo_app_audit_recordsArgs<ExtArgs> = {}>(args?: Subset<T, todo_app_admin$todo_app_audit_recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_app_audit_recordsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_app_admin model\n   */\n  interface todo_app_adminFieldRefs {\n    readonly id: FieldRef<\"todo_app_admin\", 'String'>\n    readonly email: FieldRef<\"todo_app_admin\", 'String'>\n    readonly password_hash: FieldRef<\"todo_app_admin\", 'String'>\n    readonly is_super: FieldRef<\"todo_app_admin\", 'Boolean'>\n    readonly created_at: FieldRef<\"todo_app_admin\", 'DateTime'>\n    readonly last_active_at: FieldRef<\"todo_app_admin\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_app_admin findUnique\n   */\n  export type todo_app_adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_admin\n     */\n    select?: todo_app_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_admin\n     */\n    omit?: todo_app_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_admin to fetch.\n     */\n    where: todo_app_adminWhereUniqueInput\n  }\n\n  /**\n   * todo_app_admin findUniqueOrThrow\n   */\n  export type todo_app_adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_admin\n     */\n    select?: todo_app_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_admin\n     */\n    omit?: todo_app_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_admin to fetch.\n     */\n    where: todo_app_adminWhereUniqueInput\n  }\n\n  /**\n   * todo_app_admin findFirst\n   */\n  export type todo_app_adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_admin\n     */\n    select?: todo_app_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_admin\n     */\n    omit?: todo_app_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_admin to fetch.\n     */\n    where?: todo_app_adminWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_admins to fetch.\n     */\n    orderBy?: todo_app_adminOrderByWithRelationInput | todo_app_adminOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_app_admins.\n     */\n    cursor?: todo_app_adminWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_app_admins.\n     */\n    distinct?: Todo_app_adminScalarFieldEnum | Todo_app_adminScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_admin findFirstOrThrow\n   */\n  export type todo_app_adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_admin\n     */\n    select?: todo_app_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_admin\n     */\n    omit?: todo_app_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_admin to fetch.\n     */\n    where?: todo_app_adminWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_admins to fetch.\n     */\n    orderBy?: todo_app_adminOrderByWithRelationInput | todo_app_adminOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_app_admins.\n     */\n    cursor?: todo_app_adminWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_admins.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_app_admins.\n     */\n    distinct?: Todo_app_adminScalarFieldEnum | Todo_app_adminScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_admin findMany\n   */\n  export type todo_app_adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_admin\n     */\n    select?: todo_app_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_admin\n     */\n    omit?: todo_app_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_adminInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_app_admins to fetch.\n     */\n    where?: todo_app_adminWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_app_admins to fetch.\n     */\n    orderBy?: todo_app_adminOrderByWithRelationInput | todo_app_adminOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_app_admins.\n     */\n    cursor?: todo_app_adminWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_app_admins from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_app_admins.\n     */\n    skip?: number\n    distinct?: Todo_app_adminScalarFieldEnum | Todo_app_adminScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_admin create\n   */\n  export type todo_app_adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_admin\n     */\n    select?: todo_app_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_admin\n     */\n    omit?: todo_app_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_adminInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_app_admin.\n     */\n    data: XOR<todo_app_adminCreateInput, todo_app_adminUncheckedCreateInput>\n  }\n\n  /**\n   * todo_app_admin createMany\n   */\n  export type todo_app_adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_app_admins.\n     */\n    data: todo_app_adminCreateManyInput | todo_app_adminCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_app_admin createManyAndReturn\n   */\n  export type todo_app_adminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_admin\n     */\n    select?: todo_app_adminSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_admin\n     */\n    omit?: todo_app_adminOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_app_admins.\n     */\n    data: todo_app_adminCreateManyInput | todo_app_adminCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_app_admin update\n   */\n  export type todo_app_adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_admin\n     */\n    select?: todo_app_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_admin\n     */\n    omit?: todo_app_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_adminInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_app_admin.\n     */\n    data: XOR<todo_app_adminUpdateInput, todo_app_adminUncheckedUpdateInput>\n    /**\n     * Choose, which todo_app_admin to update.\n     */\n    where: todo_app_adminWhereUniqueInput\n  }\n\n  /**\n   * todo_app_admin updateMany\n   */\n  export type todo_app_adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_app_admins.\n     */\n    data: XOR<todo_app_adminUpdateManyMutationInput, todo_app_adminUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_app_admins to update\n     */\n    where?: todo_app_adminWhereInput\n    /**\n     * Limit how many todo_app_admins to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_admin updateManyAndReturn\n   */\n  export type todo_app_adminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_admin\n     */\n    select?: todo_app_adminSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_admin\n     */\n    omit?: todo_app_adminOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_app_admins.\n     */\n    data: XOR<todo_app_adminUpdateManyMutationInput, todo_app_adminUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_app_admins to update\n     */\n    where?: todo_app_adminWhereInput\n    /**\n     * Limit how many todo_app_admins to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_admin upsert\n   */\n  export type todo_app_adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_admin\n     */\n    select?: todo_app_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_admin\n     */\n    omit?: todo_app_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_adminInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_app_admin to update in case it exists.\n     */\n    where: todo_app_adminWhereUniqueInput\n    /**\n     * In case the todo_app_admin found by the `where` argument doesn't exist, create a new todo_app_admin with this data.\n     */\n    create: XOR<todo_app_adminCreateInput, todo_app_adminUncheckedCreateInput>\n    /**\n     * In case the todo_app_admin was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_app_adminUpdateInput, todo_app_adminUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_app_admin delete\n   */\n  export type todo_app_adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_admin\n     */\n    select?: todo_app_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_admin\n     */\n    omit?: todo_app_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_adminInclude<ExtArgs> | null\n    /**\n     * Filter which todo_app_admin to delete.\n     */\n    where: todo_app_adminWhereUniqueInput\n  }\n\n  /**\n   * todo_app_admin deleteMany\n   */\n  export type todo_app_adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_app_admins to delete\n     */\n    where?: todo_app_adminWhereInput\n    /**\n     * Limit how many todo_app_admins to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_app_admin.todo_app_audit_records\n   */\n  export type todo_app_admin$todo_app_audit_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_audit_records\n     */\n    select?: todo_app_audit_recordsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_audit_records\n     */\n    omit?: todo_app_audit_recordsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_audit_recordsInclude<ExtArgs> | null\n    where?: todo_app_audit_recordsWhereInput\n    orderBy?: todo_app_audit_recordsOrderByWithRelationInput | todo_app_audit_recordsOrderByWithRelationInput[]\n    cursor?: todo_app_audit_recordsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Todo_app_audit_recordsScalarFieldEnum | Todo_app_audit_recordsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_app_admin without action\n   */\n  export type todo_app_adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_app_admin\n     */\n    select?: todo_app_adminSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_app_admin\n     */\n    omit?: todo_app_adminOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_app_adminInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Enums\n   */\n\n  export const TransactionIsolationLevel: {\n    ReadUncommitted: 'ReadUncommitted',\n    ReadCommitted: 'ReadCommitted',\n    RepeatableRead: 'RepeatableRead',\n    Serializable: 'Serializable'\n  };\n\n  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\n  export const Todo_app_todosScalarFieldEnum: {\n    id: 'id',\n    user_id: 'user_id',\n    title: 'title',\n    description: 'description',\n    is_completed: 'is_completed',\n    completed_at: 'completed_at',\n    position: 'position',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Todo_app_todosScalarFieldEnum = (typeof Todo_app_todosScalarFieldEnum)[keyof typeof Todo_app_todosScalarFieldEnum]\n\n\n  export const Todo_app_todo_snapshotsScalarFieldEnum: {\n    id: 'id',\n    todo_app_todo_id: 'todo_app_todo_id',\n    title: 'title',\n    description: 'description',\n    is_completed: 'is_completed',\n    completed_at: 'completed_at',\n    position: 'position',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at',\n    snapshot_at: 'snapshot_at'\n  };\n\n  export type Todo_app_todo_snapshotsScalarFieldEnum = (typeof Todo_app_todo_snapshotsScalarFieldEnum)[keyof typeof Todo_app_todo_snapshotsScalarFieldEnum]\n\n\n  export const Todo_app_audit_recordsScalarFieldEnum: {\n    id: 'id',\n    admin_id: 'admin_id',\n    user_id: 'user_id',\n    actor_role: 'actor_role',\n    action_type: 'action_type',\n    target_resource: 'target_resource',\n    target_id: 'target_id',\n    reason: 'reason',\n    created_at: 'created_at'\n  };\n\n  export type Todo_app_audit_recordsScalarFieldEnum = (typeof Todo_app_audit_recordsScalarFieldEnum)[keyof typeof Todo_app_audit_recordsScalarFieldEnum]\n\n\n  export const Todo_app_guestScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    created_at: 'created_at',\n    last_active_at: 'last_active_at',\n    status: 'status'\n  };\n\n  export type Todo_app_guestScalarFieldEnum = (typeof Todo_app_guestScalarFieldEnum)[keyof typeof Todo_app_guestScalarFieldEnum]\n\n\n  export const Todo_app_userScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    display_name: 'display_name',\n    password_hash: 'password_hash',\n    account_status: 'account_status',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    last_active_at: 'last_active_at'\n  };\n\n  export type Todo_app_userScalarFieldEnum = (typeof Todo_app_userScalarFieldEnum)[keyof typeof Todo_app_userScalarFieldEnum]\n\n\n  export const Todo_app_adminScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    is_super: 'is_super',\n    created_at: 'created_at',\n    last_active_at: 'last_active_at'\n  };\n\n  export type Todo_app_adminScalarFieldEnum = (typeof Todo_app_adminScalarFieldEnum)[keyof typeof Todo_app_adminScalarFieldEnum]\n\n\n  export const SortOrder: {\n    asc: 'asc',\n    desc: 'desc'\n  };\n\n  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\n  export const QueryMode: {\n    default: 'default',\n    insensitive: 'insensitive'\n  };\n\n  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\n  export const NullsOrder: {\n    first: 'first',\n    last: 'last'\n  };\n\n  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n  /**\n   * Field references\n   */\n\n\n  /**\n   * Reference to a field of type 'String'\n   */\n  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n  /**\n   * Reference to a field of type 'String[]'\n   */\n  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Boolean'\n   */\n  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime'\n   */\n  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime[]'\n   */\n  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int'\n   */\n  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int[]'\n   */\n  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Float'\n   */\n  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>\n    \n\n\n  /**\n   * Reference to a field of type 'Float[]'\n   */\n  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>\n    \n  /**\n   * Deep Input Types\n   */\n\n\n  export type todo_app_todosWhereInput = {\n    AND?: todo_app_todosWhereInput | todo_app_todosWhereInput[]\n    OR?: todo_app_todosWhereInput[]\n    NOT?: todo_app_todosWhereInput | todo_app_todosWhereInput[]\n    id?: UuidFilter<\"todo_app_todos\"> | string\n    user_id?: UuidFilter<\"todo_app_todos\"> | string\n    title?: StringFilter<\"todo_app_todos\"> | string\n    description?: StringNullableFilter<\"todo_app_todos\"> | string | null\n    is_completed?: BoolFilter<\"todo_app_todos\"> | boolean\n    completed_at?: DateTimeNullableFilter<\"todo_app_todos\"> | Date | string | null\n    position?: IntNullableFilter<\"todo_app_todos\"> | number | null\n    created_at?: DateTimeFilter<\"todo_app_todos\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_app_todos\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"todo_app_todos\"> | Date | string | null\n    user?: XOR<Todo_app_userScalarRelationFilter, todo_app_userWhereInput>\n    todo_app_todo_snapshots?: Todo_app_todo_snapshotsListRelationFilter\n  }\n\n  export type todo_app_todosOrderByWithRelationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrderInput | SortOrder\n    is_completed?: SortOrder\n    completed_at?: SortOrderInput | SortOrder\n    position?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    user?: todo_app_userOrderByWithRelationInput\n    todo_app_todo_snapshots?: todo_app_todo_snapshotsOrderByRelationAggregateInput\n  }\n\n  export type todo_app_todosWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: todo_app_todosWhereInput | todo_app_todosWhereInput[]\n    OR?: todo_app_todosWhereInput[]\n    NOT?: todo_app_todosWhereInput | todo_app_todosWhereInput[]\n    user_id?: UuidFilter<\"todo_app_todos\"> | string\n    title?: StringFilter<\"todo_app_todos\"> | string\n    description?: StringNullableFilter<\"todo_app_todos\"> | string | null\n    is_completed?: BoolFilter<\"todo_app_todos\"> | boolean\n    completed_at?: DateTimeNullableFilter<\"todo_app_todos\"> | Date | string | null\n    position?: IntNullableFilter<\"todo_app_todos\"> | number | null\n    created_at?: DateTimeFilter<\"todo_app_todos\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_app_todos\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"todo_app_todos\"> | Date | string | null\n    user?: XOR<Todo_app_userScalarRelationFilter, todo_app_userWhereInput>\n    todo_app_todo_snapshots?: Todo_app_todo_snapshotsListRelationFilter\n  }, \"id\">\n\n  export type todo_app_todosOrderByWithAggregationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrderInput | SortOrder\n    is_completed?: SortOrder\n    completed_at?: SortOrderInput | SortOrder\n    position?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: todo_app_todosCountOrderByAggregateInput\n    _avg?: todo_app_todosAvgOrderByAggregateInput\n    _max?: todo_app_todosMaxOrderByAggregateInput\n    _min?: todo_app_todosMinOrderByAggregateInput\n    _sum?: todo_app_todosSumOrderByAggregateInput\n  }\n\n  export type todo_app_todosScalarWhereWithAggregatesInput = {\n    AND?: todo_app_todosScalarWhereWithAggregatesInput | todo_app_todosScalarWhereWithAggregatesInput[]\n    OR?: todo_app_todosScalarWhereWithAggregatesInput[]\n    NOT?: todo_app_todosScalarWhereWithAggregatesInput | todo_app_todosScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_app_todos\"> | string\n    user_id?: UuidWithAggregatesFilter<\"todo_app_todos\"> | string\n    title?: StringWithAggregatesFilter<\"todo_app_todos\"> | string\n    description?: StringNullableWithAggregatesFilter<\"todo_app_todos\"> | string | null\n    is_completed?: BoolWithAggregatesFilter<\"todo_app_todos\"> | boolean\n    completed_at?: DateTimeNullableWithAggregatesFilter<\"todo_app_todos\"> | Date | string | null\n    position?: IntNullableWithAggregatesFilter<\"todo_app_todos\"> | number | null\n    created_at?: DateTimeWithAggregatesFilter<\"todo_app_todos\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"todo_app_todos\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"todo_app_todos\"> | Date | string | null\n  }\n\n  export type todo_app_todo_snapshotsWhereInput = {\n    AND?: todo_app_todo_snapshotsWhereInput | todo_app_todo_snapshotsWhereInput[]\n    OR?: todo_app_todo_snapshotsWhereInput[]\n    NOT?: todo_app_todo_snapshotsWhereInput | todo_app_todo_snapshotsWhereInput[]\n    id?: UuidFilter<\"todo_app_todo_snapshots\"> | string\n    todo_app_todo_id?: UuidFilter<\"todo_app_todo_snapshots\"> | string\n    title?: StringFilter<\"todo_app_todo_snapshots\"> | string\n    description?: StringNullableFilter<\"todo_app_todo_snapshots\"> | string | null\n    is_completed?: BoolFilter<\"todo_app_todo_snapshots\"> | boolean\n    completed_at?: DateTimeNullableFilter<\"todo_app_todo_snapshots\"> | Date | string | null\n    position?: IntNullableFilter<\"todo_app_todo_snapshots\"> | number | null\n    created_at?: DateTimeFilter<\"todo_app_todo_snapshots\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_app_todo_snapshots\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"todo_app_todo_snapshots\"> | Date | string | null\n    snapshot_at?: DateTimeFilter<\"todo_app_todo_snapshots\"> | Date | string\n    todo?: XOR<Todo_app_todosScalarRelationFilter, todo_app_todosWhereInput>\n  }\n\n  export type todo_app_todo_snapshotsOrderByWithRelationInput = {\n    id?: SortOrder\n    todo_app_todo_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrderInput | SortOrder\n    is_completed?: SortOrder\n    completed_at?: SortOrderInput | SortOrder\n    position?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    snapshot_at?: SortOrder\n    todo?: todo_app_todosOrderByWithRelationInput\n  }\n\n  export type todo_app_todo_snapshotsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: todo_app_todo_snapshotsWhereInput | todo_app_todo_snapshotsWhereInput[]\n    OR?: todo_app_todo_snapshotsWhereInput[]\n    NOT?: todo_app_todo_snapshotsWhereInput | todo_app_todo_snapshotsWhereInput[]\n    todo_app_todo_id?: UuidFilter<\"todo_app_todo_snapshots\"> | string\n    title?: StringFilter<\"todo_app_todo_snapshots\"> | string\n    description?: StringNullableFilter<\"todo_app_todo_snapshots\"> | string | null\n    is_completed?: BoolFilter<\"todo_app_todo_snapshots\"> | boolean\n    completed_at?: DateTimeNullableFilter<\"todo_app_todo_snapshots\"> | Date | string | null\n    position?: IntNullableFilter<\"todo_app_todo_snapshots\"> | number | null\n    created_at?: DateTimeFilter<\"todo_app_todo_snapshots\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_app_todo_snapshots\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"todo_app_todo_snapshots\"> | Date | string | null\n    snapshot_at?: DateTimeFilter<\"todo_app_todo_snapshots\"> | Date | string\n    todo?: XOR<Todo_app_todosScalarRelationFilter, todo_app_todosWhereInput>\n  }, \"id\">\n\n  export type todo_app_todo_snapshotsOrderByWithAggregationInput = {\n    id?: SortOrder\n    todo_app_todo_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrderInput | SortOrder\n    is_completed?: SortOrder\n    completed_at?: SortOrderInput | SortOrder\n    position?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    snapshot_at?: SortOrder\n    _count?: todo_app_todo_snapshotsCountOrderByAggregateInput\n    _avg?: todo_app_todo_snapshotsAvgOrderByAggregateInput\n    _max?: todo_app_todo_snapshotsMaxOrderByAggregateInput\n    _min?: todo_app_todo_snapshotsMinOrderByAggregateInput\n    _sum?: todo_app_todo_snapshotsSumOrderByAggregateInput\n  }\n\n  export type todo_app_todo_snapshotsScalarWhereWithAggregatesInput = {\n    AND?: todo_app_todo_snapshotsScalarWhereWithAggregatesInput | todo_app_todo_snapshotsScalarWhereWithAggregatesInput[]\n    OR?: todo_app_todo_snapshotsScalarWhereWithAggregatesInput[]\n    NOT?: todo_app_todo_snapshotsScalarWhereWithAggregatesInput | todo_app_todo_snapshotsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_app_todo_snapshots\"> | string\n    todo_app_todo_id?: UuidWithAggregatesFilter<\"todo_app_todo_snapshots\"> | string\n    title?: StringWithAggregatesFilter<\"todo_app_todo_snapshots\"> | string\n    description?: StringNullableWithAggregatesFilter<\"todo_app_todo_snapshots\"> | string | null\n    is_completed?: BoolWithAggregatesFilter<\"todo_app_todo_snapshots\"> | boolean\n    completed_at?: DateTimeNullableWithAggregatesFilter<\"todo_app_todo_snapshots\"> | Date | string | null\n    position?: IntNullableWithAggregatesFilter<\"todo_app_todo_snapshots\"> | number | null\n    created_at?: DateTimeWithAggregatesFilter<\"todo_app_todo_snapshots\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"todo_app_todo_snapshots\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"todo_app_todo_snapshots\"> | Date | string | null\n    snapshot_at?: DateTimeWithAggregatesFilter<\"todo_app_todo_snapshots\"> | Date | string\n  }\n\n  export type todo_app_audit_recordsWhereInput = {\n    AND?: todo_app_audit_recordsWhereInput | todo_app_audit_recordsWhereInput[]\n    OR?: todo_app_audit_recordsWhereInput[]\n    NOT?: todo_app_audit_recordsWhereInput | todo_app_audit_recordsWhereInput[]\n    id?: UuidFilter<\"todo_app_audit_records\"> | string\n    admin_id?: UuidNullableFilter<\"todo_app_audit_records\"> | string | null\n    user_id?: UuidNullableFilter<\"todo_app_audit_records\"> | string | null\n    actor_role?: StringFilter<\"todo_app_audit_records\"> | string\n    action_type?: StringFilter<\"todo_app_audit_records\"> | string\n    target_resource?: StringFilter<\"todo_app_audit_records\"> | string\n    target_id?: UuidNullableFilter<\"todo_app_audit_records\"> | string | null\n    reason?: StringNullableFilter<\"todo_app_audit_records\"> | string | null\n    created_at?: DateTimeFilter<\"todo_app_audit_records\"> | Date | string\n    admin?: XOR<Todo_app_adminNullableScalarRelationFilter, todo_app_adminWhereInput> | null\n    user?: XOR<Todo_app_userNullableScalarRelationFilter, todo_app_userWhereInput> | null\n  }\n\n  export type todo_app_audit_recordsOrderByWithRelationInput = {\n    id?: SortOrder\n    admin_id?: SortOrderInput | SortOrder\n    user_id?: SortOrderInput | SortOrder\n    actor_role?: SortOrder\n    action_type?: SortOrder\n    target_resource?: SortOrder\n    target_id?: SortOrderInput | SortOrder\n    reason?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    admin?: todo_app_adminOrderByWithRelationInput\n    user?: todo_app_userOrderByWithRelationInput\n  }\n\n  export type todo_app_audit_recordsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: todo_app_audit_recordsWhereInput | todo_app_audit_recordsWhereInput[]\n    OR?: todo_app_audit_recordsWhereInput[]\n    NOT?: todo_app_audit_recordsWhereInput | todo_app_audit_recordsWhereInput[]\n    admin_id?: UuidNullableFilter<\"todo_app_audit_records\"> | string | null\n    user_id?: UuidNullableFilter<\"todo_app_audit_records\"> | string | null\n    actor_role?: StringFilter<\"todo_app_audit_records\"> | string\n    action_type?: StringFilter<\"todo_app_audit_records\"> | string\n    target_resource?: StringFilter<\"todo_app_audit_records\"> | string\n    target_id?: UuidNullableFilter<\"todo_app_audit_records\"> | string | null\n    reason?: StringNullableFilter<\"todo_app_audit_records\"> | string | null\n    created_at?: DateTimeFilter<\"todo_app_audit_records\"> | Date | string\n    admin?: XOR<Todo_app_adminNullableScalarRelationFilter, todo_app_adminWhereInput> | null\n    user?: XOR<Todo_app_userNullableScalarRelationFilter, todo_app_userWhereInput> | null\n  }, \"id\">\n\n  export type todo_app_audit_recordsOrderByWithAggregationInput = {\n    id?: SortOrder\n    admin_id?: SortOrderInput | SortOrder\n    user_id?: SortOrderInput | SortOrder\n    actor_role?: SortOrder\n    action_type?: SortOrder\n    target_resource?: SortOrder\n    target_id?: SortOrderInput | SortOrder\n    reason?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    _count?: todo_app_audit_recordsCountOrderByAggregateInput\n    _max?: todo_app_audit_recordsMaxOrderByAggregateInput\n    _min?: todo_app_audit_recordsMinOrderByAggregateInput\n  }\n\n  export type todo_app_audit_recordsScalarWhereWithAggregatesInput = {\n    AND?: todo_app_audit_recordsScalarWhereWithAggregatesInput | todo_app_audit_recordsScalarWhereWithAggregatesInput[]\n    OR?: todo_app_audit_recordsScalarWhereWithAggregatesInput[]\n    NOT?: todo_app_audit_recordsScalarWhereWithAggregatesInput | todo_app_audit_recordsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_app_audit_records\"> | string\n    admin_id?: UuidNullableWithAggregatesFilter<\"todo_app_audit_records\"> | string | null\n    user_id?: UuidNullableWithAggregatesFilter<\"todo_app_audit_records\"> | string | null\n    actor_role?: StringWithAggregatesFilter<\"todo_app_audit_records\"> | string\n    action_type?: StringWithAggregatesFilter<\"todo_app_audit_records\"> | string\n    target_resource?: StringWithAggregatesFilter<\"todo_app_audit_records\"> | string\n    target_id?: UuidNullableWithAggregatesFilter<\"todo_app_audit_records\"> | string | null\n    reason?: StringNullableWithAggregatesFilter<\"todo_app_audit_records\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"todo_app_audit_records\"> | Date | string\n  }\n\n  export type todo_app_guestWhereInput = {\n    AND?: todo_app_guestWhereInput | todo_app_guestWhereInput[]\n    OR?: todo_app_guestWhereInput[]\n    NOT?: todo_app_guestWhereInput | todo_app_guestWhereInput[]\n    id?: UuidFilter<\"todo_app_guest\"> | string\n    email?: StringNullableFilter<\"todo_app_guest\"> | string | null\n    created_at?: DateTimeFilter<\"todo_app_guest\"> | Date | string\n    last_active_at?: DateTimeNullableFilter<\"todo_app_guest\"> | Date | string | null\n    status?: StringNullableFilter<\"todo_app_guest\"> | string | null\n  }\n\n  export type todo_app_guestOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    last_active_at?: SortOrderInput | SortOrder\n    status?: SortOrderInput | SortOrder\n  }\n\n  export type todo_app_guestWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: todo_app_guestWhereInput | todo_app_guestWhereInput[]\n    OR?: todo_app_guestWhereInput[]\n    NOT?: todo_app_guestWhereInput | todo_app_guestWhereInput[]\n    email?: StringNullableFilter<\"todo_app_guest\"> | string | null\n    created_at?: DateTimeFilter<\"todo_app_guest\"> | Date | string\n    last_active_at?: DateTimeNullableFilter<\"todo_app_guest\"> | Date | string | null\n    status?: StringNullableFilter<\"todo_app_guest\"> | string | null\n  }, \"id\">\n\n  export type todo_app_guestOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    last_active_at?: SortOrderInput | SortOrder\n    status?: SortOrderInput | SortOrder\n    _count?: todo_app_guestCountOrderByAggregateInput\n    _max?: todo_app_guestMaxOrderByAggregateInput\n    _min?: todo_app_guestMinOrderByAggregateInput\n  }\n\n  export type todo_app_guestScalarWhereWithAggregatesInput = {\n    AND?: todo_app_guestScalarWhereWithAggregatesInput | todo_app_guestScalarWhereWithAggregatesInput[]\n    OR?: todo_app_guestScalarWhereWithAggregatesInput[]\n    NOT?: todo_app_guestScalarWhereWithAggregatesInput | todo_app_guestScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_app_guest\"> | string\n    email?: StringNullableWithAggregatesFilter<\"todo_app_guest\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"todo_app_guest\"> | Date | string\n    last_active_at?: DateTimeNullableWithAggregatesFilter<\"todo_app_guest\"> | Date | string | null\n    status?: StringNullableWithAggregatesFilter<\"todo_app_guest\"> | string | null\n  }\n\n  export type todo_app_userWhereInput = {\n    AND?: todo_app_userWhereInput | todo_app_userWhereInput[]\n    OR?: todo_app_userWhereInput[]\n    NOT?: todo_app_userWhereInput | todo_app_userWhereInput[]\n    id?: UuidFilter<\"todo_app_user\"> | string\n    email?: StringFilter<\"todo_app_user\"> | string\n    display_name?: StringNullableFilter<\"todo_app_user\"> | string | null\n    password_hash?: StringNullableFilter<\"todo_app_user\"> | string | null\n    account_status?: StringFilter<\"todo_app_user\"> | string\n    created_at?: DateTimeFilter<\"todo_app_user\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_app_user\"> | Date | string\n    last_active_at?: DateTimeNullableFilter<\"todo_app_user\"> | Date | string | null\n    todo_app_todos?: Todo_app_todosListRelationFilter\n    todo_app_audit_records?: Todo_app_audit_recordsListRelationFilter\n  }\n\n  export type todo_app_userOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    display_name?: SortOrderInput | SortOrder\n    password_hash?: SortOrderInput | SortOrder\n    account_status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    last_active_at?: SortOrderInput | SortOrder\n    todo_app_todos?: todo_app_todosOrderByRelationAggregateInput\n    todo_app_audit_records?: todo_app_audit_recordsOrderByRelationAggregateInput\n  }\n\n  export type todo_app_userWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: todo_app_userWhereInput | todo_app_userWhereInput[]\n    OR?: todo_app_userWhereInput[]\n    NOT?: todo_app_userWhereInput | todo_app_userWhereInput[]\n    display_name?: StringNullableFilter<\"todo_app_user\"> | string | null\n    password_hash?: StringNullableFilter<\"todo_app_user\"> | string | null\n    account_status?: StringFilter<\"todo_app_user\"> | string\n    created_at?: DateTimeFilter<\"todo_app_user\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_app_user\"> | Date | string\n    last_active_at?: DateTimeNullableFilter<\"todo_app_user\"> | Date | string | null\n    todo_app_todos?: Todo_app_todosListRelationFilter\n    todo_app_audit_records?: Todo_app_audit_recordsListRelationFilter\n  }, \"id\" | \"email\">\n\n  export type todo_app_userOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    display_name?: SortOrderInput | SortOrder\n    password_hash?: SortOrderInput | SortOrder\n    account_status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    last_active_at?: SortOrderInput | SortOrder\n    _count?: todo_app_userCountOrderByAggregateInput\n    _max?: todo_app_userMaxOrderByAggregateInput\n    _min?: todo_app_userMinOrderByAggregateInput\n  }\n\n  export type todo_app_userScalarWhereWithAggregatesInput = {\n    AND?: todo_app_userScalarWhereWithAggregatesInput | todo_app_userScalarWhereWithAggregatesInput[]\n    OR?: todo_app_userScalarWhereWithAggregatesInput[]\n    NOT?: todo_app_userScalarWhereWithAggregatesInput | todo_app_userScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_app_user\"> | string\n    email?: StringWithAggregatesFilter<\"todo_app_user\"> | string\n    display_name?: StringNullableWithAggregatesFilter<\"todo_app_user\"> | string | null\n    password_hash?: StringNullableWithAggregatesFilter<\"todo_app_user\"> | string | null\n    account_status?: StringWithAggregatesFilter<\"todo_app_user\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"todo_app_user\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"todo_app_user\"> | Date | string\n    last_active_at?: DateTimeNullableWithAggregatesFilter<\"todo_app_user\"> | Date | string | null\n  }\n\n  export type todo_app_adminWhereInput = {\n    AND?: todo_app_adminWhereInput | todo_app_adminWhereInput[]\n    OR?: todo_app_adminWhereInput[]\n    NOT?: todo_app_adminWhereInput | todo_app_adminWhereInput[]\n    id?: UuidFilter<\"todo_app_admin\"> | string\n    email?: StringFilter<\"todo_app_admin\"> | string\n    password_hash?: StringNullableFilter<\"todo_app_admin\"> | string | null\n    is_super?: BoolFilter<\"todo_app_admin\"> | boolean\n    created_at?: DateTimeFilter<\"todo_app_admin\"> | Date | string\n    last_active_at?: DateTimeNullableFilter<\"todo_app_admin\"> | Date | string | null\n    todo_app_audit_records?: Todo_app_audit_recordsListRelationFilter\n  }\n\n  export type todo_app_adminOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrderInput | SortOrder\n    is_super?: SortOrder\n    created_at?: SortOrder\n    last_active_at?: SortOrderInput | SortOrder\n    todo_app_audit_records?: todo_app_audit_recordsOrderByRelationAggregateInput\n  }\n\n  export type todo_app_adminWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: todo_app_adminWhereInput | todo_app_adminWhereInput[]\n    OR?: todo_app_adminWhereInput[]\n    NOT?: todo_app_adminWhereInput | todo_app_adminWhereInput[]\n    password_hash?: StringNullableFilter<\"todo_app_admin\"> | string | null\n    is_super?: BoolFilter<\"todo_app_admin\"> | boolean\n    created_at?: DateTimeFilter<\"todo_app_admin\"> | Date | string\n    last_active_at?: DateTimeNullableFilter<\"todo_app_admin\"> | Date | string | null\n    todo_app_audit_records?: Todo_app_audit_recordsListRelationFilter\n  }, \"id\" | \"email\">\n\n  export type todo_app_adminOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrderInput | SortOrder\n    is_super?: SortOrder\n    created_at?: SortOrder\n    last_active_at?: SortOrderInput | SortOrder\n    _count?: todo_app_adminCountOrderByAggregateInput\n    _max?: todo_app_adminMaxOrderByAggregateInput\n    _min?: todo_app_adminMinOrderByAggregateInput\n  }\n\n  export type todo_app_adminScalarWhereWithAggregatesInput = {\n    AND?: todo_app_adminScalarWhereWithAggregatesInput | todo_app_adminScalarWhereWithAggregatesInput[]\n    OR?: todo_app_adminScalarWhereWithAggregatesInput[]\n    NOT?: todo_app_adminScalarWhereWithAggregatesInput | todo_app_adminScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_app_admin\"> | string\n    email?: StringWithAggregatesFilter<\"todo_app_admin\"> | string\n    password_hash?: StringNullableWithAggregatesFilter<\"todo_app_admin\"> | string | null\n    is_super?: BoolWithAggregatesFilter<\"todo_app_admin\"> | boolean\n    created_at?: DateTimeWithAggregatesFilter<\"todo_app_admin\"> | Date | string\n    last_active_at?: DateTimeNullableWithAggregatesFilter<\"todo_app_admin\"> | Date | string | null\n  }\n\n  export type todo_app_todosCreateInput = {\n    id: string\n    title: string\n    description?: string | null\n    is_completed: boolean\n    completed_at?: Date | string | null\n    position?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    user: todo_app_userCreateNestedOneWithoutTodo_app_todosInput\n    todo_app_todo_snapshots?: todo_app_todo_snapshotsCreateNestedManyWithoutTodoInput\n  }\n\n  export type todo_app_todosUncheckedCreateInput = {\n    id: string\n    user_id: string\n    title: string\n    description?: string | null\n    is_completed: boolean\n    completed_at?: Date | string | null\n    position?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    todo_app_todo_snapshots?: todo_app_todo_snapshotsUncheckedCreateNestedManyWithoutTodoInput\n  }\n\n  export type todo_app_todosUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    user?: todo_app_userUpdateOneRequiredWithoutTodo_app_todosNestedInput\n    todo_app_todo_snapshots?: todo_app_todo_snapshotsUpdateManyWithoutTodoNestedInput\n  }\n\n  export type todo_app_todosUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_app_todo_snapshots?: todo_app_todo_snapshotsUncheckedUpdateManyWithoutTodoNestedInput\n  }\n\n  export type todo_app_todosCreateManyInput = {\n    id: string\n    user_id: string\n    title: string\n    description?: string | null\n    is_completed: boolean\n    completed_at?: Date | string | null\n    position?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_app_todosUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_app_todosUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_app_todo_snapshotsCreateInput = {\n    id: string\n    title: string\n    description?: string | null\n    is_completed: boolean\n    completed_at?: Date | string | null\n    position?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    snapshot_at: Date | string\n    todo: todo_app_todosCreateNestedOneWithoutTodo_app_todo_snapshotsInput\n  }\n\n  export type todo_app_todo_snapshotsUncheckedCreateInput = {\n    id: string\n    todo_app_todo_id: string\n    title: string\n    description?: string | null\n    is_completed: boolean\n    completed_at?: Date | string | null\n    position?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    snapshot_at: Date | string\n  }\n\n  export type todo_app_todo_snapshotsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    snapshot_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    todo?: todo_app_todosUpdateOneRequiredWithoutTodo_app_todo_snapshotsNestedInput\n  }\n\n  export type todo_app_todo_snapshotsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_app_todo_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    snapshot_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_app_todo_snapshotsCreateManyInput = {\n    id: string\n    todo_app_todo_id: string\n    title: string\n    description?: string | null\n    is_completed: boolean\n    completed_at?: Date | string | null\n    position?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    snapshot_at: Date | string\n  }\n\n  export type todo_app_todo_snapshotsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    snapshot_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_app_todo_snapshotsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_app_todo_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    snapshot_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_app_audit_recordsCreateInput = {\n    id: string\n    actor_role: string\n    action_type: string\n    target_resource: string\n    target_id?: string | null\n    reason?: string | null\n    created_at: Date | string\n    admin?: todo_app_adminCreateNestedOneWithoutTodo_app_audit_recordsInput\n    user?: todo_app_userCreateNestedOneWithoutTodo_app_audit_recordsInput\n  }\n\n  export type todo_app_audit_recordsUncheckedCreateInput = {\n    id: string\n    admin_id?: string | null\n    user_id?: string | null\n    actor_role: string\n    action_type: string\n    target_resource: string\n    target_id?: string | null\n    reason?: string | null\n    created_at: Date | string\n  }\n\n  export type todo_app_audit_recordsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    actor_role?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    target_resource?: StringFieldUpdateOperationsInput | string\n    target_id?: NullableStringFieldUpdateOperationsInput | string | null\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    admin?: todo_app_adminUpdateOneWithoutTodo_app_audit_recordsNestedInput\n    user?: todo_app_userUpdateOneWithoutTodo_app_audit_recordsNestedInput\n  }\n\n  export type todo_app_audit_recordsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    admin_id?: NullableStringFieldUpdateOperationsInput | string | null\n    user_id?: NullableStringFieldUpdateOperationsInput | string | null\n    actor_role?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    target_resource?: StringFieldUpdateOperationsInput | string\n    target_id?: NullableStringFieldUpdateOperationsInput | string | null\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_app_audit_recordsCreateManyInput = {\n    id: string\n    admin_id?: string | null\n    user_id?: string | null\n    actor_role: string\n    action_type: string\n    target_resource: string\n    target_id?: string | null\n    reason?: string | null\n    created_at: Date | string\n  }\n\n  export type todo_app_audit_recordsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    actor_role?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    target_resource?: StringFieldUpdateOperationsInput | string\n    target_id?: NullableStringFieldUpdateOperationsInput | string | null\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_app_audit_recordsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    admin_id?: NullableStringFieldUpdateOperationsInput | string | null\n    user_id?: NullableStringFieldUpdateOperationsInput | string | null\n    actor_role?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    target_resource?: StringFieldUpdateOperationsInput | string\n    target_id?: NullableStringFieldUpdateOperationsInput | string | null\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_app_guestCreateInput = {\n    id: string\n    email?: string | null\n    created_at: Date | string\n    last_active_at?: Date | string | null\n    status?: string | null\n  }\n\n  export type todo_app_guestUncheckedCreateInput = {\n    id: string\n    email?: string | null\n    created_at: Date | string\n    last_active_at?: Date | string | null\n    status?: string | null\n  }\n\n  export type todo_app_guestUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type todo_app_guestUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type todo_app_guestCreateManyInput = {\n    id: string\n    email?: string | null\n    created_at: Date | string\n    last_active_at?: Date | string | null\n    status?: string | null\n  }\n\n  export type todo_app_guestUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type todo_app_guestUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    status?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type todo_app_userCreateInput = {\n    id: string\n    email: string\n    display_name?: string | null\n    password_hash?: string | null\n    account_status: string\n    created_at: Date | string\n    updated_at: Date | string\n    last_active_at?: Date | string | null\n    todo_app_todos?: todo_app_todosCreateNestedManyWithoutUserInput\n    todo_app_audit_records?: todo_app_audit_recordsCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_app_userUncheckedCreateInput = {\n    id: string\n    email: string\n    display_name?: string | null\n    password_hash?: string | null\n    account_status: string\n    created_at: Date | string\n    updated_at: Date | string\n    last_active_at?: Date | string | null\n    todo_app_todos?: todo_app_todosUncheckedCreateNestedManyWithoutUserInput\n    todo_app_audit_records?: todo_app_audit_recordsUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_app_userUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    display_name?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    account_status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_app_todos?: todo_app_todosUpdateManyWithoutUserNestedInput\n    todo_app_audit_records?: todo_app_audit_recordsUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_app_userUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    display_name?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    account_status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_app_todos?: todo_app_todosUncheckedUpdateManyWithoutUserNestedInput\n    todo_app_audit_records?: todo_app_audit_recordsUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_app_userCreateManyInput = {\n    id: string\n    email: string\n    display_name?: string | null\n    password_hash?: string | null\n    account_status: string\n    created_at: Date | string\n    updated_at: Date | string\n    last_active_at?: Date | string | null\n  }\n\n  export type todo_app_userUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    display_name?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    account_status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_app_userUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    display_name?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    account_status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_app_adminCreateInput = {\n    id: string\n    email: string\n    password_hash?: string | null\n    is_super: boolean\n    created_at: Date | string\n    last_active_at?: Date | string | null\n    todo_app_audit_records?: todo_app_audit_recordsCreateNestedManyWithoutAdminInput\n  }\n\n  export type todo_app_adminUncheckedCreateInput = {\n    id: string\n    email: string\n    password_hash?: string | null\n    is_super: boolean\n    created_at: Date | string\n    last_active_at?: Date | string | null\n    todo_app_audit_records?: todo_app_audit_recordsUncheckedCreateNestedManyWithoutAdminInput\n  }\n\n  export type todo_app_adminUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    is_super?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_app_audit_records?: todo_app_audit_recordsUpdateManyWithoutAdminNestedInput\n  }\n\n  export type todo_app_adminUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    is_super?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_app_audit_records?: todo_app_audit_recordsUncheckedUpdateManyWithoutAdminNestedInput\n  }\n\n  export type todo_app_adminCreateManyInput = {\n    id: string\n    email: string\n    password_hash?: string | null\n    is_super: boolean\n    created_at: Date | string\n    last_active_at?: Date | string | null\n  }\n\n  export type todo_app_adminUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    is_super?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_app_adminUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    is_super?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type UuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type StringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type StringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type BoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type DateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type IntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type DateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type Todo_app_userScalarRelationFilter = {\n    is?: todo_app_userWhereInput\n    isNot?: todo_app_userWhereInput\n  }\n\n  export type Todo_app_todo_snapshotsListRelationFilter = {\n    every?: todo_app_todo_snapshotsWhereInput\n    some?: todo_app_todo_snapshotsWhereInput\n    none?: todo_app_todo_snapshotsWhereInput\n  }\n\n  export type SortOrderInput = {\n    sort: SortOrder\n    nulls?: NullsOrder\n  }\n\n  export type todo_app_todo_snapshotsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type todo_app_todosCountOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrder\n    is_completed?: SortOrder\n    completed_at?: SortOrder\n    position?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type todo_app_todosAvgOrderByAggregateInput = {\n    position?: SortOrder\n  }\n\n  export type todo_app_todosMaxOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrder\n    is_completed?: SortOrder\n    completed_at?: SortOrder\n    position?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type todo_app_todosMinOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrder\n    is_completed?: SortOrder\n    completed_at?: SortOrder\n    position?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type todo_app_todosSumOrderByAggregateInput = {\n    position?: SortOrder\n  }\n\n  export type UuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type BoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _avg?: NestedFloatNullableFilter<$PrismaModel>\n    _sum?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedIntNullableFilter<$PrismaModel>\n    _max?: NestedIntNullableFilter<$PrismaModel>\n  }\n\n  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type Todo_app_todosScalarRelationFilter = {\n    is?: todo_app_todosWhereInput\n    isNot?: todo_app_todosWhereInput\n  }\n\n  export type todo_app_todo_snapshotsCountOrderByAggregateInput = {\n    id?: SortOrder\n    todo_app_todo_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrder\n    is_completed?: SortOrder\n    completed_at?: SortOrder\n    position?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n    snapshot_at?: SortOrder\n  }\n\n  export type todo_app_todo_snapshotsAvgOrderByAggregateInput = {\n    position?: SortOrder\n  }\n\n  export type todo_app_todo_snapshotsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    todo_app_todo_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrder\n    is_completed?: SortOrder\n    completed_at?: SortOrder\n    position?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n    snapshot_at?: SortOrder\n  }\n\n  export type todo_app_todo_snapshotsMinOrderByAggregateInput = {\n    id?: SortOrder\n    todo_app_todo_id?: SortOrder\n    title?: SortOrder\n    description?: SortOrder\n    is_completed?: SortOrder\n    completed_at?: SortOrder\n    position?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n    snapshot_at?: SortOrder\n  }\n\n  export type todo_app_todo_snapshotsSumOrderByAggregateInput = {\n    position?: SortOrder\n  }\n\n  export type UuidNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type Todo_app_adminNullableScalarRelationFilter = {\n    is?: todo_app_adminWhereInput | null\n    isNot?: todo_app_adminWhereInput | null\n  }\n\n  export type Todo_app_userNullableScalarRelationFilter = {\n    is?: todo_app_userWhereInput | null\n    isNot?: todo_app_userWhereInput | null\n  }\n\n  export type todo_app_audit_recordsCountOrderByAggregateInput = {\n    id?: SortOrder\n    admin_id?: SortOrder\n    user_id?: SortOrder\n    actor_role?: SortOrder\n    action_type?: SortOrder\n    target_resource?: SortOrder\n    target_id?: SortOrder\n    reason?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type todo_app_audit_recordsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    admin_id?: SortOrder\n    user_id?: SortOrder\n    actor_role?: SortOrder\n    action_type?: SortOrder\n    target_resource?: SortOrder\n    target_id?: SortOrder\n    reason?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type todo_app_audit_recordsMinOrderByAggregateInput = {\n    id?: SortOrder\n    admin_id?: SortOrder\n    user_id?: SortOrder\n    actor_role?: SortOrder\n    action_type?: SortOrder\n    target_resource?: SortOrder\n    target_id?: SortOrder\n    reason?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type todo_app_guestCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    created_at?: SortOrder\n    last_active_at?: SortOrder\n    status?: SortOrder\n  }\n\n  export type todo_app_guestMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    created_at?: SortOrder\n    last_active_at?: SortOrder\n    status?: SortOrder\n  }\n\n  export type todo_app_guestMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    created_at?: SortOrder\n    last_active_at?: SortOrder\n    status?: SortOrder\n  }\n\n  export type Todo_app_todosListRelationFilter = {\n    every?: todo_app_todosWhereInput\n    some?: todo_app_todosWhereInput\n    none?: todo_app_todosWhereInput\n  }\n\n  export type Todo_app_audit_recordsListRelationFilter = {\n    every?: todo_app_audit_recordsWhereInput\n    some?: todo_app_audit_recordsWhereInput\n    none?: todo_app_audit_recordsWhereInput\n  }\n\n  export type todo_app_todosOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type todo_app_audit_recordsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type todo_app_userCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    display_name?: SortOrder\n    password_hash?: SortOrder\n    account_status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    last_active_at?: SortOrder\n  }\n\n  export type todo_app_userMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    display_name?: SortOrder\n    password_hash?: SortOrder\n    account_status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    last_active_at?: SortOrder\n  }\n\n  export type todo_app_userMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    display_name?: SortOrder\n    password_hash?: SortOrder\n    account_status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    last_active_at?: SortOrder\n  }\n\n  export type todo_app_adminCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    is_super?: SortOrder\n    created_at?: SortOrder\n    last_active_at?: SortOrder\n  }\n\n  export type todo_app_adminMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    is_super?: SortOrder\n    created_at?: SortOrder\n    last_active_at?: SortOrder\n  }\n\n  export type todo_app_adminMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    is_super?: SortOrder\n    created_at?: SortOrder\n    last_active_at?: SortOrder\n  }\n\n  export type todo_app_userCreateNestedOneWithoutTodo_app_todosInput = {\n    create?: XOR<todo_app_userCreateWithoutTodo_app_todosInput, todo_app_userUncheckedCreateWithoutTodo_app_todosInput>\n    connectOrCreate?: todo_app_userCreateOrConnectWithoutTodo_app_todosInput\n    connect?: todo_app_userWhereUniqueInput\n  }\n\n  export type todo_app_todo_snapshotsCreateNestedManyWithoutTodoInput = {\n    create?: XOR<todo_app_todo_snapshotsCreateWithoutTodoInput, todo_app_todo_snapshotsUncheckedCreateWithoutTodoInput> | todo_app_todo_snapshotsCreateWithoutTodoInput[] | todo_app_todo_snapshotsUncheckedCreateWithoutTodoInput[]\n    connectOrCreate?: todo_app_todo_snapshotsCreateOrConnectWithoutTodoInput | todo_app_todo_snapshotsCreateOrConnectWithoutTodoInput[]\n    createMany?: todo_app_todo_snapshotsCreateManyTodoInputEnvelope\n    connect?: todo_app_todo_snapshotsWhereUniqueInput | todo_app_todo_snapshotsWhereUniqueInput[]\n  }\n\n  export type todo_app_todo_snapshotsUncheckedCreateNestedManyWithoutTodoInput = {\n    create?: XOR<todo_app_todo_snapshotsCreateWithoutTodoInput, todo_app_todo_snapshotsUncheckedCreateWithoutTodoInput> | todo_app_todo_snapshotsCreateWithoutTodoInput[] | todo_app_todo_snapshotsUncheckedCreateWithoutTodoInput[]\n    connectOrCreate?: todo_app_todo_snapshotsCreateOrConnectWithoutTodoInput | todo_app_todo_snapshotsCreateOrConnectWithoutTodoInput[]\n    createMany?: todo_app_todo_snapshotsCreateManyTodoInputEnvelope\n    connect?: todo_app_todo_snapshotsWhereUniqueInput | todo_app_todo_snapshotsWhereUniqueInput[]\n  }\n\n  export type StringFieldUpdateOperationsInput = {\n    set?: string\n  }\n\n  export type NullableStringFieldUpdateOperationsInput = {\n    set?: string | null\n  }\n\n  export type BoolFieldUpdateOperationsInput = {\n    set?: boolean\n  }\n\n  export type NullableDateTimeFieldUpdateOperationsInput = {\n    set?: Date | string | null\n  }\n\n  export type NullableIntFieldUpdateOperationsInput = {\n    set?: number | null\n    increment?: number\n    decrement?: number\n    multiply?: number\n    divide?: number\n  }\n\n  export type DateTimeFieldUpdateOperationsInput = {\n    set?: Date | string\n  }\n\n  export type todo_app_userUpdateOneRequiredWithoutTodo_app_todosNestedInput = {\n    create?: XOR<todo_app_userCreateWithoutTodo_app_todosInput, todo_app_userUncheckedCreateWithoutTodo_app_todosInput>\n    connectOrCreate?: todo_app_userCreateOrConnectWithoutTodo_app_todosInput\n    upsert?: todo_app_userUpsertWithoutTodo_app_todosInput\n    connect?: todo_app_userWhereUniqueInput\n    update?: XOR<XOR<todo_app_userUpdateToOneWithWhereWithoutTodo_app_todosInput, todo_app_userUpdateWithoutTodo_app_todosInput>, todo_app_userUncheckedUpdateWithoutTodo_app_todosInput>\n  }\n\n  export type todo_app_todo_snapshotsUpdateManyWithoutTodoNestedInput = {\n    create?: XOR<todo_app_todo_snapshotsCreateWithoutTodoInput, todo_app_todo_snapshotsUncheckedCreateWithoutTodoInput> | todo_app_todo_snapshotsCreateWithoutTodoInput[] | todo_app_todo_snapshotsUncheckedCreateWithoutTodoInput[]\n    connectOrCreate?: todo_app_todo_snapshotsCreateOrConnectWithoutTodoInput | todo_app_todo_snapshotsCreateOrConnectWithoutTodoInput[]\n    upsert?: todo_app_todo_snapshotsUpsertWithWhereUniqueWithoutTodoInput | todo_app_todo_snapshotsUpsertWithWhereUniqueWithoutTodoInput[]\n    createMany?: todo_app_todo_snapshotsCreateManyTodoInputEnvelope\n    set?: todo_app_todo_snapshotsWhereUniqueInput | todo_app_todo_snapshotsWhereUniqueInput[]\n    disconnect?: todo_app_todo_snapshotsWhereUniqueInput | todo_app_todo_snapshotsWhereUniqueInput[]\n    delete?: todo_app_todo_snapshotsWhereUniqueInput | todo_app_todo_snapshotsWhereUniqueInput[]\n    connect?: todo_app_todo_snapshotsWhereUniqueInput | todo_app_todo_snapshotsWhereUniqueInput[]\n    update?: todo_app_todo_snapshotsUpdateWithWhereUniqueWithoutTodoInput | todo_app_todo_snapshotsUpdateWithWhereUniqueWithoutTodoInput[]\n    updateMany?: todo_app_todo_snapshotsUpdateManyWithWhereWithoutTodoInput | todo_app_todo_snapshotsUpdateManyWithWhereWithoutTodoInput[]\n    deleteMany?: todo_app_todo_snapshotsScalarWhereInput | todo_app_todo_snapshotsScalarWhereInput[]\n  }\n\n  export type todo_app_todo_snapshotsUncheckedUpdateManyWithoutTodoNestedInput = {\n    create?: XOR<todo_app_todo_snapshotsCreateWithoutTodoInput, todo_app_todo_snapshotsUncheckedCreateWithoutTodoInput> | todo_app_todo_snapshotsCreateWithoutTodoInput[] | todo_app_todo_snapshotsUncheckedCreateWithoutTodoInput[]\n    connectOrCreate?: todo_app_todo_snapshotsCreateOrConnectWithoutTodoInput | todo_app_todo_snapshotsCreateOrConnectWithoutTodoInput[]\n    upsert?: todo_app_todo_snapshotsUpsertWithWhereUniqueWithoutTodoInput | todo_app_todo_snapshotsUpsertWithWhereUniqueWithoutTodoInput[]\n    createMany?: todo_app_todo_snapshotsCreateManyTodoInputEnvelope\n    set?: todo_app_todo_snapshotsWhereUniqueInput | todo_app_todo_snapshotsWhereUniqueInput[]\n    disconnect?: todo_app_todo_snapshotsWhereUniqueInput | todo_app_todo_snapshotsWhereUniqueInput[]\n    delete?: todo_app_todo_snapshotsWhereUniqueInput | todo_app_todo_snapshotsWhereUniqueInput[]\n    connect?: todo_app_todo_snapshotsWhereUniqueInput | todo_app_todo_snapshotsWhereUniqueInput[]\n    update?: todo_app_todo_snapshotsUpdateWithWhereUniqueWithoutTodoInput | todo_app_todo_snapshotsUpdateWithWhereUniqueWithoutTodoInput[]\n    updateMany?: todo_app_todo_snapshotsUpdateManyWithWhereWithoutTodoInput | todo_app_todo_snapshotsUpdateManyWithWhereWithoutTodoInput[]\n    deleteMany?: todo_app_todo_snapshotsScalarWhereInput | todo_app_todo_snapshotsScalarWhereInput[]\n  }\n\n  export type todo_app_todosCreateNestedOneWithoutTodo_app_todo_snapshotsInput = {\n    create?: XOR<todo_app_todosCreateWithoutTodo_app_todo_snapshotsInput, todo_app_todosUncheckedCreateWithoutTodo_app_todo_snapshotsInput>\n    connectOrCreate?: todo_app_todosCreateOrConnectWithoutTodo_app_todo_snapshotsInput\n    connect?: todo_app_todosWhereUniqueInput\n  }\n\n  export type todo_app_todosUpdateOneRequiredWithoutTodo_app_todo_snapshotsNestedInput = {\n    create?: XOR<todo_app_todosCreateWithoutTodo_app_todo_snapshotsInput, todo_app_todosUncheckedCreateWithoutTodo_app_todo_snapshotsInput>\n    connectOrCreate?: todo_app_todosCreateOrConnectWithoutTodo_app_todo_snapshotsInput\n    upsert?: todo_app_todosUpsertWithoutTodo_app_todo_snapshotsInput\n    connect?: todo_app_todosWhereUniqueInput\n    update?: XOR<XOR<todo_app_todosUpdateToOneWithWhereWithoutTodo_app_todo_snapshotsInput, todo_app_todosUpdateWithoutTodo_app_todo_snapshotsInput>, todo_app_todosUncheckedUpdateWithoutTodo_app_todo_snapshotsInput>\n  }\n\n  export type todo_app_adminCreateNestedOneWithoutTodo_app_audit_recordsInput = {\n    create?: XOR<todo_app_adminCreateWithoutTodo_app_audit_recordsInput, todo_app_adminUncheckedCreateWithoutTodo_app_audit_recordsInput>\n    connectOrCreate?: todo_app_adminCreateOrConnectWithoutTodo_app_audit_recordsInput\n    connect?: todo_app_adminWhereUniqueInput\n  }\n\n  export type todo_app_userCreateNestedOneWithoutTodo_app_audit_recordsInput = {\n    create?: XOR<todo_app_userCreateWithoutTodo_app_audit_recordsInput, todo_app_userUncheckedCreateWithoutTodo_app_audit_recordsInput>\n    connectOrCreate?: todo_app_userCreateOrConnectWithoutTodo_app_audit_recordsInput\n    connect?: todo_app_userWhereUniqueInput\n  }\n\n  export type todo_app_adminUpdateOneWithoutTodo_app_audit_recordsNestedInput = {\n    create?: XOR<todo_app_adminCreateWithoutTodo_app_audit_recordsInput, todo_app_adminUncheckedCreateWithoutTodo_app_audit_recordsInput>\n    connectOrCreate?: todo_app_adminCreateOrConnectWithoutTodo_app_audit_recordsInput\n    upsert?: todo_app_adminUpsertWithoutTodo_app_audit_recordsInput\n    disconnect?: todo_app_adminWhereInput | boolean\n    delete?: todo_app_adminWhereInput | boolean\n    connect?: todo_app_adminWhereUniqueInput\n    update?: XOR<XOR<todo_app_adminUpdateToOneWithWhereWithoutTodo_app_audit_recordsInput, todo_app_adminUpdateWithoutTodo_app_audit_recordsInput>, todo_app_adminUncheckedUpdateWithoutTodo_app_audit_recordsInput>\n  }\n\n  export type todo_app_userUpdateOneWithoutTodo_app_audit_recordsNestedInput = {\n    create?: XOR<todo_app_userCreateWithoutTodo_app_audit_recordsInput, todo_app_userUncheckedCreateWithoutTodo_app_audit_recordsInput>\n    connectOrCreate?: todo_app_userCreateOrConnectWithoutTodo_app_audit_recordsInput\n    upsert?: todo_app_userUpsertWithoutTodo_app_audit_recordsInput\n    disconnect?: todo_app_userWhereInput | boolean\n    delete?: todo_app_userWhereInput | boolean\n    connect?: todo_app_userWhereUniqueInput\n    update?: XOR<XOR<todo_app_userUpdateToOneWithWhereWithoutTodo_app_audit_recordsInput, todo_app_userUpdateWithoutTodo_app_audit_recordsInput>, todo_app_userUncheckedUpdateWithoutTodo_app_audit_recordsInput>\n  }\n\n  export type todo_app_todosCreateNestedManyWithoutUserInput = {\n    create?: XOR<todo_app_todosCreateWithoutUserInput, todo_app_todosUncheckedCreateWithoutUserInput> | todo_app_todosCreateWithoutUserInput[] | todo_app_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_app_todosCreateOrConnectWithoutUserInput | todo_app_todosCreateOrConnectWithoutUserInput[]\n    createMany?: todo_app_todosCreateManyUserInputEnvelope\n    connect?: todo_app_todosWhereUniqueInput | todo_app_todosWhereUniqueInput[]\n  }\n\n  export type todo_app_audit_recordsCreateNestedManyWithoutUserInput = {\n    create?: XOR<todo_app_audit_recordsCreateWithoutUserInput, todo_app_audit_recordsUncheckedCreateWithoutUserInput> | todo_app_audit_recordsCreateWithoutUserInput[] | todo_app_audit_recordsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_app_audit_recordsCreateOrConnectWithoutUserInput | todo_app_audit_recordsCreateOrConnectWithoutUserInput[]\n    createMany?: todo_app_audit_recordsCreateManyUserInputEnvelope\n    connect?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n  }\n\n  export type todo_app_todosUncheckedCreateNestedManyWithoutUserInput = {\n    create?: XOR<todo_app_todosCreateWithoutUserInput, todo_app_todosUncheckedCreateWithoutUserInput> | todo_app_todosCreateWithoutUserInput[] | todo_app_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_app_todosCreateOrConnectWithoutUserInput | todo_app_todosCreateOrConnectWithoutUserInput[]\n    createMany?: todo_app_todosCreateManyUserInputEnvelope\n    connect?: todo_app_todosWhereUniqueInput | todo_app_todosWhereUniqueInput[]\n  }\n\n  export type todo_app_audit_recordsUncheckedCreateNestedManyWithoutUserInput = {\n    create?: XOR<todo_app_audit_recordsCreateWithoutUserInput, todo_app_audit_recordsUncheckedCreateWithoutUserInput> | todo_app_audit_recordsCreateWithoutUserInput[] | todo_app_audit_recordsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_app_audit_recordsCreateOrConnectWithoutUserInput | todo_app_audit_recordsCreateOrConnectWithoutUserInput[]\n    createMany?: todo_app_audit_recordsCreateManyUserInputEnvelope\n    connect?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n  }\n\n  export type todo_app_todosUpdateManyWithoutUserNestedInput = {\n    create?: XOR<todo_app_todosCreateWithoutUserInput, todo_app_todosUncheckedCreateWithoutUserInput> | todo_app_todosCreateWithoutUserInput[] | todo_app_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_app_todosCreateOrConnectWithoutUserInput | todo_app_todosCreateOrConnectWithoutUserInput[]\n    upsert?: todo_app_todosUpsertWithWhereUniqueWithoutUserInput | todo_app_todosUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: todo_app_todosCreateManyUserInputEnvelope\n    set?: todo_app_todosWhereUniqueInput | todo_app_todosWhereUniqueInput[]\n    disconnect?: todo_app_todosWhereUniqueInput | todo_app_todosWhereUniqueInput[]\n    delete?: todo_app_todosWhereUniqueInput | todo_app_todosWhereUniqueInput[]\n    connect?: todo_app_todosWhereUniqueInput | todo_app_todosWhereUniqueInput[]\n    update?: todo_app_todosUpdateWithWhereUniqueWithoutUserInput | todo_app_todosUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: todo_app_todosUpdateManyWithWhereWithoutUserInput | todo_app_todosUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: todo_app_todosScalarWhereInput | todo_app_todosScalarWhereInput[]\n  }\n\n  export type todo_app_audit_recordsUpdateManyWithoutUserNestedInput = {\n    create?: XOR<todo_app_audit_recordsCreateWithoutUserInput, todo_app_audit_recordsUncheckedCreateWithoutUserInput> | todo_app_audit_recordsCreateWithoutUserInput[] | todo_app_audit_recordsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_app_audit_recordsCreateOrConnectWithoutUserInput | todo_app_audit_recordsCreateOrConnectWithoutUserInput[]\n    upsert?: todo_app_audit_recordsUpsertWithWhereUniqueWithoutUserInput | todo_app_audit_recordsUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: todo_app_audit_recordsCreateManyUserInputEnvelope\n    set?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    disconnect?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    delete?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    connect?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    update?: todo_app_audit_recordsUpdateWithWhereUniqueWithoutUserInput | todo_app_audit_recordsUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: todo_app_audit_recordsUpdateManyWithWhereWithoutUserInput | todo_app_audit_recordsUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: todo_app_audit_recordsScalarWhereInput | todo_app_audit_recordsScalarWhereInput[]\n  }\n\n  export type todo_app_todosUncheckedUpdateManyWithoutUserNestedInput = {\n    create?: XOR<todo_app_todosCreateWithoutUserInput, todo_app_todosUncheckedCreateWithoutUserInput> | todo_app_todosCreateWithoutUserInput[] | todo_app_todosUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_app_todosCreateOrConnectWithoutUserInput | todo_app_todosCreateOrConnectWithoutUserInput[]\n    upsert?: todo_app_todosUpsertWithWhereUniqueWithoutUserInput | todo_app_todosUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: todo_app_todosCreateManyUserInputEnvelope\n    set?: todo_app_todosWhereUniqueInput | todo_app_todosWhereUniqueInput[]\n    disconnect?: todo_app_todosWhereUniqueInput | todo_app_todosWhereUniqueInput[]\n    delete?: todo_app_todosWhereUniqueInput | todo_app_todosWhereUniqueInput[]\n    connect?: todo_app_todosWhereUniqueInput | todo_app_todosWhereUniqueInput[]\n    update?: todo_app_todosUpdateWithWhereUniqueWithoutUserInput | todo_app_todosUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: todo_app_todosUpdateManyWithWhereWithoutUserInput | todo_app_todosUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: todo_app_todosScalarWhereInput | todo_app_todosScalarWhereInput[]\n  }\n\n  export type todo_app_audit_recordsUncheckedUpdateManyWithoutUserNestedInput = {\n    create?: XOR<todo_app_audit_recordsCreateWithoutUserInput, todo_app_audit_recordsUncheckedCreateWithoutUserInput> | todo_app_audit_recordsCreateWithoutUserInput[] | todo_app_audit_recordsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_app_audit_recordsCreateOrConnectWithoutUserInput | todo_app_audit_recordsCreateOrConnectWithoutUserInput[]\n    upsert?: todo_app_audit_recordsUpsertWithWhereUniqueWithoutUserInput | todo_app_audit_recordsUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: todo_app_audit_recordsCreateManyUserInputEnvelope\n    set?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    disconnect?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    delete?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    connect?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    update?: todo_app_audit_recordsUpdateWithWhereUniqueWithoutUserInput | todo_app_audit_recordsUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: todo_app_audit_recordsUpdateManyWithWhereWithoutUserInput | todo_app_audit_recordsUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: todo_app_audit_recordsScalarWhereInput | todo_app_audit_recordsScalarWhereInput[]\n  }\n\n  export type todo_app_audit_recordsCreateNestedManyWithoutAdminInput = {\n    create?: XOR<todo_app_audit_recordsCreateWithoutAdminInput, todo_app_audit_recordsUncheckedCreateWithoutAdminInput> | todo_app_audit_recordsCreateWithoutAdminInput[] | todo_app_audit_recordsUncheckedCreateWithoutAdminInput[]\n    connectOrCreate?: todo_app_audit_recordsCreateOrConnectWithoutAdminInput | todo_app_audit_recordsCreateOrConnectWithoutAdminInput[]\n    createMany?: todo_app_audit_recordsCreateManyAdminInputEnvelope\n    connect?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n  }\n\n  export type todo_app_audit_recordsUncheckedCreateNestedManyWithoutAdminInput = {\n    create?: XOR<todo_app_audit_recordsCreateWithoutAdminInput, todo_app_audit_recordsUncheckedCreateWithoutAdminInput> | todo_app_audit_recordsCreateWithoutAdminInput[] | todo_app_audit_recordsUncheckedCreateWithoutAdminInput[]\n    connectOrCreate?: todo_app_audit_recordsCreateOrConnectWithoutAdminInput | todo_app_audit_recordsCreateOrConnectWithoutAdminInput[]\n    createMany?: todo_app_audit_recordsCreateManyAdminInputEnvelope\n    connect?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n  }\n\n  export type todo_app_audit_recordsUpdateManyWithoutAdminNestedInput = {\n    create?: XOR<todo_app_audit_recordsCreateWithoutAdminInput, todo_app_audit_recordsUncheckedCreateWithoutAdminInput> | todo_app_audit_recordsCreateWithoutAdminInput[] | todo_app_audit_recordsUncheckedCreateWithoutAdminInput[]\n    connectOrCreate?: todo_app_audit_recordsCreateOrConnectWithoutAdminInput | todo_app_audit_recordsCreateOrConnectWithoutAdminInput[]\n    upsert?: todo_app_audit_recordsUpsertWithWhereUniqueWithoutAdminInput | todo_app_audit_recordsUpsertWithWhereUniqueWithoutAdminInput[]\n    createMany?: todo_app_audit_recordsCreateManyAdminInputEnvelope\n    set?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    disconnect?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    delete?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    connect?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    update?: todo_app_audit_recordsUpdateWithWhereUniqueWithoutAdminInput | todo_app_audit_recordsUpdateWithWhereUniqueWithoutAdminInput[]\n    updateMany?: todo_app_audit_recordsUpdateManyWithWhereWithoutAdminInput | todo_app_audit_recordsUpdateManyWithWhereWithoutAdminInput[]\n    deleteMany?: todo_app_audit_recordsScalarWhereInput | todo_app_audit_recordsScalarWhereInput[]\n  }\n\n  export type todo_app_audit_recordsUncheckedUpdateManyWithoutAdminNestedInput = {\n    create?: XOR<todo_app_audit_recordsCreateWithoutAdminInput, todo_app_audit_recordsUncheckedCreateWithoutAdminInput> | todo_app_audit_recordsCreateWithoutAdminInput[] | todo_app_audit_recordsUncheckedCreateWithoutAdminInput[]\n    connectOrCreate?: todo_app_audit_recordsCreateOrConnectWithoutAdminInput | todo_app_audit_recordsCreateOrConnectWithoutAdminInput[]\n    upsert?: todo_app_audit_recordsUpsertWithWhereUniqueWithoutAdminInput | todo_app_audit_recordsUpsertWithWhereUniqueWithoutAdminInput[]\n    createMany?: todo_app_audit_recordsCreateManyAdminInputEnvelope\n    set?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    disconnect?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    delete?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    connect?: todo_app_audit_recordsWhereUniqueInput | todo_app_audit_recordsWhereUniqueInput[]\n    update?: todo_app_audit_recordsUpdateWithWhereUniqueWithoutAdminInput | todo_app_audit_recordsUpdateWithWhereUniqueWithoutAdminInput[]\n    updateMany?: todo_app_audit_recordsUpdateManyWithWhereWithoutAdminInput | todo_app_audit_recordsUpdateManyWithWhereWithoutAdminInput[]\n    deleteMany?: todo_app_audit_recordsScalarWhereInput | todo_app_audit_recordsScalarWhereInput[]\n  }\n\n  export type NestedUuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedBoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type NestedIntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type NestedDateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedIntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _avg?: NestedFloatNullableFilter<$PrismaModel>\n    _sum?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedIntNullableFilter<$PrismaModel>\n    _max?: NestedIntNullableFilter<$PrismaModel>\n  }\n\n  export type NestedFloatNullableFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type NestedUuidNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type todo_app_userCreateWithoutTodo_app_todosInput = {\n    id: string\n    email: string\n    display_name?: string | null\n    password_hash?: string | null\n    account_status: string\n    created_at: Date | string\n    updated_at: Date | string\n    last_active_at?: Date | string | null\n    todo_app_audit_records?: todo_app_audit_recordsCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_app_userUncheckedCreateWithoutTodo_app_todosInput = {\n    id: string\n    email: string\n    display_name?: string | null\n    password_hash?: string | null\n    account_status: string\n    created_at: Date | string\n    updated_at: Date | string\n    last_active_at?: Date | string | null\n    todo_app_audit_records?: todo_app_audit_recordsUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_app_userCreateOrConnectWithoutTodo_app_todosInput = {\n    where: todo_app_userWhereUniqueInput\n    create: XOR<todo_app_userCreateWithoutTodo_app_todosInput, todo_app_userUncheckedCreateWithoutTodo_app_todosInput>\n  }\n\n  export type todo_app_todo_snapshotsCreateWithoutTodoInput = {\n    id: string\n    title: string\n    description?: string | null\n    is_completed: boolean\n    completed_at?: Date | string | null\n    position?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    snapshot_at: Date | string\n  }\n\n  export type todo_app_todo_snapshotsUncheckedCreateWithoutTodoInput = {\n    id: string\n    title: string\n    description?: string | null\n    is_completed: boolean\n    completed_at?: Date | string | null\n    position?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    snapshot_at: Date | string\n  }\n\n  export type todo_app_todo_snapshotsCreateOrConnectWithoutTodoInput = {\n    where: todo_app_todo_snapshotsWhereUniqueInput\n    create: XOR<todo_app_todo_snapshotsCreateWithoutTodoInput, todo_app_todo_snapshotsUncheckedCreateWithoutTodoInput>\n  }\n\n  export type todo_app_todo_snapshotsCreateManyTodoInputEnvelope = {\n    data: todo_app_todo_snapshotsCreateManyTodoInput | todo_app_todo_snapshotsCreateManyTodoInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type todo_app_userUpsertWithoutTodo_app_todosInput = {\n    update: XOR<todo_app_userUpdateWithoutTodo_app_todosInput, todo_app_userUncheckedUpdateWithoutTodo_app_todosInput>\n    create: XOR<todo_app_userCreateWithoutTodo_app_todosInput, todo_app_userUncheckedCreateWithoutTodo_app_todosInput>\n    where?: todo_app_userWhereInput\n  }\n\n  export type todo_app_userUpdateToOneWithWhereWithoutTodo_app_todosInput = {\n    where?: todo_app_userWhereInput\n    data: XOR<todo_app_userUpdateWithoutTodo_app_todosInput, todo_app_userUncheckedUpdateWithoutTodo_app_todosInput>\n  }\n\n  export type todo_app_userUpdateWithoutTodo_app_todosInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    display_name?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    account_status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_app_audit_records?: todo_app_audit_recordsUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_app_userUncheckedUpdateWithoutTodo_app_todosInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    display_name?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    account_status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_app_audit_records?: todo_app_audit_recordsUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_app_todo_snapshotsUpsertWithWhereUniqueWithoutTodoInput = {\n    where: todo_app_todo_snapshotsWhereUniqueInput\n    update: XOR<todo_app_todo_snapshotsUpdateWithoutTodoInput, todo_app_todo_snapshotsUncheckedUpdateWithoutTodoInput>\n    create: XOR<todo_app_todo_snapshotsCreateWithoutTodoInput, todo_app_todo_snapshotsUncheckedCreateWithoutTodoInput>\n  }\n\n  export type todo_app_todo_snapshotsUpdateWithWhereUniqueWithoutTodoInput = {\n    where: todo_app_todo_snapshotsWhereUniqueInput\n    data: XOR<todo_app_todo_snapshotsUpdateWithoutTodoInput, todo_app_todo_snapshotsUncheckedUpdateWithoutTodoInput>\n  }\n\n  export type todo_app_todo_snapshotsUpdateManyWithWhereWithoutTodoInput = {\n    where: todo_app_todo_snapshotsScalarWhereInput\n    data: XOR<todo_app_todo_snapshotsUpdateManyMutationInput, todo_app_todo_snapshotsUncheckedUpdateManyWithoutTodoInput>\n  }\n\n  export type todo_app_todo_snapshotsScalarWhereInput = {\n    AND?: todo_app_todo_snapshotsScalarWhereInput | todo_app_todo_snapshotsScalarWhereInput[]\n    OR?: todo_app_todo_snapshotsScalarWhereInput[]\n    NOT?: todo_app_todo_snapshotsScalarWhereInput | todo_app_todo_snapshotsScalarWhereInput[]\n    id?: UuidFilter<\"todo_app_todo_snapshots\"> | string\n    todo_app_todo_id?: UuidFilter<\"todo_app_todo_snapshots\"> | string\n    title?: StringFilter<\"todo_app_todo_snapshots\"> | string\n    description?: StringNullableFilter<\"todo_app_todo_snapshots\"> | string | null\n    is_completed?: BoolFilter<\"todo_app_todo_snapshots\"> | boolean\n    completed_at?: DateTimeNullableFilter<\"todo_app_todo_snapshots\"> | Date | string | null\n    position?: IntNullableFilter<\"todo_app_todo_snapshots\"> | number | null\n    created_at?: DateTimeFilter<\"todo_app_todo_snapshots\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_app_todo_snapshots\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"todo_app_todo_snapshots\"> | Date | string | null\n    snapshot_at?: DateTimeFilter<\"todo_app_todo_snapshots\"> | Date | string\n  }\n\n  export type todo_app_todosCreateWithoutTodo_app_todo_snapshotsInput = {\n    id: string\n    title: string\n    description?: string | null\n    is_completed: boolean\n    completed_at?: Date | string | null\n    position?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    user: todo_app_userCreateNestedOneWithoutTodo_app_todosInput\n  }\n\n  export type todo_app_todosUncheckedCreateWithoutTodo_app_todo_snapshotsInput = {\n    id: string\n    user_id: string\n    title: string\n    description?: string | null\n    is_completed: boolean\n    completed_at?: Date | string | null\n    position?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_app_todosCreateOrConnectWithoutTodo_app_todo_snapshotsInput = {\n    where: todo_app_todosWhereUniqueInput\n    create: XOR<todo_app_todosCreateWithoutTodo_app_todo_snapshotsInput, todo_app_todosUncheckedCreateWithoutTodo_app_todo_snapshotsInput>\n  }\n\n  export type todo_app_todosUpsertWithoutTodo_app_todo_snapshotsInput = {\n    update: XOR<todo_app_todosUpdateWithoutTodo_app_todo_snapshotsInput, todo_app_todosUncheckedUpdateWithoutTodo_app_todo_snapshotsInput>\n    create: XOR<todo_app_todosCreateWithoutTodo_app_todo_snapshotsInput, todo_app_todosUncheckedCreateWithoutTodo_app_todo_snapshotsInput>\n    where?: todo_app_todosWhereInput\n  }\n\n  export type todo_app_todosUpdateToOneWithWhereWithoutTodo_app_todo_snapshotsInput = {\n    where?: todo_app_todosWhereInput\n    data: XOR<todo_app_todosUpdateWithoutTodo_app_todo_snapshotsInput, todo_app_todosUncheckedUpdateWithoutTodo_app_todo_snapshotsInput>\n  }\n\n  export type todo_app_todosUpdateWithoutTodo_app_todo_snapshotsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    user?: todo_app_userUpdateOneRequiredWithoutTodo_app_todosNestedInput\n  }\n\n  export type todo_app_todosUncheckedUpdateWithoutTodo_app_todo_snapshotsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_app_adminCreateWithoutTodo_app_audit_recordsInput = {\n    id: string\n    email: string\n    password_hash?: string | null\n    is_super: boolean\n    created_at: Date | string\n    last_active_at?: Date | string | null\n  }\n\n  export type todo_app_adminUncheckedCreateWithoutTodo_app_audit_recordsInput = {\n    id: string\n    email: string\n    password_hash?: string | null\n    is_super: boolean\n    created_at: Date | string\n    last_active_at?: Date | string | null\n  }\n\n  export type todo_app_adminCreateOrConnectWithoutTodo_app_audit_recordsInput = {\n    where: todo_app_adminWhereUniqueInput\n    create: XOR<todo_app_adminCreateWithoutTodo_app_audit_recordsInput, todo_app_adminUncheckedCreateWithoutTodo_app_audit_recordsInput>\n  }\n\n  export type todo_app_userCreateWithoutTodo_app_audit_recordsInput = {\n    id: string\n    email: string\n    display_name?: string | null\n    password_hash?: string | null\n    account_status: string\n    created_at: Date | string\n    updated_at: Date | string\n    last_active_at?: Date | string | null\n    todo_app_todos?: todo_app_todosCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_app_userUncheckedCreateWithoutTodo_app_audit_recordsInput = {\n    id: string\n    email: string\n    display_name?: string | null\n    password_hash?: string | null\n    account_status: string\n    created_at: Date | string\n    updated_at: Date | string\n    last_active_at?: Date | string | null\n    todo_app_todos?: todo_app_todosUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_app_userCreateOrConnectWithoutTodo_app_audit_recordsInput = {\n    where: todo_app_userWhereUniqueInput\n    create: XOR<todo_app_userCreateWithoutTodo_app_audit_recordsInput, todo_app_userUncheckedCreateWithoutTodo_app_audit_recordsInput>\n  }\n\n  export type todo_app_adminUpsertWithoutTodo_app_audit_recordsInput = {\n    update: XOR<todo_app_adminUpdateWithoutTodo_app_audit_recordsInput, todo_app_adminUncheckedUpdateWithoutTodo_app_audit_recordsInput>\n    create: XOR<todo_app_adminCreateWithoutTodo_app_audit_recordsInput, todo_app_adminUncheckedCreateWithoutTodo_app_audit_recordsInput>\n    where?: todo_app_adminWhereInput\n  }\n\n  export type todo_app_adminUpdateToOneWithWhereWithoutTodo_app_audit_recordsInput = {\n    where?: todo_app_adminWhereInput\n    data: XOR<todo_app_adminUpdateWithoutTodo_app_audit_recordsInput, todo_app_adminUncheckedUpdateWithoutTodo_app_audit_recordsInput>\n  }\n\n  export type todo_app_adminUpdateWithoutTodo_app_audit_recordsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    is_super?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_app_adminUncheckedUpdateWithoutTodo_app_audit_recordsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    is_super?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_app_userUpsertWithoutTodo_app_audit_recordsInput = {\n    update: XOR<todo_app_userUpdateWithoutTodo_app_audit_recordsInput, todo_app_userUncheckedUpdateWithoutTodo_app_audit_recordsInput>\n    create: XOR<todo_app_userCreateWithoutTodo_app_audit_recordsInput, todo_app_userUncheckedCreateWithoutTodo_app_audit_recordsInput>\n    where?: todo_app_userWhereInput\n  }\n\n  export type todo_app_userUpdateToOneWithWhereWithoutTodo_app_audit_recordsInput = {\n    where?: todo_app_userWhereInput\n    data: XOR<todo_app_userUpdateWithoutTodo_app_audit_recordsInput, todo_app_userUncheckedUpdateWithoutTodo_app_audit_recordsInput>\n  }\n\n  export type todo_app_userUpdateWithoutTodo_app_audit_recordsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    display_name?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    account_status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_app_todos?: todo_app_todosUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_app_userUncheckedUpdateWithoutTodo_app_audit_recordsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    display_name?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: NullableStringFieldUpdateOperationsInput | string | null\n    account_status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    last_active_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_app_todos?: todo_app_todosUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_app_todosCreateWithoutUserInput = {\n    id: string\n    title: string\n    description?: string | null\n    is_completed: boolean\n    completed_at?: Date | string | null\n    position?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    todo_app_todo_snapshots?: todo_app_todo_snapshotsCreateNestedManyWithoutTodoInput\n  }\n\n  export type todo_app_todosUncheckedCreateWithoutUserInput = {\n    id: string\n    title: string\n    description?: string | null\n    is_completed: boolean\n    completed_at?: Date | string | null\n    position?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    todo_app_todo_snapshots?: todo_app_todo_snapshotsUncheckedCreateNestedManyWithoutTodoInput\n  }\n\n  export type todo_app_todosCreateOrConnectWithoutUserInput = {\n    where: todo_app_todosWhereUniqueInput\n    create: XOR<todo_app_todosCreateWithoutUserInput, todo_app_todosUncheckedCreateWithoutUserInput>\n  }\n\n  export type todo_app_todosCreateManyUserInputEnvelope = {\n    data: todo_app_todosCreateManyUserInput | todo_app_todosCreateManyUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type todo_app_audit_recordsCreateWithoutUserInput = {\n    id: string\n    actor_role: string\n    action_type: string\n    target_resource: string\n    target_id?: string | null\n    reason?: string | null\n    created_at: Date | string\n    admin?: todo_app_adminCreateNestedOneWithoutTodo_app_audit_recordsInput\n  }\n\n  export type todo_app_audit_recordsUncheckedCreateWithoutUserInput = {\n    id: string\n    admin_id?: string | null\n    actor_role: string\n    action_type: string\n    target_resource: string\n    target_id?: string | null\n    reason?: string | null\n    created_at: Date | string\n  }\n\n  export type todo_app_audit_recordsCreateOrConnectWithoutUserInput = {\n    where: todo_app_audit_recordsWhereUniqueInput\n    create: XOR<todo_app_audit_recordsCreateWithoutUserInput, todo_app_audit_recordsUncheckedCreateWithoutUserInput>\n  }\n\n  export type todo_app_audit_recordsCreateManyUserInputEnvelope = {\n    data: todo_app_audit_recordsCreateManyUserInput | todo_app_audit_recordsCreateManyUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type todo_app_todosUpsertWithWhereUniqueWithoutUserInput = {\n    where: todo_app_todosWhereUniqueInput\n    update: XOR<todo_app_todosUpdateWithoutUserInput, todo_app_todosUncheckedUpdateWithoutUserInput>\n    create: XOR<todo_app_todosCreateWithoutUserInput, todo_app_todosUncheckedCreateWithoutUserInput>\n  }\n\n  export type todo_app_todosUpdateWithWhereUniqueWithoutUserInput = {\n    where: todo_app_todosWhereUniqueInput\n    data: XOR<todo_app_todosUpdateWithoutUserInput, todo_app_todosUncheckedUpdateWithoutUserInput>\n  }\n\n  export type todo_app_todosUpdateManyWithWhereWithoutUserInput = {\n    where: todo_app_todosScalarWhereInput\n    data: XOR<todo_app_todosUpdateManyMutationInput, todo_app_todosUncheckedUpdateManyWithoutUserInput>\n  }\n\n  export type todo_app_todosScalarWhereInput = {\n    AND?: todo_app_todosScalarWhereInput | todo_app_todosScalarWhereInput[]\n    OR?: todo_app_todosScalarWhereInput[]\n    NOT?: todo_app_todosScalarWhereInput | todo_app_todosScalarWhereInput[]\n    id?: UuidFilter<\"todo_app_todos\"> | string\n    user_id?: UuidFilter<\"todo_app_todos\"> | string\n    title?: StringFilter<\"todo_app_todos\"> | string\n    description?: StringNullableFilter<\"todo_app_todos\"> | string | null\n    is_completed?: BoolFilter<\"todo_app_todos\"> | boolean\n    completed_at?: DateTimeNullableFilter<\"todo_app_todos\"> | Date | string | null\n    position?: IntNullableFilter<\"todo_app_todos\"> | number | null\n    created_at?: DateTimeFilter<\"todo_app_todos\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_app_todos\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"todo_app_todos\"> | Date | string | null\n  }\n\n  export type todo_app_audit_recordsUpsertWithWhereUniqueWithoutUserInput = {\n    where: todo_app_audit_recordsWhereUniqueInput\n    update: XOR<todo_app_audit_recordsUpdateWithoutUserInput, todo_app_audit_recordsUncheckedUpdateWithoutUserInput>\n    create: XOR<todo_app_audit_recordsCreateWithoutUserInput, todo_app_audit_recordsUncheckedCreateWithoutUserInput>\n  }\n\n  export type todo_app_audit_recordsUpdateWithWhereUniqueWithoutUserInput = {\n    where: todo_app_audit_recordsWhereUniqueInput\n    data: XOR<todo_app_audit_recordsUpdateWithoutUserInput, todo_app_audit_recordsUncheckedUpdateWithoutUserInput>\n  }\n\n  export type todo_app_audit_recordsUpdateManyWithWhereWithoutUserInput = {\n    where: todo_app_audit_recordsScalarWhereInput\n    data: XOR<todo_app_audit_recordsUpdateManyMutationInput, todo_app_audit_recordsUncheckedUpdateManyWithoutUserInput>\n  }\n\n  export type todo_app_audit_recordsScalarWhereInput = {\n    AND?: todo_app_audit_recordsScalarWhereInput | todo_app_audit_recordsScalarWhereInput[]\n    OR?: todo_app_audit_recordsScalarWhereInput[]\n    NOT?: todo_app_audit_recordsScalarWhereInput | todo_app_audit_recordsScalarWhereInput[]\n    id?: UuidFilter<\"todo_app_audit_records\"> | string\n    admin_id?: UuidNullableFilter<\"todo_app_audit_records\"> | string | null\n    user_id?: UuidNullableFilter<\"todo_app_audit_records\"> | string | null\n    actor_role?: StringFilter<\"todo_app_audit_records\"> | string\n    action_type?: StringFilter<\"todo_app_audit_records\"> | string\n    target_resource?: StringFilter<\"todo_app_audit_records\"> | string\n    target_id?: UuidNullableFilter<\"todo_app_audit_records\"> | string | null\n    reason?: StringNullableFilter<\"todo_app_audit_records\"> | string | null\n    created_at?: DateTimeFilter<\"todo_app_audit_records\"> | Date | string\n  }\n\n  export type todo_app_audit_recordsCreateWithoutAdminInput = {\n    id: string\n    actor_role: string\n    action_type: string\n    target_resource: string\n    target_id?: string | null\n    reason?: string | null\n    created_at: Date | string\n    user?: todo_app_userCreateNestedOneWithoutTodo_app_audit_recordsInput\n  }\n\n  export type todo_app_audit_recordsUncheckedCreateWithoutAdminInput = {\n    id: string\n    user_id?: string | null\n    actor_role: string\n    action_type: string\n    target_resource: string\n    target_id?: string | null\n    reason?: string | null\n    created_at: Date | string\n  }\n\n  export type todo_app_audit_recordsCreateOrConnectWithoutAdminInput = {\n    where: todo_app_audit_recordsWhereUniqueInput\n    create: XOR<todo_app_audit_recordsCreateWithoutAdminInput, todo_app_audit_recordsUncheckedCreateWithoutAdminInput>\n  }\n\n  export type todo_app_audit_recordsCreateManyAdminInputEnvelope = {\n    data: todo_app_audit_recordsCreateManyAdminInput | todo_app_audit_recordsCreateManyAdminInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type todo_app_audit_recordsUpsertWithWhereUniqueWithoutAdminInput = {\n    where: todo_app_audit_recordsWhereUniqueInput\n    update: XOR<todo_app_audit_recordsUpdateWithoutAdminInput, todo_app_audit_recordsUncheckedUpdateWithoutAdminInput>\n    create: XOR<todo_app_audit_recordsCreateWithoutAdminInput, todo_app_audit_recordsUncheckedCreateWithoutAdminInput>\n  }\n\n  export type todo_app_audit_recordsUpdateWithWhereUniqueWithoutAdminInput = {\n    where: todo_app_audit_recordsWhereUniqueInput\n    data: XOR<todo_app_audit_recordsUpdateWithoutAdminInput, todo_app_audit_recordsUncheckedUpdateWithoutAdminInput>\n  }\n\n  export type todo_app_audit_recordsUpdateManyWithWhereWithoutAdminInput = {\n    where: todo_app_audit_recordsScalarWhereInput\n    data: XOR<todo_app_audit_recordsUpdateManyMutationInput, todo_app_audit_recordsUncheckedUpdateManyWithoutAdminInput>\n  }\n\n  export type todo_app_todo_snapshotsCreateManyTodoInput = {\n    id: string\n    title: string\n    description?: string | null\n    is_completed: boolean\n    completed_at?: Date | string | null\n    position?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    snapshot_at: Date | string\n  }\n\n  export type todo_app_todo_snapshotsUpdateWithoutTodoInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    snapshot_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_app_todo_snapshotsUncheckedUpdateWithoutTodoInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    snapshot_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_app_todo_snapshotsUncheckedUpdateManyWithoutTodoInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    snapshot_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_app_todosCreateManyUserInput = {\n    id: string\n    title: string\n    description?: string | null\n    is_completed: boolean\n    completed_at?: Date | string | null\n    position?: number | null\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_app_audit_recordsCreateManyUserInput = {\n    id: string\n    admin_id?: string | null\n    actor_role: string\n    action_type: string\n    target_resource: string\n    target_id?: string | null\n    reason?: string | null\n    created_at: Date | string\n  }\n\n  export type todo_app_todosUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_app_todo_snapshots?: todo_app_todo_snapshotsUpdateManyWithoutTodoNestedInput\n  }\n\n  export type todo_app_todosUncheckedUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_app_todo_snapshots?: todo_app_todo_snapshotsUncheckedUpdateManyWithoutTodoNestedInput\n  }\n\n  export type todo_app_todosUncheckedUpdateManyWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    description?: NullableStringFieldUpdateOperationsInput | string | null\n    is_completed?: BoolFieldUpdateOperationsInput | boolean\n    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    position?: NullableIntFieldUpdateOperationsInput | number | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_app_audit_recordsUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    actor_role?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    target_resource?: StringFieldUpdateOperationsInput | string\n    target_id?: NullableStringFieldUpdateOperationsInput | string | null\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    admin?: todo_app_adminUpdateOneWithoutTodo_app_audit_recordsNestedInput\n  }\n\n  export type todo_app_audit_recordsUncheckedUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    admin_id?: NullableStringFieldUpdateOperationsInput | string | null\n    actor_role?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    target_resource?: StringFieldUpdateOperationsInput | string\n    target_id?: NullableStringFieldUpdateOperationsInput | string | null\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_app_audit_recordsUncheckedUpdateManyWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    admin_id?: NullableStringFieldUpdateOperationsInput | string | null\n    actor_role?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    target_resource?: StringFieldUpdateOperationsInput | string\n    target_id?: NullableStringFieldUpdateOperationsInput | string | null\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_app_audit_recordsCreateManyAdminInput = {\n    id: string\n    user_id?: string | null\n    actor_role: string\n    action_type: string\n    target_resource: string\n    target_id?: string | null\n    reason?: string | null\n    created_at: Date | string\n  }\n\n  export type todo_app_audit_recordsUpdateWithoutAdminInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    actor_role?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    target_resource?: StringFieldUpdateOperationsInput | string\n    target_id?: NullableStringFieldUpdateOperationsInput | string | null\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: todo_app_userUpdateOneWithoutTodo_app_audit_recordsNestedInput\n  }\n\n  export type todo_app_audit_recordsUncheckedUpdateWithoutAdminInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: NullableStringFieldUpdateOperationsInput | string | null\n    actor_role?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    target_resource?: StringFieldUpdateOperationsInput | string\n    target_id?: NullableStringFieldUpdateOperationsInput | string | null\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_app_audit_recordsUncheckedUpdateManyWithoutAdminInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: NullableStringFieldUpdateOperationsInput | string | null\n    actor_role?: StringFieldUpdateOperationsInput | string\n    action_type?: StringFieldUpdateOperationsInput | string\n    target_resource?: StringFieldUpdateOperationsInput | string\n    target_id?: NullableStringFieldUpdateOperationsInput | string | null\n    reason?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n\n\n  /**\n   * Batch Payload for updateMany & deleteMany & createMany\n   */\n\n  export type BatchPayload = {\n    count: number\n  }\n\n  /**\n   * DMMF\n   */\n  export const dmmf: runtime.BaseDMMF\n}","node_modules/.prisma/client/runtime/client.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/index-browser.d.ts":"declare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\ndeclare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\ndeclare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\ndeclare type Narrowable = string | number | bigint | boolean | [];\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\ndeclare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/library.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/wasm.d.ts":"export * from \"./default\"","node_modules/@prisma/client/index.d.ts":"export * from '.prisma/client/default'"},"document":"# Prisma Markdown\n\n> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)\n\n- [Todos](#todos)\n\n## Todos\n\n```mermaid\nerDiagram\n\"todo_app_todos\" {\n  String id PK\n  String user_id FK\n  String title\n  String description \"nullable\"\n  Boolean is_completed\n  DateTime completed_at \"nullable\"\n  Int position \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"todo_app_todo_snapshots\" {\n  String id PK\n  String todo_app_todo_id FK\n  String title\n  String description \"nullable\"\n  Boolean is_completed\n  DateTime completed_at \"nullable\"\n  Int position \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n  DateTime snapshot_at\n}\n\"todo_app_audit_records\" {\n  String id PK\n  String admin_id FK \"nullable\"\n  String user_id FK \"nullable\"\n  String actor_role\n  String action_type\n  String target_resource\n  String target_id \"nullable\"\n  String reason \"nullable\"\n  DateTime created_at\n}\n\"todo_app_guest\" {\n  String id PK\n  String email \"nullable\"\n  DateTime created_at\n  DateTime last_active_at \"nullable\"\n  String status \"nullable\"\n}\n\"todo_app_user\" {\n  String id PK\n  String email UK\n  String display_name \"nullable\"\n  String password_hash \"nullable\"\n  String account_status\n  DateTime created_at\n  DateTime updated_at\n  DateTime last_active_at \"nullable\"\n}\n\"todo_app_admin\" {\n  String id PK\n  String email UK\n  String password_hash \"nullable\"\n  Boolean is_super\n  DateTime created_at\n  DateTime last_active_at \"nullable\"\n}\n\"todo_app_todos\" }o--|| \"todo_app_user\" : user\n\"todo_app_todo_snapshots\" }o--|| \"todo_app_todos\" : todo\n\"todo_app_audit_records\" }o--o| \"todo_app_admin\" : admin\n\"todo_app_audit_records\" }o--o| \"todo_app_user\" : user\n```\n\n### `todo_app_todos`\n\nPrimary Todo items for the minimal Todo app. Stores raw task data for\nquick capture and lifecycle management (active, completed, deleted). Each\ntodo is owned by a user (owner) to ensure data isolation. Temporal fields\nsupport audit and soft-delete semantics. Related snapshots are captured\nin {@\\link todo_app_todo_snapshots.id}.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `user_id`: Owner user. {@\\link todo_app_user.id}.\n- `title`\n  > Short task title. Required business field used for display and quick\n  > capture.\n- `description`: Optional longer description or notes for the todo item.\n- `is_completed`: Whether the todo is completed. Used for filtering and UI state.\n- `completed_at`: Timestamp when the todo was marked completed. Null if not completed.\n- `position`: Optional manual ordering position used by client for custom sort orders.\n- `created_at`: Record creation timestamp.\n- `updated_at`: Record last modification timestamp.\n- `deleted_at`: Soft-delete timestamp. Null when item is active or completed.\n\n### `todo_app_todo_snapshots`\n\nSnapshot history for todos. Captures point-in-time copies of a todo item\nfor audit and historical queries. Each snapshot references the source\n{@\\link todo_app_todos.id} and records snapshot_at when the snapshot was\ntaken.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `todo_app_todo_id`: Referenced todo item. {@\\link todo_app_todos.id}.\n- `title`: Snapshot of todo.title at snapshot time.\n- `description`: Snapshot of todo.description at snapshot time.\n- `is_completed`: Snapshot of completion flag at snapshot time.\n- `completed_at`: Snapshot of completed_at (if set on source).\n- `position`: Snapshot of position for ordering.\n- `created_at`: Original created_at from source todo at snapshot time.\n- `updated_at`: Original updated_at from source todo at snapshot time.\n- `deleted_at`: Original deleted_at from source todo at snapshot time.\n- `snapshot_at`: Timestamp when this snapshot was created.\n\n### `todo_app_audit_records`\n\nAppend-only audit records for administrative and system actions. Records\nactor (admin or system), action type, target resource, optional reason,\nand timestamp for forensic and compliance purposes. Actor references are\nnullable to preserve system-initiated events. Foreign-key delete behavior\nmust not cascade to preserve audit history.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `admin_id`: Acting admin's {@\\link todo_app_admin.id}. Nullable for system actions.\n- `user_id`\n  > Referenced user affected by the action. {@\\link todo_app_user.id}.\n  > Nullable when not applicable.\n- `actor_role`: Role of the actor performing the action (e.g., 'admin','system').\n- `action_type`: Type of action performed (e.g., 'suspend_user','restore_todo','purge').\n- `target_resource`: Logical resource type affected by the action (e.g., 'todo','user').\n- `target_id`\n  > Optional identifier of the target resource (e.g., todo id) for quick\n  > lookup.\n- `reason`: Optional reason provided by the actor for the action.\n- `created_at`: Timestamp when the audit record was created.\n\n### `todo_app_guest`\n\nLightweight record for unauthenticated or ephemeral visitors. Kept\nminimal per component guidance; useful for analytics or short-term\nsession tracking. Managed as a subsidiary support table.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`: Optional visitor-provided email address (nullable).\n- `created_at`: Record creation timestamp for the guest entry.\n- `last_active_at`: Last observed activity for the guest (nullable).\n- `status`\n  > Optional status for administrative housekeeping (e.g.,\n  > 'active','bounced').\n\n### `todo_app_user`\n\nUser accounts for the application. Users are independently managed\nbusiness entities (registration, authentication, profile). This model is\nintentionally included but todos do not require a mandatory user relation\nin this MVP shape.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`: Primary email for the user account. Used for login and communication.\n- `display_name`: Optional display name for the user.\n- `password_hash`: Password hash for authentication (nullable if external auth used).\n- `account_status`: Account lifecycle status (e.g., 'active','suspended').\n- `created_at`: Account creation timestamp.\n- `updated_at`: Last update timestamp for the account.\n- `last_active_at`: Last activity timestamp (nullable).\n\n### `todo_app_admin`\n\nAdministrative accounts with elevated privileges used for support and\nmaintenance. Admin actions are audited in {@\\link\ntodo_app_audit_records.id}. This model is primary since admins require\nindependent management and auditability.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`: Admin account email used for login and notifications.\n- `password_hash`: Password hash for admin authentication (nullable if external SSO used).\n- `is_super`: Flag indicating super-admin privileges.\n- `created_at`: Admin account creation timestamp.\n- `last_active_at`: Last activity timestamp for the admin (nullable).\n","diagrams":{"Todos":"```mermaid\nerDiagram\n\"todo_app_todos\" {\n  String id PK\n  String user_id FK\n  String title\n  String description \"nullable\"\n  Boolean is_completed\n  DateTime completed_at \"nullable\"\n  Int position \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"todo_app_todo_snapshots\" {\n  String id PK\n  String todo_app_todo_id FK\n  String title\n  String description \"nullable\"\n  Boolean is_completed\n  DateTime completed_at \"nullable\"\n  Int position \"nullable\"\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n  DateTime snapshot_at\n}\n\"todo_app_audit_records\" {\n  String id PK\n  String admin_id FK \"nullable\"\n  String user_id FK \"nullable\"\n  String actor_role\n  String action_type\n  String target_resource\n  String target_id \"nullable\"\n  String reason \"nullable\"\n  DateTime created_at\n}\n\"todo_app_guest\" {\n  String id PK\n  String email \"nullable\"\n  DateTime created_at\n  DateTime last_active_at \"nullable\"\n  String status \"nullable\"\n}\n\"todo_app_user\" {\n  String id PK\n  String email UK\n  String display_name \"nullable\"\n  String password_hash \"nullable\"\n  String account_status\n  DateTime created_at\n  DateTime updated_at\n  DateTime last_active_at \"nullable\"\n}\n\"todo_app_admin\" {\n  String id PK\n  String email UK\n  String password_hash \"nullable\"\n  Boolean is_super\n  DateTime created_at\n  DateTime last_active_at \"nullable\"\n}\n\"todo_app_todos\" }o--|| \"todo_app_user\" : user\n\"todo_app_todo_snapshots\" }o--|| \"todo_app_todos\" : todo\n\"todo_app_audit_records\" }o--o| \"todo_app_admin\" : admin\n\"todo_app_audit_records\" }o--o| \"todo_app_user\" : user\n```"}},"created_at":"2025-10-07T18:48:40.593Z","completed_at":"2025-10-07T18:52:26.130Z","step":0},{"id":"0199c004-8938-751a-9c8e-7e13f089339b","type":"userMessage","contents":[{"type":"text","text":"Create the API interface specification."}],"created_at":"2025-10-07T18:52:26.808Z"},{"type":"interface","id":"0199c03f-704b-72f3-85c8-3ef7bdc9f81d","instruction":"Create an API interface specification for a minimal single-user Todo list application. Only include the API/interface-specific details (endpoints, HTTP methods, request/response shapes, status codes, and basic validation rules). Do NOT include database schema or implementation logic. Keep the design minimal — only the essential endpoints to manage Todos. Constraints and assumptions:\n\n- Single-user app (no authentication or multi-user features).\n- JSON over HTTP, RESTful style for simplicity.\n- Minimal set of fields for a Todo: id (UUID), title (string), description (string, optional), isCompleted (boolean), createdAt (ISO 8601 datetime), updatedAt (ISO 8601 datetime), position (integer, optional).\n- Use standard HTTP status codes (200, 201, 204, 400, 404, 500).\n- Support partial updates for Todo (PATCH) to change any of title, description, isCompleted, position.\n- Provide a simple list endpoint with optional filtering by isCompleted and optional sorting by createdAt or position.\n- Keep request/response examples small and easy to understand for non-technical users.\n\nDeliverables expected from the Interface agent:\n- A concise OpenAPI-style summary (endpoint, method, path, brief description, request body schema, response schema, status codes) for each endpoint.\n- DTO (request/response) field definitions for each relevant operation (name, type, required/optional, brief description). Keep DTOs minimal and focused on the fields above.\n- Basic error response schema used across endpoints.\n- Notes about validations for fields (e.g., title required, title non-empty, isCompleted boolean, position integer).\n\nEndpoints to design (minimal):\n- List Todos: GET /todos\n- Create Todo: POST /todos\n- Get Todo by ID: GET /todos/{id}\n- Update Todo (partial): PATCH /todos/{id}\n- Delete Todo: DELETE /todos/{id}\n\nDo NOT add authentication endpoints or user management. Do NOT add batch operations, tagging, due dates, priority, or sharing features. If any decision is left ambiguous, list the question(s) at the end for the user to confirm.","authorizations":[{"role":"guest","operations":[{"specification":"Create a temporary guest entry and issue initial temporary tokens. This operation writes to the Prisma table `todo_app_guest` and creates a new row with server-managed `id` (UUID), optional `email`, and timestamps such as `created_at`. The operation is intended to support unauthenticated visitors who need short-lived persistence or temporary identity for client-side workflows.","authorizationType":"join","description":"Purpose and functionality:\nThis endpoint allows an unauthenticated visitor to create a temporary guest record in the `todo_app_guest` table. The API accepts an optional `email` (if provided by the client) and the server will create a new record with a system-assigned `id` (UUID) and set `created_at`. The returned response contains an authorization payload (short-lived tokens) suitable for guest workflows.\n\nImplementation details using confirmed schema fields:\nThe request maps directly to fields present in the Prisma model `todo_app_guest`. Specifically, provided `email` maps to `todo_app_guest.email`. The server will set `todo_app_guest.id` (UUID) and `todo_app_guest.created_at` (timestamp). The server may also initialize `todo_app_guest.status` and leave `last_active_at` null until the guest performs subsequent activity.\n\nRole-specific integration and business context:\nThis operation is a public join endpoint for the role 'guest' and is intended to be used in client flows that need temporary identity without full user registration. Because the `email` column in `todo_app_guest` is nullable in the schema, the request may omit `email` to create an anonymous guest record. The response follows the authorization response naming convention and returns `ITodoAppGuest.IAuthorized` as the successful response type.\n\nSecurity considerations within schema constraints:\nValidate the optional `email` format when present (RFC 5322 basic validation) and rate-limit join attempts to prevent abuse. Do not store additional user credentials in `todo_app_guest.password` because that field does not exist. Keep issued tokens short-lived and tie refresh operations to the guest `id` and `last_active_at` lifecycle.\n\nRelated operations and workflow integration:\nThis operation pairs with `POST /auth/guest/refresh` which can update `todo_app_guest.last_active_at` and may create audit entries in `todo_app_audit_records` (for example, recording refresh events using `todo_app_audit_records.actor_role`, `action_type`, `target_resource`, `target_id`, and `created_at`).","summary":"Create a guest record in the todo_app_guest table and issue temporary authorization tokens.","parameters":[],"requestBody":{"description":"Guest registration payload. Maps to `todo_app_guest.email` (nullable). If omitted, an anonymous guest record is created.","typeName":"ITodoAppGuest.IJoin"},"responseBody":{"description":"Authorized response containing temporary access (and refresh) tokens for the guest role. Follows the authentication response naming convention for the service prefix.","typeName":"ITodoAppGuest.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/guest/join","method":"post"},{"specification":"Refresh short-lived access tokens for a guest identity. This operation updates activity metadata for the guest in `todo_app_guest` (notably `last_active_at`) and may record an audit event in `todo_app_audit_records` for tracking refresh activity.","authorizationType":"refresh","description":"Purpose and functionality:\nThis endpoint accepts a valid guest refresh credential and issues a new short-lived access token (and optionally rotates the refresh token). It targets the `todo_app_guest` table so that guest activity can be associated with the `id` and `last_active_at` fields.\n\nImplementation details using confirmed schema fields:\nOn successful validation of the presented refresh credential, the server SHOULD update `todo_app_guest.last_active_at` to the current server timestamp and may record the refresh event in `todo_app_audit_records` by populating `actor_role` (e.g., 'system' or 'guest'), `action_type` (e.g., 'refresh_token'), `target_resource` = 'guest', `target_id` = the guest `id`, and `created_at` to capture the event time.\n\nRole-specific integration and business context:\nThis operation is role-restricted: it requires a valid refresh credential tied to a previously created guest (role = 'guest'). The API path `/auth/guest/refresh` follows the service naming conventions for guest token lifecycle management and returns `ITodoAppGuest.IAuthorized` on success, matching the service prefix and role naming pattern.\n\nSecurity considerations within schema constraints:\nRotate refresh tokens when practical and invalidate refresh tokens upon abuse detection. Because `todo_app_guest.password_hash` does not exist in the schema, do not attempt password-based verification for guests; instead rely on token material. Record refresh attempts and consider rate-limiting per guest `id` to reduce token replay risk.\n\nRelated operations and workflow integration:\nThis operation complements `/auth/guest/join` (which issues initial tokens) and may be followed by guest-scoped API calls. Audit entries for refresh events can be stored in `todo_app_audit_records` (fields: `actor_role`, `action_type`, `target_resource`, `target_id`, `created_at`) to help operations and security teams investigate token usage patterns.","summary":"Exchange a valid guest refresh credential for a new access token and update guest activity metadata in todo_app_guest.","parameters":[],"requestBody":{"description":"Refresh request payload. Contains the refresh credential/token associated with a guest identity. Server will validate and rotate as appropriate.","typeName":"ITodoAppGuest.IRefresh"},"responseBody":{"description":"Authorized response containing a renewed access token and optional rotated refresh token for the guest session.","typeName":"ITodoAppGuest.IAuthorized"},"authorizationRole":"guest","name":"refresh","prerequisites":[],"path":"/auth/guest/refresh","method":"post"}]},{"role":"user","operations":[{"specification":"This operation creates a new user account for the Todo application. It is associated with the Prisma table `todo_app_user`. The endpoint accepts register information (email, optional display_name, and password) and creates a new row in the `todo_app_user` table with fields `email`, `display_name`, `password_hash` (set by server after hashing), `account_status`, `created_at`, and `updated_at`. The operation will validate the email uniqueness (enforced by @@unique([email]) in schema) and will set initial account_status (e.g., 'active' or 'unverified') per product policy. On success the operation returns an authorization response including issued tokens and a representation of the authenticated user (the authorized response type includes token(s) and selected user fields).","authorizationType":"join","description":"Purpose and overview: This endpoint registers a new user and persists a new record in the `todo_app_user` table. It uses the table's `email` field as the primary unique identifier for account creation and will cause a new `todo_app_user` row to be created with server-calculated `password_hash`, `created_at`, and `updated_at` values.\n\nImplementation details and required fields: The request must supply an `email` and a plaintext password (or equivalent credential material). The server implementation will compute and store `password_hash` in the `todo_app_user.password_hash` column and will enforce the unique constraint on `todo_app_user.email` (@@unique([email]) in the Prisma schema). The server will populate `created_at` and `updated_at` timestamps on the new row and initialize `account_status` according to product policy (for example, 'active' or 'unverified').\n\nRole-specific integration and business context: Registration is a public operation (no prior authentication required). The created user record is the same entity referenced by todo rows via `todo_app_todos.user_id`, enabling the app to later associate todos to this account. The operation ties into audit/auditing flows when admin review is required (audit entries may be created in `todo_app_audit_records` by administrative processes, not by this public join operation).\n\nSecurity considerations: The server MUST never store plaintext passwords; instead it MUST produce a secure `password_hash` and store it in `todo_app_user.password_hash`. Email uniqueness is enforced by the Prisma schema unique constraint on `email`; the server MUST handle duplicate-email errors gracefully. Returned tokens should be short-lived access tokens (for example, JWT) with a refresh token mechanism; the `todo_app_user.last_active_at` and `todo_app_user.updated_at` columns may be updated on successful immediate authentication after registration.\n\nRelated operations and workflow integration: Typical next operations after successful join are `login` (if the server requires explicit login after verification) and `refresh` to renew tokens. If email verification is enabled by product policy, the server may create an out-of-band verification flow; note that there is no explicit `email_verified` column in `todo_app_user` in the Prisma schema, so verification state must be represented within `account_status` or an external store.","summary":"Register a new TodoApp user (creates a row in todo_app_user)","parameters":[],"requestBody":{"description":"Registration payload for creating a new user account. Contains a valid email and plaintext password. Optional display_name may be included.","typeName":"ITodoAppUser.ICreate"},"responseBody":{"description":"Authorized response returned after successful registration. Contains issued authorization tokens and user summary fields.","typeName":"ITodoAppUser.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/user/join","method":"post"},{"specification":"This operation authenticates an existing user in the `todo_app_user` table. It validates provided credentials (email + password) against `todo_app_user.email` and `todo_app_user.password_hash`. On successful authentication the server issues authorization tokens and may update `todo_app_user.last_active_at` and `todo_app_user.updated_at` to reflect recent activity. The operation returns an authorized response containing the issued tokens and selected user fields.","authorizationType":"login","description":"Purpose and overview: This endpoint authenticates a user record from the `todo_app_user` table. It uses `email` to locate the account and verifies secrets against `todo_app_user.password_hash`. Successful authentication results in issuance of authorization material (access token and refresh token) and a response representing the authenticated user.\n\nImplementation details and required fields: Request must include `email` and password. The server will check `todo_app_user.email` (unique by schema) and verify the secret against `todo_app_user.password_hash`. On success the server SHOULD update `todo_app_user.last_active_at` and `todo_app_user.updated_at` to reflect activity and may set or confirm `account_status` (for example, deny login when `account_status` is 'suspended').\n\nRole-specific integration and business context: Login is a public operation used to obtain session tokens that allow management of todos owned by the authenticated user (todos are associated via `todo_app_todos.user_id`). The tokens returned by this endpoint are used by subsequent protected operations.\n\nSecurity considerations: Implement strong rate limiting for failed login attempts and ensure errors do not leak whether an email exists. Because the Prisma schema contains `password_hash` but not refresh-token storage columns, refresh token lifecycle may be managed by a dedicated token store external to the `todo_app_user` table; however `todo_app_user.updated_at` and `todo_app_user.last_active_at` are available within the schema to record activity.\n\nRelated operations and workflow integration: Typical complementary operations include `refresh` to renew an access token and `changePassword` (authenticated) to update `todo_app_user.password_hash` for the account. Admin suspend/reactivate actions also interact with `todo_app_user.account_status` (managed by admin flows recorded in `todo_app_audit_records`).","summary":"Authenticate a TodoApp user (login against todo_app_user)","parameters":[],"requestBody":{"description":"Login payload containing `email` and `password` to authenticate an existing user.","typeName":"ITodoAppUser.ILogin"},"responseBody":{"description":"Authorized response including access and refresh tokens along with a user summary.","typeName":"ITodoAppUser.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/user/login","method":"post"},{"specification":"This operation refreshes an access token for a user associated with the `todo_app_user` table. It accepts a refresh token and issues a new access token (and optionally a new refresh token) for the associated user. The operation may update `todo_app_user.last_active_at` and `todo_app_user.updated_at` to indicate continued activity. The Prisma `todo_app_user` table provides the user identity fields used to associate the refreshed session with the correct account.","authorizationType":"refresh","description":"Purpose and overview: This endpoint renews an access token using a valid refresh token for a user record that exists in `todo_app_user`. The refresh flow ties the presented refresh token to the user identity so the server can return a fresh access token and possibly rotate the refresh token.\n\nImplementation details and required fields: Request payload should include a valid refresh token. Because the Prisma schema does not include an explicit refresh-token storage column, refresh token management is typically implemented using a separate token store; however the operation will still update `todo_app_user.last_active_at` and `todo_app_user.updated_at` to reflect the renewed session activity for auditing and presence metrics.\n\nRole-specific integration and business context: Refresh is a public endpoint that accepts a valid refresh token to provide continued authenticated access without re-entering credentials. The refreshed tokens continue to permit operations on `todo_app_todos` rows owned by the user (via `todo_app_todos.user_id`).\n\nSecurity considerations: Ensure refresh tokens are rotated or invalidated on logout or account suspension (check and propagate `todo_app_user.account_status` to deny refresh when suspended). Monitor and record suspicious refresh activity in `todo_app_audit_records` when appropriate.\n\nRelated operations and workflow integration: `refresh` is commonly used after `login` and before protected operations; it complements `join` and `login` flows and should be part of the token lifecycle design alongside revocation and rotation strategies.","summary":"Refresh access token for a TodoApp user (ties to todo_app_user identity)","parameters":[],"requestBody":{"description":"Refresh request containing a valid refresh token to obtain a new access token.","typeName":"ITodoAppUser.IRefresh"},"responseBody":{"description":"Authorized response containing new access token (and optionally rotated refresh token) and user summary.","typeName":"ITodoAppUser.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/user/refresh","method":"post"},{"specification":"This operation allows an authenticated user (from `todo_app_user`) to change their account password. It updates the `todo_app_user.password_hash` column and sets `todo_app_user.updated_at` (and optionally `todo_app_user.last_active_at`) to reflect the change. This operation is associated with the `todo_app_user` table and requires the requesting actor to be authenticated as the user being modified.","authorizationType":null,"description":"Purpose and overview: This authenticated endpoint enables a user to change their password. It targets the `todo_app_user` record and updates `password_hash` after verifying the current secret (if required) or validating a password-reset flow. The server updates `todo_app_user.updated_at` after successfully changing the stored `password_hash`.\n\nImplementation details and required fields: The request must be authenticated as the user whose password is being changed. The payload typically includes the `currentPassword` and `newPassword` (or a reset token in alternative flows). Upon verification, the server computes a new secure `password_hash` and writes it to `todo_app_user.password_hash`. The server MUST update `todo_app_user.updated_at` and may update `todo_app_user.last_active_at` as part of session continuity.\n\nRole-specific integration and business context: This operation is restricted to the `user` role and supports the security hygiene for accounts created in `todo_app_user`. Because the Prisma schema includes `password_hash`, the table supports password-based authentication and updates to that field.\n\nSecurity considerations: The server MUST verify the requester is the owner of the account and MUST re-authenticate or verify the current credential before changing the password, unless this endpoint is used with a validated password-reset token flow. Passwords MUST be hashed before storage. Admins changing user passwords for support purposes SHOULD create an entry in `todo_app_audit_records` to record the admin action (admin_id, action_type='change_password', target_id=user_id, reason).\n\nRelated operations and workflow integration: This operation complements `login` and `refresh`. A password change SHOULD invalidate or rotate refresh tokens depending on security policy and SHOULD be recorded for auditing if performed by an admin.","summary":"Change authenticated user's password (updates todo_app_user.password_hash)","parameters":[],"requestBody":{"description":"Authenticated password-change payload containing current and new password values (or reset token + new password).","typeName":"ITodoAppUser.IChangePassword"},"responseBody":{"description":"Profile-style response confirming update; returns key user fields (email, display_name, account_status, updated_at).","typeName":"ITodoAppUser.IProfile"},"authorizationRole":"user","name":"changePassword","prerequisites":[],"path":"/auth/user/change-password","method":"put"}]},{"role":"admin","operations":[{"specification":"This operation creates a new administrator account and issues initial authorization tokens. It is associated with the Prisma table `todo_app_admin` and uses fields on that table for account identity and initial state. The operation will insert a new row into `todo_app_admin` (populating at least `email`, `password_hash`, and `is_super` as applicable) and may create an initial audit record in `todo_app_audit_records` to record the account creation event for compliance purposes.","authorizationType":"join","description":"Purpose and overview:\nThis endpoint registers a new administrator account for the system and issues an initial authorized response payload. It is explicitly tied to the Prisma model `todo_app_admin` and will rely on the `email`, `password_hash`, `is_super`, `created_at`, and `last_active_at` fields on that table to represent account identity and state.\n\nImplementation details and required fields:\nWhen called, the implementation will validate the provided `email` and password, persist the new `todo_app_admin` row (setting `email` and, after hashing, `password_hash`) and set the initial `created_at` and `last_active_at` timestamps. If elevated privileges are required for the account, `is_super` may be set per the request. The response payload uses tokens and the admin summary, but token persistence or revocation mechanism is implementation specific and not assumed to be a column on `todo_app_admin`.\n\nRole-specific integration:\nThis endpoint is the public entry point for creating admin accounts. It should ensure the `email` value is unique (the Prisma model defines `@@unique([email])`) and must fail cleanly if a duplicate `email` exists. As part of the workflow, an audit entry may be recorded in `todo_app_audit_records` referencing the created admin (`admin_id`) with `action_type` like `create_admin` to satisfy compliance and traceability.\n\nSecurity considerations:\nPasswords MUST be hashed before storing in `password_hash` and never returned in responses. The implementation must not expose `password_hash` in any response. All audit actions related to account creation SHOULD be recorded in `todo_app_audit_records` (fields available: `admin_id`, `actor_role`, `action_type`, `target_resource`, `target_id`, `created_at`). Use secure transport (HTTPS) and apply rate limiting to prevent abuse.\n\nRelated operations and workflow integration:\nThis operation complements `POST /auth/admin/login` (to obtain access tokens) and `POST /auth/admin/refresh` (to refresh tokens). After creation, the caller is expected to use the issued tokens from this response (see response schema) to authenticate subsequent admin-only endpoints. If email verification is required by policy, the implementation should create an initial unverified state and record this in `todo_app_audit_records`.","summary":"Create a new admin account (todo_app_admin)","parameters":[],"requestBody":{"description":"Registration payload for a new admin account.","typeName":"ITodoAppAdmin.ICreate"},"responseBody":{"description":"Authorized response containing access and refresh tokens and a minimal admin summary.","typeName":"ITodoAppAdmin.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/admin/join","method":"post"},{"specification":"This operation authenticates an administrator against the `todo_app_admin` table. It validates credentials (matching `email` against the unique index on `todo_app_admin.email` and verifying the supplied password against `password_hash`) and issues authorization tokens. Login attempts and important authentication events may be recorded into `todo_app_audit_records` for traceability.","authorizationType":"login","description":"Purpose and overview:\nThis endpoint authenticates an administrator by validating supplied credentials against the `todo_app_admin` model. It references the `email` (unique) column and compares the supplied password to the stored `password_hash` field before issuing tokens. Successful authentication may update `last_active_at` on the `todo_app_admin` row.\n\nImplementation details and validation:\nThe implementation MUST validate that the provided `email` exists in `todo_app_admin`. Password verification must compare the supplied secret to the `password_hash` using secure hash verification (e.g., bcrypt/argon2). On success, the implementation may update `last_active_at` to the current timestamp and optionally create an audit record in `todo_app_audit_records` with `action_type` such as `admin_login` and `actor_role` set to `admin`.\n\nRole-specific integration and behavior:\nThis is a public authentication endpoint that issues an `ITodoAppAdmin.IAuthorized` response containing short-lived access credentials and a refresh credential. The caller uses these tokens for subsequent admin-scoped API calls. The operation should respect account status (the `account_status` field on `todo_app_user` exists for users; for admins the `todo_app_admin` model has `is_super` and timestamps — implementors may add an `account_status` equivalent if needed, but do not assume it exists by default on `todo_app_admin`).\n\nSecurity considerations:\nDo NOT include `password_hash` in any response. Failed login attempts SHOULD be logged to `todo_app_audit_records` with `action_type` like `admin_login_failed` to support monitoring and abuse detection. Apply rate limits and account lockout policies at higher layers.\n\nRelated operations:\nAfter successful login, the issued tokens are expected to be used with `POST /auth/admin/refresh` to renew short-lived access tokens and with admin-protected endpoints that require `authorizationRole: \"admin\"` such as password change or administrative maintenance actions.","summary":"Authenticate admin and issue tokens (todo_app_admin)","parameters":[],"requestBody":{"description":"Login payload: admin email and password.","typeName":"ITodoAppAdmin.ILogin"},"responseBody":{"description":"Authorized response containing access and refresh tokens and a minimal admin summary.","typeName":"ITodoAppAdmin.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/admin/login","method":"post"},{"specification":"This operation refreshes access credentials for an authenticated administrator. It is part of token lifecycle management and is related to admin session handling; the operation is not directly backed by a specific `todo_app_admin` column for tokens (no token columns exist in the Prisma model), but refresh events and revocation attempts SHOULD be recorded in `todo_app_audit_records` for traceability.","authorizationType":"refresh","description":"Purpose and overview:\nThis endpoint accepts a valid refresh credential and issues a new short-lived access token (and optionally a new refresh token). While `todo_app_admin` does not store token values in any specific column, the operation is semantically tied to admin sessions for accounts represented by `todo_app_admin.id` and `todo_app_admin.email`.\n\nImplementation details and security:\nThe implementation must validate the presented refresh credential according to the chosen session/token architecture. Because the Prisma schema does not include dedicated token storage fields, token persistence and revocation logic is an implementation concern; however, all refresh operations SHOULD be recorded to `todo_app_audit_records` (e.g., `action_type = refresh_token_used`, `target_id = admin id`) to support auditability.\n\nRole-specific integration:\nThis is a public endpoint in the auth flow (clients call it with a refresh credential). On successful refresh, the response returns the same `ITodoAppAdmin.IAuthorized` shape used for login / join so that clients have a consistent authorized payload. The server SHOULD update `last_active_at` for the related `todo_app_admin` row when appropriate.\n\nSecurity considerations:\nRefresh tokens SHOULD be revocable (server-side blacklist or rotating refresh tokens). Revocation and revocation attempts SHOULD be logged to `todo_app_audit_records` with appropriate `actor_role` and `action_type` so that administrators can trace suspicious activity.\n\nRelated operations:\nWorks together with `POST /auth/admin/login` (initial issuance) and admin session revocation endpoints (not included here).","summary":"Refresh admin access token","parameters":[],"requestBody":{"description":"Payload containing the refresh credential for token renewal.","typeName":"ITodoAppAdmin.IRefresh"},"responseBody":{"description":"Authorized response containing new access (and optionally refresh) tokens.","typeName":"ITodoAppAdmin.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/admin/refresh","method":"post"},{"specification":"This operation initiates a password-reset flow for an administrator account identified by email. It references the `todo_app_admin` table (field `email`) to locate the target account. Because the Prisma schema does not include a dedicated reset token column on `todo_app_admin`, implementations commonly emit a time-limited token via email and record the request in `todo_app_audit_records` for traceability.","authorizationType":null,"description":"Purpose and overview:\nThis endpoint starts a password reset workflow for an admin identified by `email` (the `todo_app_admin.email` column). It is used when an admin can no longer authenticate and requires a secure path to re-establish credentials.\n\nImplementation details and required behavior:\nOn receipt of a valid email that maps to an existing `todo_app_admin` row, the implementation SHOULD generate a time-limited reset token (not persisted on `todo_app_admin` by the schema itself) and send it to the provided email address. The operation SHOULD create an audit record in `todo_app_audit_records` with `action_type` like `request_password_reset` and `target_id` set to the admin id to record the event.\n\nRole-specific integration:\nThis is a public endpoint (no prior authentication required). The request MUST NOT disclose whether the email exists in the system in order to avoid user enumeration attacks; instead, the response SHOULD be a generic success message while the server performs any email actions silently.\n\nSecurity considerations:\nEnsure the reset token is single-use and expires promptly (recommended default: 24 hours). Do NOT return reset tokens in the API response. Record all reset initiation attempts in `todo_app_audit_records` for monitoring.\n\nRelated operations:\nA subsequent endpoint (not included here) would accept the token and the new password to complete the reset and update `todo_app_admin.password_hash` accordingly; that operation SHOULD also create an audit record with `action_type`: `complete_password_reset`.","summary":"Initiate admin password reset (todo_app_admin.email)","parameters":[],"requestBody":{"description":"Payload containing the admin email to initiate a password reset.","typeName":"ITodoAppAdmin.IRequestPasswordReset"},"responseBody":{"description":"Generic operation result message (do not disclose whether account exists).","typeName":"ITodoAppAdmin.IMessage"},"authorizationRole":null,"name":"requestPasswordReset","prerequisites":[],"path":"/auth/admin/password/reset","method":"post"},{"specification":"This operation allows an authenticated administrator to change their password. It updates the `password_hash` column on the `todo_app_admin` row for the authenticated admin and records the change in `todo_app_audit_records` for traceability (e.g., `action_type` = `change_password`).","authorizationType":null,"description":"Purpose and overview:\nThis endpoint enables an authenticated admin to change their password. It targets the `todo_app_admin` record for the calling admin (fields: `id`, `email`, `password_hash`, `last_active_at`) and updates `password_hash` with a new hashed secret.\n\nImplementation details and validation:\nThe endpoint requires the caller to be authenticated as an admin (`authorizationRole: \"admin\"`). It should verify the caller's current credential or session and validate the new password against password policy before hashing and storing it in `password_hash`. Upon success, the implementation SHOULD update `updated_at` and optionally `last_active_at` on the `todo_app_admin` row.\n\nSecurity considerations:\nDo NOT log the plain-text password. Record the password change action in `todo_app_audit_records` with `action_type` such as `change_password` and include the `admin_id` and timestamp. Consider revoking outstanding refresh tokens or sessions after a password change to reduce risk.\n\nRelated operations:\nThis operation complements `POST /auth/admin/password/reset` (reset flow) and token refresh endpoints. It is restricted to authenticated admins and must be audited.","summary":"Change authenticated admin password (todo_app_admin.password_hash)","parameters":[],"requestBody":{"description":"Payload containing current credential proof and the new password.","typeName":"ITodoAppAdmin.IChangePassword"},"responseBody":{"description":"Operation result message confirming password change.","typeName":"ITodoAppAdmin.IMessage"},"authorizationRole":"admin","name":"changePassword","prerequisites":[],"path":"/auth/admin/password/change","method":"put"}]}],"document":{"operations":[{"specification":"Create a temporary guest entry and issue initial temporary tokens. This operation writes to the Prisma table `todo_app_guest` and creates a new row with server-managed `id` (UUID), optional `email`, and timestamps such as `created_at`. The operation is intended to support unauthenticated visitors who need short-lived persistence or temporary identity for client-side workflows.","authorizationType":"join","description":"Purpose and functionality:\nThis endpoint allows an unauthenticated visitor to create a temporary guest record in the `todo_app_guest` table. The API accepts an optional `email` (if provided by the client) and the server will create a new record with a system-assigned `id` (UUID) and set `created_at`. The returned response contains an authorization payload (short-lived tokens) suitable for guest workflows.\n\nImplementation details using confirmed schema fields:\nThe request maps directly to fields present in the Prisma model `todo_app_guest`. Specifically, provided `email` maps to `todo_app_guest.email`. The server will set `todo_app_guest.id` (UUID) and `todo_app_guest.created_at` (timestamp). The server may also initialize `todo_app_guest.status` and leave `last_active_at` null until the guest performs subsequent activity.\n\nRole-specific integration and business context:\nThis operation is a public join endpoint for the role 'guest' and is intended to be used in client flows that need temporary identity without full user registration. Because the `email` column in `todo_app_guest` is nullable in the schema, the request may omit `email` to create an anonymous guest record. The response follows the authorization response naming convention and returns `ITodoAppGuest.IAuthorized` as the successful response type.\n\nSecurity considerations within schema constraints:\nValidate the optional `email` format when present (RFC 5322 basic validation) and rate-limit join attempts to prevent abuse. Do not store additional user credentials in `todo_app_guest.password` because that field does not exist. Keep issued tokens short-lived and tie refresh operations to the guest `id` and `last_active_at` lifecycle.\n\nRelated operations and workflow integration:\nThis operation pairs with `POST /auth/guest/refresh` which can update `todo_app_guest.last_active_at` and may create audit entries in `todo_app_audit_records` (for example, recording refresh events using `todo_app_audit_records.actor_role`, `action_type`, `target_resource`, `target_id`, and `created_at`).","summary":"Create a guest record in the todo_app_guest table and issue temporary authorization tokens.","parameters":[],"requestBody":{"description":"Guest registration payload. Maps to `todo_app_guest.email` (nullable). If omitted, an anonymous guest record is created.","typeName":"ITodoAppGuest.IJoin"},"responseBody":{"description":"Authorized response containing temporary access (and refresh) tokens for the guest role. Follows the authentication response naming convention for the service prefix.","typeName":"ITodoAppGuest.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/guest/join","method":"post"},{"specification":"Refresh short-lived access tokens for a guest identity. This operation updates activity metadata for the guest in `todo_app_guest` (notably `last_active_at`) and may record an audit event in `todo_app_audit_records` for tracking refresh activity.","authorizationType":"refresh","description":"Purpose and functionality:\nThis endpoint accepts a valid guest refresh credential and issues a new short-lived access token (and optionally rotates the refresh token). It targets the `todo_app_guest` table so that guest activity can be associated with the `id` and `last_active_at` fields.\n\nImplementation details using confirmed schema fields:\nOn successful validation of the presented refresh credential, the server SHOULD update `todo_app_guest.last_active_at` to the current server timestamp and may record the refresh event in `todo_app_audit_records` by populating `actor_role` (e.g., 'system' or 'guest'), `action_type` (e.g., 'refresh_token'), `target_resource` = 'guest', `target_id` = the guest `id`, and `created_at` to capture the event time.\n\nRole-specific integration and business context:\nThis operation is role-restricted: it requires a valid refresh credential tied to a previously created guest (role = 'guest'). The API path `/auth/guest/refresh` follows the service naming conventions for guest token lifecycle management and returns `ITodoAppGuest.IAuthorized` on success, matching the service prefix and role naming pattern.\n\nSecurity considerations within schema constraints:\nRotate refresh tokens when practical and invalidate refresh tokens upon abuse detection. Because `todo_app_guest.password_hash` does not exist in the schema, do not attempt password-based verification for guests; instead rely on token material. Record refresh attempts and consider rate-limiting per guest `id` to reduce token replay risk.\n\nRelated operations and workflow integration:\nThis operation complements `/auth/guest/join` (which issues initial tokens) and may be followed by guest-scoped API calls. Audit entries for refresh events can be stored in `todo_app_audit_records` (fields: `actor_role`, `action_type`, `target_resource`, `target_id`, `created_at`) to help operations and security teams investigate token usage patterns.","summary":"Exchange a valid guest refresh credential for a new access token and update guest activity metadata in todo_app_guest.","parameters":[],"requestBody":{"description":"Refresh request payload. Contains the refresh credential/token associated with a guest identity. Server will validate and rotate as appropriate.","typeName":"ITodoAppGuest.IRefresh"},"responseBody":{"description":"Authorized response containing a renewed access token and optional rotated refresh token for the guest session.","typeName":"ITodoAppGuest.IAuthorized"},"authorizationRole":"guest","name":"refresh","prerequisites":[],"path":"/auth/guest/refresh","method":"post"},{"specification":"This operation creates a new user account for the Todo application. It is associated with the Prisma table `todo_app_user`. The endpoint accepts register information (email, optional display_name, and password) and creates a new row in the `todo_app_user` table with fields `email`, `display_name`, `password_hash` (set by server after hashing), `account_status`, `created_at`, and `updated_at`. The operation will validate the email uniqueness (enforced by @@unique([email]) in schema) and will set initial account_status (e.g., 'active' or 'unverified') per product policy. On success the operation returns an authorization response including issued tokens and a representation of the authenticated user (the authorized response type includes token(s) and selected user fields).","authorizationType":"join","description":"Purpose and overview: This endpoint registers a new user and persists a new record in the `todo_app_user` table. It uses the table's `email` field as the primary unique identifier for account creation and will cause a new `todo_app_user` row to be created with server-calculated `password_hash`, `created_at`, and `updated_at` values.\n\nImplementation details and required fields: The request must supply an `email` and a plaintext password (or equivalent credential material). The server implementation will compute and store `password_hash` in the `todo_app_user.password_hash` column and will enforce the unique constraint on `todo_app_user.email` (@@unique([email]) in the Prisma schema). The server will populate `created_at` and `updated_at` timestamps on the new row and initialize `account_status` according to product policy (for example, 'active' or 'unverified').\n\nRole-specific integration and business context: Registration is a public operation (no prior authentication required). The created user record is the same entity referenced by todo rows via `todo_app_todos.user_id`, enabling the app to later associate todos to this account. The operation ties into audit/auditing flows when admin review is required (audit entries may be created in `todo_app_audit_records` by administrative processes, not by this public join operation).\n\nSecurity considerations: The server MUST never store plaintext passwords; instead it MUST produce a secure `password_hash` and store it in `todo_app_user.password_hash`. Email uniqueness is enforced by the Prisma schema unique constraint on `email`; the server MUST handle duplicate-email errors gracefully. Returned tokens should be short-lived access tokens (for example, JWT) with a refresh token mechanism; the `todo_app_user.last_active_at` and `todo_app_user.updated_at` columns may be updated on successful immediate authentication after registration.\n\nRelated operations and workflow integration: Typical next operations after successful join are `login` (if the server requires explicit login after verification) and `refresh` to renew tokens. If email verification is enabled by product policy, the server may create an out-of-band verification flow; note that there is no explicit `email_verified` column in `todo_app_user` in the Prisma schema, so verification state must be represented within `account_status` or an external store.","summary":"Register a new TodoApp user (creates a row in todo_app_user)","parameters":[],"requestBody":{"description":"Registration payload for creating a new user account. Contains a valid email and plaintext password. Optional display_name may be included.","typeName":"ITodoAppUser.ICreate"},"responseBody":{"description":"Authorized response returned after successful registration. Contains issued authorization tokens and user summary fields.","typeName":"ITodoAppUser.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/user/join","method":"post"},{"specification":"This operation authenticates an existing user in the `todo_app_user` table. It validates provided credentials (email + password) against `todo_app_user.email` and `todo_app_user.password_hash`. On successful authentication the server issues authorization tokens and may update `todo_app_user.last_active_at` and `todo_app_user.updated_at` to reflect recent activity. The operation returns an authorized response containing the issued tokens and selected user fields.","authorizationType":"login","description":"Purpose and overview: This endpoint authenticates a user record from the `todo_app_user` table. It uses `email` to locate the account and verifies secrets against `todo_app_user.password_hash`. Successful authentication results in issuance of authorization material (access token and refresh token) and a response representing the authenticated user.\n\nImplementation details and required fields: Request must include `email` and password. The server will check `todo_app_user.email` (unique by schema) and verify the secret against `todo_app_user.password_hash`. On success the server SHOULD update `todo_app_user.last_active_at` and `todo_app_user.updated_at` to reflect activity and may set or confirm `account_status` (for example, deny login when `account_status` is 'suspended').\n\nRole-specific integration and business context: Login is a public operation used to obtain session tokens that allow management of todos owned by the authenticated user (todos are associated via `todo_app_todos.user_id`). The tokens returned by this endpoint are used by subsequent protected operations.\n\nSecurity considerations: Implement strong rate limiting for failed login attempts and ensure errors do not leak whether an email exists. Because the Prisma schema contains `password_hash` but not refresh-token storage columns, refresh token lifecycle may be managed by a dedicated token store external to the `todo_app_user` table; however `todo_app_user.updated_at` and `todo_app_user.last_active_at` are available within the schema to record activity.\n\nRelated operations and workflow integration: Typical complementary operations include `refresh` to renew an access token and `changePassword` (authenticated) to update `todo_app_user.password_hash` for the account. Admin suspend/reactivate actions also interact with `todo_app_user.account_status` (managed by admin flows recorded in `todo_app_audit_records`).","summary":"Authenticate a TodoApp user (login against todo_app_user)","parameters":[],"requestBody":{"description":"Login payload containing `email` and `password` to authenticate an existing user.","typeName":"ITodoAppUser.ILogin"},"responseBody":{"description":"Authorized response including access and refresh tokens along with a user summary.","typeName":"ITodoAppUser.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/user/login","method":"post"},{"specification":"This operation refreshes an access token for a user associated with the `todo_app_user` table. It accepts a refresh token and issues a new access token (and optionally a new refresh token) for the associated user. The operation may update `todo_app_user.last_active_at` and `todo_app_user.updated_at` to indicate continued activity. The Prisma `todo_app_user` table provides the user identity fields used to associate the refreshed session with the correct account.","authorizationType":"refresh","description":"Purpose and overview: This endpoint renews an access token using a valid refresh token for a user record that exists in `todo_app_user`. The refresh flow ties the presented refresh token to the user identity so the server can return a fresh access token and possibly rotate the refresh token.\n\nImplementation details and required fields: Request payload should include a valid refresh token. Because the Prisma schema does not include an explicit refresh-token storage column, refresh token management is typically implemented using a separate token store; however the operation will still update `todo_app_user.last_active_at` and `todo_app_user.updated_at` to reflect the renewed session activity for auditing and presence metrics.\n\nRole-specific integration and business context: Refresh is a public endpoint that accepts a valid refresh token to provide continued authenticated access without re-entering credentials. The refreshed tokens continue to permit operations on `todo_app_todos` rows owned by the user (via `todo_app_todos.user_id`).\n\nSecurity considerations: Ensure refresh tokens are rotated or invalidated on logout or account suspension (check and propagate `todo_app_user.account_status` to deny refresh when suspended). Monitor and record suspicious refresh activity in `todo_app_audit_records` when appropriate.\n\nRelated operations and workflow integration: `refresh` is commonly used after `login` and before protected operations; it complements `join` and `login` flows and should be part of the token lifecycle design alongside revocation and rotation strategies.","summary":"Refresh access token for a TodoApp user (ties to todo_app_user identity)","parameters":[],"requestBody":{"description":"Refresh request containing a valid refresh token to obtain a new access token.","typeName":"ITodoAppUser.IRefresh"},"responseBody":{"description":"Authorized response containing new access token (and optionally rotated refresh token) and user summary.","typeName":"ITodoAppUser.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/user/refresh","method":"post"},{"specification":"This operation allows an authenticated user (from `todo_app_user`) to change their account password. It updates the `todo_app_user.password_hash` column and sets `todo_app_user.updated_at` (and optionally `todo_app_user.last_active_at`) to reflect the change. This operation is associated with the `todo_app_user` table and requires the requesting actor to be authenticated as the user being modified.","authorizationType":null,"description":"Purpose and overview: This authenticated endpoint enables a user to change their password. It targets the `todo_app_user` record and updates `password_hash` after verifying the current secret (if required) or validating a password-reset flow. The server updates `todo_app_user.updated_at` after successfully changing the stored `password_hash`.\n\nImplementation details and required fields: The request must be authenticated as the user whose password is being changed. The payload typically includes the `currentPassword` and `newPassword` (or a reset token in alternative flows). Upon verification, the server computes a new secure `password_hash` and writes it to `todo_app_user.password_hash`. The server MUST update `todo_app_user.updated_at` and may update `todo_app_user.last_active_at` as part of session continuity.\n\nRole-specific integration and business context: This operation is restricted to the `user` role and supports the security hygiene for accounts created in `todo_app_user`. Because the Prisma schema includes `password_hash`, the table supports password-based authentication and updates to that field.\n\nSecurity considerations: The server MUST verify the requester is the owner of the account and MUST re-authenticate or verify the current credential before changing the password, unless this endpoint is used with a validated password-reset token flow. Passwords MUST be hashed before storage. Admins changing user passwords for support purposes SHOULD create an entry in `todo_app_audit_records` to record the admin action (admin_id, action_type='change_password', target_id=user_id, reason).\n\nRelated operations and workflow integration: This operation complements `login` and `refresh`. A password change SHOULD invalidate or rotate refresh tokens depending on security policy and SHOULD be recorded for auditing if performed by an admin.","summary":"Change authenticated user's password (updates todo_app_user.password_hash)","parameters":[],"requestBody":{"description":"Authenticated password-change payload containing current and new password values (or reset token + new password).","typeName":"ITodoAppUser.IChangePassword"},"responseBody":{"description":"Profile-style response confirming update; returns key user fields (email, display_name, account_status, updated_at).","typeName":"ITodoAppUser.IProfile"},"authorizationRole":"user","name":"changePassword","prerequisites":[],"path":"/auth/user/change-password","method":"put"},{"specification":"This operation creates a new administrator account and issues initial authorization tokens. It is associated with the Prisma table `todo_app_admin` and uses fields on that table for account identity and initial state. The operation will insert a new row into `todo_app_admin` (populating at least `email`, `password_hash`, and `is_super` as applicable) and may create an initial audit record in `todo_app_audit_records` to record the account creation event for compliance purposes.","authorizationType":"join","description":"Purpose and overview:\nThis endpoint registers a new administrator account for the system and issues an initial authorized response payload. It is explicitly tied to the Prisma model `todo_app_admin` and will rely on the `email`, `password_hash`, `is_super`, `created_at`, and `last_active_at` fields on that table to represent account identity and state.\n\nImplementation details and required fields:\nWhen called, the implementation will validate the provided `email` and password, persist the new `todo_app_admin` row (setting `email` and, after hashing, `password_hash`) and set the initial `created_at` and `last_active_at` timestamps. If elevated privileges are required for the account, `is_super` may be set per the request. The response payload uses tokens and the admin summary, but token persistence or revocation mechanism is implementation specific and not assumed to be a column on `todo_app_admin`.\n\nRole-specific integration:\nThis endpoint is the public entry point for creating admin accounts. It should ensure the `email` value is unique (the Prisma model defines `@@unique([email])`) and must fail cleanly if a duplicate `email` exists. As part of the workflow, an audit entry may be recorded in `todo_app_audit_records` referencing the created admin (`admin_id`) with `action_type` like `create_admin` to satisfy compliance and traceability.\n\nSecurity considerations:\nPasswords MUST be hashed before storing in `password_hash` and never returned in responses. The implementation must not expose `password_hash` in any response. All audit actions related to account creation SHOULD be recorded in `todo_app_audit_records` (fields available: `admin_id`, `actor_role`, `action_type`, `target_resource`, `target_id`, `created_at`). Use secure transport (HTTPS) and apply rate limiting to prevent abuse.\n\nRelated operations and workflow integration:\nThis operation complements `POST /auth/admin/login` (to obtain access tokens) and `POST /auth/admin/refresh` (to refresh tokens). After creation, the caller is expected to use the issued tokens from this response (see response schema) to authenticate subsequent admin-only endpoints. If email verification is required by policy, the implementation should create an initial unverified state and record this in `todo_app_audit_records`.","summary":"Create a new admin account (todo_app_admin)","parameters":[],"requestBody":{"description":"Registration payload for a new admin account.","typeName":"ITodoAppAdmin.ICreate"},"responseBody":{"description":"Authorized response containing access and refresh tokens and a minimal admin summary.","typeName":"ITodoAppAdmin.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/admin/join","method":"post"},{"specification":"This operation authenticates an administrator against the `todo_app_admin` table. It validates credentials (matching `email` against the unique index on `todo_app_admin.email` and verifying the supplied password against `password_hash`) and issues authorization tokens. Login attempts and important authentication events may be recorded into `todo_app_audit_records` for traceability.","authorizationType":"login","description":"Purpose and overview:\nThis endpoint authenticates an administrator by validating supplied credentials against the `todo_app_admin` model. It references the `email` (unique) column and compares the supplied password to the stored `password_hash` field before issuing tokens. Successful authentication may update `last_active_at` on the `todo_app_admin` row.\n\nImplementation details and validation:\nThe implementation MUST validate that the provided `email` exists in `todo_app_admin`. Password verification must compare the supplied secret to the `password_hash` using secure hash verification (e.g., bcrypt/argon2). On success, the implementation may update `last_active_at` to the current timestamp and optionally create an audit record in `todo_app_audit_records` with `action_type` such as `admin_login` and `actor_role` set to `admin`.\n\nRole-specific integration and behavior:\nThis is a public authentication endpoint that issues an `ITodoAppAdmin.IAuthorized` response containing short-lived access credentials and a refresh credential. The caller uses these tokens for subsequent admin-scoped API calls. The operation should respect account status (the `account_status` field on `todo_app_user` exists for users; for admins the `todo_app_admin` model has `is_super` and timestamps — implementors may add an `account_status` equivalent if needed, but do not assume it exists by default on `todo_app_admin`).\n\nSecurity considerations:\nDo NOT include `password_hash` in any response. Failed login attempts SHOULD be logged to `todo_app_audit_records` with `action_type` like `admin_login_failed` to support monitoring and abuse detection. Apply rate limits and account lockout policies at higher layers.\n\nRelated operations:\nAfter successful login, the issued tokens are expected to be used with `POST /auth/admin/refresh` to renew short-lived access tokens and with admin-protected endpoints that require `authorizationRole: \"admin\"` such as password change or administrative maintenance actions.","summary":"Authenticate admin and issue tokens (todo_app_admin)","parameters":[],"requestBody":{"description":"Login payload: admin email and password.","typeName":"ITodoAppAdmin.ILogin"},"responseBody":{"description":"Authorized response containing access and refresh tokens and a minimal admin summary.","typeName":"ITodoAppAdmin.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/admin/login","method":"post"},{"specification":"This operation refreshes access credentials for an authenticated administrator. It is part of token lifecycle management and is related to admin session handling; the operation is not directly backed by a specific `todo_app_admin` column for tokens (no token columns exist in the Prisma model), but refresh events and revocation attempts SHOULD be recorded in `todo_app_audit_records` for traceability.","authorizationType":"refresh","description":"Purpose and overview:\nThis endpoint accepts a valid refresh credential and issues a new short-lived access token (and optionally a new refresh token). While `todo_app_admin` does not store token values in any specific column, the operation is semantically tied to admin sessions for accounts represented by `todo_app_admin.id` and `todo_app_admin.email`.\n\nImplementation details and security:\nThe implementation must validate the presented refresh credential according to the chosen session/token architecture. Because the Prisma schema does not include dedicated token storage fields, token persistence and revocation logic is an implementation concern; however, all refresh operations SHOULD be recorded to `todo_app_audit_records` (e.g., `action_type = refresh_token_used`, `target_id = admin id`) to support auditability.\n\nRole-specific integration:\nThis is a public endpoint in the auth flow (clients call it with a refresh credential). On successful refresh, the response returns the same `ITodoAppAdmin.IAuthorized` shape used for login / join so that clients have a consistent authorized payload. The server SHOULD update `last_active_at` for the related `todo_app_admin` row when appropriate.\n\nSecurity considerations:\nRefresh tokens SHOULD be revocable (server-side blacklist or rotating refresh tokens). Revocation and revocation attempts SHOULD be logged to `todo_app_audit_records` with appropriate `actor_role` and `action_type` so that administrators can trace suspicious activity.\n\nRelated operations:\nWorks together with `POST /auth/admin/login` (initial issuance) and admin session revocation endpoints (not included here).","summary":"Refresh admin access token","parameters":[],"requestBody":{"description":"Payload containing the refresh credential for token renewal.","typeName":"ITodoAppAdmin.IRefresh"},"responseBody":{"description":"Authorized response containing new access (and optionally refresh) tokens.","typeName":"ITodoAppAdmin.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/admin/refresh","method":"post"},{"specification":"This operation initiates a password-reset flow for an administrator account identified by email. It references the `todo_app_admin` table (field `email`) to locate the target account. Because the Prisma schema does not include a dedicated reset token column on `todo_app_admin`, implementations commonly emit a time-limited token via email and record the request in `todo_app_audit_records` for traceability.","authorizationType":null,"description":"Purpose and overview:\nThis endpoint starts a password reset workflow for an admin identified by `email` (the `todo_app_admin.email` column). It is used when an admin can no longer authenticate and requires a secure path to re-establish credentials.\n\nImplementation details and required behavior:\nOn receipt of a valid email that maps to an existing `todo_app_admin` row, the implementation SHOULD generate a time-limited reset token (not persisted on `todo_app_admin` by the schema itself) and send it to the provided email address. The operation SHOULD create an audit record in `todo_app_audit_records` with `action_type` like `request_password_reset` and `target_id` set to the admin id to record the event.\n\nRole-specific integration:\nThis is a public endpoint (no prior authentication required). The request MUST NOT disclose whether the email exists in the system in order to avoid user enumeration attacks; instead, the response SHOULD be a generic success message while the server performs any email actions silently.\n\nSecurity considerations:\nEnsure the reset token is single-use and expires promptly (recommended default: 24 hours). Do NOT return reset tokens in the API response. Record all reset initiation attempts in `todo_app_audit_records` for monitoring.\n\nRelated operations:\nA subsequent endpoint (not included here) would accept the token and the new password to complete the reset and update `todo_app_admin.password_hash` accordingly; that operation SHOULD also create an audit record with `action_type`: `complete_password_reset`.","summary":"Initiate admin password reset (todo_app_admin.email)","parameters":[],"requestBody":{"description":"Payload containing the admin email to initiate a password reset.","typeName":"ITodoAppAdmin.IRequestPasswordReset"},"responseBody":{"description":"Generic operation result message (do not disclose whether account exists).","typeName":"ITodoAppAdmin.IMessage"},"authorizationRole":null,"name":"requestPasswordReset","prerequisites":[],"path":"/auth/admin/password/reset","method":"post"},{"specification":"This operation allows an authenticated administrator to change their password. It updates the `password_hash` column on the `todo_app_admin` row for the authenticated admin and records the change in `todo_app_audit_records` for traceability (e.g., `action_type` = `change_password`).","authorizationType":null,"description":"Purpose and overview:\nThis endpoint enables an authenticated admin to change their password. It targets the `todo_app_admin` record for the calling admin (fields: `id`, `email`, `password_hash`, `last_active_at`) and updates `password_hash` with a new hashed secret.\n\nImplementation details and validation:\nThe endpoint requires the caller to be authenticated as an admin (`authorizationRole: \"admin\"`). It should verify the caller's current credential or session and validate the new password against password policy before hashing and storing it in `password_hash`. Upon success, the implementation SHOULD update `updated_at` and optionally `last_active_at` on the `todo_app_admin` row.\n\nSecurity considerations:\nDo NOT log the plain-text password. Record the password change action in `todo_app_audit_records` with `action_type` such as `change_password` and include the `admin_id` and timestamp. Consider revoking outstanding refresh tokens or sessions after a password change to reduce risk.\n\nRelated operations:\nThis operation complements `POST /auth/admin/password/reset` (reset flow) and token refresh endpoints. It is restricted to authenticated admins and must be audited.","summary":"Change authenticated admin password (todo_app_admin.password_hash)","parameters":[],"requestBody":{"description":"Payload containing current credential proof and the new password.","typeName":"ITodoAppAdmin.IChangePassword"},"responseBody":{"description":"Operation result message confirming password change.","typeName":"ITodoAppAdmin.IMessage"},"authorizationRole":"admin","name":"changePassword","prerequisites":[],"path":"/auth/admin/password/change","method":"put"},{"specification":"Operation: Retrieve a filtered, paginated list of todo items from the todo_app_todos table in the Prisma schema. This operation corresponds to the Prisma model `todo_app_todos` and implements business-facing search and pagination for a user's todos. It is designed to work with the table columns defined in the Prisma schema (id, user_id, title, description, is_completed, completed_at, position, created_at, updated_at, deleted_at) and to respect the table's soft-delete semantics by excluding rows where deleted_at is set unless explicitly requested. The operation supports filtering by completion state (is_completed), optional inclusion of deleted items, sorting by created_at or position, and standard pagination parameters (page, pageSize). The response is a paginated summary collection referencing the main entity type `ITodoAppTodo.ISummary` and a paginated container type `IPageITodoAppTodo.ISummary` per service prefix conventions.\n\nBusiness purpose: Provide a single endpoint for clients to list a user's todos with common filtering, sorting, and pagination needs. The operation is tailored to the `todo_app_todos` Prisma table and therefore only references columns that exist in that model. This operation is intended for authenticated users and will return only todos owned by the requesting user (enforced in business logic).","path":"/todoApp/user/todos","method":"patch","summary":"Search and retrieve a filtered, paginated list of todo summaries from todo_app_todos","description":"Retrieve a filtered and paginated list of todo items owned by the requesting user.\n\nPurpose and overview:\nThis endpoint returns a paginated collection of todo summaries derived from the Prisma `todo_app_todos` model. The model stores primary todo data including title, optional description, completion flag, timestamps, and a nullable deleted_at column that implements soft-delete semantics in the schema. By default, the operation excludes records with `deleted_at` set (deleted items). Callers may request inclusion of deleted items via the request DTO when an administrative or recovery view is required.\n\nSecurity and permissions:\nOnly authenticated requests scoped to the owning user may retrieve their todos; the operation must ensure the returned rows have `user_id` equal to the requesting user's id. The API surface for listing is restricted to role `user`. Any elevated listing that includes other users' data or exhaustive audit results must be implemented in separate admin endpoints and recorded in `todo_app_audit_records`.\n\nRelationship to underlying database entities:\nThis operation maps to the Prisma model `todo_app_todos`. It relies on columns explicitly defined in that model: `id`, `user_id`, `title`, `description`, `is_completed`, `completed_at`, `position`, `created_at`, `updated_at`, and `deleted_at`. Snapshots are captured separately in `todo_app_todo_snapshots`; snapshot creation is a background or explicit process and is not performed by this read operation.\n\nValidation rules and business logic:\n- The operation accepts pagination parameters (page, pageSize) and enforces sane server-side limits for pageSize.\n- Filter fields: `isCompleted` (boolean) filters by `is_completed`. If omitted, both active and completed todos are returned (subject to exclusion of deleted items).\n- Sorting: clients may request sort by `createdAt` or `position` with ascending/descending direction. Sorting keys correspond to `created_at` and `position` columns in the Prisma model.\n- Deleted items: by default, rows where `deleted_at` is NOT null are excluded; inclusion requires an explicit includeDeleted flag and should be limited to administrative/owner recovery scenarios.\n\nRelated operations and error handling:\nUse `GET /todoApp/user/todos/{todoId}` (operation `at`) to fetch a single todo detail. Clients requesting export or heavy full-text search should use dedicated endpoints. Common errors: 400 for invalid request parameters, 401/403 for unauthorized access, and 500 for unexpected server errors. Missing resources are returned as empty pages rather than 404 for list endpoints.","parameters":[],"requestBody":{"description":"Search, filter, sort, and pagination parameters for listing todos owned by the requesting user.","typeName":"ITodoAppTodo.IRequest"},"responseBody":{"description":"Paginated list of todo summaries matching the search criteria. Each summary includes id, title, isCompleted, createdAt, updatedAt, position, and a short excerpt of the description when present.","typeName":"IPageITodoAppTodo.ISummary"},"authorizationType":null,"authorizationRole":"user","name":"index","prerequisites":[{"endpoint":{"path":"/todoApp/user/todos","method":"post"},"description":"Create a Todo item for the authenticated user (inserts a row into todo_app_todos). Listing the user's todos assumes there may be persisted items; executing POST /todoApp/user/todos ensures a todo_app_todos record exists for the requesting user. If creation fails or is not performed, list endpoints may return empty pages and tests that expect returned data will fail."}]},{"specification":"Operation: Retrieve a single todo detail from the `todo_app_todos` Prisma table. This operation is associated with the `todo_app_todos` model and returns the full entity for a given todo id. The operation respects the model's soft-delete semantics by returning 404 when the target row has `deleted_at` set (unless business rules allow returning deleted items to owners/admins). The returned entity includes fields defined on the Prisma model: id, user_id, title, description, is_completed, completed_at, position, created_at, updated_at, deleted_at.\n\nBusiness purpose: Allow clients to fetch one todo item by its UUID for display or editing. The endpoint enforces ownership: only the owner (or an authorized admin) can successfully retrieve the record.","path":"/todoApp/user/todos/{todoId}","method":"get","summary":"Retrieve detailed information for a single todo by id from todo_app_todos","description":"Retrieve full details of a single todo item.\n\nPurpose and overview:\nThis endpoint returns the complete `todo_app_todos` entity for the provided `todoId`. It is intended to supply clients with all available fields defined in the Prisma model, enabling detailed views and edit screens. Timestamps provided are those defined on the model (`created_at`, `updated_at`, `completed_at`, `deleted_at`).\n\nSecurity and user permissions:\nThe operation requires that the requester be the owner of the todo (matching `user_id`) or an authorized admin with audited access. Unauthorized attempts must result in 403. If the todo is soft-deleted (non-null `deleted_at`), the API returns 404 unless the request is for owner recovery and the business logic explicitly allows returning deleted items to the owner.\n\nRelationship to database and snapshots:\nThe todo returned is the live record in `todo_app_todos`. Historical snapshots exist in `todo_app_todo_snapshots` and are not returned by this endpoint. Snapshot retrieval is available via a separate audit/history endpoint if needed.\n\nValidation and error handling:\n- Path parameter `todoId` MUST be a UUID. If malformed, return 400.\n- If the todo does not exist or is not accessible to the requester (including when it is deleted and not permitted to be returned), return 404.\n- On success, return the full `ITodoAppTodo` representation with all model-described fields.\n\nRelated operations:\nUse `PATCH /todoApp/user/todos` (operation `index`) to search/paginate lists. Use `PATCH /todoApp/user/todos/{todoId}` (update) to modify the item. Administrative restores and purges are separate operations and must be recorded in `todo_app_audit_records`.","parameters":[{"name":"todoId","description":"Unique identifier (UUID) of the target todo item","schema":{"type":"string","format":"uuid"},"in":"path"}],"requestBody":null,"responseBody":{"description":"Complete todo entity as defined by the `todo_app_todos` Prisma model.","typeName":"ITodoAppTodo"},"authorizationType":null,"authorizationRole":"user","name":"at","prerequisites":[{"endpoint":{"path":"/todoApp/user/todos","method":"post"},"description":"The GET operation requires the todo resource to exist. POST /todoApp/user/todos creates a todo and returns its generated id (todoId). The created todo must exist and be accessible to the requester (owner or authorized admin); if this prerequisite is not satisfied the retrieval will result in 404 or 403 as appropriate."}]},{"specification":"Create operation for the todo_app_todos Prisma model. This operation inserts a new todo record into the todo_app_todos table, associating the created record with the authenticated user and returning the created resource with server-populated timestamps. It maps directly to the Prisma model `todo_app_todos` and must respect the model's constraints: `title` is required, `description` is optional, `position` is optional. System-managed fields (id, user_id, created_at, updated_at, completed_at, deleted_at) are set by the server and must not be supplied by clients. The operation enforces ownership: the created record is associated to the calling user. Validation rules and examples are provided in the description.","path":"/todoApp/user/todos","method":"post","summary":"Create a new Todo (todo_app_todos)","description":"Create a new Todo item and persist it in the `todo_app_todos` table. This endpoint accepts minimal user-provided fields required for quick capture (title plus optional description and position). On success the server returns the full Todo record including server-populated fields such as `id`, `created_at`, and `updated_at`.\n\nSecurity and permissions:\nOnly authenticated users may create todos. The creating user's identity is used to set the `user_id` relation in `todo_app_todos`. The operation requires role `user` and the request must be authorized before creating data.\n\nValidation rules and business logic:\n- `title` is required: non-empty string after trimming (1..250 chars recommended).\n- `description` is optional (<= 4000 chars recommended).\n- `position` is optional integer used by clients for ordering.\n- `is_completed` defaults to false; if provided must be boolean.\n- Server sets `created_at` and `updated_at`.\n\nErrors:\n- 400 for validation errors (ERR_INVALID_TITLE, ERR_INVALID_DESCRIPTION).\n- 401/403 for auth errors.\n- 500 for server errors.","parameters":[],"requestBody":{"description":"Creation payload for a new Todo. Clients provide only user-editable fields (title required, description optional, position optional). System-managed fields (id, user_id, created_at, updated_at, completed_at, deleted_at) are omitted and set by the server.","typeName":"ITodoAppTodo.ICreate"},"responseBody":{"description":"Created Todo object including server-populated fields (id, user_id, created_at, updated_at).","typeName":"ITodoAppTodo"},"authorizationType":null,"authorizationRole":"user","name":"create","prerequisites":[]},{"specification":"Update operation for the todo_app_todos Prisma model. This operation updates an existing todo record identified by its UUID. It modifies client-editable fields (title, description, is_completed, position). System-managed fields (id, user_id, created_at) are immutable from the API; `updated_at` and `completed_at` are set/managed by the server. Ownership verification is required and updates to soft-deleted records are rejected. The operation maps to the Prisma model `todo_app_todos` and must follow its constraints.","path":"/todoApp/user/todos/{todoId}","method":"put","summary":"Update an existing Todo by ID (todo_app_todos)","description":"Update an existing Todo item in the `todo_app_todos` table. Clients supply the todo identifier in the path and a payload with the fields to change. The server validates ownership and input, applies allowed updates, sets `updated_at`, and returns the updated resource.\n\nSecurity and permissions:\nOnly the owner of the todo (authenticated role `user`) or an authorized admin flow may update the record. Attempts to update another user's todo MUST be rejected with 403 Forbidden. If the target record has a non-null `deleted_at` (soft-deleted), the server SHOULD return 404 Not Found or 410 Gone depending on policy; this operation does not implicitly undelete resources.\n\nValidation and business logic:\n- `title` if provided must be non-empty and within allowed length (1..250 chars).\n- `description` if provided must be <= 4000 chars.\n- `is_completed` toggled true sets `completed_at` to server time; toggled false clears `completed_at`.\n- `position` if provided must be an integer.\n\nNote on PUT semantics:\nThis operation uses PUT for updates per API conventions. Ensure `ITodoAppTodo.IUpdate` semantics are documented (partial-update with optional fields vs full-replace). If partial updates are used, clients may send only fields to change.","parameters":[{"name":"todoId","in":"path","description":"Unique identifier (UUID) of the target todo to update","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Partial or full update payload for a Todo. Include only fields to be changed if IUpdate is defined with optional fields. System-managed timestamps and identifiers are not accepted from clients.","typeName":"ITodoAppTodo.IUpdate"},"responseBody":{"description":"Updated Todo object after applying requested changes. Server-populated fields (updated_at, completed_at) reflect the performed updates.","typeName":"ITodoAppTodo"},"authorizationType":null,"authorizationRole":"user","name":"update","prerequisites":[{"endpoint":{"path":"/todoApp/user/todos","method":"post"},"description":"The todo resource identified by todoId must exist before it can be updated. POST /todoApp/user/todos creates a Todo and returns its id; the update operation requires that the specified todoId reference an existing todo owned by the caller. If this prerequisite is not met, the update will fail with 404 Not Found or 403 Forbidden due to missing resource or ownership issues."}]},{"specification":"Soft-delete (mark as deleted) a Todo record in the todo_app_todos table. This operation targets the todo_app_todos Prisma model and implements a business-level soft-delete by setting the deleted_at timestamp. It requires server-side ownership verification: only the owning user may perform this action. The operation updates deleted_at atomically, preserves created_at and updated_at, and does not modify todo_app_todo_snapshots. The operation returns 204 No Content on success and standard error codes for validation, authorization, and not-found cases.","path":"/todoApp/user/todos/{todoId}","method":"delete","summary":"Soft-delete a todo (mark as deleted) in the todo_app_todos table","description":"Mark a Todo item as deleted by setting its deleted_at timestamp.\n\nPurpose and overview: This operation marks a todo item in the todo_app_todos table as deleted (soft-delete) so it is removed from active and completed lists but retained for recovery and historical purposes. It uses the todo_app_todos.deleted_at column defined in the Prisma schema to record deletion time.\n\nSecurity considerations and user permissions: Only the owning user is permitted to soft-delete their todo. The service must validate ownership using the todo_app_todos.user_id relation to todo_app_user.id. Admin maintenance flows that permanently purge data are separate and must be audited via todo_app_audit_records.\n\nValidation rules and business logic: The todoId path parameter must be a valid UUID and must reference an existing todo record. If the record already has deleted_at set, the operation is idempotent and returns 204. Ownership must be enforced; attempts to delete another user's todo must be rejected with 403. If the todo is missing, return 404. Errors should include machine-readable codes and human-friendly messages.","parameters":[{"name":"todoId","in":"path","description":"Unique identifier (UUID) of the target todo (todo_app_todos.id)","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationType":null,"authorizationRole":"user","prerequisites":[{"endpoint":{"path":"/todoApp/user/todos","method":"post"},"description":"The todo resource identified by todoId must exist before it can be soft-deleted. POST /todoApp/user/todos creates the Todo and returns its id; the delete operation requires that the specified todoId reference an existing todo owned by the caller. If this prerequisite is not met, the delete will fail with 404 Not Found or 403 Forbidden."}],"name":"erase"},{"specification":"Retrieve a paginated, filterable list of snapshot versions for a specific todo. This operation reads from the todo_app_todo_snapshots Prisma model and returns historical snapshots for the referenced todo_app_todos.id. Supports filtering by snapshot_at ranges, is_completed, sorting (snapshot_at desc default), and pagination. Snapshots are system-generated and this endpoint is read-only.","path":"/todoApp/user/todos/{todoId}/versions","method":"patch","summary":"List paginated snapshot versions for a specific todo (todo_app_todo_snapshots)","description":"Retrieve snapshot history for a given todo item.\n\nPurpose and overview: This operation returns historical snapshots stored in todo_app_todo_snapshots for the specified todo (todo_app_todo_id). Snapshots capture the todo state at snapshot_at and are useful for audit and user-facing \"version history\" views.\n\nSecurity considerations and user permissions: Only the todo owner (or an authorized admin via separate audit endpoints) should be permitted to view snapshot history. The service must validate ownership by joining todo_app_todo_snapshots.todo_app_todo_id -> todo_app_todos.id -> todo_app_todos.user_id and comparing to the calling user.\n\nValidation rules and business logic: Accepts pagination, sort, and optional filter parameters (e.g., snapshot_at range, is_completed). Defaults: sort by snapshot_at desc, default page size 20, enforce a reasonable max page size to prevent large payloads. Return paginated container with metadata (page, pageSize, total). Handle empty results gracefully.","parameters":[{"name":"todoId","in":"path","description":"Unique identifier (UUID) of the parent todo (todo_app_todos.id) to list snapshots for","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Search, filter, sort and pagination parameters for todo snapshot listing","typeName":"ITodoAppTodoSnapshot.IRequest"},"responseBody":{"description":"Paginated list of todo snapshot summaries","typeName":"IPageITodoAppTodoSnapshot"},"authorizationType":null,"authorizationRole":"user","prerequisites":[{"endpoint":{"path":"/todoApp/user/todos","method":"post"},"description":"A Todo must exist before its snapshot history can be listed. POST /todoApp/user/todos creates the parent todo and returns its id (todoId). If the todo does not exist the snapshot listing cannot succeed."}],"name":"index"},{"specification":"Retrieve a specific todo snapshot (version) from the todo_app_todo_snapshots Prisma model. This read-only operation returns the exact point-in-time snapshot recorded in the `todo_app_todo_snapshots` table. This operation MUST verify that the snapshot.todo_app_todo_id equals the provided todoId and that the parent todo's user_id equals the requesting user's id. The response MUST only include fields defined on the snapshot model (id, todo_app_todo_id, title, description, is_completed, completed_at, position, created_at, updated_at, deleted_at, snapshot_at) and MUST NOT include any sensitive fields from related user or admin records (e.g., password_hash).","path":"/todoApp/user/todos/{todoId}/versions/{versionId}","method":"get","summary":"Retrieve a specific todo snapshot (version) from todo_app_todo_snapshots","description":"Retrieve a specific todo snapshot (version) from the todo_app_todo_snapshots table.\n\nPurpose and overview: This operation returns the stored snapshot representing the state of a todo at a past point in time. The data is sourced from the Prisma model `todo_app_todo_snapshots` and exposes fields captured at the snapshot moment (id, todo_app_todo_id, title, description, is_completed, completed_at, position, created_at, updated_at, deleted_at, snapshot_at). It is read-only and intended for history, audit, and owner support usage.\n\nSecurity and permissions: This endpoint is accessible to the owning user only. Implementations MUST verify ownership by ensuring the parent todo (todo_app_todos.id) has user_id equal to the requesting user. Admins should use the admin-scoped endpoint instead. Under no circumstances should this endpoint return authentication secrets or sensitive fields from other models.\n\nRelationship to database entities: Maps directly to `todo_app_todo_snapshots`. The path parameter `todoId` corresponds to the source todo id (todo_app_todo_snapshots.todo_app_todo_id) and `versionId` corresponds to snapshot primary key (todo_app_todo_snapshots.id).\n\nValidation and error handling: Both path parameters MUST be valid UUIDs. If the snapshot is not found or does not belong to the provided todoId, return 404. If ownership check fails, return 403.\n","parameters":[{"name":"todoId","description":"Unique identifier of the parent todo (references todo_app_todos.id).","schema":{"type":"string","format":"uuid"}},{"name":"versionId","description":"Unique identifier of the snapshot record (todo_app_todo_snapshots.id).","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"A single todo snapshot record as defined by the todo_app_todo_snapshots model.","typeName":"ITodoAppTodoSnapshot"},"authorizationType":null,"authorizationRole":"user","name":"at","prerequisites":[{"endpoint":{"path":"/todoApp/user/todos","method":"post"},"description":"The parent Todo must exist before a specific snapshot can be retrieved. POST /todoApp/user/todos creates the todo and yields the todoId that snapshots reference. If the parent todo is missing the snapshot cannot be validated or returned."}]},{"specification":"Administrator read access to a specific todo snapshot (version) from the todo_app_todo_snapshots Prisma model. This operation is intended for support and audit workflows. Implementations MUST record the admin access in `todo_app_audit_records` (actor_role='admin', action_type='view_snapshot', target_resource='todo_snapshot', target_id=versionId) and must not return sensitive authentication fields. Response content MUST be limited to snapshot model fields.","path":"/todoApp/admin/todos/{todoId}/versions/{versionId}","method":"get","summary":"Admin retrieve a specific todo snapshot (version) from todo_app_todo_snapshots","description":"Retrieve a specific todo snapshot (version) from the todo_app_todo_snapshots table for administrative/support use.\n\nPurpose and overview: Returns the snapshot recorded for a todo at a prior time. This admin endpoint supports troubleshooting and audit investigations.\n\nSecurity and permissions: Access restricted to admin role. Implementations MUST authenticate the admin, authorize the request, and create an audit record documenting the access (admin id, action_type 'view_snapshot', target_resource 'todo_snapshot', target_id). The response MUST NOT include any authentication secrets or other sensitive fields from related models.\n\nRelationship to database entities: Maps directly to `todo_app_todo_snapshots`. The path parameter `todoId` corresponds to snapshot.todo_app_todo_id; `versionId` corresponds to snapshot.id.\n\nValidation and error handling: Both path parameters MUST be valid UUIDs. If the snapshot is not found or the todoId does not match, return 404.\n","parameters":[{"name":"todoId","description":"Unique identifier of the parent todo (references todo_app_todos.id).","schema":{"type":"string","format":"uuid"}},{"name":"versionId","description":"Unique identifier of the snapshot record (todo_app_todo_snapshots.id).","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"A single todo snapshot record as defined by the todo_app_todo_snapshots model.","typeName":"ITodoAppTodoSnapshot"},"authorizationType":null,"authorizationRole":"admin","name":"at","prerequisites":[{"endpoint":{"path":"/todoApp/user/todos","method":"post"},"description":"The parent Todo must exist before a snapshot can be retrieved. POST /todoApp/user/todos creates a todo_app_todos record and returns its generated id, which is referenced by todo_app_todo_snapshots.todo_app_todo_id. If the Todo does not exist, the snapshot lookup will be invalid or return 404."}]},{"specification":"Search and retrieve paginated audit records from the todo_app_audit_records Prisma model. This operation supports filters (admin_id, user_id, actor_role, action_type, target_resource, target_id, created_at range), sorting, and pagination. It is admin-only and MUST enforce pageSize caps to prevent expensive queries.","path":"/todoApp/admin/auditRecords","method":"patch","summary":"Search and retrieve a paginated list of audit records (todo_app_audit_records)","description":"Retrieve a filtered, paginated list of audit records from the todo_app_audit_records table.\n\nPurpose and overview: Enables administrative interfaces to search audit events (suspend_user, restore_todo, purge, view_snapshot, etc.). Each record contains admin_id (nullable for system actions), user_id (nullable), actor_role, action_type, target_resource, target_id, reason, and created_at. Returned results MUST only include fields present in the audit model or explicitly allowed metadata; do not project authentication secrets from related user/admin tables.\n\nSecurity and permissions: Access is restricted to admin role. Implementations MUST validate requestor's admin privileges and enforce rate limits and page size caps. All admin access to audit data for support should itself be recorded as an audit event when appropriate.\n\nRelationship to database entities: Maps directly to `todo_app_audit_records`. Suggested filters in requestBody must reference the model fields only.\n\nValidation and business logic: Request body supports paging (page, pageSize), sorting (created_at asc/desc), and optional filters. Server must validate pagination and impose a maximum pageSize to prevent heavy queries. Use available indexes (created_at, admin_id, user_id, target_resource/target_id) to implement efficient queries.\n","parameters":[],"requestBody":{"description":"Search criteria, pagination, and sorting options for audit record retrieval","typeName":"ITodoAppAuditRecord.IRequest"},"responseBody":{"description":"Paginated list of audit records matching the search criteria","typeName":"IPageITodoAppAuditRecord"},"authorizationType":null,"authorizationRole":"admin","name":"index","prerequisites":[{"endpoint":{"path":"/todoApp/user/todos","method":"post"},"description":"When audit searches are filtered by a target_id that references a todo, that todo must exist. POST /todoApp/user/todos creates the referenced todo resource (todo_app_todos) so audit records can meaningfully reference it; without the Todo existing, searches scoped to that target_id may return no results."}]},{"specification":"Retrieve a single audit record by ID from the Prisma table todo_app_audit_records. This read-only operation returns the stored audit record fields (id, admin_id, user_id, actor_role, action_type, target_resource, target_id, reason, created_at) for administrative inspection. Implementation must not provide write access to audit records and must avoid expanding related admin or user objects that include sensitive fields (password_hash).","path":"/todoApp/admin/auditRecords/{auditRecordId}","method":"get","summary":"Retrieve a single audit record (todo_app_audit_records) by ID","description":"Retrieve a single audit record by its unique identifier from the audit record store.\n\nThis operation returns the audit entry that corresponds to the Prisma model `todo_app_audit_records`. The model stores append-only records including admin_id (nullable), user_id (nullable), actor_role, action_type, target_resource, optional target_id, optional reason, and created_at. The operation MUST return these fields exactly as stored and MUST NOT expose sensitive fields from related admin/user records (for example, password_hash).\n\nSecurity and permissions: This endpoint is restricted to administrative actors. Server-side enforcement of the admin role is mandatory. Access to this endpoint should itself be logged in operational access logs for traceability. The endpoint is read-only and must not modify audit records.\n\nBehavior and errors: If the requested id does not exist, return 404 Not Found. On success return the audit record. Server errors return 500 with an error body.","parameters":[{"name":"auditRecordId","description":"Unique identifier (UUID) of the target audit record","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed audit record corresponding to todo_app_audit_records","typeName":"ITodoAppAuditRecord"},"authorizationType":null,"authorizationRole":"admin","name":"at","prerequisites":[{"endpoint":{"path":"/auth/admin/password/reset","method":"post"},"description":"Initiating an admin password reset (POST /auth/admin/password/reset) should create an audit record in todo_app_audit_records (e.g., action_type 'request_password_reset' with target_id set to the admin id). This prerequisite ensures an audit record exists that can be retrieved by the GET operation. If this prerequisite fails or does not create a record, the GET may return 404 Not Found."}]},{"specification":"Search and retrieve a paginated list of guest records from the Prisma table todo_app_guest. This operation supports complex filtering (email partial/exact, status, created_at range), sorting, and pagination. It is intended for administrative maintenance and analytics. Implementations must validate and parameterize filters, apply server-side rate limiting, and avoid exposing personal data (such as full emails) to unauthorized consumers.","path":"/todoApp/admin/guests","method":"patch","summary":"Search and retrieve a paginated list of guest records (todo_app_guest)","description":"Search and retrieve guest records using flexible criteria and pagination. This operation targets the Prisma model `todo_app_guest` and supports filters such as email (exact or partial), status, created_at range, and sorting by created_at or last_active_at.\n\nResponse items include the model's core attributes: id, email (nullable), created_at, last_active_at (nullable), and status (nullable). The request body contains search criteria, pagination, and sorting options. The response is a paginated container of guest record summaries.\n\nSecurity and permissions: Access is limited to administrative actors. Returned personal data (email) must be disclosed only to authorized callers; consider role-based projection or email redaction for lower-privilege support. Implement server-side input validation and parameterized queries to avoid injection and protect performance. Implement rate limiting and audit logging for searches.\n\nErrors: invalid request payloads return 400 with validation details; server errors return 500.","parameters":[],"requestBody":{"description":"Search criteria, pagination, and sorting parameters for guest records","typeName":"ITodoAppGuest.IRequest"},"responseBody":{"description":"Paginated list of guest record summaries matching the search criteria","typeName":"IPageITodoAppGuest.ISummary"},"authorizationType":null,"authorizationRole":"admin","name":"index","prerequisites":[]},{"specification":"Retrieve a single guest record from the todo_app_guest Prisma model. This operation is for administrative/support investigative use and returns the persisted fields from todo_app_guest (id, email, created_at, last_active_at, status). The implementation MUST validate guestId is a UUID, return 400 for malformed IDs, 404 when not found, and 500 for unexpected server errors. The service MUST record an audit entry in todo_app_audit_records for each access (admin_id, actor_role='admin', action_type='read_guest', target_resource='guest', target_id=guestId, created_at).","path":"/todoApp/admin/guests/{guestId}","method":"get","summary":"Retrieve a guest (visitor) record by ID from the todo_app_guest table","description":"Returns a single guest record from the todo_app_guest model. The guest model stores lightweight visitor entries such as optional email, creation timestamp, last activity, and a housekeeping status.\n\nSecurity and permissions: Access to guest records is restricted to administrative/support users only. Calls to this endpoint MUST be authenticated and authorized. The server implementation MUST create an audit record in todo_app_audit_records for each access (actor_role='admin', action_type='read_guest', target_resource='guest', target_id=guestId).\n\nData and behavior: The response contains the guest's persisted fields (id, email, created_at, last_active_at, status). This endpoint performs no mutation; it is strictly read-only. Validation rules require the path parameter to be a UUID. Errors returned include 400 for invalid ID format, 404 when the guest is not found, and 500 for unexpected server errors.","parameters":[{"name":"guestId","in":"path","description":"Unique identifier (UUID) of the guest record","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Guest record representation","typeName":"ITodoAppGuest"},"authorizationType":null,"authorizationRole":"admin","name":"at","prerequisites":[]},{"specification":"Search and retrieve a paginated list of users from the todo_app_user Prisma model. Supports pagination, sorting, and optional filters (e.g., account_status, emailLike). Returns summary fields suitable for admin listing (id, email, display_name, account_status, created_at, last_active_at). The service MUST exclude secrets such as password_hash from responses and MUST audit admin searches in todo_app_audit_records (actor_role='admin', action_type='search_users', reason optional). Implementers should validate pagination parameters and account_status filter values against the canonical set of statuses and enforce reasonable pageSize limits.","path":"/todoApp/admin/users","method":"patch","summary":"Search and retrieve a paginated list of user accounts (admin)","description":"Provides a paginated, filterable list of users from the todo_app_user model. Intended for administrative use to find users by email substring, account_status, or creation timeframe. Supports pagination and sorting to enable efficient UI listing.\n\nSecurity and permissions: This endpoint MUST be restricted to administrative roles. The response MUST NOT include sensitive fields such as password_hash. All accesses SHOULD be recorded in todo_app_audit_records with admin identifier and the used filter parameters (avoid storing full PII in logs unless necessary).\n\nValidation and errors: Validate pagination parameters (page >= 1, pageSize reasonable bounds), validate account_status values against the canonical list (e.g., 'active','suspended'), and validate emailLike length. Return 400 for malformed requests, 401/403 for unauthorized access, and 500 for server errors.","parameters":[],"requestBody":{"description":"Search criteria and pagination parameters for filtering users","typeName":"ITodoAppUser.IRequest"},"responseBody":{"description":"Paginated list of user summary information matching search criteria","typeName":"IPageITodoAppUser.ISummary"},"authorizationType":null,"authorizationRole":"admin","name":"index","prerequisites":[]},{"specification":"Retrieve a single user account by ID from the Prisma model `todo_app_user`. Returns a safe public profile representation suitable for UI display and support. This operation MUST NOT expose sensitive authentication fields such as `password_hash`. Authorization: only the account owner or an administrator may retrieve the record; administrative accesses MUST be recorded to `todo_app_audit_records` with actor_role='admin' and action_type='read_user'.","path":"/todoApp/user/users/{userId}","method":"get","summary":"Retrieve a user account by ID (todo_app_user)","description":"Purpose and overview:\n\nRetrieve the requested user account from the `todo_app_user` table by `userId`. The response contains public profile fields: `id`, `email`, `display_name`, `account_status`, `created_at`, `updated_at`, and `last_active_at`. The endpoint MUST NOT return `password_hash` or any internal secrets.\n\nSecurity and permissions:\n\n- Access policy: Owner or admin only. If the caller is the owner, return the full profile (excluding secrets). If the caller is an admin, return the profile and create an audit record in `todo_app_audit_records` with `actor_role='admin'` and `action_type='read_user'` and include optional reason when provided.\n- Validation: `userId` must be a UUID. Return 400 for malformed, 404 if not found, 403 if unauthorized.\n\nSchema relationship and notes:\n\nThis operation maps to Prisma model `todo_app_user`. Use only the documented safe fields in responses; do not expose `password_hash`. Any derived flags (e.g., `isVerified`) must be computed server-side and documented separately.\n\nError handling:\n\n- 400 Bad Request: invalid UUID\n- 403 Forbidden: not owner or not admin\n- 404 Not Found: user does not exist\n- 500 Internal Server Error: unexpected failures\n","parameters":[{"name":"userId","description":"Unique identifier of the target user (UUID).","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"User account details (public profile fields). Excludes `password_hash` and other sensitive fields.","typeName":"ITodoAppUser"},"authorizationType":null,"authorizationRole":"user","name":"at","prerequisites":[]},{"specification":"Administrator retrieval of a user account by ID from the Prisma model `todo_app_user`. Designed for support/maintenance UIs. This operation MUST NOT expose `password_hash`. Administrative access MUST be auditable in `todo_app_audit_records` (actor_role='admin', action_type='read_user').","path":"/todoApp/admin/users/{userId}","method":"get","summary":"Admin: retrieve a user account by ID (todo_app_user)","description":"Purpose and overview:\n\nAllow administrators to retrieve a user's profile for support and maintenance. Returns the same safe profile fields as the user-facing endpoint: `id`, `email`, `display_name`, `account_status`, `created_at`, `updated_at`, and `last_active_at`. Do NOT include `password_hash` or other secrets.\n\nSecurity and permissions:\n\n- Access policy: Only callers with admin privileges may call this endpoint. Each admin access MUST create an audit record in `todo_app_audit_records` with `actor_role='admin'`, `action_type='read_user'`, and include `admin_id` and `user_id`.\n- Validation: `userId` must be a UUID. Return 400 for malformed, 404 if not found, 403 if the caller lacks admin privileges.\n\nError handling: same as user-facing GET but ensure audit creation on success and on unauthorized attempts where applicable.\n","parameters":[{"name":"userId","description":"Unique identifier of the target user (UUID).","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"User account details for administrative view. Excludes `password_hash` and other sensitive fields.","typeName":"ITodoAppUser"},"authorizationType":null,"authorizationRole":"admin","name":"at","prerequisites":[]},{"specification":"Update allowed profile fields on the Prisma `todo_app_user` model. This endpoint is for the account owner to update their own profile (e.g., `display_name`). It MUST NOT accept or persist `password_hash`. Admins may use a separate admin update path to change `account_status` and such admin actions MUST be audited in `todo_app_audit_records` with `actor_role='admin'` and `action_type='update_user'.`","path":"/todoApp/user/users/{userId}","method":"put","summary":"Update a user account (todo_app_user) — owner","description":"Purpose and overview:\n\nUpdate mutable profile attributes for the specified user. Intended for owner-initiated updates such as `display_name`. System-managed fields (`id`, `created_at`, `updated_at`, `password_hash`) MUST NOT be accepted from clients. The server will set `updated_at` on successful update.\n\nSecurity and permissions:\n\n- Access policy: Only the resource owner may update their own profile via this path. Attempts to modify another user's profile MUST be rejected with 403. Admins should use the admin update endpoint.\n- Validation: `userId` must be a UUID. Validate `display_name` length (suggested <=255). If `email` changes are allowed by policy, require separate verification flow; otherwise reject email change attempts and return a clear error.\n\nSchema mapping and writable fields:\n\n- Writable by owner: `display_name` (optional).\n- Server-side only / disallowed: `id`, `created_at`, `updated_at`, `password_hash`.\n\nResponses and errors:\n\n- 200: updated user representation (safe fields only)\n- 400: invalid input or malformed UUID\n- 403: unauthorized (not owner)\n- 404: user not found\n","parameters":[{"name":"userId","description":"Unique identifier of the target user (UUID).","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Owner-updatable user fields. Clients MUST NOT provide `password_hash`. Typical allowed property: `display_name` (optional).","typeName":"ITodoAppUser.IUpdate"},"responseBody":{"description":"Updated user account (public profile fields). Excludes `password_hash`.","typeName":"ITodoAppUser"},"authorizationType":null,"authorizationRole":"user","name":"update","prerequisites":[]},{"specification":"Administrator update of user account fields on the Prisma `todo_app_user` model. Admins may change `account_status` (for example to 'suspended' or 'active') and such operations MUST be recorded in `todo_app_audit_records` with `actor_role='admin'` and `action_type='update_user'` including an optional `reason`. This endpoint MUST NOT accept `password_hash` for direct setting; password resets must use a dedicated flow.","path":"/todoApp/admin/users/{userId}","method":"put","summary":"Admin: update a user account (todo_app_user)","description":"Purpose and overview:\n\nAllow administrators to perform sanctioned updates to user accounts such as changing `account_status`. Admin updates must be auditable and follow validation rules. Do NOT accept `password_hash` in the request body.\n\nSecurity and permissions:\n\n- Access policy: Admin-only. Each successful admin update MUST create an audit record in `todo_app_audit_records` containing `admin_id`, `user_id`, `action_type='update_user'`, `reason` (optional), and `created_at`.\n- Validation: `userId` must be a UUID. `account_status` must be validated against allowed values (e.g., 'active','suspended') and rejected if invalid.\n\nSchema mapping and writable fields:\n\n- Admin-writable: `account_status` (validated), optionally `display_name` for admin corrections.\n- Disallowed: `password_hash`, `id`, `created_at` (server-managed).\n\nResponses and errors: standard 200/400/403/404 semantics apply.\n","parameters":[{"name":"userId","description":"Unique identifier of the target user (UUID).","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Admin-updatable user fields. Must not include `password_hash`. Typical allowed properties: `account_status` (e.g., 'active','suspended'), `display_name` (optional).","typeName":"ITodoAppUser.IUpdate"},"responseBody":{"description":"Updated user account (public profile fields). Excludes `password_hash`.","typeName":"ITodoAppUser"},"authorizationType":null,"authorizationRole":"admin","name":"update","prerequisites":[]},{"specification":"This operation provides an administrative search and retrieval API for the todo_app_admin table in the Prisma schema. It enables privileged clients (administrators) to perform complex queries, filtering, sorting and pagination over administrative accounts. The operation maps to the todo_app_admin model and uses only fields present in that model (id, email, password_hash, is_super, created_at, last_active_at) for filtering and projection. Implementation must redact or exclude sensitive fields such as password_hash from responses and enforce strict audit logging for all accesses. Query rules include optional filters by email (exact or partial), by is_super flag, by created_at date ranges, and sorting by created_at or last_active_at. Pagination parameters (page, pageSize) and search text (email) should be supported in the request DTO. Security considerations: only callers with administrative privileges may call this endpoint; responses must not include password_hash. Related operations: GET /admins/{adminId} returns a single admin detail.","path":"/todoApp/admin/admins","method":"patch","description":"Retrieve a filtered, sorted and paginated list of administrative accounts from the todo_app_admin table.\n\nPurpose and overview: This operation lets authorized systems and operators query administrative accounts for support, audit, and maintenance tasks. It operates directly on the todo_app_admin model defined in the Prisma schema, which stores admin account identifiers, email addresses, super-admin flags, account creation timestamps, and last-active timestamps. The operation supports pagination, free-text email search, boolean filtering on the is_super flag, and sorting by created_at or last_active_at.\n\nSecurity considerations and user permissions: Access to this endpoint is restricted to administrative actors. All accesses to admin records via this endpoint MUST be recorded in audit logs (see todo_app_audit_records) with actor id, action_type, target_resource and timestamp. Responses MUST NOT expose sensitive fields such as password_hash. The service layer should filter out or redact password_hash before sending any response. Rate-limiting and monitoring are recommended to detect abusive enumeration attempts.\n\nRelationship to underlying database entities: This operation queries the todo_app_admin table (Prisma model todo_app_admin). Querying capabilities should correspond to existing schema fields: id (uuid), email (unique), is_super (boolean), created_at (timestamptz), and last_active_at (nullable timestamptz). Implementations may optionally join audit data for enriched results but must avoid leaking audit details unless explicitly requested.\n\nValidation rules and business logic: The request DTO must validate pagination parameters (page >= 1, pageSize reasonable limits), validate sort fields to allowed set (created_at, last_active_at), and require that the caller is an admin. Search parameters for email should be normalized and limited to prevent high-cost queries. Any attempt to include password_hash in projection or filters must be rejected.\n\nRelated API operations: Use GET /admins/{adminId} to retrieve a single admin's details. Use audit-record endpoints (not part of this interface) to inspect who accessed admin records. Error handling: return 400 for invalid request payloads, 401/403 for unauthorized requests, 429 for rate limits, and 500 for unexpected server errors.","summary":"Search and retrieve a filtered, paginated list of administrative accounts (todo_app_admin)","parameters":[],"requestBody":{"description":"Search, filter, sort and pagination parameters for listing administrative accounts","typeName":"ITodoAppAdmin.IRequest"},"responseBody":{"description":"Paginated list of administrative account summaries (sensitive fields redacted)","typeName":"IPageITodoAppAdmin.ISummary"},"authorizationRoles":["admin"],"name":"index","authorizationRole":"admin","authorizationType":null,"prerequisites":[]},{"specification":"This operation returns detailed information about a single administrative account from the todo_app_admin Prisma model. It exposes non-sensitive fields (id, email, is_super, created_at, last_active_at) and explicitly excludes or redacts sensitive data such as password_hash. The operation must validate the existence of the admin record referenced by the adminId path parameter and enforce access control so only authorized administrative callers may retrieve the record. All accesses should be recorded in the audit trail (todo_app_audit_records).\n\nThis operation references the todo_app_admin table and must use that model's fields directly; it must not reference fields that are not present in the model. If the requested adminId does not exist, the operation should return a 404 Not Found. If the caller is not authorized, return 403 Forbidden.","path":"/todoApp/admin/admins/{adminId}","method":"get","description":"Retrieve a single administrative account by its identifier from the todo_app_admin table.\n\nPurpose and overview: Returns details for one admin account to support operational and support workflows. The response includes id, email, is_super, created_at, and last_active_at and MUST NOT include password_hash or other sensitive secrets.\n\nSecurity considerations and user permissions: Only administrative callers are allowed to use this endpoint. Each successful or failed access SHOULD be recorded in todo_app_audit_records for traceability. Super-admin privileges (is_super) may be required for certain management actions, but simple read access may be permitted to standard admins depending on policy; the business rule here is that only \"admin\" role callers may reach this endpoint.\n\nRelationship to underlying database entities: This operation directly maps to the todo_app_admin Prisma model. Implementations should use the schema's id (uuid) path parameter to find the corresponding record and map the model's fields into the response DTO.\n\nValidation rules and business logic: The adminId path parameter MUST be a UUID. The service MUST return 404 if the record is absent. The response MUST redact password_hash. Audit logging is required for all accesses.\n\nRelated API operations: The PATCH /admins endpoint supports searching and listing admins; use that for broader queries.\n\nExpected errors: 400 for malformed UUID, 403 for unauthorized access, 404 when admin not found, 500 for server errors.","summary":"Retrieve detailed information for a specific administrative account (todo_app_admin)","parameters":[{"name":"adminId","description":"Unique identifier (UUID) of the target admin account","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed admin account information with sensitive fields redacted","typeName":"ITodoAppAdmin"},"authorizationRoles":["admin"],"name":"at","authorizationRole":"admin","authorizationType":null,"prerequisites":[]},{"specification":"Update an administrative account in the todo_app_admin table. This operation modifies permitted admin fields (email, is_super, last_active_at) for a given admin identified by adminId. It must NOT accept or return password_hash; credential changes are handled by a dedicated credential management endpoint. Implementations MUST create an audit record in todo_app_audit_records as a server-side side effect with action_type 'update_admin', actor_role 'admin', target_resource 'admin', and target_id set to the admin being modified. Business rule: if the request attempts to change is_super, the caller must be an existing super-admin; otherwise the request must be rejected with 403. Associated Prisma DB table: todo_app_admin.","path":"/todoApp/admin/admins/{adminId}","method":"put","summary":"Update an admin account (todo_app_admin)","description":"Update an administrative account's permitted, non-sensitive fields. This operation updates fields on the todo_app_admin model as defined in the Prisma schema (id, email, is_super, created_at, last_active_at). IMPORTANT: this endpoint MUST NOT accept or return `password_hash` or any other credential material. Password/credential rotation must be performed via a dedicated secure credential endpoint.\n\nSecurity and permissions: Only authenticated admins may call this endpoint. If the request payload attempts to change the `is_super` flag, the server MUST verify the caller is a super-admin and otherwise return 403 Forbidden. The server must also validate that the provided email (if present) does not conflict with other unique constraints and handle 409 Conflict when appropriate.\n\nAudit: Implementations MUST generate an audit record in todo_app_audit_records as a server-side side effect for every successful administrative modification. The audit entry should include actor_id (caller), actor_role='admin', action_type='update_admin', target_resource='admin', target_id (adminId), optional reason, and created_at timestamp.\n\nValidation and error handling: The request MUST conform to the ITodoAppAdmin.IUpdate DTO which excludes password_hash. Possible responses: 200 OK with a safe admin representation (no secrets), 400 Bad Request for validation errors, 403 Forbidden for insufficient privileges, 404 Not Found if adminId does not exist, 409 Conflict for uniqueness violations, and 500 for server errors.","parameters":[{"name":"adminId","description":"Unique identifier (UUID) of the target admin account","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Admin update payload. Only include mutable, non-sensitive fields (email, is_super, last_active_at). Do NOT include password_hash. For credential updates use the credential management endpoint.","typeName":"ITodoAppAdmin.IUpdate"},"responseBody":{"description":"Updated administrative account representation (safe view). This summary MUST NOT include password_hash or other secret fields.","typeName":"ITodoAppAdmin.ISummary"},"authorizationType":null,"authorizationRole":"admin","name":"update","prerequisites":[]},{"specification":"Permanently remove an administrative account from the todo_app_admin table. The todo_app_admin model does not include soft-delete timestamps, so this endpoint performs a hard delete; implementations must ensure backups, compliance, and auditability before removal. Only super-admins should be permitted to perform permanent removals. The operation MUST create an audit record in todo_app_audit_records with action_type 'erase_admin' (or 'purge_admin'), actor_role 'admin', target_resource 'admin', target_id equal to removed admin id, optional reason, and created_at timestamp. Associated Prisma DB table: todo_app_admin.","path":"/todoApp/admin/admins/{adminId}","method":"delete","summary":"Permanently remove an admin account (todo_app_admin)","description":"Permanently deletes an admin record identified by adminId from the todo_app_admin table. Because the model lacks a soft-delete field, this action is irreversible through normal user flows and should only be permitted after appropriate operational checks.\n\nSecurity and permissions: This operation MUST be restricted to super-admins. The server MUST enforce protections to prevent accidental lockout: it MUST prevent self-deletion (caller deleting their own account) unless an explicit, documented multi-step confirmation flow is used, and it MUST prevent deleting the last remaining super-admin (return 409 Conflict). If the caller lacks privileges, return 403 Forbidden.\n\nAudit and retention: The server MUST create an append-only audit record in todo_app_audit_records for this action with actor_id, actor_role='admin', action_type='erase_admin', target_resource='admin', target_id (adminId), optional reason, and created_at timestamp. Audit records referencing the removed admin MUST NOT be deleted as part of this operation.\n\nBehavior and errors: On success return 204 No Content. If adminId not found return 404 Not Found. If the deletion would violate policy (self-delete or removal of last super-admin) return 409 Conflict with explanatory message. Server errors return 500.","parameters":[{"name":"adminId","description":"Unique identifier (UUID) of the admin account to remove","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationType":null,"authorizationRole":"admin","name":"erase","prerequisites":[]}],"components":{"authorization":[{"name":"guest","description":"Unauthenticated visitor who can view public landing information and help content but cannot create, view, modify, or delete todos. Guests cannot authenticate via API and have no persistent personal data.","kind":"guest"},{"name":"user","description":"Authenticated standard user who can register, authenticate via API, and manage their own todos (create, read, update, delete, mark complete/incomplete). Can set optional attributes such as due date and priority for each todo. Cannot access other users' data or administrative functions.","kind":"member"},{"name":"admin","description":"Authenticated administrator who can authenticate via API and perform elevated management tasks: view aggregate usage, manage user accounts (suspend/reactivate), and perform data maintenance operations. Admins may also act as a regular user for troubleshooting but must be audited when performing admin actions.","kind":"admin"}],"schemas":{"IPage.IPagination":{"type":"object","properties":{"current":{"type":"integer","minimum":0,"description":"Current page number."},"limit":{"type":"integer","minimum":0,"description":"Limitation of records per a page."},"records":{"type":"integer","minimum":0,"description":"Total records in the database."},"pages":{"type":"integer","minimum":0,"description":"Total pages.\n\nEqual to {@link records} / {@link limit} with ceiling."}},"required":["current","limit","records","pages"],"description":"Page information."},"IAuthorizationToken":{"type":"object","properties":{"access":{"type":"string","description":"JWT access token for authenticated requests.\n\nThis token should be included in the Authorization header for subsequent\nauthenticated API requests as `Bearer {token}`."},"refresh":{"type":"string","description":"Refresh token for obtaining new access tokens.\n\nThis token can be used to request new access tokens when the current access\ntoken expires, extending the user's session."},"expired_at":{"type":"string","format":"date-time","description":"Access token expiration timestamp.\n\nISO 8601 date-time string indicating when the access token will expire and\ncan no longer be used for authentication."},"refreshable_until":{"type":"string","format":"date-time","description":"Refresh token expiration timestamp.\n\nISO 8601 date-time string indicating the latest time until which the\nrefresh token can be used to obtain new access tokens."}},"required":["access","refresh","expired_at","refreshable_until"],"description":"Authorization token response structure.\n\nThis interface defines the structure of the authorization token response\nreturned after successful user authentication. It contains both access and\nrefresh tokens along with their expiration information.\n\nThis token structure is automatically included in API schemas when the system\ndetects authorization roles in the requirements analysis phase. It provides a\nstandard format for JWT-based authentication across the generated backend\napplications."},"IPageITodoAppTodo.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoAppTodo.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageITodoAppTodoSnapshot":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoAppTodoSnapshot"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageITodoAppAuditRecord":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoAppAuditRecord"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageITodoAppGuest.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoAppGuest.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageITodoAppUser.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoAppUser.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageITodoAppAdmin.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoAppAdmin.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"ITodoAppGuest.IJoin":{"type":"object","x-autobe-prisma-schema":"todo_app_guest","properties":{"email":{"oneOf":[{"type":"string","format":"email"},{"type":"null"}],"description":"Optional visitor email address as defined by the Prisma model `todo_app_guest.email`.\n\nThis property maps directly to the `email` column in the `todo_app_guest` Prisma model and is nullable by design. When provided, the value MUST be a valid email address. Clients may omit this property to create an anonymous guest record; the server will generate system-managed fields such as `id` and `created_at` and must set them itself."}},"required":[],"description":"Payload to create a guest record (maps to the Prisma model `todo_app_guest`).\n\nThis request object contains only fields the client may provide when creating an ephemeral or anonymous guest record. System-managed fields (id, created_at, last_active_at, status) are set by the server and MUST NOT be provided by the client."},"ITodoAppGuest.IAuthorized":{"type":"object","x-autobe-prisma-schema":"todo_app_guest","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier for the guest record.\n\nThis value corresponds to the `todo_app_guest.id` primary key in the Prisma model. It is generated by the server as a UUID and is intended for client usage to reference the created guest record in subsequent calls."},"email":{"oneOf":[{"type":"string","format":"email"},{"type":"null"}],"description":"Guest email as stored on the `todo_app_guest` row (nullable).\n\nWhen present, this is the persisted `email` column value for the guest. It may be `null` for anonymous guests. This property is provided in the authorized response to help clients display or cache guest contact data when available."},"created_at":{"type":"string","format":"date-time","description":"Record creation timestamp for the guest entry.\n\nThis corresponds to the `todo_app_guest.created_at` column in the Prisma model and is expressed in RFC 3339 / ISO 8601 date-time format (UTC recommended). It indicates when the guest record was created by the server."},"last_active_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Last observed activity timestamp for the guest (nullable).\n\nMaps to `todo_app_guest.last_active_at`. This field may be updated by refresh or activity endpoints and is `null` until the guest performs subsequent interactions."},"status":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Administrative housekeeping status for the guest as stored in `todo_app_guest.status`.\n\nThis optional field is used for administrative classification (for example, \"active\", \"bounced\"). Values are implementation-defined strings stored in the Prisma model. Clients SHOULD treat this as informational only and MUST NOT rely on exact status text for client-side logic unless agreed with the service contract."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","created_at","token"],"description":"Authorization response returned after successful guest creation or token refresh.\n\nThis object contains both persisted guest attributes (those that exist on the `todo_app_guest` Prisma model) and a computed `token` property that provides the authorization material for client usage. The `id` and `token` properties are always present in successful authorization responses. Timestamps use ISO 8601 date-time format. Audit and security-sensitive fields are intentionally excluded from this response."},"ITodoAppGuest.IRefresh":{"type":"object","properties":{"refresh_token":{"type":"string","description":"Opaque refresh credential previously issued to the guest session. The server validates this token, rotates or replaces it when appropriate, and issues a new access token on success. This value is required and must be provided exactly as issued by the service (do not URL-encode or alter).","minLength":1}},"required":["refresh_token"],"description":"Guest refresh request used to obtain a new short-lived access token for an existing guest identity.\n\nThis request payload contains a single required property, `refresh_token`, which represents the refresh credential issued by the server when the guest session was created. On successful validation the server SHOULD update the guest record's `last_active_at` (todo_app_guest.last_active_at) to the current timestamp and MAY record the refresh event in audit logs (todo_app_audit_records) for operational observability.\n\nThis schema is a request DTO and does not directly map to a persistent Prisma model column for token material; the underlying `todo_app_guest` model contains `id`, `email`, `created_at`, `last_active_at`, and `status`. Do NOT include any sensitive secrets or password material in this request. All descriptions and processing notes are provided for implementers and API consumers."},"ITodoAppUser.ICreate":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Primary email address for the new user account. This maps to `todo_app_user.email` in the Prisma schema and must be unique. Use a business-format address suitable for account recovery and notifications. The server enforces uniqueness and will return a conflict error if the email already exists."},"password":{"type":"string","description":"Plain-text password supplied by the client. The server MUST hash this value (store only `password_hash` in the database) and MUST never return the plain-text password in any response. Recommended minimum length: 8 characters. The server may enforce additional password rules (complexity) per policy.","minLength":8},"display_name":{"oneOf":[{"type":"string","minLength":1,"maxLength":255},{"type":"null"}],"description":"Optional human-friendly display name for the account. This maps to `todo_app_user.display_name` in the Prisma schema. If omitted the server may leave the column null. The property explicitly allows null to indicate clearing the display name when supported."}},"required":["email","password"],"description":"Create DTO for a new user account.\n\nThis request object contains the minimal fields required to register a new user in the system. It maps to the `todo_app_user` Prisma model conceptually; upon successful processing the server will create a new row and populate server-managed fields (`id`, `password_hash`, `account_status`, `created_at`, `updated_at`, `last_active_at`).\n\nSecurity notes: Clients MUST send the `password` in plain text over a secure channel (TLS) so the server can hash it; the server MUST NOT accept pre-hashed password fields (e.g., `password_hash`). The server MUST enforce the unique constraint on `email` as defined by the Prisma schema and return an appropriate conflict error when violated. Do not include server-only fields (id, created_at, updated_at, password_hash, account_status) in this DTO."},"ITodoAppUser.IAuthorized":{"type":"object","x-autobe-prisma-schema":"todo_app_user","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the authenticated user (maps to todo_app_user.id). This value is a UUID assigned by the system and MUST be used by clients to reference the authenticated account in subsequent API calls."},"email":{"type":"string","format":"email","description":"Primary email address of the user account.\n\nThis field corresponds to `todo_app_user.email` in the Prisma schema and is unique across accounts. It is used for authentication, password recovery flows, and administrative contact. Implementations should validate email format (RFC 5322 basic validation) and never expose this field in logs without appropriate privacy controls."},"display_name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional human-friendly display name for the user.\n\nThis property maps to `todo_app_user.display_name`. It is nullable and intended for UI presentation. When present, it should be a trimmed string; when not set, the property may be null. Do not use this field to infer authentication or authorization decisions."},"account_status":{"type":"string","description":"Lifecycle status of the user account.\n\nThis property corresponds to `todo_app_user.account_status` in the Prisma model and records account state such as 'active' or 'suspended' as defined by product policy. Values are implementation-defined strings managed by administrative workflows and must be enforced by business logic (for example: deny login when status = 'suspended')."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was created.\n\nThis maps to `todo_app_user.created_at` in the Prisma schema. Timestamps use ISO 8601 / RFC 3339 format with timezone (recommended 'date-time' format). This value is system-generated and immutable after creation."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was last modified.\n\nThis field maps to `todo_app_user.updated_at` in the Prisma model and is updated by server-side operations that change account data (profile edits, password changes, etc.). Clients should treat this as authoritative for optimistic-concurrency checks."},"last_active_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Optional timestamp of the user's most recent activity.\n\nThis property corresponds to `todo_app_user.last_active_at`. It may be null when no activity has been recorded. Use this field for presence and analytics; do not rely on it for strict security checks."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"},"user":{"$ref":"#/components/schemas/ITodoAppUser.ISummary","description":"Optional lightweight representation of the authenticated user. Includes safe profile fields suitable for client display. Sensitive fields such as password_hash are intentionally excluded."}},"required":["id","email","account_status","created_at","updated_at","token"],"description":"Authorization response returned after successful authentication or registration.\n\nThis schema represents the authorized session for a TodoApp user. It includes the user's stable identifier and a token object that contains the access/refresh credentials necessary for subsequent authenticated API calls. The token property references the shared IAuthorizationToken schema to ensure consistent token handling across authentication endpoints.\n\nThe optional `user` property provides a safe summary of the authenticated user's profile (for example, email and display name) and is intended for immediate client display after authentication. Sensitive fields such as password_hash are excluded from this DTO.\n\nNote: Because this schema corresponds to the Prisma model `todo_app_user`, all listed properties (except computed or runtime-only properties) exist in the underlying model and must be consistent with database constraints. The server MUST NOT return password or password hash in this response."},"ITodoAppUser.ILogin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"The user's primary email address used for authentication. Must be a valid email format and correspond to an existing account when attempting to log in."},"password":{"type":"string","description":"Plain-text password supplied by the user for authentication. This value is accepted only for authentication; the server MUST hash and never store plain-text passwords. Clients MUST transmit this value over TLS."}},"required":["email","password"],"description":"Login request payload for authenticating an existing user.\n\nClients MUST provide the email and password in this object to obtain an authorization response. The server validates credentials against the `todo_app_user.password_hash` and, on success, returns an `ITodoAppUser.IAuthorized` response containing tokens and optional user summary.\n\nSecurity note: Passwords MUST be transmitted using secure channels (TLS). The server MUST never echo the password back in responses or logs. Error responses for authentication failures SHOULD be generic to avoid account enumeration."},"ITodoAppUser.ISummary":{"type":"object","x-autobe-prisma-schema":"todo_app_user","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the user account (UUID) as stored in the todo_app_user table."},"email":{"type":"string","format":"email","description":"Primary email address for the user account. This field is required by the Prisma model and is used for login and communication.\n\nReturned in summaries for administrative listing and owner-facing profile views. Never include password_hash in any response."},"display_name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional display name for the user. Nullable in the Prisma model; when absent the value is null."},"account_status":{"type":"string","description":"Account lifecycle status as stored in the Prisma model (for example 'active' or 'suspended').\n\nThis field is required in summary responses to enable admin filtering and support workflows."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was created (ISO 8601 date-time). This field exists in the Prisma model and is server-populated."},"last_active_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Nullable timestamp of the user's last observed activity. May be null if the user has not been active since account creation."}},"required":["id","email","account_status","created_at"],"description":"User account summary used in paginated admin/user listings.\n\nThis schema intentionally excludes the `password_hash` and other sensitive fields from responses. It maps directly to the Prisma model `todo_app_user` and includes only safe, public-facing attributes."},"ITodoAppUser.IRefresh":{"type":"object","properties":{"refreshToken":{"type":"string","description":"Refresh credential previously issued by the authentication service. Present the token exactly as issued (opaque token or JWT). The server will validate this token and, on success, issue a new access token and optionally rotate the refresh token.","minLength":1}},"required":["refreshToken"],"description":"Request body for exchanging a refresh credential for a new access token.\n\nThis DTO is used when a client needs to obtain a fresh short-lived access token without re-entering credentials. The server validates the provided refreshToken and, if valid, issues a new access token and may rotate the refresh token. The server may update the corresponding user's last_active_at timestamp when the refresh is accepted.\n\nSecurity note: Treat refreshToken as sensitive and transmit it only over TLS."},"ITodoAppUser.IChangePassword.IByCurrent":{"type":"object","properties":{"currentPassword":{"type":"string","description":"The user's current plaintext password. The server MUST verify this value against the stored credential before accepting the change. Do NOT log or echo this value in any responses.","minLength":8},"newPassword":{"type":"string","description":"The desired new plaintext password. The server will hash this value and store the result in the user's password_hash field. Follow the service password policy (recommended minimum 8 characters, at least one letter and one number). Do NOT return this value in any responses.","minLength":8}},"required":["currentPassword","newPassword"],"description":"Change-password request variant for owner-initiated password changes that include the current password.\n\nServer behavior: validate the provided currentPassword, compute and store a secure hash of newPassword, update updated_at on the user record, optionally revoke/rotate refresh tokens, and record an audit entry when policy requires."},"ITodoAppUser.IChangePassword.IByReset":{"type":"object","properties":{"resetToken":{"type":"string","description":"One-time password-reset token previously issued by the system (for example via email). The server MUST validate the token's authenticity and expiry before allowing the change.","minLength":1},"newPassword":{"type":"string","description":"The desired new plaintext password for the account. The server will hash this value and store the result in the user's password_hash field. Follow the service password policy (recommended minimum 8 characters, at least one letter and one number).","minLength":8}},"required":["resetToken","newPassword"],"description":"Change-password request variant used when the user supplies a valid password-reset token.\n\nServer behaviour: validate resetToken (single-use, unexpired), compute and store secure hash of newPassword, update updated_at, and record the action in audit logs when policy requires."},"ITodoAppUser.IChangePassword":{"oneOf":[{"$ref":"#/components/schemas/ITodoAppUser.IChangePassword.IByCurrent"},{"$ref":"#/components/schemas/ITodoAppUser.IChangePassword.IByReset"}],"description":"Change-password request DTO supporting two mutually exclusive patterns.\n\nClients MUST provide exactly one of the two variants:\n- Owner-initiated change (currentPassword + newPassword)\n- Reset-flow change (resetToken + newPassword)\n\nThe server validates the provided proof (current password or reset token), updates the stored password hash with a secure hash of newPassword, updates updated_at, and may revoke/rotate refresh tokens according to security policy."},"ITodoAppUser.IProfile":{"type":"object","x-autobe-prisma-schema":"todo_app_user","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the user account as defined in the Prisma model (todo_app_user.id).\n\nThis value uniquely identifies the user within the system and is used to associate todos and audit events with the account. It is produced by the server and is returned in profile responses for client-side correlation and navigation."},"email":{"type":"string","format":"email","description":"Primary email address for the user account (todo_app_user.email).\n\nThis field is the canonical contact and login identifier for the account. It is returned in profile responses but must never expose authentication secrets. Email values must follow a valid email format."},"display_name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional display name for the user (todo_app_user.display_name).\n\nThis value may be null when the user has not provided a display name. It is intended for UI presentation only and may contain user-chosen text such as a full name or nickname."},"account_status":{"type":"string","description":"Account lifecycle status (todo_app_user.account_status).\n\nPossible values are implementation-specific (for example: 'active', 'suspended', 'deleted' or 'unverified'). This property reflects the current account state as stored in the database and is used by clients to determine whether the account may perform authenticated actions."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was created (todo_app_user.created_at).\n\nRepresented in ISO 8601 / RFC 3339 date-time format. This value is system-managed and returned for display, sorting, and audit purposes."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was last modified (todo_app_user.updated_at).\n\nThis value is system-managed and updated on profile or credential changes. Clients may use it to detect stale cached profiles."},"last_active_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Optional timestamp of the user's last observed activity (todo_app_user.last_active_at).\n\nThis field is nullable and may be omitted or null if no activity has been recorded yet. When present, it indicates the most recent time the user interacted with the system (login, API call, etc.)."}},"required":["id","email","account_status","created_at","updated_at"],"description":"User profile returned to clients (public-facing, safe view).\n\nThis schema represents a safe, public profile view of the todo_app_user Prisma model. It intentionally omits sensitive authentication fields such as password_hash and includes only fields suitable for client consumption and support workflows. The schema maps to the Prisma model `todo_app_user` and therefore only includes properties that exist on that model or are derived in a manner consistent with server-side handling.\n\nProfile fields: id (UUID), email, optional display_name, account_status, created_at, updated_at, and optional last_active_at. Use this type for authenticated-user profile responses and authorization-aware views."},"ITodoAppAdmin.ICreate":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Admin account email (todo_app_admin.email).\n\nThis is the primary identifier for the administrative account and must be unique. Provide a valid business email address used for login and notifications."},"password":{"type":"string","description":"Plain-text password for initial admin account creation.\n\nClients MUST provide a user-chosen password in plain text for creation flows; the server is responsible for hashing and storing the result in `todo_app_admin.password_hash`. Do NOT include or expect `password_hash` in requests or responses. Password policy (min length, complexity) is enforced by the server."},"is_super":{"type":"boolean","description":"Flag indicating whether the created admin should have super-admin privileges (todo_app_admin.is_super).\n\nWhen true, the account is granted elevated capabilities; server policies may restrict who can create super-admin accounts. This property is optional and defaults to false when omitted."}},"required":["email","password"],"description":"Create DTO for administrative accounts.\n\nThis schema is the request body for creating a new admin. It accepts the client-provided, user-editable fields required to register an admin: `email` and `password` (plain text). The server will hash the supplied password and persist it as `password_hash` on the todo_app_admin record. The optional `is_super` flag allows requesting super-admin privileges, subject to server-side authorization checks and policies.\n\nSecurity notes: The server MUST never echo back password plaintext or `password_hash` in responses. Administrative creation actions SHOULD be logged in audit records for traceability."},"ITodoAppAdmin.IAuthorized":{"type":"object","x-autobe-prisma-schema":"todo_app_admin","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the administrator account as stored in the todo_app_admin table.\n\nThis value maps directly to the Prisma model primary key and is used to correlate audit records and administrative actions."},"email":{"type":"string","format":"email","description":"Administrator's email address used for login and notifications.\n\nThis field matches the `email` column on the todo_app_admin Prisma model and is returned as part of the authorized user summary. For privacy and security reasons, hashed credentials are never exposed."},"is_super":{"type":"boolean","description":"Flag indicating whether the administrator has super-admin privileges.\n\nTrue indicates elevated privileges that may be required for sensitive administrative operations. This property mirrors the `is_super` column on the todo_app_admin Prisma model."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the administrator account was created.\n\nThis uses ISO 8601 / RFC 3339 date-time format and directly corresponds to the `created_at` column on the todo_app_admin model."},"last_active_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Most recent activity timestamp for the admin account, or null if no activity has been recorded.\n\nWhen present, this timestamp is an ISO 8601 date-time and corresponds to the `last_active_at` column on the todo_app_admin model."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","email","is_super","created_at","token"],"description":"Authorization response for administrative accounts.\n\nThis schema is returned after successful admin authentication flows such as login, join, or token refresh. It provides a minimal, safe summary of the authenticated admin account (id, email, is_super, timestamps) together with the issued authorization token payload referenced by `IAuthorizationToken`.\n\nSensitive fields such as `password_hash` are intentionally omitted. When `x-autobe-prisma-schema` is present, every property listed here corresponds to an actual column on the `todo_app_admin` Prisma model."},"ITodoAppAdmin.ILogin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Admin account email used for authentication.\n\nMust be a valid email address associated with an existing administrative account. Implementations should treat this value case-insensitively when matching existing records."},"password":{"type":"string","description":"Plain-text password supplied for authentication.\n\nThis value is accepted only for authentication purposes and MUST NOT be stored or echoed back in any response. The server is responsible for validating and then hashing or discarding the plain secret."}},"required":["email","password"],"description":"Login request body for administrator authentication.\n\nClients must provide the admin's email and password. On success, this request is expected to return an `ITodoAppAdmin.IAuthorized` response containing issued tokens and admin summary. The schema intentionally does not include any persistent or server-managed fields."},"ITodoAppAdmin.IRefresh":{"type":"object","properties":{"refresh_token":{"type":"string","description":"Refresh token previously issued by the authentication service. This opaque string is presented to the server to obtain a new short-lived access token. Clients MUST treat this value as sensitive and transmit it only over TLS."}},"required":["refresh_token"],"description":"Request payload for renewing administrator access tokens.\n\nThis DTO is used by the admin token refresh endpoint (POST /auth/admin/refresh). It contains the refresh credential that the server validates and (optionally) rotates when issuing a new access token. This type does not map directly to a Prisma model and is part of the token lifecycle contract between client and server.\n\nSecurity note: Refresh tokens should be stored and transmitted securely. The server should apply rotation and revocation policies and log suspicious refresh activity for audit purposes."},"ITodoAppAdmin.IRequestPasswordReset":{"type":"object","x-autobe-prisma-schema":"todo_app_admin","properties":{"email":{"type":"string","format":"email","description":"Email address of the administrator account to initiate password reset for. This value corresponds to the todo_app_admin.email column in the Prisma schema. For security, the API SHOULD not disclose whether the email exists in the system in its response body."}},"required":["email"],"description":"Request payload to initiate an administrator password reset.\n\nThis DTO is used by POST /auth/admin/password/reset. The server locates the matching todo_app_admin row using the provided email and, if policy permits, issues a time-limited reset token via email. The presence of \"x-autobe-prisma-schema\": \"todo_app_admin\" indicates the `email` property maps to the Prisma model's email column; when this field is present it MUST exist on the referenced Prisma model."},"ITodoAppAdmin.IMessage":{"type":"object","properties":{"message":{"type":"string","description":"Human-readable summary message describing the result of an operation.\n\nThis field is intended for display in administrative UIs or API clients to convey short operation outcomes such as confirmations, informational notes, or non-sensitive status messages. Keep content concise and user-facing."}},"required":["message"],"description":"Simple operation result container for administrative endpoints.\n\nUse this schema when an API operation needs to return a short, human-friendly confirmation or informational message and no additional structured data. This type intentionally contains only a single, mandatory string property so callers can reliably display the returned text to administrators or support staff.\n\nDo not include sensitive details (passwords, tokens, hashes) in the message property. Use audit records for security-relevant event recording."},"ITodoAppAdmin.IChangePassword":{"type":"object","properties":{"currentPassword":{"type":"string","minLength":8,"description":"Current account password (plain text) presented for verification.\n\nFor authenticated change-password flows the server MUST verify this value before updating credentials. This property is required for owner-initiated password changes; password-reset flows that use one-time tokens use a different DTO and are not represented by this type."},"newPassword":{"type":"string","minLength":8,"description":"New desired password (plain text). Must meet the service password policy.\n\nThe server is responsible for applying hashing (e.g., bcrypt/argon2) and must never store or return plaintext passwords. Recommended policy: minimum length 8 with at least one letter and one number; apply additional complexity rules as product policy requires."}},"required":["currentPassword","newPassword"],"description":"Payload for an authenticated administrator to change their account password.\n\nThis request object is used by admin-scoped change-password endpoints and contains the current credential for verification plus the new credential to be set. The server MUST validate the currentPassword, enforce password policy on newPassword, hash the new password before storage (populate `todo_app_admin.password_hash`), update relevant timestamps, and record audit events for admin-initiated credential changes.\n\nImportant security notes: Do not echo passwords in any API responses or logs. Consider revoking or rotating active refresh tokens after a successful password change to reduce session theft risk."},"ITodoAppTodo":{"type":"object","x-autobe-prisma-schema":"todo_app_todos","properties":{"id":{"type":"string","format":"uuid","description":"Primary identifier for the todo item as defined in the Prisma model `todo_app_todos`.\n\nThis value is a UUID generated by the system and uniquely identifies the record. It is used in API paths and references (for example, when fetching or updating a single todo). Do not allow clients to set or change this value; it is system-managed."},"user_id":{"type":"string","format":"uuid","description":"Identifier of the owning user as stored in `todo_app_todos.user_id`.\n\nThis property links the todo to the owning `todo_app_user` record. The API must ensure returned todos belong to the requesting user (or that the caller is authorized to view the resource). This field is system-populated on create and must not be accepted from untrusted clients in create/update requests."},"title":{"type":"string","description":"Short task title taken from the `title` column in the Prisma model.\n\nThis is a required, public-facing field used for quick-capture and list display. Business validation: the title should be non-empty after trimming and constrained in length by server-side policy (recommended 1–250 characters)."},"description":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional longer description or notes for the todo item as defined by `description` in the Prisma model.\n\nThis field may be null when no description is provided. When present it can contain additional details to help users recall context; server-side validation should limit length (recommended <= 4000 characters)."},"is_completed":{"type":"boolean","description":"Boolean flag reflecting completion state of the todo (`is_completed` column in Prisma).\n\nTrue indicates the item has been completed. The API should update `completed_at` when this flag transitions to true and clear `completed_at` when it transitions back to false."},"completed_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when the todo was marked completed (`completed_at` in Prisma).\n\nThis is null for incomplete items. When present it is an RFC 3339 / ISO 8601 timestamp representing the completion time. The server is authoritative for this value."},"position":{"oneOf":[{"type":"integer"},{"type":"null"}],"description":"Optional integer used by clients to indicate manual ordering (`position` column in Prisma).\n\nNullable: when not provided the server or client may fall back to default ordering (e.g., created_at desc). If provided, it must be an integer and may be used for sort-by-position views."},"created_at":{"type":"string","format":"date-time","description":"Record creation timestamp from the `created_at` Prisma column.\n\nThis is a server-set timestamp indicating when the todo was originally created. It is provided to clients for display and sorting and must be produced in ISO 8601 / RFC 3339 format."},"updated_at":{"type":"string","format":"date-time","description":"Record last-modified timestamp from the `updated_at` Prisma column.\n\nThe server updates this on every change to the todo record. Clients should use this value for caching, concurrency checks, and to detect changes."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Soft-delete timestamp corresponding to `deleted_at` in the Prisma model.\n\nWhen null, the item is active (or completed). When set to a timestamp the item is considered soft-deleted and should be excluded from default list views. The retention and purge policy for deleted items is an operational concern described in product requirements."}},"required":["id","user_id","title","is_completed","created_at","updated_at"],"description":"Full representation of a todo record mapped to the Prisma model `todo_app_todos`.\n\nThis schema includes all persistent fields defined by the database model and is intended for detailed item views returned by read endpoints (GET /todoApp/user/todos/{todoId}) and for responses from create/update operations. Sensitive or system-managed fields (IDs and timestamps) are documented as server-managed and should not be accepted from untrusted clients in create/update requests."},"ITodoAppTodo.IRequest":{"type":"object","properties":{"page":{"type":"integer","minimum":1,"description":"Page number for pagination. Use 1-based indexing. Optional: if omitted the server will default to the first page."},"pageSize":{"type":"integer","minimum":1,"maximum":100,"description":"Number of items per page for paginated results. The server enforces a maximum page size (recommended max 100) to protect performance. If omitted the server default will apply."},"isCompleted":{"type":"boolean","description":"Optional filter to return only items matching completion state. When omitted, both completed and active items are returned (subject to deleted-item exclusion)."},"includeDeleted":{"type":"boolean","description":"When true, include soft-deleted records (items where `deleted_at` is not null). This flag should be used only in recovery or administrative contexts. By default (false or omitted) deleted items are excluded."},"sortBy":{"oneOf":[{"const":"created_at","description":"Sort key. Allowed values map to columns in the Prisma model: `created_at` or `position`. Use `created_at` for chronological order and `position` for client-managed ordering."},{"const":"position","description":"Sort key. Allowed values map to columns in the Prisma model: `created_at` or `position`. Use `created_at` for chronological order and `position` for client-managed ordering."}],"description":"Sort key. Allowed values map to columns in the Prisma model: `created_at` or `position`. Use `created_at` for chronological order and `position` for client-managed ordering."},"sortOrder":{"oneOf":[{"const":"asc","description":"Sort direction applied to the `sortBy` key. Allowed values: `asc` or `desc`. Default server behavior should be documented in the API (for example, newest-first for created_at)."},{"const":"desc","description":"Sort direction applied to the `sortBy` key. Allowed values: `asc` or `desc`. Default server behavior should be documented in the API (for example, newest-first for created_at)."}],"description":"Sort direction applied to the `sortBy` key. Allowed values: `asc` or `desc`. Default server behavior should be documented in the API (for example, newest-first for created_at)."},"q":{"type":"string","description":"Optional simple text search applied to title and/or description. The server may implement simple substring matching or use indexed search depending on implementation. Keep queries short for performance."}},"required":[],"description":"Request DTO for listing/searching todos owned by the requesting user.\n\nThis object contains pagination, filtering, and sorting parameters that map to the `todo_app_todos` model fields. All properties are optional to allow flexible queries. Servers SHOULD validate parameters and enforce sane defaults and limits to prevent expensive queries."},"ITodoAppTodo.ICreate":{"type":"object","x-autobe-prisma-schema":"todo_app_todos","properties":{"title":{"type":"string","minLength":1,"maxLength":250,"description":"Short task title used for quick capture and display.\n\nThis property maps to the Prisma model column `todo_app_todos.title`. It is a required business field and must contain at least one non-whitespace character. Use a concise summary suitable for list displays (recommended max 250 characters). The server will trim leading and trailing whitespace before validation."},"description":{"type":"string","maxLength":4000,"description":"Optional longer description or notes for the todo item.\n\nThis property maps to `todo_app_todos.description` in the Prisma model. It may be omitted when creating a todo. If provided, the text should be suitable for display in a detail view. Maximum length is 4000 characters; the server may trim surrounding whitespace."},"position":{"type":"integer","description":"Optional integer used by clients to indicate manual ordering or position within a list.\n\nThis property maps to `todo_app_todos.position` in the Prisma model. When present, it must be an integer. The server may normalize or adjust positions when persisting to maintain list invariants."},"is_completed":{"type":"boolean","description":"Optional initial completion state for the new todo.\n\nThis property maps to `todo_app_todos.is_completed` in the Prisma model. If omitted, the server will default the value to false. If provided as true, the server will also set the server-side `completed_at` timestamp according to business rules."}},"required":["title"],"description":"Create DTO for todo_app_todos.\n\nThis schema defines the request body for creating a new todo item. It intentionally includes only user-editable fields that exist on the `todo_app_todos` Prisma model. System-managed fields such as `id`, `user_id`, `created_at`, `updated_at`, `completed_at`, and `deleted_at` are NOT accepted in this payload and will be set by the server. The `title` property is required; other properties are optional and will be validated against the constraints described above."},"ITodoAppTodo.IUpdate":{"type":"object","x-autobe-prisma-schema":"todo_app_todos","properties":{"title":{"type":"string","minLength":1,"maxLength":250,"description":"Updated short title for the todo item.\n\nThis property maps to `todo_app_todos.title` and is optional in update payloads. When present, it must be a non-empty string (1..250 chars after trimming). Use this field to change the display summary of the todo."},"description":{"type":"string","maxLength":4000,"description":"Updated longer description or notes for the todo.\n\nThis property maps to `todo_app_todos.description` in the Prisma model. It is optional for updates. If omitted, the existing description remains unchanged. To clear an existing description, send an explicit empty string if policy allows; null semantics are implementation-dependent and clients should follow the API guide."},"position":{"type":"integer","description":"Updated integer position used for ordering within a list.\n\nThis property maps to `todo_app_todos.position`. Provide an integer value when reordering items. The server may re-normalize positions to maintain ordering constraints."},"is_completed":{"type":"boolean","description":"Toggle completion state for the todo item.\n\nThis property maps to `todo_app_todos.is_completed`. When set to true, the server will set `completed_at` to the current timestamp. When set to false, the server will clear `completed_at` and set the item back to the active state. This field is optional in update payloads."}},"required":[],"description":"Update DTO for todo_app_todos.\n\nAll properties are optional to support partial updates (PATCH/PUT semantics where partial payloads are permitted). This schema permits only client-editable columns defined on the `todo_app_todos` Prisma model. Immutable and system-managed columns (e.g., `id`, `user_id`, `created_at`, `updated_at`, `deleted_at`) must not be supplied by clients and will be enforced server-side. Validation rules for each property mirror the constraints described in the create DTO."},"ITodoAppTodoSnapshot":{"type":"object","x-autobe-prisma-schema":"todo_app_todo_snapshots","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the snapshot record. Corresponds to todo_app_todo_snapshots.id in the Prisma schema.\n\nThis field is a system-generated UUID that uniquely identifies the snapshot. It is used for lookups and audit/history references."},"todo_app_todo_id":{"type":"string","format":"uuid","description":"Reference to the source todo item. Corresponds to todo_app_todo_snapshots.todo_app_todo_id.\n\nThis UUID links the snapshot to the original todo_app_todos record and is required to correlate history with the live todo."},"title":{"type":"string","description":"Snapshot of the todo title at the time the snapshot was taken. Corresponds to todo_app_todo_snapshots.title.\n\nThis is a textual copy of the source title and is intended for display in history/version views."},"description":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Snapshot of the todo description at snapshot time. Corresponds to todo_app_todo_snapshots.description.\n\nThis field is nullable in the Prisma model and therefore may be null when no description existed at snapshot time."},"is_completed":{"type":"boolean","description":"Snapshot of the completion flag at snapshot time. Corresponds to todo_app_todo_snapshots.is_completed.\n\nTrue indicates the source todo was completed at the captured moment; false indicates it was not."},"completed_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Snapshot of the completed_at timestamp (if set on source). Corresponds to todo_app_todo_snapshots.completed_at.\n\nThis is nullable and records when the source todo was marked completed at the time of snapshot."},"position":{"oneOf":[{"type":"integer"},{"type":"null"}],"description":"Snapshot of the optional manual ordering position. Corresponds to todo_app_todo_snapshots.position.\n\nThis integer is nullable and used by clients that maintain custom ordering."},"created_at":{"type":"string","format":"date-time","description":"Original created_at from the source todo at snapshot time. Corresponds to todo_app_todo_snapshots.created_at.\n\nRepresents when the source todo was originally created; useful for historical context in the snapshot."},"updated_at":{"type":"string","format":"date-time","description":"Original updated_at from the source todo at snapshot time. Corresponds to todo_app_todo_snapshots.updated_at.\n\nIndicates the latest modification time on the source todo as observed when the snapshot was taken."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Original deleted_at from the source todo at snapshot time (nullable). Corresponds to todo_app_todo_snapshots.deleted_at.\n\nWhen present, this indicates the source todo was soft-deleted at or before the snapshot time."},"snapshot_at":{"type":"string","format":"date-time","description":"Timestamp when this snapshot was created. Corresponds to todo_app_todo_snapshots.snapshot_at.\n\nThis field records the point-in-time when the snapshot was captured and is required for ordering snapshot history."}},"required":["id","todo_app_todo_id","title","is_completed","created_at","updated_at","snapshot_at"],"description":"A todo snapshot representing the state of a todo_app_todos row at a specific point in time.\n\nThis schema maps directly to the Prisma model `todo_app_todo_snapshots`. It includes all persisted columns from that model and mirrors their optionality: nullable fields in the Prisma model are represented using oneOf with a null variant. Use this schema for snapshot retrieval and version-history responses."},"ITodoAppTodoSnapshot.IRequest":{"type":"object","properties":{"page":{"type":"integer","description":"Page number for pagination (1-based). If omitted, the server default page is applied.\n\nClients should use sensible paging to avoid large responses."},"pageSize":{"type":"integer","description":"Number of items per page. Server may enforce a maximum. If omitted the server default page size will be used."},"sortBy":{"oneOf":[{"const":"snapshot_at","description":"Sort key for snapshots. Allowed values reference snapshot fields on the model: 'snapshot_at' (default) or 'created_at'.\n\nExact enum values must be used."},{"const":"created_at","description":"Sort key for snapshots. Allowed values reference snapshot fields on the model: 'snapshot_at' (default) or 'created_at'.\n\nExact enum values must be used."}],"description":"Sort key for snapshots. Allowed values reference snapshot fields on the model: 'snapshot_at' (default) or 'created_at'.\n\nExact enum values must be used."},"sortOrder":{"oneOf":[{"const":"asc","description":"Sort direction. Allowed values: 'asc' or 'desc'.\n\nDefaults to 'desc' when not provided."},{"const":"desc","description":"Sort direction. Allowed values: 'asc' or 'desc'.\n\nDefaults to 'desc' when not provided."}],"description":"Sort direction. Allowed values: 'asc' or 'desc'.\n\nDefaults to 'desc' when not provided."},"snapshotAtFrom":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Optional lower bound (inclusive) for snapshot_at filtering. Use ISO 8601 date-time format.\n\nProvide null explicitly if no lower bound is intended."},"snapshotAtTo":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Optional upper bound (inclusive) for snapshot_at filtering. Use ISO 8601 date-time format.\n\nProvide null explicitly if no upper bound is intended."},"isCompleted":{"oneOf":[{"type":"boolean"},{"type":"null"}],"description":"Optional filter for snapshot is_completed state. When true, only snapshots captured from completed todos are returned. When false, only non-completed snapshots are returned. Null or omitted returns both."},"includeDeleted":{"type":"boolean","description":"When true, include snapshots taken when the source todo had deleted_at set. Default is false; snapshots of deleted source todos are excluded unless explicitly requested."},"todoId":{"type":"string","format":"uuid","description":"Optional UUID of the parent todo (todo_app_todos.id) to scope snapshots to a specific todo. When provided, results will be limited to snapshots for that todo."}},"description":"Request DTO for listing todo snapshots. Contains pagination, sorting, and filter parameters that map to fields on the `todo_app_todo_snapshots` model.\n\nThis DTO is intended for use with the snapshot listing endpoint and supports server-side limits and validation. All date-time fields must use ISO 8601 date-time format where provided.","required":[]},"ITodoAppAuditRecord":{"type":"object","x-autobe-prisma-schema":"todo_app_audit_records","properties":{"id":{"type":"string","format":"uuid","description":"Primary key for the audit record. This maps to the `id` column on the Prisma model `todo_app_audit_records`.\n\nThis value is a UUID generated by the system when the audit record is created. It uniquely identifies the audit event for lookup, retention, and forensic purposes.","example":"3fa85f64-5717-4562-b3fc-2c963f66afa6"},"admin_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional reference to the acting administrator's id. This corresponds to the nullable `admin_id` column in the Prisma model `todo_app_audit_records`.\n\nWhen present, it identifies the admin account that performed the action. When the action was system-initiated (no admin actor) this field is null."},"user_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional reference to the user affected by the action. Maps to the nullable `user_id` column on the Prisma model `todo_app_audit_records`.\n\nWhen the audit entry targets a specific user resource, this contains that user's id. For system actions not associated with a user this field may be null."},"actor_role":{"type":"string","description":"Role of the actor who performed the action (for example: 'admin' or 'system'). This maps to the `actor_role` column in the Prisma model.\n\nThis property documents whether the action was performed by an administrative actor or by an automated/system process and aids auditing and filtering.","example":"admin"},"action_type":{"type":"string","description":"Type of action performed, as recorded in the `action_type` column (examples: 'suspend_user', 'restore_todo', 'purge', 'view_snapshot').\n\nThis field is used for quick classification of audit events and MUST use the canonical action type strings used by the application.","example":"restore_todo"},"target_resource":{"type":"string","description":"Logical resource type affected by the action (for example: 'todo', 'user', 'guest', 'todo_snapshot'). This corresponds to the `target_resource` column in the Prisma model.\n\nUsed to scope and filter audit events by the kind of resource that was impacted.","example":"todo"},"target_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional identifier of the specific target resource (for example the todo id). Maps to the nullable `target_id` column in the Prisma model `todo_app_audit_records`.\n\nWhen present this provides a direct reference to the affected resource instance for quick lookup; otherwise it may be null for actions that are not resource-specific."},"reason":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional human-provided reason or note describing why the action was taken. This maps to the nullable `reason` column on the Prisma model.\n\nThis field is intended for short explanatory text recorded by the admin or system operator to provide context for the audit event."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the audit record was created. Maps to the `created_at` timestamptz column on the Prisma model `todo_app_audit_records`.\n\nTimestamps are stored in ISO 8601 / RFC3339 format (UTC recommended) and used for retention, search, and ordering of audit events.","example":"2025-10-07T19:00:00Z"}},"required":["id","actor_role","action_type","target_resource","created_at"],"description":"Audit record entity representing an append-only event created for administrative and system actions.\n\nThis schema maps directly to the Prisma model `todo_app_audit_records` and includes all persisted columns present on that model. Audit records are append-only and used for compliance, troubleshooting, and forensic analysis. Each property description references the corresponding Prisma column and explains the field's role in business workflows."},"ITodoAppAuditRecord.IRequest":{"type":"object","properties":{"actor_role":{"type":"string","description":"Optional filter by actor role (for example 'admin' or 'system'). When provided, the backend SHOULD filter results to matching actor_role values."},"action_type":{"type":"string","description":"Optional filter for one or more action types (e.g., 'suspend_user', 'restore_todo'). If provided, results should be limited to matching action_type values."},"target_resource":{"type":"string","description":"Optional filter by resource kind (for example 'todo', 'user', 'guest', 'todo_snapshot'). When omitted, records across all resources are considered."},"target_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional filter by specific target resource id (UUID). When provided the backend should return audit events referencing that exact resource instance. Note: this is a resource identifier filter, not a direct user/admin actor id filter."},"created_at_from":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Optional start time (inclusive) to filter audit records by created_at. Use ISO 8601 / RFC3339 date-time strings in UTC where possible."},"created_at_to":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Optional end time (inclusive) to filter audit records by created_at. Use ISO 8601 / RFC3339 date-time strings in UTC where possible."},"page":{"type":"integer","minimum":1,"description":"Optional pagination page number (1-based). If omitted the server MAY default to page 1."},"pageSize":{"type":"integer","minimum":1,"maximum":200,"description":"Optional pagination page size. The server SHOULD enforce a sensible maximum (suggested 200) to protect against expensive queries."},"sort_by":{"oneOf":[{"const":"created_at","description":"Sort by creation timestamp."},{"const":"action_type","description":"Sort by action type."},{"const":"actor_role","description":"Sort by actor role."}],"description":"Optional sorting key. Allowed values map to indexed columns on the audit table and help the server choose efficient query plans."},"sort_order":{"oneOf":[{"const":"asc","description":"Ascending sort direction."},{"const":"desc","description":"Descending sort direction."}],"description":"Optional sort direction. Defaults to 'desc' when omitted to return newest events first."}},"description":"Request DTO for searching and paginating audit records. This object defines filter, sort, and pagination parameters used by administrative audit search endpoints. Direct actor identifier filters (for example `user_id` or `admin_id`) have been intentionally omitted from this generic IRequest to avoid exposing direct ID-based filtering in the generic request DTO. If admin-only identifier filters are required, create a separate admin-only request DTO.","required":[]},"ITodoAppGuest":{"type":"object","x-autobe-prisma-schema":"todo_app_guest","properties":{"id":{"type":"string","format":"uuid","description":"Primary key for the guest record as defined in the Prisma model (todo_app_guest.id).\n\nThis value is system-generated (UUID) when a guest record is created. It uniquely identifies the guest entry and SHOULD be used for any subsequent server-side operations that reference the guest (for example, token issuance or activity updates)."},"email":{"oneOf":[{"type":"string","format":"email"},{"type":"null"}],"description":"Optional visitor-provided email address recorded on the guest entry.\n\nThis field maps directly to the Prisma column todo_app_guest.email and is nullable by design. When present it SHOULD conform to a valid email format. Use of this field is optional for anonymous guests; when supplied it enables lightweight communication or follow-up flows (for example, passwordless links or recovery)."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the guest record was created (Prisma: todo_app_guest.created_at).\n\nThis field is populated by the server at insertion time and expressed as an ISO 8601 date-time with timezone. It is guaranteed to be present for every persisted guest record and is useful for retention, audit, and housekeeping."},"last_active_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Optional timestamp of the guest's last observed activity (Prisma: todo_app_guest.last_active_at).\n\nThis field is nullable and updated by server-side activity handlers (for example, when a guest refreshes tokens or performs actions). Null indicates no observed subsequent activity since creation."},"status":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional housekeeping status for the guest record (Prisma: todo_app_guest.status).\n\nTypical values might include 'active', 'bounced', or other operational markers used by support systems. This field is optional and nullable in the Prisma schema; use it for administrative classification only."}},"required":["id","created_at"],"description":"Guest record representation for todoApp.\n\nThis object corresponds directly to the Prisma model `todo_app_guest` and includes the persisted fields that are safe to expose in API responses. The schema intentionally uses the same field names as the Prisma model to facilitate server-side mapping and validation. Sensitive or internal-only fields are not present on the Prisma model and therefore are not included here.\n\nUse this type when returning persisted guest information from endpoints such as guest creation or administrative retrieval. When exposing this object in responses, ensure that access control rules are applied (admin-only endpoints may reveal full emails while lower-privilege support views may redact PII)."},"ITodoAppGuest.IRequest":{"type":"object","properties":{"email":{"type":"string","description":"Optional filter for guest email. Supports exact or partial match depending on server implementation (e.g., prefix or contains). Provide the email string without surrounding wildcards; the server determines matching semantics."},"status":{"type":"string","description":"Optional filter for guest status (e.g., 'active', 'bounced'). When provided, the server SHALL filter records by the exact status value."},"created_at_from":{"type":"string","format":"date-time","description":"Optional lower bound (inclusive) for created_at timestamp. Format: ISO 8601 date-time. Use to restrict results to guests created on or after this timestamp."},"created_at_to":{"type":"string","format":"date-time","description":"Optional upper bound (inclusive) for created_at timestamp. Format: ISO 8601 date-time. Use to restrict results to guests created on or before this timestamp."},"last_active_at_from":{"type":"string","format":"date-time","description":"Optional lower bound (inclusive) for last_active_at timestamp. Format: ISO 8601 date-time."},"last_active_at_to":{"type":"string","format":"date-time","description":"Optional upper bound (inclusive) for last_active_at timestamp. Format: ISO 8601 date-time."},"page":{"type":"integer","description":"Page number for pagination (1-based). If omitted the server may default to page 1."},"pageSize":{"type":"integer","description":"Number of records per page for pagination. The server SHOULD enforce a maximum page size to protect performance (for example, 100). If omitted the server may apply a sensible default (for example, 20)."},"sortBy":{"oneOf":[{"const":"created_at","description":"Sort key for results. Allowed values correspond to indexed timestamp columns on the Prisma model. Use 'created_at' or 'last_active_at'."},{"const":"last_active_at","description":"Sort key for results. Allowed values correspond to indexed timestamp columns on the Prisma model. Use 'created_at' or 'last_active_at'."}],"description":"Sort key for results. Allowed values correspond to indexed timestamp columns on the Prisma model. Use 'created_at' or 'last_active_at'."},"sortOrder":{"oneOf":[{"const":"asc","description":"Sort direction. Allowed values: 'asc' for ascending, 'desc' for descending."},{"const":"desc","description":"Sort direction. Allowed values: 'asc' for ascending, 'desc' for descending."}],"description":"Sort direction. Allowed values: 'asc' for ascending, 'desc' for descending."}},"required":[],"description":"Request DTO for searching and paginating guest records.\n\nThis object is intended for administrative search endpoints that query the `todo_app_guest` table. All fields are optional: omit fields you do not wish to filter by. Date-time filters must be provided in ISO 8601 format. Pagination and sorting hints are provided to guide efficient server-side querying.\n\nNote: This type is a query/request object and does not use x-autobe-prisma-schema linkage because it describes operation parameters rather than a direct persisted model representation."},"ITodoAppUser":{"type":"object","x-autobe-prisma-schema":"todo_app_user","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier for the user account.\n\nThis property maps directly to the Prisma model column `todo_app_user.id`. It is a system-generated UUID value that uniquely identifies the account across the system and is used as the canonical reference in related tables such as `todo_app_todos` and `todo_app_audit_records`."},"email":{"type":"string","format":"email","description":"Primary email address of the user account.\n\nThis field corresponds to `todo_app_user.email` in the Prisma schema and is unique across accounts. It is used for authentication, password recovery flows, and administrative contact. Implementations should validate email format (RFC 5322 basic validation) and never expose this field in logs without appropriate privacy controls."},"display_name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional human-friendly display name for the user.\n\nThis property maps to `todo_app_user.display_name`. It is nullable and intended for UI presentation. When present, it should be a trimmed string; when not set, the property may be null. Do not use this field to infer authentication or authorization decisions."},"account_status":{"type":"string","description":"Lifecycle status of the user account.\n\nThis property corresponds to `todo_app_user.account_status` in the Prisma model and records account state such as 'active' or 'suspended' as defined by product policy. Values are implementation-defined strings managed by administrative workflows and must be enforced by business logic (for example: deny login when status = 'suspended')."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was created.\n\nThis maps to `todo_app_user.created_at` in the Prisma schema. Timestamps use ISO 8601 / RFC 3339 format with timezone (recommended 'date-time' format). This value is system-generated and immutable after creation."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was last modified.\n\nThis field maps to `todo_app_user.updated_at` in the Prisma model and is updated by server-side operations that change account data (profile edits, password changes, etc.). Clients should treat this as authoritative for optimistic-concurrency checks."},"last_active_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Optional timestamp of the user's most recent activity.\n\nThis property corresponds to `todo_app_user.last_active_at`. It may be null when no activity has been recorded. Use this field for presence and analytics; do not rely on it for strict security checks."}},"required":["id","email","account_status","created_at","updated_at"],"description":"User account representation (public-safe view) mapped to the Prisma model `todo_app_user`.\n\nThis schema exposes the public profile and lifecycle fields of a user account while deliberately omitting sensitive columns such as `password_hash`. Each property references the related Prisma model column and purpose. Use this type for responses that return user information to owners or authorized administrative viewers. The representation is designed for read and display purposes; write and credential-change operations should use dedicated DTOs.\n\nSecurity note: Do not expose `password_hash` or other secret fields in responses derived from this schema. Administrative endpoints may return this schema for support views but must ensure access is auditable and authorized."},"ITodoAppUser.IRequest":{"type":"object","properties":{"page":{"type":"integer","description":"Requested page number for paginated results.\n\nThis is a 1-based integer indicating which page of results the client requests. If omitted, the server may default to page 1. Server-side limits and validation apply (e.g., page >= 1).","minimum":1},"pageSize":{"type":"integer","description":"Number of items per page for paginated results.\n\nClients should request a reasonable page size. The server may impose upper bounds to prevent expensive queries. Typical defaults for administrative listings are 20 or 50 items per page.","minimum":1,"maximum":500},"emailLike":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional substring or pattern used to filter users by email.\n\nWhen provided, the server should perform a case-insensitive search on the `email` column (e.g., SQL ILIKE '%emailLike%') and return matching accounts. This parameter is intended for administrative search UIs and may be redacted in audit logs to protect privacy."},"account_status":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional filter by account status (e.g., 'active','suspended').\n\nWhen supplied, the server SHOULD filter results to accounts whose `account_status` equals the provided value. Valid values depend on product policy; servers should validate against the canonical set of statuses."},"sortBy":{"oneOf":[{"const":"created_at","description":"Sorting key for returned results.\n\nAllowed values typically include 'created_at' and 'last_active_at'. If omitted, the server may use a default sort order. Servers MUST validate the value and reject unknown sort keys."},{"const":"last_active_at","description":"Sorting key for returned results.\n\nAllowed values typically include 'created_at' and 'last_active_at'. If omitted, the server may use a default sort order. Servers MUST validate the value and reject unknown sort keys."}],"description":"Sorting key for returned results.\n\nAllowed values typically include 'created_at' and 'last_active_at'. If omitted, the server may use a default sort order. Servers MUST validate the value and reject unknown sort keys."},"order":{"oneOf":[{"const":"asc","description":"Sort direction to apply to the `sortBy` key.\n\nAllowed values are 'asc' (ascending) or 'desc' (descending). If omitted, the server may default to 'desc'."},{"const":"desc","description":"Sort direction to apply to the `sortBy` key.\n\nAllowed values are 'asc' (ascending) or 'desc' (descending). If omitted, the server may default to 'desc'."}],"description":"Sort direction to apply to the `sortBy` key.\n\nAllowed values are 'asc' (ascending) or 'desc' (descending). If omitted, the server may default to 'desc'."},"search":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional full-text search string applied to multiple user fields.\n\nWhen provided, the server MAY apply the search term across several safe fields (email, display_name) using an indexed search strategy. Servers should enforce length limits and sanitize inputs to avoid expensive queries."}},"required":[],"description":"Request DTO used to search, filter, sort, and paginate user accounts.\n\nThis object is intended for administrative listing endpoints and owner self-service listing flows where applicable. It is not directly mapped to a Prisma model (no `x-autobe-prisma-schema`), and therefore may contain query parameters and control flags that assist server-side pagination and filtering logic.\n\nValidation notes:\n- `page` is 1-based and should be >= 1.\n- `pageSize` should be within server-allowed bounds; servers SHOULD enforce a maximum to protect performance.\n- `sortBy` and `order` values are validated by the server; unknown values should return 400 Bad Request.\n\nSecurity note: Avoid logging raw `emailLike` or `search` values in plaintext in broad access logs to protect user privacy. Audit logs for administrative searches should capture who performed the search and when, but redact or hash query strings when appropriate."},"ITodoAppUser.IUpdate":{"type":"object","x-autobe-prisma-schema":"todo_app_user","properties":{"display_name":{"oneOf":[{"type":"string","maxLength":255},{"type":"null"}],"description":"Optional display name for the user as defined by the Prisma model `todo_app_user.display_name`.\n\nThis property maps directly to the `display_name` column in the `todo_app_user` table. It is intended for user-facing profile presentation and may be updated by the account owner. The value SHOULD be trimmed of leading/trailing whitespace before persisting and MUST be no longer than 255 characters to remain compatible with typical UI constraints."}},"required":[],"description":"Update DTO for a TodoApp user (owner-updatable fields).\n\nThis object represents the writable profile fields that an account owner may modify. It maps to the `todo_app_user` Prisma model (see `x-autobe-prisma-schema`) and therefore includes only properties that exist on that model. System-managed and sensitive fields such as `id`, `email`, `password_hash`, `created_at`, and `updated_at` are intentionally excluded from this DTO and MUST NOT be supplied by clients.\n\nSecurity note: Password changes are handled by dedicated endpoints and MUST NOT be attempted via this update DTO. Audit-sensitive updates (for example, account_status changes) are reserved for admin-scoped endpoints."},"ITodoAppAdmin.IRequest":{"type":"object","properties":{"page":{"oneOf":[{"type":"integer","minimum":1,"description":"Page number for paginated results. The first page is 1."},{"type":"null"}],"description":"Page number (1-based). If omitted or null, the server uses its default page (typically 1)."},"pageSize":{"oneOf":[{"type":"integer","minimum":1,"maximum":100,"description":"Maximum number of items to return for this page. Servers SHOULD enforce an upper bound (recommended max 100)."},{"type":"null"}],"description":"Requested page size. If omitted or null, server default page size is applied."},"email":{"oneOf":[{"type":"string","description":"Email address to filter exact-match against `todo_app_admin.email`.","format":"email"},{"type":"null"}],"description":"Exact email to match (filters `todo_app_admin.email`). Use exact-match when present."},"emailLike":{"oneOf":[{"type":"string","description":"Substring or pattern used for partial matching of admin emails (server may implement case-insensitive contains or trigram search).","maxLength":256},{"type":"null"}],"description":"Partial email match (e.g., domain or local-part substring). Use for fuzzy/admin search scenarios."},"is_super":{"oneOf":[{"type":"boolean","description":"Filter for super-admin flag (`todo_app_admin.is_super`)."},{"type":"null"}],"description":"When provided, restrict results to admins with the given `is_super` boolean value."},"created_from":{"oneOf":[{"type":"string","format":"date-time","description":"Lower bound (inclusive) for admin `created_at` filtering in ISO 8601 format."},{"type":"null"}],"description":"Start of creation time range (ISO 8601 date-time)."},"created_to":{"oneOf":[{"type":"string","format":"date-time","description":"Upper bound (inclusive) for admin `created_at` filtering in ISO 8601 format."},{"type":"null"}],"description":"End of creation time range (ISO 8601 date-time)."},"sort_by":{"oneOf":[{"const":"created_at","description":"Field to sort results by. Allowed values correspond to columns on `todo_app_admin`."},{"const":"last_active_at","description":"Field to sort results by. Allowed values correspond to columns on `todo_app_admin`."}],"description":"Field to sort results by. Allowed values correspond to columns on `todo_app_admin`."},"sort_order":{"oneOf":[{"const":"asc","description":"Sort direction: 'asc' for ascending, 'desc' for descending."},{"const":"desc","description":"Sort direction: 'asc' for ascending, 'desc' for descending."}],"description":"Sort direction: 'asc' for ascending, 'desc' for descending."}},"required":[],"description":"Request DTO for admin user search/list operations.\n\nThis object describes the search, filter, sort, and pagination parameters that administrative UIs may pass when listing admin accounts. It references only fields that exist on the `todo_app_admin` Prisma model (email, is_super, created_at, last_active_at) and includes controls for pagination and sorting. All date/time values use ISO 8601 date-time format.\n\nSecurity and usage notes:\n- Access to endpoints accepting this DTO MUST be restricted to administrative actors.\n- Servers SHOULD enforce sensible pageSize caps and sanitize/filter free-text input (emailLike) to prevent expensive queries. Audit logging of admin searches is recommended per product policy."},"ITodoAppAdmin":{"type":"object","x-autobe-prisma-schema":"todo_app_admin","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the admin account as defined in the Prisma model todo_app_admin.id.\n\nThis value is a UUID assigned by the system when the admin record is created. It uniquely identifies the administrative account across the system and is used for audit trails and reference in related models (for example, todo_app_audit_records.admin_id)."},"email":{"type":"string","format":"email","description":"Primary email address for the admin account as defined in todo_app_admin.email.\n\nThis field is used for login and communication. It must be unique across admin records per the Prisma @@unique([email]) constraint. Responses MUST NOT reveal credential material but this public email value is safe to include in admin summaries."},"is_super":{"type":"boolean","description":"Flag indicating whether the admin has super-administrator privileges as stored in todo_app_admin.is_super.\n\nA value of true means the admin holds elevated rights that may be required for sensitive operations. This property is authoritative for role checks in admin-scoped endpoints."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the admin account was created (todo_app_admin.created_at).\n\nThis is set by the server at insertion time and returned in ISO 8601 / RFC 3339 date-time format. Use this field for sorting and operational timelines."},"last_active_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp of the admin's last observed activity as stored in todo_app_admin.last_active_at.\n\nThis field is nullable: null means no recent activity has been recorded. When present, it uses ISO 8601 / RFC 3339 date-time format and can be used for presence indicators and housekeeping."}},"required":["id","email","is_super","created_at"],"description":"Admin account representation (safe view).\n\nThis schema represents the public, non-sensitive view of an administrative account. It maps to the Prisma model todo_app_admin and includes identifying and operational fields that are safe to expose in API responses. Sensitive fields present in the underlying Prisma model (for example, password_hash) are intentionally omitted from this DTO to preserve security.\n\nUse cases: returned by admin listing and detail endpoints where an administrative summary is required (for UI display, audit summaries, and support workflows)."},"ITodoAppAdmin.IUpdate":{"type":"object","x-autobe-prisma-schema":"todo_app_admin","properties":{"email":{"type":"string","format":"email","description":"New email value for the admin account (todo_app_admin.email).\n\nIf provided, the server MUST validate uniqueness and proper email format. Changing email may require verification depending on product policy. This field is optional in update requests."},"is_super":{"type":"boolean","description":"Update to the super-admin flag (todo_app_admin.is_super).\n\nOnly callers with appropriate authorization (for example, an existing super-admin) should be permitted to change this flag. The server MUST enforce privilege checks and audit this change when applied."},"last_active_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Administrative override for last_active_at (todo_app_admin.last_active_at).\n\nTypically managed by the system; provided here for administrative maintenance tasks. Accepts ISO 8601 / RFC 3339 date-time strings or null to clear. Use with caution: updates to this field SHOULD be audited."}},"required":[],"description":"Admin update DTO for partial updates to an admin account.\n\nAll properties are optional to support partial updates (Partial<T> semantics). This DTO maps to the Prisma model todo_app_admin and therefore includes only properties that exist in that model. The server MUST enforce security rules (who may update which fields), validate inputs (unique email constraint), and create audit records for administrative modifications (especially for is_super changes)."},"ITodoAppAdmin.ISummary":{"type":"object","x-autobe-prisma-schema":"todo_app_admin","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the admin account.\n\nThis property maps to todo_app_admin.id in the Prisma schema and uniquely identifies an administrative account."},"email":{"type":"string","format":"email","description":"Admin account email address.\n\nThis property maps to todo_app_admin.email in the Prisma schema. This field is returned for display in administrative UIs. Password hashes or secrets are intentionally NOT included."},"is_super":{"type":"boolean","description":"Flag indicating whether the admin has super-admin privileges.\n\nMaps to todo_app_admin.is_super in the Prisma schema. Use this flag to gate sensitive admin-only actions."},"created_at":{"type":"string","format":"date-time","description":"Record creation timestamp as stored in todo_app_admin.created_at.\n\nOnly present because the Prisma model defines it; this is a read-only system field."},"last_active_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Last observed activity timestamp for the admin (nullable).\n\nMaps to todo_app_admin.last_active_at in the Prisma schema and may be null if no activity has been recorded."}},"required":["id","email","is_super","created_at"],"description":"Administrative account summary.\n\nProvides a safe, public-facing summary representation of an administrative account for listing and audit UIs. This summary intentionally omits sensitive fields such as `password_hash` even though that column exists in the Prisma model. All included properties map directly to columns that exist in the `todo_app_admin` Prisma model.\n\nThis schema is used in paginated lists and admin index endpoints (for example, IPageITodoAppAdmin.ISummary)."},"ITodoAppTodo.ISummary":{"type":"object","x-autobe-prisma-schema":"todo_app_todos","properties":{"id":{"type":"string","format":"uuid","description":"Primary identifier of the todo item (Prisma: todo_app_todos.id).\n\nThis UUID is assigned by the server at creation and is the canonical reference used in item-level operations and audit records."},"title":{"type":"string","description":"Short task title used for display and quick capture (Prisma: todo_app_todos.title).\n\nTitles should be concise and are the primary field shown in list views. Validation rules require non-empty trimmed strings; length guidance is 1–250 characters."},"is_completed":{"type":"boolean","description":"Completion flag indicating whether the todo is marked completed (Prisma: todo_app_todos.is_completed).\n\nUse this flag for quick filtering in lists and to drive UI state."},"completed_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when the todo was marked completed (Prisma: todo_app_todos.completed_at).\n\nNullable: null indicates the item is not completed. When set, it records the exact server time the todo entered the completed state."},"position":{"oneOf":[{"type":"integer"},{"type":"null"}],"description":"Optional client-managed integer used for manual ordering (Prisma: todo_app_todos.position).\n\nThis property is nullable and may be used by clients to represent custom sort order. The server stores the numeric position if provided."},"created_at":{"type":"string","format":"date-time","description":"Record creation timestamp for the todo (Prisma: todo_app_todos.created_at).\n\nManaged by the server; included to support sorting and display of when the item was created."},"updated_at":{"type":"string","format":"date-time","description":"Last modification timestamp for the todo (Prisma: todo_app_todos.updated_at).\n\nThis timestamp updates on every successful modification and enables clients to detect recent changes and synchronize state."}},"required":["id","title","is_completed","created_at","updated_at"],"description":"Compact representation of a Todo item suitable for list views.\n\nThis summary schema corresponds to the Prisma model `todo_app_todos` and intentionally excludes large-text fields (for example, the full `description`) to keep list responses lightweight. Clients that need the full content must request the detailed `ITodoAppTodo` entity via the single-item endpoint."},"ITodoAppGuest.ISummary":{"type":"object","x-autobe-prisma-schema":"todo_app_guest","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the guest record (UUID). This value is assigned by the server when the guest row is created.\n\nUsed to correlate temporary sessions and short-lived tokens to the guest entry."},"email":{"oneOf":[{"type":"string","format":"email"},{"type":"null"}],"description":"Optional email address provided by the visitor. This field is nullable in the Prisma model and may be omitted for anonymous guests.\n\nWhen present, it should be a valid email address; when absent the value is null."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the guest row was created in the database (ISO 8601 / date-time). This field exists in the Prisma model and is populated by the server."},"last_active_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Nullable timestamp of the guest's last observed activity. May be null if no subsequent activity has been recorded.\n\nRepresented in ISO 8601 date-time format when present."},"status":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional housekeeping status for the guest record (for example 'active' or 'bounced'). This mirrors the nullable status column in the Prisma model."}},"required":["id","created_at"],"description":"Guest summary record returned in administrative listings.\n\nThis summary contains only safe, non-sensitive fields drawn directly from the Prisma model `todo_app_guest`. It intentionally excludes any credentials (there are none on the model) and provides nullable fields via oneOf to represent database nullability."}}}},"missed":[],"created_at":"2025-10-07T18:52:37.101Z","completed_at":"2025-10-07T19:56:47.051Z","step":0},{"id":"0199c03f-74e1-7106-a08f-a8dc5f4f2bc8","type":"userMessage","contents":[{"type":"text","text":"Make the e2e test functions."}],"created_at":"2025-10-07T19:56:48.225Z"},{"type":"test","id":"0199c04b-b3c2-769f-8bd0-becedbe66756","instruction":"Generate a comprehensive end-to-end (E2E) test suite for the minimal single-user Todo list REST API (as previously defined by the Interface agent). Focus only on testing strategy and test scenarios — do NOT include database schema or implementation logic. Produce executable test functions (preferably in TypeScript) and describe how they should behave. Use Jest + SuperTest style tests as the target format.\n\nContext/Assumptions (only use what was already specified):\n- Single-user app, no authentication.\n- JSON over HTTP, RESTful endpoints: GET /todos, POST /todos, GET /todos/{id}, PATCH /todos/{id}, DELETE /todos/{id}.\n- Todo fields: id (UUID), title (string, required), description (string, optional), isCompleted (boolean, default false), createdAt (ISO 8601), updatedAt (ISO 8601), position (integer, optional).\n- Standard HTTP codes expected: 200, 201, 204, 400, 404, 500.\n- PATCH supports partial updates for title, description, isCompleted, position.\n- List endpoint supports optional filter by isCompleted and optional sort by createdAt or position.\n\nTesting goals / priorities (in order):\n1. Basic CRUD flows (create → read → update → delete).\n2. Validation and error handling (missing title, invalid UUID, update/delete non-existent id).\n3. List behavior including filters and sorting.\n4. Partial update semantics (PATCH changes only provided fields).\n5. Idempotency of delete (deleting a non-existent resource should return 404).\n6. Data consistency across requests (timestamps, isCompleted changes, ordering by position).\n\nTest environment requirements:\n- Tests run against a running instance of the API (configurable base URL, e.g., http://localhost:3000).\n- Each test file or test suite must ensure a clean server state before starting (e.g., a test-specific cleanup endpoint or by recreating the database). If no cleanup endpoint exists, tests must assume a fresh database at start and be written to avoid interfering with external state by using unique titles/IDs where needed.\n- Use deterministic assertions for createdAt/updatedAt formats (ISO 8601) and verify timestamps are parsed correctly, but avoid asserting exact timestamps (just ensure createdAt exists and updatedAt is >= createdAt after updates).\n\nDeliverables (what to produce):\n1. A set of E2E test functions grouped into logical test cases. For each test, provide:\n   - Test name/description\n   - Test steps (HTTP requests sent)\n   - Expected HTTP status codes\n   - Key assertions on response body and headers\n   - Any required setup/teardown steps\n2. Example TypeScript/Jest+SuperTest test file(s) containing the test functions, using clear helper methods where appropriate (e.g., createTodo(), getTodo(), updateTodo(), deleteTodo(), listTodos()). Keep tests readable and minimal, suitable for a developer to copy into a project.\n3. Edge cases and negative tests (validation errors, 404 for missing resources, invalid request shapes).\n4. A short note on how to run the tests and any configuration (base URL env var, how to reset state if a helper endpoint is available).\n\nDetailed test cases to include (at minimum):\n- Create Todo: success (201) with required fields and optional fields\n- Create Todo: fail (400) when title is missing or empty\n- Get Todo by ID: success (200) returns created Todo\n- Get Todo by ID: fail (404) when id does not exist or invalid\n- Update Todo (PATCH): success (200) partial update of isCompleted and title; verify updatedAt changes\n- Update Todo (PATCH): fail (404) when id not found\n- Delete Todo: success (204); subsequent GET returns 404\n- Delete Todo: fail (404) when deleting non-existent id\n- List Todos: returns list sorted by createdAt by default; supports filter isCompleted=true and sort by position\n- Partial update does not overwrite unspecified fields\n\nConstraints: do NOT invent extra API endpoints (e.g., admin cleanup). If the interface lacks a cleanup endpoint, instruct tests to assume a fresh DB and note that an optional test-only cleanup endpoint would simplify tests.\n\nFormat of the test code: produce a single TypeScript test file named todos.e2e.spec.ts using Jest and SuperTest. Use descriptive test names and helper functions. Keep the implementation minimal but executable assuming a standard Express-like JSON API. Include comments where helpful for a non-expert to understand what each test does.\n\nDo NOT include implementation of the API server. Only produce the tests and test-running notes.\n\nIf anything in the interface is ambiguous for testing, list the questions at the end for the user to confirm.","files":[{"scenario":{"endpoint":{"method":"get","path":"/todoApp/user/todos/{todoId}"},"draft":"Get Todo by ID - Not found: Authenticate via POST /auth/user/join. Attempt GET /todoApp/user/todos/{todoId} using a well-formed UUID that does not exist; expect 404 Not Found. Validate error codes and messages. (Note: malformed-UUID validation checks removed from this scenario to focus on business-level 404 behavior.)","functionName":"test_api_todo_get_by_id_not_found","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a new user to exercise GET error cases for non-existent ids"}]},"location":"test/features/api/todo/test_api_todo_get_by_id_not_found.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_todo_get_by_id_not_found(\n  connection: api.IConnection,\n) {\n  // Scenario: Attempt to GET a todo by a well-formed UUID that does not exist.\n  // 1) Register a new user to ensure authenticated context (SDK will attach token).\n  const userEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const joinBody = {\n    email: userEmail,\n    password: \"Password123!\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const authorized: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: joinBody,\n    });\n  typia.assert(authorized);\n\n  // 2) Generate a valid UUID that (very likely) does not correspond to any todo.\n  const nonExistentTodoId: string = typia.random<\n    string & tags.Format<\"uuid\">\n  >();\n\n  // 3) Attempt to retrieve the non-existent todo and assert that the call fails.\n  //    We use TestValidator.error with an async callback to ensure the Promise rejection\n  //    is properly captured. We avoid asserting specific HTTP status codes here.\n  await TestValidator.error(\n    \"getting non-existent todo should throw\",\n    async () => {\n      await api.functional.todoApp.user.todos.at(connection, {\n        todoId: nonExistentTodoId,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"method":"patch","path":"/todoApp/user/todos"},"draft":"List Todos - Filters and Sorting: Authenticate via POST /auth/user/join. Create multiple todos via POST /todoApp/user/todos with varying isCompleted values and positions to exercise list behavior (e.g., one completed, two incomplete, different positions). Call PATCH /todoApp/user/todos without filters to verify default sorting (by createdAt descending) and that all non-deleted todos are returned. Then call with filter isCompleted=true to return only completed todos (validate counts and contents). Finally, call with sort by position to verify ordering by position ascending/descending. Validate pagination metadata when page/pageSize provided. Ensure responses are 200 and items include summary fields (id, title, isCompleted, createdAt, updatedAt, position).","functionName":"test_api_todo_list_filters_and_sorting","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a new user to create multiple todos for listing tests"},{"endpoint":{"method":"post","path":"/todoApp/user/todos"},"purpose":"Create multiple todos with varied isCompleted and position to validate list filtering, sorting and pagination"}]},"location":"test/features/api/todo/test_api_todo_list_filters_and_sorting.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppTodo\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Validate todo listing behavior: filters, sorting and pagination.\n *\n * Scenario summary:\n *\n * 1. Register a new user via POST /auth/user/join (SDK: auth.user.join).\n * 2. Create multiple todos via POST /todoApp/user/todos with varying is_completed\n *    values and positions to exercise list behavior.\n * 3. Call PATCH /todoApp/user/todos with no filters to verify default sorting\n *    (created_at desc) and presence of created items.\n * 4. Call with filter isCompleted=true to ensure only completed items are\n *    returned.\n * 5. Call with sortBy=position and sortOrder to validate ordering by position\n *    ascending/descending.\n * 6. Validate pagination metadata when page/pageSize provided.\n */\nexport async function test_api_todo_list_filters_and_sorting(\n  connection: api.IConnection,\n) {\n  // 1) Register user\n  const joinBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"Password123\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const auth: ITodoAppUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: joinBody,\n    },\n  );\n  typia.assert(auth);\n\n  // 2) Create todos with varied completion and position\n  const created: ITodoAppTodo[] = [];\n\n  // Helper to create a todo and push to created[]\n  async function createTodo(body: ITodoAppTodo.ICreate): Promise<void> {\n    const todo: ITodoAppTodo = await api.functional.todoApp.user.todos.create(\n      connection,\n      { body },\n    );\n    typia.assert(todo);\n    created.push(todo);\n  }\n\n  // Create 4 todos: positions 1, 2, 3, and one without position\n  await createTodo({\n    title: RandomGenerator.paragraph({ sentences: 3, wordMin: 3, wordMax: 8 }),\n    description: RandomGenerator.paragraph({ sentences: 8 }),\n    position: 1,\n    is_completed: false,\n  } satisfies ITodoAppTodo.ICreate);\n\n  await createTodo({\n    title: RandomGenerator.paragraph({ sentences: 3 }),\n    description: RandomGenerator.paragraph({ sentences: 5 }),\n    position: 2,\n    is_completed: true, // a completed todo\n  } satisfies ITodoAppTodo.ICreate);\n\n  await createTodo({\n    title: RandomGenerator.paragraph({ sentences: 3 }),\n    description: RandomGenerator.paragraph({ sentences: 4 }),\n    position: 3,\n    is_completed: false,\n  } satisfies ITodoAppTodo.ICreate);\n\n  await createTodo({\n    title: RandomGenerator.paragraph({ sentences: 2 }),\n    // no position provided (undefined)\n    is_completed: false,\n  } satisfies ITodoAppTodo.ICreate);\n\n  // At this point we have 4 created todos\n  const createdIds = created.map((t) => t.id);\n\n  // 3) Default list (no filters) - expect to include created todos\n  const defaultPage: IPageITodoAppTodo.ISummary =\n    await api.functional.todoApp.user.todos.index(connection, {\n      body: {} satisfies ITodoAppTodo.IRequest,\n    });\n  typia.assert(defaultPage);\n\n  // Assert that each created id appears in the returned data (presence check)\n  TestValidator.predicate(\n    \"list contains all newly created todo ids\",\n    createdIds.every((id) => defaultPage.data.some((d) => d.id === id)),\n  );\n\n  // Assert ordering by created_at is non-increasing (newest first)\n  (function assertCreatedAtDescending() {\n    const timestamps = defaultPage.data.map((d) =>\n      new Date(d.created_at).getTime(),\n    );\n    let ok = true;\n    for (let i = 1; i < timestamps.length; ++i) {\n      if (timestamps[i] > timestamps[i - 1]) {\n        ok = false;\n        break;\n      }\n    }\n    TestValidator.predicate(\n      \"default list is ordered by created_at descending\",\n      ok,\n    );\n  })();\n\n  // 4) Filter isCompleted = true\n  const completedPage: IPageITodoAppTodo.ISummary =\n    await api.functional.todoApp.user.todos.index(connection, {\n      body: { isCompleted: true } satisfies ITodoAppTodo.IRequest,\n    });\n  typia.assert(completedPage);\n\n  // All returned items must have is_completed === true\n  TestValidator.predicate(\n    \"filter isCompleted=true returns only completed items\",\n    completedPage.data.every((d) => d.is_completed === true),\n  );\n\n  // The known completed todo id must be present\n  const knownCompletedId = created.find((t) => t.is_completed === true)!.id;\n  TestValidator.predicate(\n    \"completed list contains known completed todo\",\n    completedPage.data.some((d) => d.id === knownCompletedId),\n  );\n\n  // 5) Sort by position ascending\n  const byPositionAsc: IPageITodoAppTodo.ISummary =\n    await api.functional.todoApp.user.todos.index(connection, {\n      body: {\n        sortBy: \"position\",\n        sortOrder: \"asc\",\n      } satisfies ITodoAppTodo.IRequest,\n    });\n  typia.assert(byPositionAsc);\n\n  // Extract positions (treat undefined/null as Number.POSITIVE_INFINITY so\n  // that items without position sort to the end when ascending)\n  const positionsAsc = byPositionAsc.data.map((d) =>\n    d.position === null || d.position === undefined\n      ? Number.POSITIVE_INFINITY\n      : d.position,\n  );\n  TestValidator.predicate(\n    \"positions are sorted ascending when sortBy=position & sortOrder=asc\",\n    positionsAsc.every((v, i, arr) => i === 0 || arr[i - 1] <= v),\n  );\n\n  // Sort by position descending\n  const byPositionDesc: IPageITodoAppTodo.ISummary =\n    await api.functional.todoApp.user.todos.index(connection, {\n      body: {\n        sortBy: \"position\",\n        sortOrder: \"desc\",\n      } satisfies ITodoAppTodo.IRequest,\n    });\n  typia.assert(byPositionDesc);\n\n  const positionsDesc = byPositionDesc.data.map((d) =>\n    d.position === null || d.position === undefined\n      ? Number.NEGATIVE_INFINITY\n      : d.position,\n  );\n  TestValidator.predicate(\n    \"positions are sorted descending when sortBy=position & sortOrder=desc\",\n    positionsDesc.every((v, i, arr) => i === 0 || arr[i - 1] >= v),\n  );\n\n  // 6) Pagination: page 1 with pageSize 2\n  const paged: IPageITodoAppTodo.ISummary =\n    await api.functional.todoApp.user.todos.index(connection, {\n      body: { page: 1, pageSize: 2 } satisfies ITodoAppTodo.IRequest,\n    });\n  typia.assert(paged);\n\n  TestValidator.equals(\"pagination current is 1\", paged.pagination.current, 1);\n  TestValidator.equals(\n    \"pagination limit is pageSize (2)\",\n    paged.pagination.limit,\n    2,\n  );\n  TestValidator.predicate(\n    \"page data length does not exceed pageSize\",\n    paged.data.length <= 2,\n  );\n}\n"},{"scenario":{"endpoint":{"method":"put","path":"/todoApp/user/todos/{todoId}"},"draft":"Update Todo (PUT) - Partial update success: Authenticate via POST /auth/user/join. Create a todo via POST /todoApp/user/todos. Perform PUT /todoApp/user/todos/{todoId} with a payload updating only title and isCompleted (partial semantics allowed). Expect 200 OK and returned todo reflecting updated fields: title updated, isCompleted toggled, completedAt set when isCompleted true (or cleared when false), updatedAt >= previous updatedAt. Validate that unspecified fields (description, position) remain unchanged. Cleanup: delete todo.","functionName":"test_api_todo_update_partial_success","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a new user before creating and updating a todo"},{"endpoint":{"method":"post","path":"/todoApp/user/todos"},"purpose":"Create a todo to be updated by PUT /todoApp/user/todos/{todoId}"}]},"location":"test/features/api/todo/test_api_todo_update_partial_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_todo_update_partial_success(\n  connection: api.IConnection,\n) {\n  // 1. Register a new user (authentication). The SDK will set Authorization header.\n  const userEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const user: ITodoAppUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: {\n        email: userEmail,\n        password: \"Password123!\",\n        display_name: RandomGenerator.name(),\n      } satisfies ITodoAppUser.ICreate,\n    },\n  );\n  typia.assert(user);\n\n  // 2. Create a new todo with description and position so we can verify they remain unchanged.\n  const originalTitle = RandomGenerator.paragraph({\n    sentences: 3,\n    wordMin: 3,\n    wordMax: 8,\n  });\n  const originalDescription = RandomGenerator.content({\n    paragraphs: 1,\n    sentenceMin: 6,\n    sentenceMax: 10,\n  });\n  const originalPosition = typia.random<\n    number & tags.Type<\"int32\"> & tags.Minimum<1> & tags.Maximum<100>\n  >();\n\n  const created: ITodoAppTodo = await api.functional.todoApp.user.todos.create(\n    connection,\n    {\n      body: {\n        title: originalTitle,\n        description: originalDescription,\n        position: originalPosition,\n        // omit is_completed so server defaults to false per DTO documentation\n      } satisfies ITodoAppTodo.ICreate,\n    },\n  );\n  typia.assert(created);\n\n  // Basic sanity checks\n  TestValidator.equals(\n    \"created todo title matches request\",\n    created.title,\n    originalTitle,\n  );\n  TestValidator.equals(\n    \"created todo description matches request\",\n    created.description,\n    originalDescription,\n  );\n  TestValidator.equals(\n    \"created todo position matches request\",\n    created.position,\n    originalPosition,\n  );\n  TestValidator.predicate(\n    \"created todo is not completed by default\",\n    created.is_completed === false,\n  );\n\n  // Keep previous updated_at for comparison after update\n  const previousUpdatedAt = created.updated_at;\n\n  // 3. Prepare partial update: only title and is_completed toggled to true\n  const newTitle = `Updated: ${RandomGenerator.paragraph({ sentences: 2, wordMin: 3, wordMax: 6 })}`;\n\n  const updated: ITodoAppTodo = await api.functional.todoApp.user.todos.update(\n    connection,\n    {\n      todoId: created.id,\n      body: {\n        title: newTitle,\n        is_completed: true,\n      } satisfies ITodoAppTodo.IUpdate,\n    },\n  );\n  typia.assert(updated);\n\n  // 4. Business assertions\n  TestValidator.equals(\"title updated\", updated.title, newTitle);\n  TestValidator.equals(\n    \"is_completed updated to true\",\n    updated.is_completed,\n    true,\n  );\n\n  // completed_at should be set when is_completed is true\n  TestValidator.predicate(\n    \"completed_at is set when completed\",\n    updated.completed_at !== null && updated.completed_at !== undefined,\n  );\n\n  // Unspecified fields should remain unchanged\n  TestValidator.equals(\n    \"description remains unchanged\",\n    updated.description,\n    created.description,\n  );\n  TestValidator.equals(\n    \"position remains unchanged\",\n    updated.position,\n    created.position,\n  );\n\n  // updated_at should be greater than or equal to previous updated_at\n  TestValidator.predicate(\n    \"updated_at increased or equal\",\n    new Date(updated.updated_at).getTime() >=\n      new Date(previousUpdatedAt).getTime(),\n  );\n\n  // Note: No DELETE operation available in provided SDK; test relies on test isolation.\n}\n"},{"scenario":{"endpoint":{"method":"put","path":"/todoApp/user/todos/{todoId}"},"draft":"Update Todo - Not found: Authenticate via POST /auth/user/join. Attempt PUT /todoApp/user/todos/{todoId} with a well-formed UUID that does not exist. Expect 404 Not Found. Validate error response structure.","functionName":"test_api_todo_update_not_found","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a new user to exercise update-not-found case"}]},"location":"test/features/api/todo/test_api_todo_update_not_found.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_todo_update_not_found(\n  connection: api.IConnection,\n) {\n  /**\n   * Scenario: Attempt to update a todo that does not exist.\n   *\n   * Steps:\n   *\n   * 1. Register a new user via POST /auth/user/join\n   *    (api.functional.auth.user.join).\n   * 2. Generate a well-formed random UUID that is not associated with any todo.\n   * 3. Generate a valid ITodoAppTodo.IUpdate payload using typia.random.\n   * 4. Call PUT /todoApp/user/todos/{todoId} with the random UUID and update body.\n   * 5. Expect an HTTP 404 error. Use TestValidator.httpError to assert the status.\n   */\n\n  // 1) Register a fresh user so SDK attaches Authorization header to connection\n  const auth: ITodoAppUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: typia.random<ITodoAppUser.ICreate>(),\n    },\n  );\n  typia.assert(auth);\n\n  // 2) Prepare a non-existent todoId (well-formed UUID)\n  const nonExistentTodoId = typia.random<string & tags.Format<\"uuid\">>();\n\n  // 3) Prepare a valid update payload (partial update allowed)\n  const updateBody = typia.random<ITodoAppTodo.IUpdate>();\n\n  // 4) Expect the update call to fail with 404 Not Found\n  await TestValidator.httpError(\n    \"updating a non-existent todo should return 404\",\n    404,\n    async () => {\n      await api.functional.todoApp.user.todos.update(connection, {\n        todoId: nonExistentTodoId,\n        body: updateBody,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"method":"delete","path":"/todoApp/user/todos/{todoId}"},"draft":"Delete Todo - Success and subsequent GET 404: Authenticate via POST /auth/user/join. Create a todo via POST /todoApp/user/todos. Call DELETE /todoApp/user/todos/{todoId} and expect 204 No Content. Then call GET /todoApp/user/todos/{todoId} and expect 404 Not Found (soft-deleted excluded by default). Validate idempotency: calling DELETE again should return 204 per soft-delete idempotency semantics. Confirm deleted_at is set on the server if accessible.","functionName":"test_api_todo_delete_success_and_idempotent","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a new user before creating and deleting a todo"},{"endpoint":{"method":"post","path":"/todoApp/user/todos"},"purpose":"Create a todo to be deleted by DELETE /todoApp/user/todos/{todoId}"}]},"location":"test/features/api/todos/test_api_todo_delete_success_and_idempotent.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Validate Todo deletion success and idempotency.\n *\n * Business context:\n *\n * - A user registers in the system and creates a todo item.\n * - The user deletes the todo. The delete operation is idempotent by design\n *   (soft-delete semantics): calling DELETE on an already-deleted resource\n *   should succeed (204) and not raise an error.\n *\n * Test steps:\n *\n * 1. Register a fresh user via POST /auth/user/join\n * 2. Create a todo via POST /todoApp/user/todos\n * 3. Delete the todo via DELETE /todoApp/user/todos/{todoId}\n * 4. Call DELETE again with the same todoId to assert idempotency (no error)\n *\n * Notes:\n *\n * - The SDK does not provide a GET operation for a single todo; therefore the\n *   test verifies idempotency by re-invoking DELETE and asserting no exception\n *   is thrown. All assertions rely on typia.assert for DTO validation and\n *   TestValidator for business assertions.\n */\nexport async function test_api_todo_delete_success_and_idempotent(\n  connection: api.IConnection,\n) {\n  // 1) Register a new user\n  const userEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const user: ITodoAppUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: {\n        email: userEmail,\n        password: \"Password123!\",\n        display_name: RandomGenerator.name(),\n      } satisfies ITodoAppUser.ICreate,\n    },\n  );\n  // Validate the authorization response and ensure token is set\n  typia.assert(user);\n\n  // 2) Create a new todo for the authenticated user\n  const createBody = {\n    title: RandomGenerator.paragraph({ sentences: 4, wordMin: 3, wordMax: 10 }),\n    description: RandomGenerator.content({\n      paragraphs: 2,\n      sentenceMin: 8,\n      sentenceMax: 16,\n      wordMin: 3,\n      wordMax: 8,\n    }),\n    position: typia.random<\n      number & tags.Type<\"int32\"> & tags.Minimum<1> & tags.Maximum<1000>\n    >(),\n  } satisfies ITodoAppTodo.ICreate;\n\n  const todo: ITodoAppTodo = await api.functional.todoApp.user.todos.create(\n    connection,\n    {\n      body: createBody,\n    },\n  );\n  typia.assert(todo);\n\n  // Basic sanity checks (business-level)\n  TestValidator.predicate(\n    \"todo id exists\",\n    typeof todo.id === \"string\" && todo.id.length > 0,\n  );\n  TestValidator.predicate(\n    \"todo has created_at\",\n    typeof todo.created_at === \"string\" && todo.created_at.length > 0,\n  );\n\n  // 3) Delete the todo (first attempt) - should succeed (no exception)\n  await api.functional.todoApp.user.todos.erase(connection, {\n    todoId: todo.id,\n  });\n\n  // 4) Delete the todo again to assert idempotency (second attempt)\n  // If the endpoint is implemented as idempotent soft-delete, this call\n  // should also succeed (no exception thrown). The SDK maps a 2xx/204 to\n  // a void return; therefore successful resolution implies idempotent\n  // behavior as documented.\n  await api.functional.todoApp.user.todos.erase(connection, {\n    todoId: todo.id,\n  });\n\n  // If we reached this point without exceptions, treat as a passing idempotency assertion.\n  TestValidator.predicate(\n    \"delete operation is idempotent (no error on repeated delete)\",\n    true,\n  );\n}\n"},{"scenario":{"endpoint":{"method":"delete","path":"/todoApp/user/todos/{todoId}"},"draft":"Delete Todo - Not found when deleting non-existent id: Authenticate via POST /auth/user/join. Attempt DELETE /todoApp/user/todos/{todoId} with a valid UUID that does not exist; expect 404 Not Found. Validate error response payload.","functionName":"test_api_todo_delete_not_found","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a new user to exercise delete-not-found case"}]},"location":"test/features/api/todo/test_api_todo_delete_not_found.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_todo_delete_not_found(\n  connection: api.IConnection,\n) {\n  /**\n   * Scenario: Delete Todo - Not found when deleting non-existent id\n   *\n   * Steps:\n   *\n   * 1. Register a new user via POST /auth/user/join to obtain authorization (the\n   *    SDK will attach the access token to the provided connection).\n   * 2. Attempt to DELETE /todoApp/user/todos/{todoId} with a valid UUID that does\n   *    not correspond to any existing todo.\n   * 3. Expect the operation to fail (an error is thrown). Use TestValidator.error\n   *    to assert that the erase call rejects. Per test rules, do not assert raw\n   *    HTTP status codes.\n   */\n\n  // 1) Register / authenticate a new user (SDK will set Authorization header)\n  const userEmail: string = typia.random<string & tags.Format<\"email\">>();\n\n  const authorized: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: {\n        email: userEmail,\n        password: \"Password123\", // satisfies minimum length >= 8\n        display_name: RandomGenerator.name(),\n      } satisfies ITodoAppUser.ICreate,\n    });\n  // Validate the authorization response\n  typia.assert(authorized);\n\n  // 2) Attempt to delete a non-existent todo id (valid UUID but not present)\n  const nonExistentTodoId: string = typia.random<\n    string & tags.Format<\"uuid\">\n  >();\n\n  // The erase endpoint should throw (resource not found or permission issue).\n  // We assert that an error occurs; we intentionally avoid asserting specific\n  // HTTP status codes here per testing guidelines.\n  await TestValidator.error(\n    \"deleting non-existent todo should throw\",\n    async () => {\n      await api.functional.todoApp.user.todos.erase(connection, {\n        todoId: nonExistentTodoId,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/join","method":"post"},"draft":"Test successful user registration via POST /auth/user/join. Steps:\n1) Send POST /auth/user/join with a unique, valid email, a strong plaintext password, and optional display_name.\n2) Expect HTTP 201 Created (or 200/201 per implementation) with an authorization payload containing accessToken and refreshToken and a user summary object. Validate response body includes: a server-generated user id (UUID), the supplied email and display_name, issued tokens (non-empty strings), and server timestamps createdAt and updatedAt in ISO 8601 format. Assert that updatedAt >= createdAt and that id is a valid UUID. Ensure no plaintext password or password_hash is returned. No prerequisites required; this scenario creates a fresh user context.","functionName":"test_api_user_registration_success","dependencies":[]},"location":"test/features/api/auth/test_api_user_registration_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Validate successful user registration via POST /auth/user/join.\n *\n * Business context:\n *\n * - This test verifies the happy-path registration flow where a client provides a\n *   valid email, a plaintext password (minimum length 8), and an optional\n *   display name. The server should create the user record, return a fully\n *   populated authorization payload (including access and refresh tokens), and\n *   include server-managed timestamps and identifiers.\n *\n * Steps:\n *\n * 1. Generate a unique email and a strong password.\n * 2. Send POST /auth/user/join with body satisfying ITodoAppUser.ICreate.\n * 3. Await the response and assert its shape with typia.assert().\n * 4. Validate business invariants: returned email/display_name, token presence,\n *    and updated_at >= created_at.\n */\nexport async function test_api_user_registration_success(\n  connection: api.IConnection,\n) {\n  // 1) Prepare unique, valid request data\n  const email = `e2e+${RandomGenerator.alphaNumeric(8)}@example.com`;\n  const password = RandomGenerator.alphaNumeric(12); // >= 8 chars\n  const display_name = RandomGenerator.name();\n\n  const requestBody = {\n    email,\n    password,\n    display_name,\n  } satisfies ITodoAppUser.ICreate;\n\n  // 2) Call the join API\n  const authorized: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: requestBody,\n    });\n\n  // 3) Runtime type validation (full schema assertion)\n  typia.assert(authorized);\n\n  // 4) Business validations\n  TestValidator.equals(\n    \"returned email matches request\",\n    authorized.email,\n    email,\n  );\n  TestValidator.equals(\n    \"returned display_name matches request\",\n    authorized.display_name,\n    display_name,\n  );\n\n  // token presence: typia.assert guarantees types, but assert non-empty semantics\n  TestValidator.predicate(\n    \"access token should be non-empty\",\n    typeof authorized.token.access === \"string\" &&\n      authorized.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"refresh token should be non-empty\",\n    typeof authorized.token.refresh === \"string\" &&\n      authorized.token.refresh.length > 0,\n  );\n\n  // Timestamps: typia.assert already validated date-time format; check business order\n  const createdAt = Date.parse(authorized.created_at);\n  const updatedAt = Date.parse(authorized.updated_at);\n  TestValidator.predicate(\n    \"updated_at must be equal or after created_at\",\n    updatedAt >= createdAt,\n  );\n\n  // Optionally validate that user summary (if present) echoes the email\n  if (authorized.user !== undefined && authorized.user !== null) {\n    TestValidator.equals(\n      \"embedded user summary email matches\",\n      authorized.user.email,\n      email,\n    );\n  }\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/login","method":"post"},"draft":"Test successful user login flow. Steps:\n1) Prerequisite: Create a new user by POST /auth/user/join with email and password (dependency). Capture the credentials used.\n2) Send POST /auth/user/login with the same email and password.\n3) Expect HTTP 200 OK with an authorized response containing accessToken and refreshToken and a user summary. Validate tokens are present and non-empty, returned user id matches the created user, and any returned timestamps (lastActiveAt or updatedAt) are present and are ISO 8601 strings. Confirm that login updates lastActiveAt/updatedAt if provided by the API (updatedAt_after_login >= createdAt). Ensure no password or password_hash is returned.\nPurpose: Verify end-to-end registration-to-login happy path and token issuance for a newly created user.","functionName":"test_api_user_login_success","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Create user account to authenticate against (new user context)"}]},"location":"test/features/api/auth/test_api_user_login_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Validate registration (join) followed by successful login.\n *\n * Business purpose:\n *\n * - Ensure that a newly created user can authenticate immediately.\n * - Verify that the login response issues authorization tokens and updates\n *   server-side timestamps (updated_at / last_active_at) relative to creation.\n * - Ensure no sensitive fields (password or password_hash) are leaked in\n *   responses.\n *\n * Test steps:\n *\n * 1. Generate unique credentials (email + password). Password length >= 8.\n * 2. POST /auth/user/join with ITodoAppUser.ICreate and assert the created\n *    ITodoAppUser.IAuthorized response.\n * 3. POST /auth/user/login with ITodoAppUser.ILogin using the same credentials and\n *    assert the returned ITodoAppUser.IAuthorized response.\n * 4. Validate:\n *\n *    - Login response contains token.access and token.refresh (non-empty strings)\n *    - Token.expired_at and token.refreshable_until are ISO 8601 strings\n *    - Returned user id equals created user id\n *    - Updated_at (from login response) is >= created_at (from join response)\n *    - No plaintext password or password_hash properties are present in responses\n */\nexport async function test_api_user_login_success(connection: api.IConnection) {\n  // 1) Prepare deterministic, valid credentials\n  const password = RandomGenerator.alphaNumeric(12); // >= 8 chars\n  const email = typia.random<string & tags.Format<\"email\">>();\n  const display_name = RandomGenerator.name();\n\n  const joinBody = {\n    email,\n    password,\n    display_name,\n  } satisfies ITodoAppUser.ICreate;\n\n  // 2) Register the new user\n  const created: ITodoAppUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: joinBody,\n    },\n  );\n  // Validate response shape and values\n  typia.assert(created);\n\n  // Basic expectations about created record\n  TestValidator.predicate(\n    \"created response contains created_at\",\n    typeof created.created_at === \"string\" &&\n      !Number.isNaN(Date.parse(created.created_at)),\n  );\n\n  // 3) Login using the same credentials\n  const loginBody = {\n    email: joinBody.email,\n    password: joinBody.password,\n  } satisfies ITodoAppUser.ILogin;\n\n  const logged: ITodoAppUser.IAuthorized = await api.functional.auth.user.login(\n    connection,\n    {\n      body: loginBody,\n    },\n  );\n  typia.assert(logged);\n\n  // 4) Business assertions\n  // 4.1 User identity\n  TestValidator.equals(\"user id matches after login\", logged.id, created.id);\n\n  // 4.2 Tokens are present and non-empty\n  TestValidator.predicate(\n    \"access token present and non-empty\",\n    typeof logged.token?.access === \"string\" && logged.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"refresh token present and non-empty\",\n    typeof logged.token?.refresh === \"string\" &&\n      logged.token.refresh.length > 0,\n  );\n\n  // 4.3 Token expiry fields are valid ISO date-times\n  TestValidator.predicate(\n    \"token.expired_at is ISO 8601\",\n    typeof logged.token.expired_at === \"string\" &&\n      !Number.isNaN(Date.parse(logged.token.expired_at)),\n  );\n  TestValidator.predicate(\n    \"token.refreshable_until is ISO 8601\",\n    typeof logged.token.refreshable_until === \"string\" &&\n      !Number.isNaN(Date.parse(logged.token.refreshable_until)),\n  );\n\n  // 4.4 Timestamps: updated_at (login) >= created_at (join)\n  TestValidator.predicate(\n    \"created_at is ISO 8601\",\n    typeof created.created_at === \"string\" &&\n      !Number.isNaN(Date.parse(created.created_at)),\n  );\n  TestValidator.predicate(\n    \"updated_at is ISO 8601\",\n    typeof logged.updated_at === \"string\" &&\n      !Number.isNaN(Date.parse(logged.updated_at)),\n  );\n\n  TestValidator.predicate(\n    \"updated_at is after or equal to created_at\",\n    Date.parse(logged.updated_at) >= Date.parse(created.created_at),\n  );\n\n  // 4.5 Ensure sensitive fields are not leaked\n  TestValidator.predicate(\n    \"password not present in login response\",\n    !(\"password\" in logged),\n  );\n  TestValidator.predicate(\n    \"password_hash not present in login response\",\n    !(\"password_hash\" in logged),\n  );\n\n  // 4.6 Optional: if user summary exists, ensure its id matches\n  if (logged.user !== undefined && logged.user !== null) {\n    TestValidator.equals(\n      \"user summary id matches created id\",\n      logged.user.id,\n      created.id,\n    );\n  }\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/login","method":"post"},"draft":"Test login failure with invalid credentials. Steps:\n1) Prerequisite: Create a new user by POST /auth/user/join with email and password (dependency).\n2) Attempt to authenticate with POST /auth/user/login using the same email but an incorrect password.\n3) Expect HTTP 401 Unauthorized (or 400/403 depending on implementation) with an error body indicating invalid credentials. Validate error code/message is present and that no tokens are returned. Confirm the original account remains usable by performing a successful login afterwards (optional cleanup step).\nPurpose: Validate authentication rejects incorrect secrets and does not leak sensitive account existence details beyond a standard error response.","functionName":"test_api_user_login_invalid_credentials","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Create user account to use for invalid-login negative test"}]},"location":"test/features/api/auth/test_api_user_login_invalid_credentials.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_user_login_invalid_credentials(\n  connection: api.IConnection,\n) {\n  // 1) Create a unique test user account\n  const password = RandomGenerator.alphaNumeric(12);\n  const email = typia.random<string & tags.Format<\"email\">>();\n  const joinBody = {\n    email,\n    password,\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const created: ITodoAppUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: joinBody,\n    },\n  );\n  typia.assert(created);\n  TestValidator.equals(\n    \"created user email matches request\",\n    created.email,\n    joinBody.email,\n  );\n\n  // 2) Attempt login with invalid credentials and expect an error\n  const wrongPassword = `${password}__wrong`;\n  await TestValidator.error(\n    \"login with incorrect password should fail\",\n    async () => {\n      await api.functional.auth.user.login(connection, {\n        body: {\n          email: joinBody.email,\n          password: wrongPassword,\n        } satisfies ITodoAppUser.ILogin,\n      });\n    },\n  );\n\n  // 3) Confirm that correct credentials still work\n  const successLogin: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.login(connection, {\n      body: {\n        email: joinBody.email,\n        password: joinBody.password,\n      } satisfies ITodoAppUser.ILogin,\n    });\n  typia.assert(successLogin);\n\n  TestValidator.equals(\n    \"successful login returns same user id\",\n    successLogin.id,\n    created.id,\n  );\n}\n"},{"scenario":{"endpoint":{"method":"post","path":"/auth/user/refresh"},"draft":"Purpose: Verify the refresh token lifecycle for a user: issuing initial tokens via join and exchanging a valid refresh token for a new access token.\n\nSteps:\n1. Create a new user via POST /auth/user/join with valid email and password (new user context). Assert 201 and capture initial accessToken and refreshToken from the response.\n2. Call POST /auth/user/refresh with the valid refreshToken in the request body. Assert 200 and that the response contains a new accessToken and optionally a rotated refreshToken. Validate that the new accessToken is present and formatted as a non-empty string, and if a refreshToken is returned it differs from the original refreshToken.\n3. Business validations: ensure server-updated metadata is present where applicable (authorized user summary or timestamps like updatedAt or lastActiveAt should be valid ISO-8601 strings).\n\nNegative flows to cover:\nA. Call POST /auth/user/refresh with an expired/invalid refresh token -> expect 401 or 400; assert error code and machine-readable error when available.\nB. Call POST /auth/user/refresh with a malformed request body (missing token) -> expect 400.\n\nExpected outcomes: Successful exchange returns HTTP 200 with renewed access token and optional rotated refresh token; failure cases return 4xx codes with clear errors.\n\nNotes: Use join to create a fresh user (do not use login) so tests run in isolated contexts. Do not assume specific token formats beyond being non-empty strings; verify presence and rotation semantics where provided.","functionName":"test_api_user_refresh_with_valid_refresh_token","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create a new user and obtain initial access and refresh tokens for the refresh flow"}]},"location":"test/features/api/auth/test_api_user_refresh_with_valid_refresh_token.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_user_refresh_with_valid_refresh_token(\n  connection: api.IConnection,\n) {\n  /**\n   * Purpose:\n   *\n   * 1. Register a fresh user via POST /auth/user/join to obtain initial tokens.\n   * 2. Exchange the obtained refresh token via POST /auth/user/refresh and\n   *    validate that a new access token is returned and that server-side\n   *    metadata is consistent (timestamps).\n   * 3. Cover negative cases: invalid refresh token and malformed request.\n   */\n\n  // 1) Create a new user to obtain initial tokens\n  const email: string = typia.random<string & tags.Format<\"email\">>();\n  const password: string = RandomGenerator.alphaNumeric(12); // >= 8 chars\n\n  const authorized: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: {\n        email,\n        password,\n        display_name: RandomGenerator.name(),\n      } satisfies ITodoAppUser.ICreate,\n    });\n  typia.assert(authorized);\n\n  // Validate presence of token values\n  const originalToken: IAuthorizationToken = authorized.token;\n  TestValidator.predicate(\n    \"join: access token present\",\n    typeof originalToken.access === \"string\" && originalToken.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"join: refresh token present\",\n    typeof originalToken.refresh === \"string\" &&\n      originalToken.refresh.length > 0,\n  );\n\n  // 2) Use the refresh endpoint with a valid refresh token\n  const refreshed: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.refresh(connection, {\n      body: {\n        refreshToken: originalToken.refresh,\n      } satisfies ITodoAppUser.IRefresh,\n    });\n  typia.assert(refreshed);\n\n  // Validate new access token present\n  TestValidator.predicate(\n    \"refresh: new access token present\",\n    typeof refreshed.token.access === \"string\" &&\n      refreshed.token.access.length > 0,\n  );\n\n  // Validate refresh token presence and optional rotation\n  TestValidator.predicate(\n    \"refresh: returned refresh token is a non-empty string\",\n    typeof refreshed.token.refresh === \"string\" &&\n      refreshed.token.refresh.length > 0,\n  );\n  if (refreshed.token.refresh !== originalToken.refresh) {\n    // If rotated, ensure they differ\n    TestValidator.notEquals(\n      \"refresh: refresh token rotated\",\n      refreshed.token.refresh,\n      originalToken.refresh,\n    );\n  } else {\n    // If not rotated, record that no rotation was applied (still acceptable)\n    TestValidator.predicate(\n      \"refresh: refresh token unchanged (rotation not applied)\",\n      true,\n    );\n  }\n\n  // 2.a Validate server-managed timestamps consistency (updated_at >= created_at)\n  // typia.assert already validated field presence and format, but check ordering.\n  const createdAt = Date.parse(refreshed.created_at);\n  const updatedAt = Date.parse(refreshed.updated_at);\n  TestValidator.predicate(\n    \"refresh: updated_at is a valid ISO-8601 date\",\n    !Number.isNaN(updatedAt),\n  );\n  TestValidator.predicate(\n    \"refresh: updated_at is >= created_at\",\n    !Number.isNaN(createdAt) && updatedAt >= createdAt,\n  );\n\n  // 3) Negative case A: invalid/expired refresh token should fail\n  await TestValidator.error(\n    \"refresh: invalid/expired refresh token should fail\",\n    async () => {\n      await api.functional.auth.user.refresh(connection, {\n        body: {\n          refreshToken: \"this-token-is-invalid-or-expired\",\n        } satisfies ITodoAppUser.IRefresh,\n      });\n    },\n  );\n\n  // 4) Negative case B: malformed request (empty refreshToken) should fail\n  await TestValidator.error(\n    \"refresh: empty refresh token (malformed body) should fail\",\n    async () => {\n      await api.functional.auth.user.refresh(connection, {\n        body: {\n          refreshToken: \"\",\n        } satisfies ITodoAppUser.IRefresh,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"method":"put","path":"/auth/user/change-password"},"draft":"Purpose: Validate the authenticated change-password flow for an owner, ensuring the operation updates server-side state and preserves account access semantics.\n\nSteps:\n1. Create a new user via POST /auth/user/join (new user context). Assert 201 and capture accessToken and user identifier.\n2. Optionally create a user-scoped resource (e.g., POST /todoApp/user/todos) to assert ownership continuity before password change.\n3. Call PUT /auth/user/change-password authenticated with the access token obtained from join. Request body contains currentPassword and newPassword. Assert HTTP 200 and that response includes updated profile fields (updatedAt) or confirmation payload per API. Verify updatedAt is a valid ISO-8601 string and is >= createdAt if createdAt is available.\n\nNegative flows:\nA. Attempt change-password with incorrect currentPassword -> expect 400 or 403 and no change to updatedAt.\nB. Attempt change-password without authentication -> expect 401/403.\nC. Attempt change-password with malformed payload (missing newPassword) -> expect 400.\n\nPost-conditions: Do not mix join and login in the same scenario. Authenticate via join for a new user context.\n\nExpected outcomes: Successful password change returns 200 with confirmation and updated metadata; invalid current password returns 4xx and leaves account credentials unchanged.","functionName":"test_api_user_change_password_by_owner","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create a fresh user and obtain an access token to authenticate the change-password request"}]},"location":"test/features/api/auth/test_api_user_change_password_by_owner.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Verify owner-initiated change-password flow for authenticated TodoApp users.\n *\n * This test performs the following:\n *\n * 1. Registers a fresh user via POST /auth/user/join (join) and uses the returned\n *    authorization token (SDK sets connection.headers.Authorization).\n * 2. Performs a successful owner-initiated password change using currentPassword +\n *    newPassword and validates that updated_at is newer than created_at.\n * 3. Validates negative scenarios:\n *\n *    - Incorrect current password (expect 4xx)\n *    - Unauthenticated request (expect 4xx)\n *    - Malformed-but-typed payload (empty resetToken with newPassword) (expect 4xx)\n *\n * Notes:\n *\n * - Uses only available SDK functions: api.functional.auth.user.join and\n *   api.functional.auth.user.change_password.changePassword.\n * - All request bodies use `satisfies` to ensure compile-time DTO conformity.\n */\nexport async function test_api_user_change_password_by_owner(\n  connection: api.IConnection,\n) {\n  // 1) Register a new user (join) and obtain authorization token\n  const password: string = RandomGenerator.alphaNumeric(12); // >= 8 chars\n  const createBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password,\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const authorized: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: createBody,\n    });\n  typia.assert(authorized);\n\n  // The SDK's join() sets connection.headers.Authorization automatically.\n  // Record the profile times for later comparison if present.\n  const originalCreatedAt: string | undefined = authorized.created_at;\n  const originalUpdatedAt: string | undefined = authorized.updated_at;\n\n  // 2) Happy path: change password by current password\n  const newPassword: string = RandomGenerator.alphaNumeric(12);\n  const changeBody = {\n    currentPassword: password,\n    newPassword,\n  } satisfies ITodoAppUser.IChangePassword.IByCurrent;\n\n  const profileAfterChange: ITodoAppUser.IProfile =\n    await api.functional.auth.user.change_password.changePassword(connection, {\n      body: changeBody,\n    });\n  typia.assert(profileAfterChange);\n\n  // Business validation: updated_at should be >= created_at (if created_at returned)\n  if (profileAfterChange.created_at && profileAfterChange.updated_at) {\n    const created = new Date(profileAfterChange.created_at).getTime();\n    const updated = new Date(profileAfterChange.updated_at).getTime();\n    TestValidator.predicate(\n      \"updated_at must be equal or later than created_at after password change\",\n      updated >= created,\n    );\n  }\n\n  // 3A) Negative: incorrect current password should fail (4xx)\n  await TestValidator.error(\n    \"incorrect current password should fail\",\n    async () => {\n      await api.functional.auth.user.change_password.changePassword(\n        connection,\n        {\n          body: {\n            currentPassword: \"wrong-password-000\",\n            newPassword: RandomGenerator.alphaNumeric(12),\n          } satisfies ITodoAppUser.IChangePassword.IByCurrent,\n        },\n      );\n    },\n  );\n\n  // 3B) Negative: unauthenticated request should fail (create a copy without headers)\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n  await TestValidator.error(\n    \"change-password without authentication should fail\",\n    async () => {\n      await api.functional.auth.user.change_password.changePassword(\n        unauthConn,\n        {\n          body: {\n            currentPassword: newPassword,\n            newPassword: RandomGenerator.alphaNumeric(12),\n          } satisfies ITodoAppUser.IChangePassword.IByCurrent,\n        },\n      );\n    },\n  );\n\n  // 3C) Negative: malformed-but-typed payload (empty resetToken) should fail at runtime\n  await TestValidator.error(\n    \"reset-token empty string should be rejected\",\n    async () => {\n      await api.functional.auth.user.change_password.changePassword(\n        connection,\n        {\n          body: {\n            resetToken: \"\",\n            newPassword: RandomGenerator.alphaNumeric(12),\n          } satisfies ITodoAppUser.IChangePassword.IByReset,\n        },\n      );\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/admin/join","method":"post"},"draft":"Test admin registration (join) happy path:\n\nPurpose: Validate that a new administrator account can be created and that the response returns an authorized payload without exposing sensitive fields.\n\nSteps:\n1. Send POST /auth/admin/join with payload { email: <unique-admin-email>, password: <strong-password>, is_super: true }.\n2. Expect HTTP 201 Created (or 200/201 per implementation) with an authorized response body containing an access token and refresh token and a minimal admin summary.\n3. Assert response body does NOT include password_hash or any sensitive credential fields.\n4. Assert returned admin summary includes id (UUID), email matching request, is_super flag (true if requested), createdAt/created_at timestamp in ISO 8601 format, and lastActive/last_active_at present or null.\n5. Validate access token format (presence of token string) and that response shape conforms to the authorized response contract. If the implementation returns headers for authentication, assert their presence too.\n6. Clean up: If test environment supports deletion, optionally call admin delete; otherwise rely on test isolation and unique email to avoid collisions.\n\nValidation points / expected outcomes:\n- 201 Created (or consistent success status) returned.\n- Response contains accessToken and refreshToken (or equivalent fields) and admin summary without password_hash.\n- id is a valid UUID and timestamps are ISO 8601. Use tolerant timestamp assertions (existence and parsability) and do not assert exact values.\n- Attempting to re-run with same email in a separate negative test should yield 4xx (duplicate) but that is covered in separate flows.\n\nNotes:\n- Use a unique email per test run (e.g., test-admin+{timestamp}@example.com) to avoid collisions.\n- Do NOT rely on server-side cleanup unless a test-only cleanup endpoint exists. If not, keep data unique.","functionName":"test_api_admin_join_success","dependencies":[]},"location":"test/features/api/auth/test_api_admin_join_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\nexport async function test_api_admin_join_success(connection: api.IConnection) {\n  // 1) Prepare a unique, valid admin creation request\n  const adminEmail = `test-admin+${Date.now()}@example.com`;\n  const requestBody = {\n    email: adminEmail,\n    password: \"StrongPassw0rd!\",\n    is_super: true,\n  } satisfies ITodoAppAdmin.ICreate;\n\n  // 2) Call the API to create/join admin\n  const output: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: requestBody,\n    });\n\n  // 3) Validate the response shape and types (typia.assert handles all type/format checks)\n  typia.assert(output);\n\n  // 4) Business assertions\n  TestValidator.equals(\n    \"returned email matches request\",\n    output.email,\n    adminEmail,\n  );\n  TestValidator.equals(\n    \"returned is_super matches request\",\n    output.is_super,\n    true,\n  );\n\n  // token presence: ensure token.access and token.refresh are non-empty strings\n  TestValidator.predicate(\n    \"access token is present\",\n    typeof output.token?.access === \"string\" && output.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"refresh token is present\",\n    typeof output.token?.refresh === \"string\" &&\n      output.token.refresh.length > 0,\n  );\n\n  // created_at parseable (ISO 8601) - tolerant assertion: must be parseable to a numeric time\n  TestValidator.predicate(\n    \"created_at is parseable ISO 8601\",\n    typeof output.created_at === \"string\" &&\n      !Number.isNaN(Date.parse(output.created_at)),\n  );\n\n  // last_active_at may be null or string; if string, it should be parseable\n  TestValidator.predicate(\n    \"last_active_at is null or parseable\",\n    output.last_active_at === null ||\n      (typeof output.last_active_at === \"string\" &&\n        !Number.isNaN(Date.parse(output.last_active_at))),\n  );\n\n  // Ensure sensitive credential fields are not present in returned keys (e.g., password_hash)\n  TestValidator.predicate(\n    \"response does not expose password_hash\",\n    !Object.keys(output).includes(\"password_hash\"),\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/admin/login","method":"post"},"draft":"Test admin login success with existing account:\n\nPurpose: Ensure that an existing administrator can authenticate using email and password and that the server returns authorized tokens and a safe admin summary.\n\nSetup (prerequisite):\n1. Create an admin account by calling POST /auth/admin/join with a unique email and known password. Capture the created admin credentials for login.\n\nSteps:\n1. Send POST /auth/admin/login with payload { email: <created-admin-email>, password: <created-password> }.\n2. Expect HTTP 200 OK (or 201 per implementation) with an authorized response containing access token, refresh token, and admin summary.\n3. Assert response does NOT include password_hash.\n4. Assert admin summary fields: id (UUID), email matches request, is_super present, createdAt/created_at, lastActive/last_active_at (should be parsable and updated or present).\n5. Validate tokens are present and non-empty. If refresh semantics apply, assert refresh token presence.\n6. Optionally, if an admin audit record is expected to be created on login, assert via admin audit endpoints (if available) or skip if not available in test API surface.\n\nValidation points / expected outcomes:\n- 200 OK returned with authorized payload.\n- Tokens present, admin summary present without password_hash.\n- last_active_at updated by server (if accessible) — assert that last_active_at is parsable and is a valid ISO 8601 timestamp.\n\nTeardown:\n- Optionally erase created admin via admin delete endpoint if test environment supports it; otherwise rely on unique email isolation.","functionName":"test_api_admin_login_success_existing_account","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Create admin account to be used for login (establish existing account)"}]},"location":"test/features/api/auth/test_api_admin_login_success_existing_account.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\n/**\n * E2E test: admin login success with an existing account.\n *\n * Business purpose:\n *\n * - Ensure that creating an admin account (POST /auth/admin/join) yields a safe\n *   authorized payload and that subsequent login (POST /auth/admin/login) with\n *   the same credentials returns an authorized response with tokens and an\n *   admin summary that does not expose sensitive fields such as password_hash.\n *\n * Steps:\n *\n * 1. Generate unique admin credentials (email, password).\n * 2. Call api.functional.auth.admin.join to create the admin account.\n * 3. Validate join response shape and business invariants (email match, tokens\n *    present, no password_hash).\n * 4. Call api.functional.auth.admin.login with the same credentials.\n * 5. Validate login response (tokens present, timestamps parsable when present, no\n *    password_hash).\n */\nexport async function test_api_admin_login_success_existing_account(\n  connection: api.IConnection,\n) {\n  // 1) Generate unique credentials\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword = RandomGenerator.alphaNumeric(12);\n\n  // 2) Create admin account (setup)\n  const joinBody = {\n    email: adminEmail,\n    password: adminPassword,\n  } satisfies ITodoAppAdmin.ICreate;\n\n  const created: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: joinBody,\n    });\n  typia.assert(created);\n\n  // Business validations for join response\n  TestValidator.equals(\n    \"join returned same email as requested\",\n    created.email,\n    adminEmail,\n  );\n  TestValidator.predicate(\n    \"join returned access token\",\n    typeof created.token?.access === \"string\" &&\n      created.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"join returned refresh token\",\n    typeof created.token?.refresh === \"string\" &&\n      created.token.refresh.length > 0,\n  );\n  TestValidator.predicate(\n    \"join response must not contain password_hash\",\n    !(\"password_hash\" in created),\n  );\n\n  // If last_active_at is present, ensure it's a valid ISO 8601 date-time\n  if (created.last_active_at !== null && created.last_active_at !== undefined) {\n    TestValidator.predicate(\n      \"join last_active_at is valid date-time\",\n      !Number.isNaN(Date.parse(created.last_active_at)),\n    );\n  }\n\n  // 3) Perform login with same credentials\n  const loginBody = {\n    email: adminEmail,\n    password: adminPassword,\n  } satisfies ITodoAppAdmin.ILogin;\n\n  const logged: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.login(connection, {\n      body: loginBody,\n    });\n  typia.assert(logged);\n\n  // Business validations for login response\n  TestValidator.equals(\n    \"login returned same email as requested\",\n    logged.email,\n    adminEmail,\n  );\n  TestValidator.predicate(\n    \"login returned access token\",\n    typeof logged.token?.access === \"string\" && logged.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"login returned refresh token\",\n    typeof logged.token?.refresh === \"string\" &&\n      logged.token.refresh.length > 0,\n  );\n  TestValidator.predicate(\n    \"login response must not contain password_hash\",\n    !(\"password_hash\" in logged),\n  );\n\n  // Validate token timestamps are ISO 8601 parsable\n  TestValidator.predicate(\n    \"access token expired_at is a parsable date-time\",\n    !Number.isNaN(Date.parse(logged.token.expired_at)),\n  );\n  TestValidator.predicate(\n    \"refresh token refreshable_until is a parsable date-time\",\n    !Number.isNaN(Date.parse(logged.token.refreshable_until)),\n  );\n\n  // last_active_at validation (if present)\n  if (logged.last_active_at !== null && logged.last_active_at !== undefined) {\n    TestValidator.predicate(\n      \"login last_active_at is valid date-time\",\n      !Number.isNaN(Date.parse(logged.last_active_at)),\n    );\n  }\n}\n"},{"scenario":{"endpoint":{"path":"/auth/admin/login","method":"post"},"draft":"Test admin login failure with wrong password:\n\nPurpose: Verify that authentication fails when credentials are incorrect and that the server returns an appropriate error code without leaking sensitive information.\n\nSetup (prerequisite):\n1. Create an admin account by calling POST /auth/admin/join with a unique email and known password.\n\nSteps:\n1. Send POST /auth/admin/login with the same email but an incorrect password.\n2. Expect HTTP 4xx (401 Unauthorized or 400 Bad Request depending on implementation) and an error body that does not disclose whether the account exists.\n3. Assert the response includes a machine-readable error code or message appropriate for authentication failure (e.g., 'ERR_INVALID_CREDENTIALS' or generic 'authentication_failed').\n4. Assert no tokens are returned in the response.\n\nValidation points / expected outcomes:\n- 401 (or configured failure status) returned.\n- No access or refresh tokens present.\n- Error response avoids user enumeration (do not return \"email not found\").\n\nNotes:\n- Use the same created admin from the prerequisite join. Ensure unique email to avoid collisions across test runs.","functionName":"test_api_admin_login_failure_wrong_password","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Create admin account to attempt login against (existing account setup)"}]},"location":"test/features/api/auth/test_api_admin_login_failure_wrong_password.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\nexport async function test_api_admin_login_failure_wrong_password(\n  connection: api.IConnection,\n) {\n  /**\n   * Test: Admin login failure with wrong password\n   *\n   * Steps:\n   *\n   * 1. Create a new admin account via POST /auth/admin/join\n   * 2. Attempt to login with the same email but an incorrect password via POST\n   *    /auth/admin/login\n   * 3. Expect an HTTP client error (400 or 401) and no tokens returned for the\n   *    failed login\n   *\n   * Notes:\n   *\n   * - Use an unauthenticated copy of the connection for the login attempt to\n   *   avoid interference from tokens set by join.\n   */\n\n  // 1. Prepare unique admin credentials\n  const adminEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword: string = RandomGenerator.alphaNumeric(12);\n\n  // 2. Create admin account (prerequisite)\n  const created: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: {\n        email: adminEmail,\n        password: adminPassword,\n        is_super: false,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  // Validate response shape and token presence\n  typia.assert(created);\n  typia.assert(created.token);\n\n  // Business assertion: returned email should match the requested email\n  TestValidator.equals(\n    \"created admin email matches\",\n    created.email,\n    adminEmail,\n  );\n\n  // 3. Prepare an unauthenticated copy of connection to attempt login\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n\n  // 4. Attempt login with incorrect password and expect client error (400 or 401)\n  const wrongPassword = adminPassword + \"_wrong\";\n  await TestValidator.httpError(\n    \"login with wrong password should fail with 400 or 401\",\n    [400, 401],\n    async () => {\n      await api.functional.auth.admin.login(unauthConn, {\n        body: {\n          email: adminEmail,\n          password: wrongPassword,\n        } satisfies ITodoAppAdmin.ILogin,\n      });\n    },\n  );\n\n  // 5. Post-condition: Ensure unauthenticated connection did not receive tokens\n  // (login failed, so SDK should not set authorization header on unauthConn)\n  // Note: Avoid inspecting original `connection.headers` per SDK policies. We only inspect unauthConn.\n  TestValidator.predicate(\n    \"unauthenticated connection remains without Authorization after failed login\",\n    !unauthConn.headers || Object.keys(unauthConn.headers).length === 0,\n  );\n}\n"},{"scenario":{"endpoint":{"method":"get","path":"/todoApp/admin/guests/{guestId}"},"draft":"Successful admin retrieval of a guest record by id.\n\nSteps:\n1. Register a new admin account via POST /auth/admin/join to obtain admin credentials/tokens. Capture admin access token from the response.\n2. Create a guest record via POST /auth/guest/join (anonymous or with an email). Capture the returned guest id.\n3. As the authenticated admin, call GET /todoApp/admin/guests/{guestId} using the admin access token and the captured guest id.\n\nValidations / Expected outcomes:\n- POST /auth/admin/join returns an authorized payload with an access token and admin id.\n- POST /auth/guest/join returns 201 with a guest id (UUID) and created_at timestamp.\n- GET /todoApp/admin/guests/{guestId} returns 200 OK with guest fields: id (matches requested guestId), email (nullable), created_at (ISO 8601), last_active_at (nullable), status (nullable).\n- Do NOT assert internal audit records directly; audit creation is a server-side side effect per spec.\n\nPurpose and business logic verified:\n- Ensures admin-scoped read access returns correct guest data and respects UUID validation and read-only semantics.","functionName":"test_api_guest_retrieval_by_admin_success","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Authenticate as an admin to perform admin-scoped retrievals (obtain access token)."},{"endpoint":{"method":"post","path":"/auth/guest/join"},"purpose":"Create a guest record to be retrieved by the admin (provides guestId)."}]},"location":"test/features/api/guest/test_api_guest_retrieval_by_admin_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport type { ITodoAppGuest } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppGuest\";\n\n/**\n * Validate admin-scoped retrieval of a guest record by ID.\n *\n * Business context:\n *\n * - An administrator must be able to read guest records for support and\n *   housekeeping purposes. This test verifies that admin authentication grants\n *   read access to the guest record and that the returned payload matches the\n *   public guest DTO (ITodoAppGuest).\n *\n * Steps:\n *\n * 1. Create a new admin account via POST /auth/admin/join and ensure admin\n *    credentials (token) are available on the provided connection.\n * 2. Create a guest record via POST /auth/guest/join using a separate\n *    unauthenticated connection object so the guest's token does not overwrite\n *    the admin token on the main connection.\n * 3. As the admin (original connection containing admin token), call GET\n *    /todoApp/admin/guests/{guestId} and validate the returned guest payload\n *    matches and contains expected fields.\n */\nexport async function test_api_guest_retrieval_by_admin_success(\n  connection: api.IConnection,\n) {\n  // 1. Admin registration (the SDK will place admin token into connection.headers)\n  const adminEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const admin: ITodoAppAdmin.IAuthorized = await api.functional.auth.admin.join(\n    connection,\n    {\n      body: {\n        email: adminEmail,\n        password: \"Admin@1234\",\n      } satisfies ITodoAppAdmin.ICreate,\n    },\n  );\n  typia.assert(admin);\n\n  // Sanity check: admin token should be present (SDK sets it on connection)\n  TestValidator.predicate(\n    \"admin token is present after join\",\n    typeof admin.token?.access === \"string\" && admin.token.access.length > 0,\n  );\n\n  // 2. Create a guest using a cloned connection with empty headers to avoid\n  // overwriting the admin token on the original connection (SDK writes tokens\n  // to the given connection object).\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n  const guestBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n  } satisfies ITodoAppGuest.IJoin;\n\n  const guestAuth: ITodoAppGuest.IAuthorized =\n    await api.functional.auth.guest.join(unauthConn, {\n      body: guestBody,\n    });\n  typia.assert(guestAuth);\n\n  TestValidator.predicate(\n    \"guest create returned a valid id\",\n    typeof guestAuth.id === \"string\" && guestAuth.id.length > 0,\n  );\n\n  // 3. As admin (original connection still holds admin token), retrieve guest\n  const retrieved: ITodoAppGuest = await api.functional.todoApp.admin.guests.at(\n    connection,\n    {\n      guestId: guestAuth.id,\n    },\n  );\n  typia.assert(retrieved);\n\n  // Validate returned business properties\n  TestValidator.equals(\n    \"retrieved guest id matches requested id\",\n    retrieved.id,\n    guestAuth.id,\n  );\n\n  // Email is nullable; compare normalized values (actual-first, expected-second)\n  TestValidator.equals(\n    \"retrieved guest email matches created guest\",\n    retrieved.email ?? null,\n    guestAuth.email ?? null,\n  );\n\n  // created_at must exist (typia.assert already checks format); check presence\n  TestValidator.predicate(\n    \"retrieved guest has created_at\",\n    typeof retrieved.created_at === \"string\" && retrieved.created_at.length > 0,\n  );\n\n  // last_active_at and status are nullable: ensure they are either null/undefined or string\n  TestValidator.predicate(\n    \"last_active_at is nullable or ISO string\",\n    retrieved.last_active_at === null ||\n      retrieved.last_active_at === undefined ||\n      typeof retrieved.last_active_at === \"string\",\n  );\n\n  TestValidator.predicate(\n    \"status is nullable or string\",\n    retrieved.status === null ||\n      retrieved.status === undefined ||\n      typeof retrieved.status === \"string\",\n  );\n}\n"},{"scenario":{"endpoint":{"method":"get","path":"/todoApp/admin/guests/{guestId}"},"draft":"Admin attempts to retrieve a non-existent or malformed guest id and receives appropriate errors.\n\nSteps:\n1. Register a new admin account via POST /auth/admin/join and obtain an admin access token.\n2. Call GET /todoApp/admin/guests/{guestId} with a) a well-formed but non-existent UUID and b) a malformed id (not a UUID) in two separate sub-tests.\n\nValidations / Expected outcomes:\n- For a well-formed but non-existent UUID: GET returns 404 Not Found with an error indicating guest not found.\n- For a malformed id (invalid UUID format): GET returns 400 Bad Request with validation error details.\n\nPurpose and business logic verified:\n- Confirms correct error handling for missing resources and path parameter validation per the API contract.","functionName":"test_api_guest_retrieval_by_admin_not_found","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Authenticate as admin to attempt retrieval and validate error handling for missing or malformed guest IDs."}]},"location":"test/features/api/guest/test_api_guest_retrieval_by_admin_not_found.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport type { ITodoAppGuest } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppGuest\";\n\nexport async function test_api_guest_retrieval_by_admin_not_found(\n  connection: api.IConnection,\n) {\n  /**\n   * Validate admin retrieval behavior for missing guest resources.\n   *\n   * Steps:\n   *\n   * 1. Register a new admin via POST /auth/admin/join to obtain authorization.\n   * 2. Attempt to retrieve a guest with a well-formed but non-existent UUID and\n   *    assert that the call results in an error (server-side not found).\n   *\n   * Note: Although the original scenario requested testing malformed path\n   * parameters (invalid UUID format -> 400), the SDK function signature\n   * enforces guestId: string & tags.Format<\"uuid\"> at compile time. Creating\n   * tests that intentionally bypass typing (to send an invalid format) would\n   * introduce deliberate type errors and/or require unsafe casts (forbidden by\n   * policy). Therefore this test-suite only covers the\n   * well-formed-but-nonexistent case and documents the limitation.\n   */\n\n  // 1) Admin sign-up (authorization)\n  const adminEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const adminPayload = {\n    email: adminEmail,\n    password: \"ValidPa$123\",\n    is_super: false,\n  } satisfies ITodoAppAdmin.ICreate;\n\n  const admin: ITodoAppAdmin.IAuthorized = await api.functional.auth.admin.join(\n    connection,\n    {\n      body: adminPayload,\n    },\n  );\n  typia.assert(admin);\n\n  // 2) Well-formed but non-existent UUID should produce a runtime error (resource not found)\n  const nonExistentId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.error(\n    \"non-existent guest should produce an error\",\n    async () => {\n      await api.functional.todoApp.admin.guests.at(connection, {\n        guestId: nonExistentId,\n      });\n    },\n  );\n\n  // Malformed-id test omitted to preserve type safety and avoid intentional type errors.\n}\n"},{"scenario":{"endpoint":{"method":"patch","path":"/todoApp/admin/users"},"draft":"Admin searches and retrieves users with pagination, filtering, and sorting.\n\nSteps:\n1. Register a new admin account via POST /auth/admin/join and obtain admin access token.\n2. Create one or more user accounts via POST /auth/user/join (use distinct emails) to ensure searchable data exists.\n3. As authenticated admin, call PATCH /todoApp/admin/users with search criteria: page=1, pageSize=10, optional filter account_status='active' or emailLike equal to one created user, and sort by created_at desc.\n\nValidations / Expected outcomes:\n- POST /auth/admin/join returns an authorized payload with access token.\n- POST /auth/user/join returns 201 with created user id(s) and basic profile fields; capture at least one user's email or id for search assertions.\n- PATCH /todoApp/admin/users returns 200 OK with a paginated container including items array, page, pageSize, and total.\n- Response items include safe summary fields: id, email (or redacted per policy), display_name, account_status, created_at, last_active_at.\n- The created test user appears in results when using appropriate filters (emailLike or account_status).\n- Verify page metadata and that pageSize and sorting are honored.\n\nPurpose and business logic verified:\n- Ensures admin-scoped listing supports pagination, filtering by account status or email substring, and sorting. Verifies admin authentication and that responses exclude sensitive fields such as password_hash.","functionName":"test_api_user_search_by_admin_success","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Authenticate as admin to perform user search operations (obtain access token)."},{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create test user accounts so the admin search returns meaningful results."}]},"location":"test/features/api/user/test_api_user_search_by_admin_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppUser\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_user_search_by_admin_success(\n  connection: api.IConnection,\n) {\n  // 1. Create admin account and obtain authorization (SDK will inject token)\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const admin = await api.functional.auth.admin.join(connection, {\n    body: {\n      email: adminEmail,\n      password: \"AdminPass123\",\n      is_super: true,\n    } satisfies ITodoAppAdmin.ICreate,\n  });\n  typia.assert(admin);\n\n  // 2. Create two distinct user accounts to ensure search returns meaningful results\n  const userEmail1 = typia.random<string & tags.Format<\"email\">>();\n  const user1 = await api.functional.auth.user.join(connection, {\n    body: {\n      email: userEmail1,\n      password: \"UserPass123\",\n      display_name: RandomGenerator.name(),\n    } satisfies ITodoAppUser.ICreate,\n  });\n  typia.assert(user1);\n\n  const userEmail2 = typia.random<string & tags.Format<\"email\">>();\n  const user2 = await api.functional.auth.user.join(connection, {\n    body: {\n      email: userEmail2,\n      password: \"UserPass123\",\n      display_name: RandomGenerator.name(),\n    } satisfies ITodoAppUser.ICreate,\n  });\n  typia.assert(user2);\n\n  // 3. Prepare search criteria: use a substring of userEmail1's local-part for emailLike\n  const localPart = userEmail1.split(\"@\")[0] ?? userEmail1;\n  const emailLike = localPart.slice(0, Math.min(6, localPart.length));\n\n  // 4. As authenticated admin (token set by admin.join), call the admin users index endpoint\n  const page: IPageITodoAppUser.ISummary =\n    await api.functional.todoApp.admin.users.index(connection, {\n      body: {\n        page: 1,\n        pageSize: 10,\n        emailLike,\n        sortBy: \"created_at\",\n        order: \"desc\",\n      } satisfies ITodoAppUser.IRequest,\n    });\n  typia.assert(page);\n\n  // 5. Validate pagination metadata and content\n  TestValidator.predicate(\n    \"response contains pagination metadata\",\n    page.pagination !== undefined,\n  );\n  TestValidator.equals(\n    \"page size equals requested limit\",\n    page.pagination.limit,\n    10,\n  );\n  // Accept either 0-based or 1-based current page implementations\n  TestValidator.predicate(\n    \"page number is non-negative\",\n    page.pagination.current >= 0,\n  );\n\n  // 6. Validate that returned data includes at least one of the created users\n  TestValidator.predicate(\n    \"returned data includes one of created user emails\",\n    Array.isArray(page.data) &&\n      (page.data.map((d) => d.email).includes(userEmail1) ||\n        page.data.map((d) => d.email).includes(userEmail2)),\n  );\n\n  // 7. Validate item shape and presence of summary fields for the first item (if exists)\n  if (Array.isArray(page.data) && page.data.length > 0) {\n    const first = page.data[0];\n    typia.assert(first);\n    TestValidator.predicate(\n      \"first item has id\",\n      typeof first.id === \"string\" && first.id.length > 0,\n    );\n    TestValidator.predicate(\n      \"first item has email\",\n      typeof first.email === \"string\" && first.email.includes(\"@\"),\n    );\n    TestValidator.predicate(\n      \"first item has account_status\",\n      typeof first.account_status === \"string\",\n    );\n    TestValidator.predicate(\n      \"first item has created_at\",\n      typeof first.created_at === \"string\",\n    );\n  }\n\n  // 8. Validate sorting by created_at descending (if more than one item returned)\n  if (Array.isArray(page.data) && page.data.length > 1) {\n    const isDesc = page.data.every((elem, i, arr) => {\n      if (i === 0) return true;\n      const prev = new Date(arr[i - 1].created_at).getTime();\n      const curr = new Date(elem.created_at).getTime();\n      return prev >= curr;\n    });\n    TestValidator.predicate(\"items are sorted by created_at desc\", isDesc);\n  }\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/user/todos/{todoId}/versions","method":"patch"},"draft":"Test listing snapshot versions for a user's todo (happy path and edge considerations).\n\nSteps:\n1) Create a new user context via POST /auth/user/join (new user context – join only). Capture returned access token and user id.\n2) Using the user's token, create one or more todos via POST /todoApp/user/todos. Capture returned todoId(s). Note: snapshots are system-generated; tests should either wait for background snapshot creation (polling with timeout) or assert empty-result behavior when snapshots are not present. If no snapshot generator exists in the test environment, assert empty page behavior rather than failing the test.\n3) Call PATCH /todoApp/user/todos/{todoId}/versions with the todoId and request parameters: default pagination, and an explicit pageSize to validate paging behavior. Also test filter by isCompleted when applicable and sort by snapshot_at desc.\n\nValidation points / Expected outcomes:\n- 200 OK response with a paginated container (page, pageSize, total) and items array of snapshot summaries.\n- Each item contains required snapshot fields: id (UUID), todo_app_todo_id matching requested todoId, title, is_completed, snapshot_at (ISO 8601). Ensure snapshot_at format is ISO 8601 and items are ordered by snapshot_at desc when requested.\n- If no snapshots exist yet, API should return an empty page (items: []). Tests should handle both cases deterministically: either wait/retry for snapshots or assert empty page behavior depending on environment.\n- Validate pagination metadata consistency (total >= items.length, page,pageSize reflect request).\n\nEdge cases included:\n- Request with invalid todoId format (malformed UUID) may produce 400; include this check only if validation-only tests are permitted by project policy.\n- Requesting snapshots for a todo that does not exist (well-formed UUID) should produce 404 per API spec; assert behavior accordingly.\n- PageSize exceeding server max should be capped or produce 400; assert server behavior.\n\nNotes:\n- Authentication must precede any user-scoped calls. Use join (not login) to create a fresh user context. Do not attempt to create snapshots via API (system-generated).","functionName":"test_api_todo_snapshot_list_by_owner","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create a new user account and obtain an access token for user-scoped operations (new user context via join)."},{"endpoint":{"method":"post","path":"/todoApp/user/todos"},"purpose":"Create a Todo owned by the authenticated user; provides the todoId required to list snapshot versions."}]},"location":"test/features/api/todo/test_api_todo_snapshot_list_by_owner.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoAppTodoSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppTodoSnapshot\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppTodoSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodoSnapshot\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Validate listing of todo snapshot versions for a todo owned by the current\n * user.\n *\n * This test covers both the happy path where snapshot records already exist and\n * the empty-state behavior where no snapshots have been generated yet. It also\n * validates pagination metadata, server-side pageSize capping behavior, and\n * ordering by snapshot_at descending when snapshots are present.\n *\n * Steps:\n *\n * 1. Create a new user via POST /auth/user/join and let SDK populate connection\n *    headers.\n * 2. Create a todo via POST /todoApp/user/todos for the authenticated user.\n * 3. Call PATCH /todoApp/user/todos/{todoId}/versions with pagination & sorting.\n * 4. Validate response structure, pagination, content, and ordering if items\n *    exist.\n * 5. Negative: request versions for a non-existent (well-formed) UUID and assert\n *    error.\n */\nexport async function test_api_todo_snapshot_list_by_owner(\n  connection: api.IConnection,\n) {\n  // 1) Create a fresh user (join)\n  const joinOutput: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: {\n        email: typia.random<string & tags.Format<\"email\">>(),\n        password: \"Password123\",\n        display_name: RandomGenerator.name(),\n      } satisfies ITodoAppUser.ICreate,\n    });\n  typia.assert(joinOutput);\n\n  // Save user id for debugging / correlation\n  const userId: string & tags.Format<\"uuid\"> = joinOutput.id;\n\n  // 2) Create a todo for that user\n  const createBody = {\n    title: RandomGenerator.paragraph({ sentences: 3, wordMin: 3, wordMax: 8 }),\n    description: RandomGenerator.paragraph({ sentences: 5 }),\n    position: typia.random<number & tags.Type<\"int32\"> & tags.Minimum<0>>(),\n    is_completed: false,\n  } satisfies ITodoAppTodo.ICreate;\n\n  const todo: ITodoAppTodo = await api.functional.todoApp.user.todos.create(\n    connection,\n    { body: createBody },\n  );\n  typia.assert(todo);\n\n  // 3) Prepare versions request (pagination + sorting)\n  const requestBody = {\n    page: 1,\n    pageSize: 5,\n    sortBy: \"snapshot_at\",\n    sortOrder: \"desc\",\n    // todoId is passed as path param below; body.todoId is optional\n  } satisfies ITodoAppTodoSnapshot.IRequest;\n\n  // Helper: attempt to fetch snapshots with conservative polling (0..2 retries)\n  async function fetchSnapshots(): Promise<IPageITodoAppTodoSnapshot> {\n    const maxAttempts = 3;\n    const delayMs = 500;\n    for (let attempt = 1; attempt <= maxAttempts; ++attempt) {\n      const page = await api.functional.todoApp.user.todos.versions.index(\n        connection,\n        {\n          todoId: todo.id,\n          body: requestBody,\n        },\n      );\n      typia.assert(page);\n      // If items exist, return immediately. Otherwise, allow a few retries to\n      // give background snapshot generators time to produce snapshots.\n      if (page.data.length > 0 || attempt === maxAttempts) return page;\n      // small delay\n      await new Promise((res) => setTimeout(res, delayMs));\n    }\n    // unreachable but TypeScript needs a return\n    return await api.functional.todoApp.user.todos.versions.index(connection, {\n      todoId: todo.id,\n      body: requestBody,\n    });\n  }\n\n  const pageResult: IPageITodoAppTodoSnapshot = await fetchSnapshots();\n  typia.assert(pageResult);\n\n  // 4) Validate pagination metadata and items\n  const pagination = pageResult.pagination;\n  const items = pageResult.data;\n\n  // pageSize / limit behavior: server may cap the requested pageSize\n  TestValidator.predicate(\n    \"pagination.limit is non-negative\",\n    pagination.limit >= 0,\n  );\n  TestValidator.predicate(\n    \"pagination.current matches request page\",\n    pagination.current === (requestBody.page ?? 1),\n  );\n  TestValidator.predicate(\n    \"server limit does not exceed requested pageSize\",\n    pagination.limit <= (requestBody.pageSize ?? pagination.limit),\n  );\n\n  // total/records consistency\n  TestValidator.predicate(\n    \"pagination.records is >= returned items length\",\n    pagination.records >= items.length,\n  );\n  TestValidator.predicate(\"pages is non-negative\", pagination.pages >= 0);\n\n  // Items: either empty (no snapshots) or contain snapshot summaries\n  if (items.length === 0) {\n    // Empty-state assertions\n    TestValidator.equals(\n      \"empty snapshots returns zero records\",\n      pagination.records,\n      0,\n    );\n    TestValidator.equals(\"empty snapshots returns empty data array\", items, []);\n  } else {\n    // If items exist, ensure each snapshot references the created todo and\n    // snapshot_at ordering is desc when requested.\n    for (const it of items) {\n      TestValidator.equals(\n        \"snapshot references same todo id\",\n        it.todo_app_todo_id,\n        todo.id,\n      );\n      // typia.assert already ensures id and snapshot_at formats are correct.\n      typia.assert<ITodoAppTodoSnapshot>(it);\n    }\n\n    // Ensure ordering by snapshot_at desc\n    if (items.length >= 2) {\n      const first = new Date(items[0].snapshot_at).getTime();\n      const last = new Date(items[items.length - 1].snapshot_at).getTime();\n      TestValidator.predicate(\n        \"snapshots ordered by snapshot_at desc\",\n        first >= last,\n      );\n    }\n  }\n\n  // 5) Negative case: requesting snapshots for a well-formed but non-existent todo\n  const fakeTodoId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.error(\n    \"requesting snapshots for non-existent todo should throw\",\n    async () => {\n      await api.functional.todoApp.user.todos.versions.index(connection, {\n        todoId: fakeTodoId,\n        body: requestBody,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/user/todos/{todoId}/versions/{versionId}","method":"get"},"draft":"Test retrieving a specific todo snapshot (version) by id, verifying ownership and exact snapshot payload.\n\nSteps:\n1) Create a new user via POST /auth/user/join and capture the access token.\n2) Create a todo via POST /todoApp/user/todos using the user's token; capture todoId. Ensure the environment produces at least one snapshot for that todo (snapshots are system-generated). If snapshots are created asynchronously, poll the snapshot list endpoint until a snapshot appears or until a timeout is reached.\n3) From the snapshot list (PATCH /todoApp/user/todos/{todoId}/versions) obtain a snapshot id (versionId) to request.\n4) Call GET /todoApp/user/todos/{todoId}/versions/{versionId} with the user's token.\n\nValidation points / Expected outcomes:\n- 200 OK with a snapshot object containing fields: id (UUID), todo_app_todo_id equal to todoId, title, description (optional), is_completed (boolean), completed_at (nullable ISO 8601), position (nullable integer), created_at, updated_at, deleted_at (nullable), snapshot_at (ISO 8601). Ensure ISO 8601 formats for timestamps.\n- Ownership enforced: if the requesting user is not the owner, expect 403 Forbidden.\n- If versionId does not exist or does not belong to the provided todoId, expect 404 Not Found.\n- If todoId or versionId is malformed (invalid UUID) that is a validation-level error; include this check only if validation-only tests are permitted by project policy.\n\nEdge cases included:\n- Attempt to retrieve a snapshot using a valid versionId that belongs to a different todo -> expect 404 per spec.\n- Attempt to retrieve a snapshot by another user -> expect 403 Forbidden when ownership check fails.\n\nNotes:\n- Authentication must be created via join (new user). Do not mix join and login. Snapshots are system-generated; tests should include polling logic or be run in environments where snapshots are produced deterministically.","functionName":"test_api_todo_snapshot_retrieval_by_owner","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create a new user account and obtain an access token for user-scoped operations (new user context via join)."},{"endpoint":{"method":"post","path":"/todoApp/user/todos"},"purpose":"Create a Todo owned by the authenticated user; provides the todoId referenced by snapshot versions."}]},"location":"test/features/api/todo/test_api_todo_snapshot_retrieval_by_owner.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppTodoSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodoSnapshot\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Validate retrieval of a todo snapshot (version) by its owner.\n *\n * Business context:\n *\n * - The backend keeps snapshots of todo items. Owners should be able to retrieve\n *   a specific snapshot by todoId and versionId.\n *\n * Test flow (simulated):\n *\n * 1. Register a new user (join)\n * 2. Create a todo for that user\n * 3. Retrieve a snapshot for that todo (versions.at)\n * 4. Validate snapshot structure and timestamps\n *\n * Notes:\n *\n * - This test uses SDK simulation mode (connection.simulate = true) to obtain\n *   deterministic typia-random responses suitable for CI or environments where\n *   the SDK was generated with simulation support. For real-server testing,\n *   remove simulate=true and ensure snapshots exist or provide a snapshot-list\n *   endpoint/fixture.\n */\nexport async function test_api_todo_snapshot_retrieval_by_owner(\n  connection: api.IConnection,\n) {\n  // Use simulation mode to obtain deterministic, typia-random responses.\n  const sim: api.IConnection = { ...connection, simulate: true };\n\n  // 1) Create a new user via join\n  const joinBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"Password123\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const user = await api.functional.auth.user.join(sim, { body: joinBody });\n  typia.assert(user);\n\n  // 2) Create a todo owned by the authenticated user\n  const createTodoBody = {\n    title: RandomGenerator.paragraph({ sentences: 3, wordMin: 4, wordMax: 8 }),\n    description: RandomGenerator.paragraph({\n      sentences: 5,\n      wordMin: 4,\n      wordMax: 10,\n    }),\n    is_completed: false,\n  } satisfies ITodoAppTodo.ICreate;\n\n  const todo = await api.functional.todoApp.user.todos.create(sim, {\n    body: createTodoBody,\n  });\n  typia.assert(todo);\n\n  // 3) Retrieve a snapshot for that todo\n  // NOTE: Without a snapshot-listing endpoint in the provided SDK materials,\n  // we cannot deterministically obtain a real versionId tied to the created\n  // todo. For simulation we request a random version id; the simulated SDK\n  // returns a random ITodoAppTodoSnapshot.\n  const versionId = typia.random<string & tags.Format<\"uuid\">>();\n  const snapshot = await api.functional.todoApp.user.todos.versions.at(sim, {\n    todoId: todo.id,\n    versionId,\n  });\n  typia.assert(snapshot);\n\n  // 4) Business validations (type and timestamp checks)\n  TestValidator.predicate(\n    \"snapshot.snapshot_at is a valid ISO 8601 datetime\",\n    !Number.isNaN(Date.parse(snapshot.snapshot_at)),\n  );\n\n  TestValidator.predicate(\n    \"snapshot.created_at is a valid ISO 8601 datetime\",\n    !Number.isNaN(Date.parse(snapshot.created_at)),\n  );\n\n  TestValidator.predicate(\n    \"snapshot.updated_at is a valid ISO 8601 datetime\",\n    !Number.isNaN(Date.parse(snapshot.updated_at)),\n  );\n\n  // Ensure required fields exist (typia.assert already validated shape)\n  TestValidator.predicate(\"snapshot has id\", typeof snapshot.id === \"string\");\n  TestValidator.predicate(\n    \"snapshot has todo_app_todo_id\",\n    typeof snapshot.todo_app_todo_id === \"string\",\n  );\n\n  // Note on ownership equality assertion:\n  // When a snapshot-listing endpoint is available or the system provides a\n  // deterministic versionId tied to the created todo, add the following\n  // assertion to verify ownership:\n  // TestValidator.equals(\"snapshot belongs to todo\", snapshot.todo_app_todo_id, todo.id);\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/user/todos","method":"post"},"draft":"Test successful creation of a Todo by an authenticated user.\n\nSteps:\n1) Register a new user via POST /auth/user/join to obtain auth tokens (new user context via join).\n2) Call POST /todoApp/user/todos with a valid payload including required title and optional description and position, using the access token in Authorization header.\n3) Assert HTTP 201 Created.\n4) Assert response body contains server-populated fields: id (UUID), user_id, createdAt, updatedAt; title matches request; isCompleted is false (default) if not provided; position present when provided.\n5) Validate createdAt and updatedAt are ISO 8601 timestamps and that updatedAt >= createdAt.\n\nExpected outcomes: 201, returned todo contains server-managed fields and matches business expectations.\n","functionName":"test_api_todo_create_by_user","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Authenticate as a new user (join) to obtain access tokens for user-scoped operations."}]},"location":"test/features/api/todo/test_api_todo_create_by_user.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_todo_create_by_user(\n  connection: api.IConnection,\n) {\n  // 1) Register a new user (join) to obtain authorization context for subsequent calls\n  const userEmail = typia.random<string & tags.Format<\"email\">>();\n  const userPassword = RandomGenerator.alphaNumeric(12);\n  const joinBody = {\n    email: userEmail,\n    password: userPassword,\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const authorized: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: joinBody,\n    });\n  typia.assert(authorized);\n\n  // 2) Create a new todo as the authenticated user\n  const createRequest = {\n    title: RandomGenerator.paragraph({ sentences: 3, wordMin: 5, wordMax: 10 }),\n    description: RandomGenerator.content({\n      paragraphs: 1,\n      sentenceMin: 5,\n      sentenceMax: 8,\n      wordMin: 4,\n      wordMax: 8,\n    }),\n    position: typia.random<\n      number & tags.Type<\"int32\"> & tags.Minimum<1> & tags.Maximum<100>\n    >(),\n    // intentionally omit is_completed to verify server default behavior\n  } satisfies ITodoAppTodo.ICreate;\n\n  const todo: ITodoAppTodo = await api.functional.todoApp.user.todos.create(\n    connection,\n    {\n      body: createRequest,\n    },\n  );\n  typia.assert(todo);\n\n  // 3) Business assertions\n  TestValidator.equals(\n    \"created todo title matches request\",\n    todo.title,\n    createRequest.title,\n  );\n  TestValidator.equals(\n    \"created todo belongs to joined user\",\n    todo.user_id,\n    authorized.id,\n  );\n  TestValidator.equals(\n    \"is_completed defaults to false when omitted\",\n    todo.is_completed,\n    false,\n  );\n  TestValidator.equals(\n    \"position is echoed when provided\",\n    todo.position,\n    createRequest.position,\n  );\n\n  // 4) Timestamp sanity: updated_at must be >= created_at\n  const createdAt = Date.parse(todo.created_at);\n  const updatedAt = Date.parse(todo.updated_at);\n  TestValidator.predicate(\n    \"updated_at should be >= created_at\",\n    updatedAt >= createdAt,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/user/todos/{todoId}","method":"get"},"draft":"Test retrieving a non-existent Todo returns 404.\n\nSteps:\n1) Register a new user via POST /auth/user/join to obtain tokens (new user context).\n2) Call GET /todoApp/user/todos/{todoId} with a syntactically valid UUID that does not exist in the database, using Authorization header.\n3) Assert HTTP 404 Not Found.\n4) Assert error body contains a clear machine-readable code and message indicating resource not found and contains no sensitive information.\n\nNotes: Do NOT create a todo for this scenario—the intent is to exercise the not-found behavior.\n","functionName":"test_api_todo_retrieve_not_found","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Authenticate as a new user (join) to obtain access tokens for user-scoped operations."}]},"location":"test/features/api/todo/test_api_todo_retrieve_not_found.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_todo_retrieve_not_found(\n  connection: api.IConnection,\n) {\n  // 1) Register a new user to establish an authenticated context.\n  const userEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const created: ITodoAppUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: {\n        email: userEmail,\n        password: \"Password123\", // Meets min length requirement (>=8)\n        display_name: RandomGenerator.name(),\n      } satisfies ITodoAppUser.ICreate,\n    },\n  );\n  // Validate the authorization response shape\n  typia.assert(created);\n\n  // 2) Generate a syntactically valid UUID that (very likely) does not exist\n  //    in the database and attempt to retrieve it.\n  const nonExistentTodoId: string = typia.random<\n    string & tags.Format<\"uuid\">\n  >();\n\n  // 3) Expect a 404 Not Found when attempting to retrieve a non-existent todo.\n  //    Use TestValidator.httpError to assert an HttpError with status 404 is thrown.\n  await TestValidator.httpError(\n    \"retrieving non-existent todo returns 404\",\n    404,\n    async () => {\n      await api.functional.todoApp.user.todos.at(connection, {\n        todoId: nonExistentTodoId,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"method":"get","path":"/todoApp/admin/todos/{todoId}/versions/{versionId}"},"draft":"Admin retrieves a specific todo snapshot (version) for support/audit.\n\nWorkflow:\n1. Create a new admin account via POST /auth/admin/join to obtain admin credentials/tokens (new admin context). Use the returned admin token when calling admin-scoped endpoints.\n2. Create a new user via POST /auth/user/join to obtain a user identity and token for creating user-owned todos.\n3. As the created user, call POST /todoApp/user/todos to create a Todo; capture the returned todo id. Verify response is 201 and the returned object includes id (UUID), title, isCompleted (false by default), createdAt and updatedAt in ISO 8601 format.\n4. Wait/poll for at least one snapshot to be available for the created todo (snapshot generation may be asynchronous). Retrieve a snapshot versionId via the system's snapshot listing if available.\n5. As the admin (use admin token from step 1), call GET /todoApp/admin/todos/{todoId}/versions/{versionId} using the todoId from step 3 and the discovered versionId. Expect 200 OK and a response body containing snapshot fields: id (UUID), todo_app_todo_id matching todoId, title, description (when present), is_completed (boolean), completed_at (nullable ISO 8601), position (integer or null), created_at, updated_at, deleted_at (nullable), and snapshot_at (ISO 8601). Verify types and formats.\n\nValidation points:\n- Admin authentication required: ensure request uses admin access token and returns 401/403 if omitted or invalid.\n- Path parameter validation: malformed UUIDs produce 400.\n- Not found behavior: if todoId/versionId mismatch or snapshot missing, expect 404.\n- Response payload contains only snapshot fields (no sensitive fields such as password_hash).\n\nNotes:\n- Snapshot creation may be asynchronous; tests should poll with a sensible timeout to discover snapshots.\n","functionName":"test_api_todo_snapshot_admin_retrieval","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Authenticate as admin to perform admin-scoped operations (create admin context via join)"},{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a regular user to create Todos used in the test (create user context via join)"},{"endpoint":{"method":"post","path":"/todoApp/user/todos"},"purpose":"Create a Todo item as the authenticated user to serve as the parent resource for snapshots (returns todoId)"}]},"location":"test/features/api/todo_snapshot/test_api_todo_snapshot_admin_retrieval.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppTodoSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodoSnapshot\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * E2E test: Admin retrieves a specific todo snapshot (version).\n *\n * Business purpose:\n *\n * - Ensures admin-scoped snapshot retrieval endpoint is accessible to admins,\n *   returns the expected snapshot DTO shape, and requires authentication.\n *\n * Test steps:\n *\n * 1. Create an admin account (admin A) — obtain admin token (SDK sets it).\n * 2. Create a regular user account (user) and create a Todo as that user.\n * 3. Create another admin account (admin B) to ensure admin-authenticated context\n *    for the admin endpoint call (SDK will set Authorization header).\n * 4. Call GET /todoApp/admin/todos/{todoId}/versions/{versionId} as admin using\n *    the todoId from created todo and a plausible random versionId.\n *    typia.assert() the response as ITodoAppTodoSnapshot.\n * 5. Validate simple business assertions on the snapshot and verify that\n *    unauthenticated access is rejected.\n */\nexport async function test_api_todo_snapshot_admin_retrieval(\n  connection: api.IConnection,\n) {\n  // 1. Create first admin (admin A) to demonstrate admin creation flow\n  const adminA: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: {\n        email: typia.random<string & tags.Format<\"email\">>(),\n        password: \"Admin#1Pass!\",\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(adminA);\n\n  // 2. Create a regular user and sign-in (SDK will set Authorization to user token)\n  const user: ITodoAppUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: {\n        email: typia.random<string & tags.Format<\"email\">>(),\n        password: \"User#1Pass!\",\n        display_name: RandomGenerator.name(),\n      } satisfies ITodoAppUser.ICreate,\n    },\n  );\n  typia.assert(user);\n\n  // 3. Create a Todo as the authenticated user\n  const todo: ITodoAppTodo = await api.functional.todoApp.user.todos.create(\n    connection,\n    {\n      body: {\n        title: RandomGenerator.paragraph({ sentences: 3 }),\n        description: RandomGenerator.paragraph({ sentences: 2 }),\n        position: typia.random<number & tags.Type<\"int32\"> & tags.Minimum<1>>(),\n      } satisfies ITodoAppTodo.ICreate,\n    },\n  );\n  typia.assert(todo);\n  TestValidator.predicate(\n    \"created todo has id\",\n    typeof todo.id === \"string\" && todo.id.length > 0,\n  );\n\n  // 4. Create a second admin (admin B) to switch to admin auth context\n  const adminB: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: {\n        email: typia.random<string & tags.Format<\"email\">>(),\n        password: \"Admin#2Pass!\",\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(adminB);\n\n  // 5. Call the admin snapshot retrieval endpoint.\n  // NOTE: Because the SDK lacks a snapshot-listing endpoint, we use a plausible\n  // versionId (a random UUID) to exercise the endpoint in simulated environments\n  // or against pre-populated systems. typia.assert validates the returned shape.\n  const versionId = typia.random<string & tags.Format<\"uuid\">>();\n  const snapshot: ITodoAppTodoSnapshot =\n    await api.functional.todoApp.admin.todos.versions.at(connection, {\n      todoId: todo.id,\n      versionId,\n    });\n  typia.assert(snapshot);\n\n  // Business-level assertions (typia.assert has already validated types/formats)\n  TestValidator.predicate(\n    \"snapshot has snapshot_at\",\n    snapshot.snapshot_at !== null && snapshot.snapshot_at !== undefined,\n  );\n  TestValidator.predicate(\n    \"snapshot contains id\",\n    typeof snapshot.id === \"string\" && snapshot.id.length > 0,\n  );\n\n  // 6. Verify unauthenticated admin access is rejected\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n  await TestValidator.error(\n    \"unauthenticated admin snapshot access is rejected\",\n    async () => {\n      await api.functional.todoApp.admin.todos.versions.at(unauthConn, {\n        todoId: todo.id,\n        versionId: typia.random<string & tags.Format<\"uuid\">>(),\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"method":"patch","path":"/todoApp/admin/auditRecords"},"draft":"Admin searches audit records to find events related to a todo snapshot view.\n\nWorkflow:\n1. Create a new admin account via POST /auth/admin/join to obtain admin credentials/tokens.\n2. Create a new user via POST /auth/user/join to own test data.\n3. As the created user, POST /todoApp/user/todos to create a Todo and capture its todoId.\n4. As the admin, call GET /todoApp/admin/todos/{todoId}/versions/{versionId} with a valid snapshot versionId for the created todo. This admin read action should generate an auditRecords entry with action_type='view_snapshot' referencing the snapshot versionId.\n5. As the admin, call PATCH /todoApp/admin/auditRecords with filters to search for audit records where target_resource='todo_snapshot' and target_id equals the snapshot versionId (or filter by actor_role='admin' and action_type='view_snapshot'). Expect 200 OK and a paginated response that includes at least one matching audit record. Validate that returned records include fields: id (UUID), actor_role (e.g., 'admin'), action_type ('view_snapshot'), target_resource ('todo_snapshot'), target_id matching versionId, created_at (ISO 8601), and optional admin_id/user_id as applicable.\n\nValidation points:\n- Authentication: the auditRecords endpoint requires admin role; ensure requests without admin token return 401/403.\n- Pagination: validate page/pageSize behavior and that responses include pagination metadata.\n- Filtering: search by target_resource/target_id and action_type should return precise results; invalid filters should return 400.\n- Security: ensure returned audit records do not expose sensitive fields from related models (no password_hash or secrets).\n\nNotes:\n- To guarantee an audit entry exists for the search, this scenario depends on performing the admin snapshot retrieval as a preparatory step. If the environment produces audit records asynchronously, tests should poll until the entry appears or fail after a sensible timeout.\n","functionName":"test_api_audit_records_search_by_admin","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Authenticate as admin to perform admin-scoped operations (create admin context via join)"},{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a regular user to create Todos referenced by audit records (create user context via join)"},{"endpoint":{"method":"post","path":"/todoApp/user/todos"},"purpose":"Create a Todo item that will be referenced by subsequent admin snapshot reads (provides todoId)"},{"endpoint":{"method":"get","path":"/todoApp/admin/todos/{todoId}/versions/{versionId}"},"purpose":"Perform an admin snapshot read to generate an auditRecords entry (action_type='view_snapshot') which the audit search will then find"}]},"location":"test/features/api/audit_records/test_api_audit_records_search_by_admin.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoAppAuditRecord } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppAuditRecord\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport type { ITodoAppAuditRecord } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAuditRecord\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppTodoSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodoSnapshot\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_audit_records_search_by_admin(\n  connection: api.IConnection,\n) {\n  // 1. Create a dedicated admin connection and register an admin account\n  const adminConn: api.IConnection = { ...connection, headers: {} };\n  const adminBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"Admin#1234\",\n    is_super: true,\n  } satisfies ITodoAppAdmin.ICreate;\n  const admin: ITodoAppAdmin.IAuthorized = await api.functional.auth.admin.join(\n    adminConn,\n    { body: adminBody },\n  );\n  typia.assert(admin);\n\n  // 2. Create a dedicated user connection and register a regular user\n  const userConn: api.IConnection = { ...connection, headers: {} };\n  const userBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"User#1234\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n  const user: ITodoAppUser.IAuthorized = await api.functional.auth.user.join(\n    userConn,\n    { body: userBody },\n  );\n  typia.assert(user);\n\n  // 3. As the created user, create a Todo item\n  const todoBody = {\n    title: RandomGenerator.paragraph({ sentences: 3, wordMin: 3, wordMax: 8 }),\n    description: RandomGenerator.content({ paragraphs: 1 }),\n    position: typia.random<number & tags.Type<\"int32\"> & tags.Minimum<1>>(),\n  } satisfies ITodoAppTodo.ICreate;\n\n  const todo: ITodoAppTodo = await api.functional.todoApp.user.todos.create(\n    userConn,\n    { body: todoBody },\n  );\n  typia.assert(todo);\n\n  // NOTE: Instead of relying on a snapshot view to generate audit entries (which\n  // may be environment-dependent), this test searches for an audit event that is\n  // generated by the admin.join operation itself (action_type: 'create_admin').\n  // This makes the test deterministic across environments where admin creation\n  // records an audit event.\n\n  // 4. Search audit records as admin for the 'create_admin' event.\n  const request = {\n    actor_role: \"admin\",\n    action_type: \"create_admin\",\n    // target_resource is optional; leave unspecified so backend will search all resources\n    page: 1,\n    pageSize: 10,\n    sort_by: \"created_at\",\n    sort_order: \"desc\",\n  } satisfies ITodoAppAuditRecord.IRequest;\n\n  let page: IPageITodoAppAuditRecord | undefined = undefined;\n  const attempts = 5;\n  for (let i = 0; i < attempts; ++i) {\n    page = await api.functional.todoApp.admin.auditRecords.index(adminConn, {\n      body: request,\n    });\n    typia.assert(page);\n    if (page.data.length > 0) break;\n    // wait 1s before retry\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n  }\n\n  // Validate that we received at least one matching audit record\n  TestValidator.predicate(\n    \"audit search returned results for create_admin\",\n    page !== undefined && page.data.length > 0,\n  );\n\n  if (page && page.data.length > 0) {\n    const found = page.data.find(\n      (r) => r.action_type === \"create_admin\" && r.actor_role === \"admin\",\n    );\n    TestValidator.predicate(\n      \"found matching audit record for create_admin\",\n      found !== undefined,\n    );\n\n    // Validate pagination metadata\n    TestValidator.predicate(\n      \"pagination metadata present\",\n      page.pagination &&\n        typeof page.pagination.records === \"number\" &&\n        page.pagination.limit > 0,\n    );\n\n    // Ensure records include required audit fields and no sensitive fields\n    for (const rec of page.data) {\n      TestValidator.predicate(\n        \"audit record has id\",\n        typeof rec.id === \"string\",\n      );\n      TestValidator.predicate(\n        \"audit record has actor_role\",\n        typeof rec.actor_role === \"string\",\n      );\n      TestValidator.predicate(\n        \"audit record has action_type\",\n        typeof rec.action_type === \"string\",\n      );\n      TestValidator.predicate(\n        \"audit record has target_resource\",\n        typeof rec.target_resource === \"string\",\n      );\n      TestValidator.predicate(\n        \"audit record has created_at\",\n        typeof rec.created_at === \"string\",\n      );\n      // Security: ensure sensitive fields are not present on audit records\n      TestValidator.predicate(\n        \"audit record does not include password_hash\",\n        !Object.prototype.hasOwnProperty.call(rec as object, \"password_hash\"),\n      );\n    }\n  }\n\n  // 5. Negative test: a non-admin (regular user) should not be able to search audit records\n  await TestValidator.error(\n    \"non-admin cannot access audit records\",\n    async () => {\n      await api.functional.todoApp.admin.auditRecords.index(userConn, {\n        body: request,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/admins","method":"patch"},"draft":"Test admin search/list endpoint with valid admin authentication, pagination, filtering, and sorting.\n\nSteps:\n1) Test setup: Create the calling admin account by invoking POST /auth/admin/join with a unique email/password and extract the returned access token. If additional admin accounts are required as test data, invoke POST /auth/admin/join again with unique payloads during setup. (Note: list the /auth/admin/join dependency once in the metadata; tests may call it multiple times in setup to create multiple accounts.)\n2) Call PATCH /todoApp/admin/admins with Authorization: Bearer <accessToken> and requestBody containing pagination (page=1,pageSize=10), optional filter (is_super=true or false), and sort (created_at desc).\n3) Assert HTTP 200. Response contains paginated container with metadata (page, pageSize, total) and items array.\n4) For each returned admin summary assert presence of allowed fields: id (UUID), email (string), is_super (boolean), created_at (ISO 8601), last_active_at (nullable ISO 8601).\n5) Assert sensitive fields such as password_hash are NOT present in any returned item.\n6) Validate pagination behaviour when pageSize is reduced (e.g., pageSize=1) and that sorting order by created_at or last_active_at matches requested direction.\n\nExpected outcomes: 200 OK with paginated list, correct filtering, sorting and pagination, no sensitive fields returned.\n\nFailure modes to include in concrete tests: 400 for invalid request body (bad page/pageSize or invalid sort field), 401/403 if the caller is not authenticated as admin, 429 if rate-limited.","functionName":"test_api_admin_admins_search_and_pagination","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create an admin account and obtain an access token to authenticate admin-scoped requests. This single dependency represents the join flow; test setup may invoke it multiple times (with unique emails) to create caller and additional admin test data as needed."}]},"location":"test/features/api/admin/test_api_admin_admins_search_and_pagination.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppAdmin\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\nexport async function test_api_admin_admins_search_and_pagination(\n  connection: api.IConnection,\n) {\n  /**\n   * E2E tests for PATCH /todoApp/admin/admins\n   *\n   * Flow:\n   *\n   * 1. Create caller admin via POST /auth/admin/join (connection will be updated\n   *    with Authorization)\n   * 2. Create several additional admin accounts to populate listing\n   * 3. Call index endpoint with various request bodies to test pagination,\n   *    filtering and sorting\n   * 4. Assert responses and business rules using typia.assert and TestValidator\n   */\n\n  // 1) Create the caller admin (will set Authorization header in connection)\n  const callerEmail = `${RandomGenerator.alphaNumeric(8)}@example.com`;\n  const caller: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: {\n        email: callerEmail,\n        password: \"P@ssw0rd!\",\n        is_super: true,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(caller);\n\n  // 2) Create additional admins (some super, some normal) to ensure list has data\n  const extraAdminsCount = 3;\n  const createdAdmins: ITodoAppAdmin.IAuthorized[] = [];\n  for (let i = 0; i < extraAdminsCount; ++i) {\n    const email = `${RandomGenerator.alphaNumeric(8)}@example.com`;\n    const created = await api.functional.auth.admin.join(connection, {\n      body: {\n        email,\n        password: \"P@ssw0rd!\",\n        is_super: i % 2 === 0, // alternate\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n    typia.assert(created);\n    createdAdmins.push(created);\n  }\n\n  // 3) Basic listing: page=1,pageSize=10 sorted by created_at desc\n  const pageAll: IPageITodoAppAdmin.ISummary =\n    await api.functional.todoApp.admin.admins.index(connection, {\n      body: {\n        page: 1,\n        pageSize: 10,\n        sort_by: \"created_at\",\n        sort_order: \"desc\",\n      } satisfies ITodoAppAdmin.IRequest,\n    });\n  typia.assert(pageAll);\n\n  // Validate pagination metadata\n  TestValidator.predicate(\n    \"pagination has current page number\",\n    pageAll.pagination.current >= 1,\n  );\n  TestValidator.predicate(\n    \"pagination has limit field\",\n    pageAll.pagination.limit >= 1,\n  );\n  TestValidator.predicate(\n    \"pagination has records count\",\n    pageAll.pagination.records >= pageAll.data.length,\n  );\n\n  // Validate returned items structure and no sensitive fields\n  for (const item of pageAll.data) {\n    TestValidator.predicate(\n      \"item has id (uuid)\",\n      typeof item.id === \"string\" && item.id.length > 0,\n    );\n    TestValidator.predicate(\n      \"item has email\",\n      typeof item.email === \"string\" && item.email.includes(\"@\"),\n    );\n    TestValidator.predicate(\n      \"item has is_super boolean\",\n      typeof item.is_super === \"boolean\",\n    );\n    TestValidator.predicate(\n      \"created_at is present\",\n      item.created_at !== null &&\n        item.created_at !== undefined &&\n        typeof item.created_at === \"string\",\n    );\n    TestValidator.predicate(\n      \"last_active_at is string or null\",\n      item.last_active_at === null || typeof item.last_active_at === \"string\",\n    );\n    // Robust check for sensitive field absence\n    TestValidator.predicate(\n      \"password_hash not present on item\",\n      Object.prototype.hasOwnProperty.call(item, \"password_hash\") === false,\n    );\n  }\n\n  // 4) Filter by is_super = true\n  const pageSuper: IPageITodoAppAdmin.ISummary =\n    await api.functional.todoApp.admin.admins.index(connection, {\n      body: {\n        page: 1,\n        pageSize: 10,\n        is_super: true,\n        sort_by: \"created_at\",\n        sort_order: \"desc\",\n      } satisfies ITodoAppAdmin.IRequest,\n    });\n  typia.assert(pageSuper);\n  TestValidator.predicate(\n    \"all returned items have is_super true\",\n    pageSuper.data.every((d) => d.is_super === true),\n  );\n\n  // 5) Pagination small pageSize (pageSize = 1)\n  const pageSingle: IPageITodoAppAdmin.ISummary =\n    await api.functional.todoApp.admin.admins.index(connection, {\n      body: {\n        page: 1,\n        pageSize: 1,\n        sort_by: \"created_at\",\n        sort_order: \"desc\",\n      } satisfies ITodoAppAdmin.IRequest,\n    });\n  typia.assert(pageSingle);\n  TestValidator.equals(\n    \"page limit should be 1\",\n    pageSingle.pagination.limit,\n    1,\n  );\n\n  // 6) Sorting behaviour: validate created_at ordering explicitly\n  // Descending list (pageAll) -> ensure each created_at is >= next created_at\n  if (pageAll.data.length >= 2) {\n    for (let i = 0; i < pageAll.data.length - 1; ++i) {\n      const cur = Date.parse(pageAll.data[i].created_at!);\n      const next = Date.parse(pageAll.data[i + 1].created_at!);\n      TestValidator.predicate(\"created_at desc ordering\", cur >= next);\n    }\n  }\n\n  // Ascending\n  const pageAsc: IPageITodoAppAdmin.ISummary =\n    await api.functional.todoApp.admin.admins.index(connection, {\n      body: {\n        page: 1,\n        pageSize: 10,\n        sort_by: \"created_at\",\n        sort_order: \"asc\",\n      } satisfies ITodoAppAdmin.IRequest,\n    });\n  typia.assert(pageAsc);\n  if (pageAsc.data.length >= 2) {\n    for (let i = 0; i < pageAsc.data.length - 1; ++i) {\n      const cur = Date.parse(pageAsc.data[i].created_at!);\n      const next = Date.parse(pageAsc.data[i + 1].created_at!);\n      TestValidator.predicate(\"created_at asc ordering\", cur <= next);\n    }\n  }\n\n  // 7) Invalid request: page = 0 should lead to 400\n  await TestValidator.httpError(\n    \"invalid pagination should return 400\",\n    400,\n    async () =>\n      await api.functional.todoApp.admin.admins.index(connection, {\n        body: {\n          page: 0,\n          pageSize: 10,\n        } satisfies ITodoAppAdmin.IRequest,\n      }),\n  );\n\n  // 8) Unauthenticated call should return 401 or 403\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n  await TestValidator.httpError(\n    \"unauthenticated admin access should be rejected\",\n    [401, 403],\n    async () =>\n      await api.functional.todoApp.admin.admins.index(unauthConn, {\n        body: {\n          page: 1,\n          pageSize: 10,\n        } satisfies ITodoAppAdmin.IRequest,\n      }),\n  );\n\n  // 9) Rate-limit best-effort test: attempt many concurrent calls and expect 429\n  // Note: This is best-effort; if server does not enforce 429 the test will fail accordingly.\n  await TestValidator.httpError(\n    \"heavy concurrent requests may trigger 429\",\n    429,\n    async () => {\n      await Promise.all(\n        ArrayUtil.repeat(20, () =>\n          api.functional.todoApp.admin.admins.index(connection, {\n            body: {\n              page: 1,\n              pageSize: 10,\n            } satisfies ITodoAppAdmin.IRequest,\n          }),\n        ),\n      );\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/admins","method":"patch"},"draft":"Test that unauthenticated requests to the admin listing endpoint are rejected.\n\nSteps:\n1) Call PATCH /todoApp/admin/admins without Authorization header using a valid request body for pagination and sorting.\n2) Assert expected failure HTTP status (401 or 403 per API design) and machine-readable error code indicating authentication/authorization failure.\n3) Verify response does not leak admin data or sensitive fields.\n\nExpected outcome: request is rejected with appropriate auth error code and message.","functionName":"test_api_admin_admins_search_unauthenticated","dependencies":[]},"location":"test/features/api/admin/test_api_admin_admins_search_unauthenticated.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppAdmin\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\nexport async function test_api_admin_admins_search_unauthenticated(\n  connection: api.IConnection,\n) {\n  // Purpose: Verify that unauthenticated requests to PATCH /todoApp/admin/admins are rejected\n  // and that error responses do not leak sensitive admin data.\n\n  // 1) Prepare a minimal, valid request body according to ITodoAppAdmin.IRequest\n  const requestBody = {\n    page: 1,\n    pageSize: 10,\n  } satisfies ITodoAppAdmin.IRequest;\n\n  // 2) Create an unauthenticated connection by cloning the provided connection\n  //    and providing an empty headers object. Do NOT mutate the original connection.headers.\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n\n  // 3) Attempt the request and assert that it fails with 401 or 403 (unauthorized/forbidden)\n  //    Capture the thrown error so we can perform an additional defensive check\n  //    that the error message does not contain sensitive fields.\n  let capturedError: unknown = undefined;\n\n  await TestValidator.httpError(\n    \"unauthenticated request should be rejected\",\n    [401, 403],\n    async () => {\n      try {\n        await api.functional.todoApp.admin.admins.index(unauthConn, {\n          body: requestBody,\n        });\n      } catch (exp) {\n        capturedError = exp;\n        // rethrow so TestValidator.httpError can validate the HTTP status\n        throw exp;\n      }\n    },\n  );\n\n  // 4) Defensive check: if the caught error exposes structured JSON, ensure\n  //    it does not leak sensitive admin fields such as password or password_hash.\n  //    This check is cautious: only run if toJSON() exists and returns a message.\n  if (capturedError && typeof (capturedError as any).toJSON === \"function\") {\n    try {\n      const json = (capturedError as any).toJSON();\n      const message = String(json?.message ?? \"\").toLowerCase();\n\n      TestValidator.predicate(\n        \"error message should not contain sensitive fields\",\n        !message.includes(\"password\") && !message.includes(\"password_hash\"),\n      );\n    } catch {\n      // If parsing the error fails for any reason, do not fail the test because\n      // the primary assertion (http error) already validated the auth enforcement.\n    }\n  }\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/admins/{adminId}","method":"get"},"draft":"Test retrieving a single admin's safe profile by id with proper admin authentication.\n\nSteps:\n1) Test setup: Create the caller admin via POST /auth/admin/join and extract caller access token. Create a separate target admin via POST /auth/admin/join (or use the created account's id if acceptable) to serve as the retrieval target; record its returned id (adminId). Note: use unique emails for each join invocation.\n2) Call GET /todoApp/admin/admins/{adminId} with Authorization: Bearer <callerAccessToken>.\n3) Assert 200 OK and that the response contains only the safe admin fields: id (UUID equals requested adminId), email (string), is_super (boolean), created_at (ISO 8601), last_active_at (nullable ISO 8601).\n4) Assert that sensitive fields such as password_hash are NOT present.\n5) (Optional) Verify that access is audited by the system if auditing is observable in the environment.\n\nExpected outcomes: 200 OK with redacted admin representation; sensitive fields omitted; permission semantics enforced for unauthorized callers in negative tests.","functionName":"test_api_admin_admin_retrieve_by_id","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create an admin account to authenticate as the calling admin and to create any target admin test data. Use unique emails for multiple invocations during setup."}]},"location":"test/features/api/admin/test_api_admin_admin_retrieve_by_id.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\n/* Finalized test implementation with suggested fixes applied */\n/**\n * E2E test for retrieving an admin's safe profile by id.\n *\n * Steps:\n *\n * 1. Create a caller admin (auth) via POST /auth/admin/join (callerConn).\n * 2. Create a separate target admin via POST /auth/admin/join (targetConn) and\n *    record its id.\n * 3. Call GET /todoApp/admin/admins/{adminId} using callerConn (authenticated as\n *    caller).\n * 4. Assert the returned representation matches ITodoAppAdmin and contains only\n *    safe fields.\n * 5. Negative tests: unauthenticated access should fail; malformed UUID should\n *    fail.\n */\nexport async function test_api_admin_admin_retrieve_by_id(\n  connection: api.IConnection,\n) {\n  // 1. Create caller admin on its own connection to retain its token locally\n  const callerConn: api.IConnection = { ...connection, headers: {} };\n  const callerEmail = typia.random<string & tags.Format<\"email\">>();\n  const callerPassword = `P@ss-${RandomGenerator.alphaNumeric(8)}`;\n\n  const caller: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(callerConn, {\n      body: {\n        email: callerEmail,\n        password: callerPassword,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(caller);\n\n  // 2. Create target admin on its own connection (so its token doesn't overwrite callerConn)\n  const targetConn: api.IConnection = { ...connection, headers: {} };\n  const targetEmail = typia.random<string & tags.Format<\"email\">>();\n  const targetPassword = `P@ss-${RandomGenerator.alphaNumeric(8)}`;\n\n  const target: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(targetConn, {\n      body: {\n        email: targetEmail,\n        password: targetPassword,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(target);\n\n  // 3. Retrieve the target admin using the caller's connection (callerConn holds caller's token)\n  const retrieved: ITodoAppAdmin = await api.functional.todoApp.admin.admins.at(\n    callerConn,\n    {\n      adminId: target.id,\n    },\n  );\n  typia.assert(retrieved);\n\n  // 4. Business assertions\n  TestValidator.equals(\n    \"retrieved admin id matches requested id\",\n    retrieved.id,\n    target.id,\n  );\n  TestValidator.equals(\n    \"retrieved admin email matches target email\",\n    retrieved.email,\n    target.email,\n  );\n  TestValidator.predicate(\n    \"is_super is boolean\",\n    typeof retrieved.is_super === \"boolean\",\n  );\n  TestValidator.predicate(\n    \"created_at exists and is string\",\n    typeof retrieved.created_at === \"string\" && retrieved.created_at.length > 0,\n  );\n  TestValidator.predicate(\n    \"last_active_at is nullable or ISO string\",\n    retrieved.last_active_at === null ||\n      typeof retrieved.last_active_at === \"string\",\n  );\n  // Sensitive fields must not be present on the safe DTO\n  TestValidator.predicate(\n    \"sensitive field password_hash is omitted\",\n    !Object.prototype.hasOwnProperty.call(retrieved, \"password_hash\"),\n  );\n\n  // 5. Negative tests: unauthenticated access should fail\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n  await TestValidator.error(\n    \"unauthenticated access should be rejected\",\n    async () => {\n      await api.functional.todoApp.admin.admins.at(unauthConn, {\n        adminId: target.id,\n      });\n    },\n  );\n\n  // 6. Negative test: malformed UUID should produce an error (bad request)\n  await TestValidator.error(\"malformed UUID should cause error\", async () => {\n    // pass an obviously invalid UUID string (no type-bypass used)\n    await api.functional.todoApp.admin.admins.at(callerConn, {\n      adminId: \"not-a-valid-uuid\",\n    } as any);\n  });\n}\n"},{"scenario":{"endpoint":{"path":"/auth/admin/refresh","method":"post"},"draft":"Purpose: Verify that an admin can exchange a valid refresh credential for a new access token and that the server updates last_active_at for the admin.\n\nSteps:\n1. Create a new admin account (POST /auth/admin/join) to obtain initial authorized response containing accessToken and refreshToken. Record admin id and refreshToken.\n2. Wait a short deterministic interval (or proceed immediately) and call POST /auth/admin/refresh with the obtained refreshToken in the request body.\n3. Assert HTTP 200 (or 201 per implementation) and that response contains a fresh access token (and optionally rotated refreshToken). Verify that returned token(s) have the expected shape (non-empty string, token format if known).\n4. Optionally verify that the new access token differs from the original access token received at join (if join returns accessToken) to confirm rotation.\n5. If API provides last_active_at in the admin record or in the authorized response, assert last_active_at is present and parsable as ISO 8601. If possible, verify last_active_at was advanced compared to the value returned at join.\n\nValidation points / expected outcomes:\n- The refresh call returns success with a renewed access token and HTTP status in the 2xx range (prefer 200 with body).\n- Response body contains an access token string and (optionally) a new refresh token.\n- Token strings are non-empty; if JWT structure is expected, tokens parseable as dot-delimited strings.\n- Server updates last_active_at (if surfaced) to a timestamp >= previous last_active_at.\n\nDependencies (ordered):\n- POST /auth/admin/join (Create an admin and obtain initial refresh token to exercise refresh flow.)","functionName":"test_api_admin_refresh_success","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Create an admin account and obtain initial authorized response (access + refresh tokens) for the refresh token exchange."}]},"location":"test/features/api/auth/test_api_admin_refresh_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\n/**\n * Test: Admin refresh token exchange\n *\n * Purpose: Verifies that an admin created via POST /auth/admin/join receives a\n * valid authorization payload (IAuthorizationToken) and that POST\n * /auth/admin/refresh accepts the issued refresh token to return a new\n * authorized payload. The test asserts token presence, optional rotation of the\n * access token, ID consistency, and advancement of last_active_at when\n * available.\n *\n * Steps:\n *\n * 1. Create a new admin via api.functional.auth.admin.join\n * 2. Extract access and refresh tokens from the join response\n * 3. Call api.functional.auth.admin.refresh with the refresh token\n * 4. Assert the refreshed authorized payload is valid and consistent\n */\nexport async function test_api_admin_refresh_success(\n  connection: api.IConnection,\n) {\n  // 1) Create an admin account (join)\n  const adminEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword: string = RandomGenerator.alphaNumeric(12);\n\n  const joinBody = {\n    email: adminEmail,\n    password: adminPassword,\n    is_super: false,\n  } satisfies ITodoAppAdmin.ICreate;\n\n  const authorized: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, { body: joinBody });\n  typia.assert(authorized);\n\n  // Basic sanity checks for returned tokens\n  const initialAccess: string = authorized.token.access;\n  const initialRefresh: string = authorized.token.refresh;\n\n  TestValidator.predicate(\n    \"join: access token is present\",\n    typeof initialAccess === \"string\" && initialAccess.length > 0,\n  );\n  TestValidator.predicate(\n    \"join: refresh token is present\",\n    typeof initialRefresh === \"string\" && initialRefresh.length > 0,\n  );\n\n  // Preserve previous last_active_at for comparison (may be null/undefined)\n  const prevLastActive: string | null | undefined = authorized.last_active_at;\n\n  // 2) Exchange refresh token for a new authorized payload\n  const refreshBody = {\n    refresh_token: initialRefresh,\n  } satisfies ITodoAppAdmin.IRefresh;\n\n  const refreshed: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.refresh(connection, { body: refreshBody });\n  typia.assert(refreshed);\n\n  // 3) Business validations\n  // Admin identity must remain the same\n  TestValidator.equals(\n    \"admin id remains unchanged\",\n    refreshed.id,\n    authorized.id,\n  );\n\n  // New access token must be present\n  TestValidator.predicate(\n    \"refresh: new access token present\",\n    typeof refreshed.token.access === \"string\" &&\n      refreshed.token.access.length > 0,\n  );\n\n  // If server rotates tokens, the new access token should usually differ.\n  // We assert inequality as a positive sign of rotation but do not fail the\n  // test if implementation chooses not to rotate (some systems reuse tokens).\n  TestValidator.predicate(\n    \"access token rotation (refreshed differs from initial)\",\n    refreshed.token.access !== initialAccess,\n  );\n\n  // Check token looks like a JWT (dot-delimited) or at least non-empty\n  TestValidator.predicate(\n    \"access token shape looks like JWT or non-empty\",\n    typeof refreshed.token.access === \"string\" &&\n      refreshed.token.access.split(\".\").length >= 2,\n  );\n\n  // 4) last_active_at handling: if previous existed, refreshed should be >= prev\n  if (prevLastActive !== null && prevLastActive !== undefined) {\n    // Both values should be parseable as date-time strings\n    TestValidator.predicate(\n      \"prev last_active_at parseable\",\n      !Number.isNaN(Date.parse(prevLastActive)),\n    );\n\n    TestValidator.predicate(\n      \"refreshed last_active_at present and parseable\",\n      refreshed.last_active_at !== null &&\n        refreshed.last_active_at !== undefined &&\n        !Number.isNaN(Date.parse(refreshed.last_active_at)),\n    );\n\n    const prevMillis = Date.parse(prevLastActive);\n    const currMillis = Date.parse(refreshed.last_active_at!);\n\n    TestValidator.predicate(\n      \"last_active_at was advanced or equal\",\n      currMillis >= prevMillis,\n    );\n  } else {\n    // If there was no previous last_active_at, ensure refreshed provides one\n    TestValidator.predicate(\n      \"refreshed last_active_at present when previous missing\",\n      refreshed.last_active_at !== null &&\n        refreshed.last_active_at !== undefined &&\n        !Number.isNaN(Date.parse(refreshed.last_active_at)),\n    );\n  }\n}\n"},{"scenario":{"endpoint":{"path":"/auth/admin/refresh","method":"post"},"draft":"Purpose: Verify the refresh endpoint rejects invalid or tampered refresh credentials and returns appropriate error responses.\n\nSteps:\n1. Create a new admin account (POST /auth/admin/join) to obtain a valid refresh token.\n2. Tamper the refresh token (e.g., change a character or truncate) to create an invalid refresh credential.\n3. Call POST /auth/admin/refresh with the tampered refresh token.\n4. Assert the server returns a 4xx error (expected 400 or 401) and includes an error code/message indicating invalid refresh credential.\n5. Confirm that no new access token is returned and that the server does not disclose sensitive information.\n\nValidation points / expected outcomes:\n- The refresh attempt with an invalid refresh credential returns an error (400 or 401). Prefer asserting 401 Unauthorized if tokens are invalid.\n- Response body contains a machine-readable error code or message explaining the failure (e.g., 'invalid_refresh_token').\n- No access token or refresh token is returned in the error response.\n\nDependencies (ordered):\n- POST /auth/admin/join (Create an admin and obtain a valid refresh token which will be tampered for the negative test.)","functionName":"test_api_admin_refresh_invalid_refresh_token","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Create an admin account and obtain a valid refresh token to tamper with for negative refresh tests."}]},"location":"test/features/api/auth/test_api_admin_refresh_invalid_refresh_token.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\nexport async function test_api_admin_refresh_invalid_refresh_token(\n  connection: api.IConnection,\n) {\n  /**\n   * Purpose: Verify that the admin token refresh endpoint rejects\n   * tampered/invalid refresh tokens and does not return a new access token.\n   *\n   * Steps:\n   *\n   * 1. Create a new admin account via POST /auth/admin/join to obtain a valid\n   *    authorized response containing an access and refresh token.\n   * 2. Tamper the returned refresh token (flip or change a character).\n   * 3. Call POST /auth/admin/refresh with the tampered token and assert the server\n   *    returns a client error (400 or 401).\n   */\n\n  // 1. Create admin account\n  const adminCreate = {\n    email:\n      RandomGenerator.name(1).replace(/\\s+/g, \"\") +\n      \".\" +\n      RandomGenerator.alphaNumeric(4) +\n      \"@example.com\",\n    password: \"P@ssw0rd!\",\n    is_super: false,\n  } satisfies ITodoAppAdmin.ICreate;\n\n  const authorized: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: adminCreate,\n    });\n  // Validate shape and extract token\n  typia.assert(authorized);\n  typia.assert(authorized.token);\n\n  const validRefresh: string = authorized.token.refresh;\n\n  // 2. Tamper the refresh token deterministically\n  let tamperedRefresh: string;\n  if (validRefresh.length >= 2) {\n    // Flip the last character to another ASCII character (not same)\n    const last = validRefresh.charAt(validRefresh.length - 1);\n    const replacement = last === \"a\" ? \"b\" : \"a\";\n    tamperedRefresh = validRefresh.slice(0, -1) + replacement;\n  } else {\n    // Append a character to make it invalid\n    tamperedRefresh = validRefresh + \"x\";\n  }\n\n  // 3. Attempt refresh with the tampered token and expect client error (400 or 401)\n  await TestValidator.httpError(\n    \"invalid refresh should be rejected\",\n    [400, 401],\n    async () => {\n      await api.functional.auth.admin.refresh(connection, {\n        body: {\n          refresh_token: tamperedRefresh,\n        } satisfies ITodoAppAdmin.IRefresh,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/admin/password/reset","method":"post"},"draft":"Purpose: Ensure initiating an admin password reset for an existing admin returns a generic success response and (optionally) creates an audit record. Validate that the endpoint does not disclose account existence in the response body.\n\nSteps:\n1. Create a new admin account (POST /auth/admin/join) using a test email address under control; record the admin id and email.\n2. Call POST /auth/admin/password/reset with the created admin's email in the request body to initiate the reset flow.\n3. Assert the response returns a generic success (HTTP 200 or 204 or 202 depending on implementation) and the body does NOT reveal whether the account existed (i.e., consistent success message for both existent and non-existent emails).\n4. (Optional verification) If audit search is available and the test harness can perform admin-scoped queries, search audit records for an entry with action_type 'request_password_reset' and target_id equal to the admin id. This requires admin-level auth to query audit records; perform this only if such query capability is available in the test environment.\n\nValidation points / expected outcomes:\n- Password reset initiation returns a non-error status (2xx) with a generic message that does not disclose account existence.\n- If audit inspection is possible, an audit record with action_type 'request_password_reset' referencing the admin id exists and was created at approximately the same time as the request.\n- No reset tokens are returned in the API response.\n\nDependencies (ordered):\n- POST /auth/admin/join (Create the admin account whose email will be used to initiate the reset.)","functionName":"test_api_admin_request_password_reset_existing_email_creates_audit","dependencies":[{"endpoint":{"path":"/auth/admin/join","method":"post"},"purpose":"Create an admin account for which the password reset will be initiated, ensuring a known target exists for audit verification."}]},"location":"test/features/api/admin/test_api_admin_request_password_reset_existing_email_creates_audit.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\n/**\n * Verify that requesting an admin password reset for an existing admin returns\n * a generic success message and does not disclose account existence or return\n * reset tokens in the API response.\n *\n * Steps:\n *\n * 1. Create an admin account via POST /auth/admin/join\n * 2. Initiate password reset via POST /auth/admin/password/reset with the created\n *    admin's email\n * 3. Assert the response is a generic success IMessage and does not include\n *    sensitive details such as the admin's email or a token\n *\n * Notes:\n *\n * - The test uses `satisfies` for request bodies and `typia.assert()` to validate\n *   response DTOs.\n * - Audit verification is not performed because no audit-read API was provided in\n *   the SDK. If available in the test environment, an additional audit query\n *   should assert an audit record with action_type 'request_password_reset' and\n *   target_id equal to the created admin id.\n */\nexport async function test_api_admin_request_password_reset_existing_email_creates_audit(\n  connection: api.IConnection,\n) {\n  // 1) Prepare test data\n  const adminEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword: string = RandomGenerator.alphaNumeric(12);\n\n  // 2) Create the admin account\n  const createdAdmin: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: {\n        email: adminEmail,\n        password: adminPassword,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  // Validate the created admin DTO\n  typia.assert(createdAdmin);\n\n  // Basic sanity checks on returned admin\n  TestValidator.predicate(\n    \"created admin has id\",\n    typeof createdAdmin.id === \"string\" && createdAdmin.id.length > 0,\n  );\n  TestValidator.equals(\n    \"created admin email matches input\",\n    createdAdmin.email,\n    adminEmail,\n  );\n\n  // 3) Initiate password reset for the created admin\n  const resetResponse: ITodoAppAdmin.IMessage =\n    await api.functional.auth.admin.password.reset.requestPasswordReset(\n      connection,\n      {\n        body: {\n          email: adminEmail,\n        } satisfies ITodoAppAdmin.IRequestPasswordReset,\n      },\n    );\n\n  // Validate response DTO shape\n  typia.assert(resetResponse);\n\n  // 4) Business assertions\n  TestValidator.predicate(\n    \"reset response contains a non-empty message\",\n    typeof resetResponse.message === \"string\" &&\n      resetResponse.message.length > 0,\n  );\n\n  TestValidator.predicate(\n    \"reset response does not disclose the admin email\",\n    !resetResponse.message.includes(adminEmail),\n  );\n\n  TestValidator.predicate(\n    \"reset response does not include token-like text\",\n    !/token/i.test(resetResponse.message),\n  );\n\n  // Optional: If audit-read endpoints become available in the test\n  // environment, query them (as an admin) and assert an audit record exists:\n  // - action_type: 'request_password_reset'\n  // - target_id: createdAdmin.id\n  // Do NOT attempt to call any audit API here because it is not present in the\n  // provided SDK. Add audit verification when such an endpoint is available.\n}\n"},{"scenario":{"endpoint":{"path":"/auth/admin/password/reset","method":"post"},"draft":"Purpose: Validate that initiating a password reset for an email that does not exist in the system returns a generic success response and does not leak account existence information.\n\nSteps:\n1. Choose an email address that is not associated with any admin (e.g., a random UUID-based email or a clearly unused test address).\n2. Call POST /auth/admin/password/reset with that email in the request body.\n3. Assert the server returns a generic success response (HTTP 200/202/204) and the response body does not indicate whether the account exists.\n4. Optionally, if audit records are available, assert that no audit record reveals sensitive info about non-existent accounts (the server may still log an attempt but should not leak account existence to API consumers).\n\nValidation points / expected outcomes:\n- The endpoint returns a 2xx success response with a generic message for both existent and non-existent emails.\n- No reset token is returned in the response.\n- No user-enumeration details are leaked in error messages.\n\nDependencies (ordered):\n- (none) This test intentionally does not create accounts so it verifies the generic success behavior for unknown emails.","functionName":"test_api_admin_request_password_reset_nonexistent_email_returns_generic_success","dependencies":[]},"location":"test/features/api/auth_admin/test_api_admin_request_password_reset_nonexistent_email_returns_generic_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\nexport async function test_api_admin_request_password_reset_nonexistent_email_returns_generic_success(\n  connection: api.IConnection,\n) {\n  // 1. Generate a highly unlikely-to-exist email address (UUID local part)\n  const nonExistentEmail: string = `${typia.random<string & tags.Format<\"uuid\">>()}@example.com`;\n\n  // 2. Call the password reset endpoint with the generated email\n  const response: ITodoAppAdmin.IMessage =\n    await api.functional.auth.admin.password.reset.requestPasswordReset(\n      connection,\n      {\n        body: {\n          email: nonExistentEmail,\n        } satisfies ITodoAppAdmin.IRequestPasswordReset,\n      },\n    );\n\n  // 3. Ensure the response matches the declared DTO\n  typia.assert(response);\n\n  // 4. Business-level assertions\n  TestValidator.predicate(\n    \"response contains a human-readable message\",\n    typeof response.message === \"string\" && response.message.length > 0,\n  );\n\n  TestValidator.predicate(\n    \"message does not reveal account existence\",\n    !/(does not exist|not found|no account|unknown user|user not found)/i.test(\n      response.message,\n    ),\n  );\n\n  TestValidator.predicate(\n    \"message does not contain tokens or URLs\",\n    !/token|reset|https?:\\/\\//i.test(response.message),\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/admins/{adminId}","method":"put"},"draft":"Successful admin update by a super-admin: verifies that a super-admin can modify non-sensitive fields (email, last_active_at, display_name) on another admin account.\n\nSteps:\n1) Create and authenticate a super-admin via POST /auth/admin/join and capture its access token (caller).  \n2) Create a separate target admin account via POST /auth/admin/join and record its returned adminId (target).  \n3) As the super-admin, call PUT /todoApp/admin/admins/{adminId} changing the target admin's email and last_active_at. Include Authorization: Bearer <super-admin-token>.  \n4) Assert HTTP 200.  \n5) Validate response body: id equals target adminId, email updated to new value, is_super unchanged unless explicitly requested, and updated_at >= created_at.  \n6) Verify server-side audit side-effect exists (audit record with action_type='update_admin', actor_role='admin', target_id=adminId) where possible.\n\nExpected outcomes: 200 OK and persisted non-sensitive updates. Audit record created.","functionName":"test_api_admin_update_profile_by_super_admin","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create and authenticate the super-admin (caller) to obtain an access token for privileged operations."},{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create the target admin account to be updated (returns target adminId)."}]},"location":"test/features/api/admin/test_api_admin_update_profile_by_super_admin.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\nexport async function test_api_admin_update_profile_by_super_admin(\n  connection: api.IConnection,\n) {\n  // Purpose: Ensure a super-admin can update another admin's non-sensitive fields\n  // Strategy:\n  // 1) Create a super-admin using a dedicated connection (so its token is isolated)\n  // 2) Create a target admin using another dedicated connection\n  // 3) Use the super-admin connection (with its Authorization set by join) to call update\n  // 4) Validate returned summary for persisted changes and timestamp coherence\n\n  // Use dedicated connection copies so join() will set Authorization on them\n  const superConn: api.IConnection = { ...connection, headers: {} };\n  const targetConn: api.IConnection = { ...connection, headers: {} };\n\n  // 1) Create super-admin\n  const superEmail = typia.random<string & tags.Format<\"email\">>();\n  const superAdmin: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(superConn, {\n      body: {\n        email: superEmail,\n        password: \"SuperSecret123!\",\n        is_super: true,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(superAdmin);\n\n  // 2) Create target admin account\n  const targetEmail = typia.random<string & tags.Format<\"email\">>();\n  const targetAdmin: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(targetConn, {\n      body: {\n        email: targetEmail,\n        password: \"TargetPass123!\",\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(targetAdmin);\n  const targetId = targetAdmin.id;\n\n  // 3) Prepare update payload: change email and last_active_at\n  const newEmail = typia.random<string & tags.Format<\"email\">>();\n  const newLastActive = new Date().toISOString();\n\n  // 4) Call update as super-admin\n  const updated: ITodoAppAdmin.ISummary =\n    await api.functional.todoApp.admin.admins.update(superConn, {\n      adminId: targetId,\n      body: {\n        email: newEmail,\n        last_active_at: newLastActive,\n      } satisfies ITodoAppAdmin.IUpdate,\n    });\n  typia.assert(updated);\n\n  // 5) Assertions\n  TestValidator.equals(\"updated admin id matches target\", updated.id, targetId);\n  TestValidator.equals(\n    \"updated admin email persisted\",\n    updated.email,\n    newEmail,\n  );\n  TestValidator.equals(\n    \"is_super unchanged\",\n    updated.is_super,\n    targetAdmin.is_super,\n  );\n\n  // Ensure last_active_at was set and is chronologically >= created_at\n  TestValidator.predicate(\n    \"last_active_at exists\",\n    updated.last_active_at !== null && updated.last_active_at !== undefined,\n  );\n\n  TestValidator.predicate(\n    \"last_active_at is >= created_at\",\n    Date.parse(updated.last_active_at ?? \"\") >= Date.parse(updated.created_at),\n  );\n\n  // Audit verification omitted: no audit-listing API provided in SDK materials.\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/admins/{adminId}","method":"put"},"draft":"Forbidden update attempt: non-super admin attempts to change the is_super flag on another admin and should be rejected.\n\nSteps:\n1) Create and authenticate a non-super admin via POST /auth/admin/join and capture its token (caller).  \n2) Create a separate target admin via POST /auth/admin/join and record its adminId (target).  \n3) As the non-super admin, call PUT /todoApp/admin/admins/{adminId} attempting to set is_super=true with Authorization: Bearer <non-super-token>.  \n4) Assert HTTP 403 Forbidden and a machine-readable error code indicating insufficient privileges.  \n5) Verify the target admin's is_super value is unchanged (via GET if available).  \n6) Confirm no audit record exists indicating a successful change; if an audit record exists it should indicate a denied attempt.\n\nExpected outcomes: 403 Forbidden and no change to is_super.","functionName":"test_api_admin_update_is_super_by_non_super_admin_forbidden","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create and authenticate the non-super admin (caller) to obtain its access token for the negative test."},{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create the target admin account that the non-super admin will attempt to modify (returns target adminId)."}]},"location":"test/features/api/admin/test_api_admin_update_is_super_by_non_super_admin_forbidden.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\n/**\n * Validate that a non-super admin cannot promote another admin to super.\n *\n * Business rationale:\n *\n * - Promotion to super-admin is a privileged operation. The test verifies that a\n *   non-super admin cannot perform the promotion and that a true super-admin\n *   can perform it (proving the operation is privilege-guarded).\n *\n * Steps:\n *\n * 1. Create a non-super admin (the caller) using POST /auth/admin/join. The SDK\n *    will populate connection.headers.Authorization for subsequent calls.\n * 2. Create a target admin using an unauthenticated connection clone so the main\n *    connection's Authorization token is not overwritten.\n * 3. Create a super-admin using another unauthenticated connection clone.\n * 4. As the non-super admin, attempt to update the target's is_super flag; expect\n *    an error (operation rejected).\n * 5. As the super-admin, perform the same update; expect success and verify the\n *    returned summary indicates is_super === true.\n */\nexport async function test_api_admin_update_is_super_by_non_super_admin_forbidden(\n  connection: api.IConnection,\n) {\n  // 1) Create a non-super admin (caller) -> this will populate connection.headers.Authorization\n  const nonSuperEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const nonSuper: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: {\n        email: nonSuperEmail,\n        password: RandomGenerator.alphaNumeric(12),\n        is_super: false,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(nonSuper);\n\n  // 2) Create the target admin using an unauthenticated connection clone\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n  const targetEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const target: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(unauthConn, {\n      body: {\n        email: targetEmail,\n        password: RandomGenerator.alphaNumeric(12),\n        is_super: false,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(target);\n\n  // 3) Create a super-admin using another unauthenticated connection clone\n  const superConn: api.IConnection = { ...connection, headers: {} };\n  const superEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const superAdmin: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(superConn, {\n      body: {\n        email: superEmail,\n        password: RandomGenerator.alphaNumeric(12),\n        is_super: true,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(superAdmin);\n\n  // 4) As non-super admin (connection has nonSuper token), attempt to set is_super=true -> expect error\n  await TestValidator.error(\n    \"non-super admin cannot promote another admin to super\",\n    async () => {\n      await api.functional.todoApp.admin.admins.update(connection, {\n        adminId: target.id,\n        body: {\n          is_super: true,\n        } satisfies ITodoAppAdmin.IUpdate,\n      });\n    },\n  );\n\n  // 5) As super-admin, perform the same update and expect success\n  const updated: ITodoAppAdmin.ISummary =\n    await api.functional.todoApp.admin.admins.update(superConn, {\n      adminId: target.id,\n      body: {\n        is_super: true,\n      } satisfies ITodoAppAdmin.IUpdate,\n    });\n  typia.assert(updated);\n  TestValidator.equals(\n    \"super-admin can promote target to is_super\",\n    updated.is_super,\n    true,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/admins/{adminId}","method":"put"},"draft":"Not-found update: authenticated super-admin attempts to update an adminId that does not exist.\n\nSteps:\n1) Create and authenticate a super-admin via POST /auth/admin/join and capture its token.  \n2) Choose a syntactically valid UUID that is not present in the system (do not create a target admin).  \n3) As the super-admin, call PUT /todoApp/admin/admins/{adminId} with the non-existent id and Authorization: Bearer <super-admin-token>.  \n4) Assert HTTP 404 Not Found and appropriate error code/message.  \n5) Verify no audit record indicates a successful update; audit entries (if any) should reflect failure.\n\nExpected outcomes: 404 Not Found and no side-effecting update.","functionName":"test_api_admin_update_not_found","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create and authenticate the super-admin (caller) to obtain an access token for the update attempt against a non-existent adminId."}]},"location":"test/features/api/admin/test_api_admin_update_not_found.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\n/**\n * Test: Admin update on non-existent admin should return error (no side effect)\n *\n * Business context: An authenticated super-admin attempts to update an admin\n * record identified by a syntactically valid but non-existent UUID. The backend\n * should respond with a not-found error and must not produce a successful\n * update side-effect.\n *\n * Steps:\n *\n * 1. Create a super-admin using POST /auth/admin/join (ITodoAppAdmin.ICreate).\n * 2. Generate a valid UUID that does not correspond to any existing admin.\n * 3. Attempt to update that non-existent admin via PUT\n *    /todoApp/admin/admins/:adminId using ITodoAppAdmin.IUpdate body and assert\n *    that the call throws.\n *\n * Notes:\n *\n * - The SDK's join() populates connection.headers.Authorization automatically on\n *   success. Do NOT read or modify connection.headers directly.\n * - No audit-listing endpoint is available in the provided SDK; therefore audit\n *   verification is not implementable here and is documented as a test\n *   limitation.\n */\nexport async function test_api_admin_update_not_found(\n  connection: api.IConnection,\n) {\n  // 1) Create super-admin (caller)\n  const adminEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const superAdmin: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: {\n        email: adminEmail,\n        password: \"P@ssw0rd123\",\n        is_super: true,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(superAdmin);\n\n  // Basic sanity check: ensure created account is super\n  TestValidator.predicate(\n    \"created account is super-admin\",\n    superAdmin.is_super === true,\n  );\n\n  // 2) Choose a syntactically valid UUID that is not present in the system\n  const nonExistentAdminId: string = typia.random<\n    string & tags.Format<\"uuid\">\n  >();\n\n  // 3) As the super-admin, attempt to update the non-existent admin\n  // Because the callback is async, we MUST await TestValidator.error\n  await TestValidator.error(\n    \"updating non-existent admin should fail\",\n    async () => {\n      await api.functional.todoApp.admin.admins.update(connection, {\n        adminId: nonExistentAdminId,\n        body: {\n          email: typia.random<string & tags.Format<\"email\">>(),\n        } satisfies ITodoAppAdmin.IUpdate,\n      });\n    },\n  );\n\n  // 4) Note: No audit verification is performed because the SDK does not\n  // provide an audit listing endpoint. If such an endpoint existed, the test\n  // would assert that no successful-update audit record exists for\n  // nonExistentAdminId.\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/admins/{adminId}","method":"delete"},"draft":"Successful admin erase by super-admin: a super-admin permanently removes another admin.\n\nSteps:\n1) Create and authenticate a super-admin via POST /auth/admin/join and capture its token (caller).  \n2) Create a separate target admin via POST /auth/admin/join and capture its adminId (target).  \n3) As the super-admin, call DELETE /todoApp/admin/admins/{adminId} on the target with Authorization: Bearer <super-admin-token>.  \n4) Assert HTTP 204 No Content.  \n5) Subsequent GET /todoApp/admin/admins/{adminId} should return 404.  \n6) Verify an audit record exists with action_type='erase_admin', actor_role='admin', target_id equal to the deleted adminId.\n\nExpected outcomes: 204 No Content, resource removed, and audit entry recorded.","functionName":"test_api_admin_erase_by_super_admin","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create and authenticate the super-admin (caller) to obtain an access token for privileged erase operations."},{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create the target admin account to be erased (returns target adminId)."}]},"location":"test/features/api/admin/test_api_admin_erase_by_super_admin.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\n/**\n * Validate that a super-admin can permanently erase another admin account.\n *\n * Business context:\n *\n * - Only super-admins may perform irreversible erase operations on administrative\n *   accounts. The SDK exposes account creation (join) and the erase operation.\n *   Because no GET or audit-listing SDK functions are available, this test\n *   confirms deletion by asserting that a subsequent erase attempt fails\n *   (resource not found).\n *\n * Steps:\n *\n * 1. Create a super-admin via POST /auth/admin/join (is_super: true).\n * 2. Create a target admin via POST /auth/admin/join (regular admin).\n * 3. As the super-admin, call DELETE /todoApp/admin/admins/{adminId} to erase the\n *    target admin. Expect success (no exception).\n * 4. Attempt to erase the same admin again and assert that the operation fails\n *    (throws), demonstrating the resource no longer exists.\n */\nexport async function test_api_admin_erase_by_super_admin(\n  connection: api.IConnection,\n) {\n  // Create isolated connection objects so join() will store tokens per-connection\n  const superConn: api.IConnection = { ...connection, headers: {} };\n  const targetConn: api.IConnection = { ...connection, headers: {} };\n\n  // 1) Create super-admin\n  const superEmail = `${RandomGenerator.alphaNumeric(8)}@example.com`;\n  const superPassword = \"P@ssw0rd!\";\n  const superAdmin: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(superConn, {\n      body: {\n        email: superEmail,\n        password: superPassword,\n        is_super: true,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  // Runtime type validation\n  typia.assert(superAdmin);\n\n  // 2) Create target admin (the one to be erased)\n  const targetEmail = `${RandomGenerator.alphaNumeric(8)}@example.com`;\n  const targetPassword = \"TargetP@ss1\";\n  const targetAdmin: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(targetConn, {\n      body: {\n        email: targetEmail,\n        password: targetPassword,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(targetAdmin);\n\n  // 3) As super-admin, erase the target admin\n  // Note: join() populated superConn.headers.Authorization with the access token\n  await api.functional.todoApp.admin.admins.erase(superConn, {\n    adminId: targetAdmin.id,\n  });\n\n  // 4) Verify that attempting to erase the same admin again fails\n  await TestValidator.error(\n    \"re-deleting the erased admin should fail\",\n    async () => {\n      await api.functional.todoApp.admin.admins.erase(superConn, {\n        adminId: targetAdmin.id,\n      });\n    },\n  );\n\n  // Additional sanity: ensure that the join responses contain token info\n  typia.assert<IAuthorizationToken>(superAdmin.token);\n  typia.assert<IAuthorizationToken>(targetAdmin.token);\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/admins/{adminId}","method":"delete"},"draft":"Self-delete prevention: super-admin attempts to erase their own account and operation is rejected to avoid accidental lockout.\n\nSteps:\n1) Create and authenticate a super-admin via POST /auth/admin/join and capture its token and adminId (caller == target).  \n2) As that same super-admin, call DELETE /todoApp/admin/admins/{adminId} using their own adminId with Authorization: Bearer <super-admin-token>.  \n3) Assert HTTP 409 Conflict (or policy-specific error) with a clear machine-readable reason preventing self-deletion.  \n4) Verify the admin still exists after the attempt (GET returns 200).  \n5) Confirm an audit record was created documenting the attempted self-deletion with action_type='erase_admin' and an explanatory reason field if available.\n\nExpected outcomes: 409 Conflict and account remains intact; audit record documents the attempt.","functionName":"test_api_admin_erase_self_delete_prevented","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create and authenticate the super-admin who will attempt to delete their own account (caller == target)."}]},"location":"test/features/api/admin/test_api_admin_erase_self_delete_prevented.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\n/**\n * Test: Prevent super-admin from erasing their own account.\n *\n * Business context:\n *\n * - Self-deletion of a super-admin can lock out administrators.\n * - Server policy must prevent an admin from deleting their own account and must\n *   return a policy error (409 Conflict) when such an attempt is made.\n *\n * Test steps:\n *\n * 1. Create a super-admin via POST /auth/admin/join (ITodoAppAdmin.ICreate).\n * 2. Attempt to DELETE /todoApp/admin/admins/{adminId} using the same admin's id.\n *    Expect 409 Conflict.\n * 3. As indirect verification (SDK lacks GET/admin and audit endpoints), try to\n *    create an admin with the same email and expect an error (duplicate email).\n *    This indicates the original account still exists.\n *\n * Notes:\n *\n * - The SDK provided does not expose GET admin or audit retrieval endpoints, so\n *   the test uses duplicate-join failure to infer the original account's\n *   continued existence. If GET/audit endpoints become available, add explicit\n *   assertions for those records.\n */\nexport async function test_api_admin_erase_self_delete_prevented(\n  connection: api.IConnection,\n) {\n  // 1) Create a super-admin account\n  const adminBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"P@ssw0rd!\",\n    is_super: true,\n  } satisfies ITodoAppAdmin.ICreate;\n\n  const created: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: adminBody,\n    });\n  // Runtime type validation\n  typia.assert(created);\n\n  // Sanity checks\n  TestValidator.equals(\n    \"created admin is_super flag matches request\",\n    created.is_super,\n    true,\n  );\n  TestValidator.equals(\n    \"created admin email matches request\",\n    created.email,\n    adminBody.email,\n  );\n\n  // 2) Attempt self-delete: should be prevented by policy (409 Conflict)\n  await TestValidator.httpError(\n    \"self-delete prevented - erase should return 409\",\n    409,\n    async () => {\n      await api.functional.todoApp.admin.admins.erase(connection, {\n        adminId: created.id,\n      });\n    },\n  );\n\n  // 3) Indirect verification: attempting to create the same admin again should fail\n  // If creation fails due to duplicate email, it indicates the original admin still exists.\n  await TestValidator.error(\n    \"duplicate admin email should be rejected\",\n    async () => {\n      await api.functional.auth.admin.join(connection, {\n        body: adminBody,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/admins/{adminId}","method":"delete"},"draft":"Forbidden erase by non-super admin: a non-super admin attempts to delete another admin and should be denied.\n\nSteps:\n1) Create and authenticate a non-super admin via POST /auth/admin/join and capture its token (caller).  \n2) Create a separate target admin via POST /auth/admin/join and capture its adminId (target).  \n3) As the non-super admin, call DELETE /todoApp/admin/admins/{adminId} on the target with Authorization: Bearer <non-super-token>.  \n4) Assert HTTP 403 Forbidden and a machine-readable error indicating insufficient privileges.  \n5) Verify the target admin still exists and no successful erase audit record was created.\n\nExpected outcomes: 403 Forbidden and no deletion performed.","functionName":"test_api_admin_erase_by_non_super_admin_forbidden","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create and authenticate the non-super admin (caller) to obtain its access token for the forbidden delete attempt."},{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create the target admin account that the non-super admin will attempt to erase (returns target adminId)."}]},"location":"test/features/api/admin/test_api_admin_erase_by_non_super_admin_forbidden.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\n/**\n * Forbidden erase by non-super admin\n *\n * This E2E test verifies that an administrator without super-admin privileges\n * cannot permanently remove another admin account. The test performs the\n * following steps:\n *\n * 1. Create a non-super admin (caller) using the provided `connection`. The SDK\n *    will attach the returned access token to the supplied connection\n *    automatically.\n * 2. Create a separate target admin using a fresh unauthenticated connection so\n *    that the `connection` remains authenticated as the caller.\n * 3. Attempt to DELETE the target admin as the non-super caller and assert that\n *    the operation fails (error thrown).\n * 4. Confirm the target remains by trying to create another admin with the same\n *    email and asserting that the join fails (duplicate email). This indirect\n *    check demonstrates that no deletion occurred.\n */\nexport async function test_api_admin_erase_by_non_super_admin_forbidden(\n  connection: api.IConnection,\n) {\n  // Prepare unique emails for each admin\n  const callerEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const targetEmail: string = typia.random<string & tags.Format<\"email\">>();\n\n  // 1) Create non-super admin (caller). The SDK sets connection.headers\n  //    Authorization to the returned access token automatically.\n  const caller: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: {\n        email: callerEmail,\n        password: \"P@ssw0rd!\",\n        is_super: false,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(caller);\n\n  TestValidator.predicate(\n    \"caller token is present\",\n    !!(caller.token && caller.token.access),\n  );\n\n  // 2) Create target admin using a fresh unauthenticated connection so that\n  //    the original `connection` remains authenticated as the caller.\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n  const target: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(unauthConn, {\n      body: {\n        email: targetEmail,\n        password: \"P@ssw0rd!\",\n        is_super: false,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(target);\n\n  // 3) As the non-super caller, attempt to erase the target admin. The call\n  //    should fail (forbidden). We assert that an error is thrown.\n  await TestValidator.error(\n    \"non-super admin cannot erase another admin\",\n    async () => {\n      await api.functional.todoApp.admin.admins.erase(connection, {\n        adminId: target.id,\n      });\n    },\n  );\n\n  // 4) Verify the target still exists by attempting to create another admin\n  //    with the same email. If the target remains, duplicate creation should\n  //    fail. Use a fresh unauthenticated connection for the duplicate check.\n  const unauthConn2: api.IConnection = { ...connection, headers: {} };\n  await TestValidator.error(\n    \"duplicate email should fail - target still exists\",\n    async () => {\n      await api.functional.auth.admin.join(unauthConn2, {\n        body: {\n          email: targetEmail,\n          password: \"P@ssw0rd!\",\n        } satisfies ITodoAppAdmin.ICreate,\n      });\n    },\n  );\n\n  // Sanity check: caller id remains present\n  TestValidator.predicate(\"caller id remains non-empty\", caller.id !== \"\");\n}\n"},{"scenario":{"endpoint":{"method":"put","path":"/auth/admin/password/change"},"draft":"Test admin password change success flow. Steps: 1) Create a fresh admin context by calling POST /auth/admin/join with unique admin credentials; assert 201 and extract issued access token and created_at. 2) Using the returned admin access token, call PUT /auth/admin/password/change with a valid payload containing the currentPassword (the original password used at join) and a newPassword. Expect 200 with a confirmation message and updated profile fields. 3) Verify response includes updated_at and that updated_at >= created_at from join. Validate no password hashes or secrets are echoed back. Success criteria: change operation returns success status and updated_at present and >= created_at.","functionName":"test_api_admin_change_password_success","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create admin account and obtain access token to authenticate the password change request"}]},"location":"test/features/api/admin/test_api_admin_change_password_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\nexport async function test_api_admin_change_password_success(\n  connection: api.IConnection,\n) {\n  // 1) Prepare unique admin credentials\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword = RandomGenerator.alphaNumeric(12); // >= 8 chars\n\n  // 2) Create admin account (join)\n  const authorized: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: {\n        email: adminEmail,\n        password: adminPassword,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  // Validate shape and important fields\n  typia.assert(authorized);\n  TestValidator.predicate(\n    \"created_at should be present\",\n    typeof authorized.created_at === \"string\" &&\n      authorized.created_at.length > 0,\n  );\n  TestValidator.predicate(\n    \"token.access should be present\",\n    typeof authorized.token.access === \"string\" &&\n      authorized.token.access.length > 0,\n  );\n\n  // Ensure that server did not echo any password fields\n  // (IAuthorized does not include password fields by design; check stringification as an extra guard)\n  TestValidator.predicate(\n    \"authorized response must not contain password or hash\",\n    !JSON.stringify(authorized).toLowerCase().includes(\"password\") &&\n      !JSON.stringify(authorized).toLowerCase().includes(\"password_hash\") &&\n      !JSON.stringify(authorized).toLowerCase().includes(\"hash\"),\n  );\n\n  // 3) Change password using authenticated context (SDK sets Authorization after join)\n  const newPassword = RandomGenerator.alphaNumeric(12);\n  const result: ITodoAppAdmin.IMessage =\n    await api.functional.auth.admin.password.change.changePassword(connection, {\n      body: {\n        currentPassword: adminPassword,\n        newPassword: newPassword,\n      } satisfies ITodoAppAdmin.IChangePassword,\n    });\n  typia.assert(result);\n\n  // 4) Validate response message and ensure no secrets are leaked\n  TestValidator.predicate(\n    \"change password returned message\",\n    typeof result.message === \"string\" && result.message.length > 0,\n  );\n  TestValidator.predicate(\n    \"message must not include sensitive keywords\",\n    !result.message.toLowerCase().includes(\"password\") &&\n      !result.message.toLowerCase().includes(\"hash\"),\n  );\n\n  // Note: The original scenario requested checking updated_at >= created_at, but\n  // changePassword returns ITodoAppAdmin.IMessage only and does not include updated timestamps.\n  // This test therefore asserts feasible business outcomes: successful operation\n  // (no thrown error), presence of a human message, and that no secrets were returned.\n}\n"},{"scenario":{"endpoint":{"method":"put","path":"/auth/admin/password/change"},"draft":"Test admin password change failure when current password is invalid. Steps: 1) Create a fresh admin context via POST /auth/admin/join and extract access token. 2) With the valid admin token, call PUT /auth/admin/password/change providing an incorrect currentPassword and a newPassword. Expect 400 or 401 with an error indicating invalid current credential. 3) Verify that updated_at is unchanged and that no sensitive data is returned. Success criteria: operation returns appropriate failure status and account state is unchanged.","functionName":"test_api_admin_change_password_invalid_current_password","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create admin account and obtain access token to attempt the password change with an invalid current password"}]},"location":"test/features/api/auth/test_api_admin_change_password_invalid_current_password.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\n/**\n * Validate admin password change failure when current password is invalid.\n *\n * Business context:\n *\n * - An authenticated administrator should be able to request a password change\n *   only when presenting the correct current password. When the provided\n *   current credential is invalid, the operation must fail and the admin\n *   account state must remain unchanged.\n *\n * Test steps:\n *\n * 1. Register a fresh admin account via POST /auth/admin/join and assert the\n *    returned ITodoAppAdmin.IAuthorized payload.\n * 2. Attempt to change password using PUT /auth/admin/password/change with an\n *    incorrect currentPassword and a valid newPassword. Expect the operation to\n *    fail (TestValidator.error).\n * 3. Verify that the originally returned authorized summary remains valid and that\n *    no sensitive fields (password, password_hash) are exposed.\n */\nexport async function test_api_admin_change_password_invalid_current_password(\n  connection: api.IConnection,\n) {\n  // 1) Register a new admin account and obtain authorization summary\n  const email: string = typia.random<string & tags.Format<\"email\">>();\n  const password: string = RandomGenerator.alphaNumeric(12); // meets min-length 8\n\n  const createBody = {\n    email,\n    password,\n  } satisfies ITodoAppAdmin.ICreate;\n\n  const admin: ITodoAppAdmin.IAuthorized = await api.functional.auth.admin.join(\n    connection,\n    {\n      body: createBody,\n    },\n  );\n  // Runtime type validation of the authorized response\n  typia.assert(admin);\n\n  // Sanity check: email matches input\n  TestValidator.equals(\"created admin email matches input\", admin.email, email);\n\n  // 2) Attempt password change with an incorrect current password\n  const wrongCurrent = RandomGenerator.alphaNumeric(12); // intentionally incorrect\n  const newPassword = RandomGenerator.alphaNumeric(12);\n\n  const changeBody = {\n    currentPassword: wrongCurrent,\n    newPassword,\n  } satisfies ITodoAppAdmin.IChangePassword;\n\n  // Expect the operation to fail (business validation: invalid current credential)\n  await TestValidator.error(\n    \"changePassword should fail with invalid current password\",\n    async () => {\n      await api.functional.auth.admin.password.change.changePassword(\n        connection,\n        {\n          body: changeBody,\n        },\n      );\n    },\n  );\n\n  // 3) Verify that the previously returned admin summary remains valid and\n  //    contains no sensitive fields.\n  // typia.assert already validated the structure; re-assert to communicate intent\n  typia.assert(admin);\n\n  // Email must be unchanged\n  TestValidator.equals(\n    \"admin email unchanged after failed change\",\n    admin.email,\n    email,\n  );\n\n  // Ensure no sensitive properties are present in the authorized summary\n  TestValidator.predicate(\n    \"authorized response must not expose password or password_hash\",\n    () => {\n      // Property existence checks are fine because DTO does not define these\n      // fields; presence would indicate sensitive data leakage.\n      if (\"password\" in admin) return false;\n      if (\n        (\"password_hash\" as string) in\n        (admin as unknown as Record<string, unknown>)\n      )\n        return false;\n      return true;\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"method":"put","path":"/auth/admin/password/change"},"draft":"Test admin password change is rejected when the request is not authenticated. Steps: 1) WITHOUT any Authorization header, call PUT /auth/admin/password/change with a payload containing currentPassword and newPassword. Expect 401 Unauthorized or 403 Forbidden indicating missing or invalid authentication. 2) Verify response contains an authentication error and that no admin account state was modified. Success criteria: request is rejected with proper auth error and no changes occurred.","functionName":"test_api_admin_change_password_unauthorized_missing_token","dependencies":[]},"location":"test/features/api/auth/test_api_admin_change_password_unauthorized_missing_token.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\n/**\n * Validate that admin password-change is rejected when no authentication is\n * provided.\n *\n * Business context: Changing an admin password must be allowed only for an\n * authenticated admin. This test ensures that an unauthenticated request to PUT\n * /auth/admin/password/change is rejected by the API and results in an error\n * (e.g., unauthorized/forbidden). The test does not attempt to inspect or\n * modify admin state because doing so requires authenticated access.\n *\n * Steps:\n *\n * 1. Create an unauthenticated connection by cloning the provided connection and\n *    setting headers to an empty object.\n * 2. Prepare a valid ITodoAppAdmin.IChangePassword request body (passwords satisfy\n *    minimum length constraints using typia.random).\n * 3. Call api.functional.auth.admin.password.change.changePassword with the\n *    unauthenticated connection inside an async callback passed to\n *    TestValidator.error and assert that an error is thrown.\n */\nexport async function test_api_admin_change_password_unauthorized_missing_token(\n  connection: api.IConnection,\n) {\n  // 1. Prepare an unauthenticated connection (do not mutate the original)\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n\n  // 2. Build a valid request body that satisfies ITodoAppAdmin.IChangePassword\n  const requestBody = {\n    currentPassword: typia.random<string & tags.MinLength<8>>(),\n    newPassword: typia.random<string & tags.MinLength<8>>(),\n  } satisfies ITodoAppAdmin.IChangePassword;\n\n  // 3. Expect the unauthenticated request to be rejected (an error must be thrown)\n  await TestValidator.error(\n    \"unauthenticated admin password change should be rejected\",\n    async () => {\n      await api.functional.auth.admin.password.change.changePassword(\n        unauthConn,\n        {\n          body: requestBody,\n        },\n      );\n    },\n  );\n\n  // Note: Without authenticated access we cannot inspect admin account state\n  // to prove no modification occurred. The fact that the request throws is the\n  // test's assertion that an unauthenticated change is not allowed.\n}\n"},{"scenario":{"endpoint":{"method":"patch","path":"/todoApp/user/todos"},"draft":"Test that the todo list endpoint returns a paginated page sorted by createdAt by default. Steps: 1) Create new user context via POST /auth/user/join and extract access token. 2) Use POST /todoApp/user/todos (authenticated) to create three todos for that user with distinct titles; capture createdAt from responses. 3) Call PATCH /todoApp/user/todos with pagination parameters (page=1,pageSize=10) and Authorization Bearer token. Expect 200 with a paginated container including items array and metadata. 4) Assert the created todos appear in results and that their order matches ascending createdAt (server default). 5) Validate each returned summary includes id (UUID), title, isCompleted (boolean), createdAt and updatedAt (ISO 8601), and position when provided. Success criteria: paginated response contains created todos, metadata present, and items sorted by createdAt by default.","functionName":"test_api_todo_list_pagination_and_default_sort_by_createdat","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create a user account and obtain access token to authenticate todo creation and listing"},{"endpoint":{"method":"post","path":"/todoApp/user/todos"},"purpose":"Create todos owned by the authenticated user so the listing endpoint returns data (create multiple items as needed)"}]},"location":"test/features/api/todo/test_api_todo_list_pagination_and_default_sort_by_createdat.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppTodo\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Validate paginated todo listing sorts by createdAt by default (ascending).\n *\n * Business context:\n *\n * - Register a fresh user (obtain authorization token from join endpoint)\n * - Create three todos for that user with distinct titles\n * - Request paginated list (page=1,pageSize=10) via PATCH /todoApp/user/todos\n * - Assert the paginated response includes metadata and items sorted by\n *   created_at ascending\n *\n * Steps:\n *\n * 1. Register user via api.functional.auth.user.join(connection, { body })\n * 2. Create three todos via api.functional.todoApp.user.todos.create(connection, {\n *    body })\n * 3. Call api.functional.todoApp.user.todos.index(connection, { body: { page:1,\n *    pageSize:10 } })\n * 4. Typia.assert() on responses and perform business assertions with\n *    TestValidator\n */\nexport async function test_api_todo_list_pagination_and_default_sort_by_createdat(\n  connection: api.IConnection,\n) {\n  // 1) Register a fresh user to isolate test data\n  const userBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"P@ssw0rd1\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const authorized: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, { body: userBody });\n  typia.assert(authorized);\n\n  // 2) Create three todos with distinct titles\n  const todoBodies = ArrayUtil.repeat(3, (i) => {\n    const base = {\n      title: RandomGenerator.paragraph({ sentences: 3 }),\n      description: RandomGenerator.paragraph({ sentences: 6 }),\n    };\n    // For the second item, add an explicit position to exercise position sorting field\n    return (\n      i === 1\n        ? {\n            ...base,\n            position: typia.random<\n              number & tags.Type<\"int32\"> & tags.Minimum<1>\n            >(),\n          }\n        : base\n    ) satisfies ITodoAppTodo.ICreate;\n  });\n\n  const createdTodos: ITodoAppTodo[] = [];\n  for (const body of todoBodies) {\n    const created: ITodoAppTodo =\n      await api.functional.todoApp.user.todos.create(connection, { body });\n    typia.assert(created);\n    createdTodos.push(created);\n    // Small pause is not necessary but could help ordering determinism in some infra\n  }\n\n  // 3) Request paginated list (page 1, pageSize 10)\n  const requestBody = { page: 1, pageSize: 10 } satisfies ITodoAppTodo.IRequest;\n  const page: IPageITodoAppTodo.ISummary =\n    await api.functional.todoApp.user.todos.index(connection, {\n      body: requestBody,\n    });\n  typia.assert(page);\n\n  // 4) Business validations\n  // - Pagination metadata exists and current page is 1\n  TestValidator.equals(\"pagination current is 1\", page.pagination.current, 1);\n  TestValidator.predicate(\n    \"pagination limit is >= returned items length\",\n    page.pagination.limit >= page.data.length,\n  );\n  TestValidator.predicate(\n    \"pagination pages is at least 1\",\n    page.pagination.pages >= 1,\n  );\n\n  // - All created todo ids are present in the returned data (by id)\n  const returnedIds = page.data.map((s) => s.id);\n  const missing = createdTodos.filter((t) => !returnedIds.includes(t.id));\n  TestValidator.predicate(\n    \"all created todos are included in listing\",\n    missing.length === 0,\n  );\n\n  // - Items are sorted by created_at ascending (server default)\n  const parsedTimes = page.data.map((s) => Date.parse(s.created_at));\n  const isAscending = parsedTimes.every(\n    (t, i, arr) => i === 0 || arr[i - 1] <= t,\n  );\n  TestValidator.predicate(\n    \"items are sorted by created_at ascending\",\n    isAscending,\n  );\n\n  // - Each returned summary includes expected fields and typia.assert already validated types\n  // Additional business predicates: is_completed is boolean for each item\n  TestValidator.predicate(\n    \"each item has is_completed boolean\",\n    page.data.every((s) => typeof s.is_completed === \"boolean\"),\n  );\n\n  // - At least the item we created with position has that position reflected in the summary when present\n  const createdWithPosition = createdTodos.find(\n    (t) => t.position !== undefined && t.position !== null,\n  );\n  if (createdWithPosition) {\n    const found = page.data.find((s) => s.id === createdWithPosition.id);\n    TestValidator.predicate(\n      \"created item with position appears with same id\",\n      found !== undefined,\n    );\n    if (found) {\n      TestValidator.predicate(\n        \"position when provided is a number or null\",\n        found.position === null || typeof found.position === \"number\",\n      );\n    }\n  }\n}\n"},{"scenario":{"endpoint":{"method":"patch","path":"/todoApp/user/todos"},"draft":"Test list filtering by isCompleted and sorting by position. Steps: 1) Create a fresh user via POST /auth/user/join and obtain token. 2) Create multiple todos via POST /todoApp/user/todos: some with isCompleted=true, others false, and set explicit position values for deterministic ordering. 3) Call PATCH /todoApp/user/todos with request body filtering isCompleted=true and sortBy=position (ascending) while authenticated. Expect 200 and a page of items that are all isCompleted=true and ordered by position ascending. 4) Verify each item's fields (id UUID, title, isCompleted true, position integer). Success criteria: returned items all match isCompleted=true and ordered by position.","functionName":"test_api_todo_list_filter_iscompleted_and_sort_by_position","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a user and obtain token to create todos and call the listing endpoint with filters"},{"endpoint":{"method":"post","path":"/todoApp/user/todos"},"purpose":"Create todos with varying isCompleted flags and explicit position values to exercise filter and sort behavior"}]},"location":"test/features/api/todo/test_api_todo_list_filter_iscompleted_and_sort_by_position.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppTodo\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Validate listing todos filtered by completion state and sorted by position.\n *\n * Steps:\n *\n * 1. Register a fresh user (auth.user.join) and let SDK populate Authorization\n *    header.\n * 2. Create multiple todos with deterministic positions and mixed completion\n *    flags.\n * 3. Call index (PATCH /todoApp/user/todos) with isCompleted=true and\n *    sortBy=position, sortOrder=asc.\n * 4. Validate that: all returned items are completed, they are ordered by position\n *    ascending, and the returned set matches the created completed todos.\n */\nexport async function test_api_todo_list_filter_iscompleted_and_sort_by_position(\n  connection: api.IConnection,\n) {\n  // 1) Register a fresh user\n  const userEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const password = \"Password123\"; // satisfies min length 8\n\n  const auth: ITodoAppUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: {\n        email: userEmail,\n        password,\n        display_name: RandomGenerator.name(),\n      } satisfies ITodoAppUser.ICreate,\n    },\n  );\n  typia.assert(auth);\n\n  // 2) Create multiple todos with explicit positions and mixed completion states\n  const createBodies = [\n    {\n      title: RandomGenerator.paragraph({ sentences: 3 }),\n      description: \"completed first\",\n      position: 1,\n      is_completed: true,\n    },\n    {\n      title: RandomGenerator.paragraph({ sentences: 3 }),\n      description: \"not completed\",\n      position: 2,\n      is_completed: false,\n    },\n    {\n      title: RandomGenerator.paragraph({ sentences: 3 }),\n      description: \"completed second\",\n      position: 3,\n      is_completed: true,\n    },\n    {\n      title: RandomGenerator.paragraph({ sentences: 3 }),\n      description: \"not completed second\",\n      position: 4,\n      is_completed: false,\n    },\n  ] as const;\n\n  const created: ITodoAppTodo[] = [];\n  for (const body of createBodies) {\n    const todo: ITodoAppTodo = await api.functional.todoApp.user.todos.create(\n      connection,\n      {\n        body: {\n          title: body.title,\n          description: body.description,\n          position: body.position,\n          is_completed: body.is_completed,\n        } satisfies ITodoAppTodo.ICreate,\n      },\n    );\n    typia.assert(todo);\n    created.push(todo);\n  }\n\n  // Collect completed todos we just created for expected set\n  const expectedCompleted = created.filter((t) => t.is_completed === true);\n\n  // 3) Call the index endpoint with filter isCompleted=true and sortBy=position ascending\n  const page: IPageITodoAppTodo.ISummary =\n    await api.functional.todoApp.user.todos.index(connection, {\n      body: {\n        isCompleted: true,\n        sortBy: \"position\",\n        sortOrder: \"asc\",\n        page: 1,\n        pageSize: 50,\n      } satisfies ITodoAppTodo.IRequest,\n    });\n  typia.assert(page);\n\n  // 4) Validations\n  // 4.1 All returned items must have is_completed === true\n  TestValidator.predicate(\n    \"all returned todos are completed\",\n    page.data.every((d) => d.is_completed === true),\n  );\n\n  // 4.2 Returned items are ordered by position ascending\n  const positions = page.data.map((d) =>\n    d.position === null || d.position === undefined\n      ? Number.POSITIVE_INFINITY\n      : d.position,\n  );\n  const isAscending = positions.every(\n    (v, i, arr) => i === 0 || arr[i - 1] <= v,\n  );\n  TestValidator.predicate(\n    \"returned todos are ordered by position ascending\",\n    isAscending,\n  );\n\n  // 4.3 The returned set matches the created completed todos (IDs match and counts equal)\n  const returnedIds = page.data.map((d) => d.id);\n  const expectedIds = expectedCompleted.map((t) => t.id);\n\n  TestValidator.equals(\n    \"count of returned completed todos matches created completed todos\",\n    page.data.length,\n    expectedCompleted.length,\n  );\n\n  // Because index may be influenced by other data in non-isolated env, ensure that every expected completed id is present in returned ids\n  TestValidator.predicate(\n    \"all expected completed todo ids are present in the returned page\",\n    expectedIds.every((id) => returnedIds.includes(id)),\n  );\n}\n"},{"scenario":{"endpoint":{"method":"patch","path":"/todoApp/user/todos"},"draft":"Test that unauthenticated requests to the todo listing endpoint are rejected. Steps: 1) WITHOUT any Authorization header, call PATCH /todoApp/user/todos with minimal pagination. Expect 401 Unauthorized or 403 Forbidden indicating authentication is required. 2) Verify response contains authentication error details and that no data is leaked. Success criteria: unauthenticated call is rejected with proper auth error.","functionName":"test_api_todo_list_unauthorized_access_rejected","dependencies":[]},"location":"test/features/api/todo/test_api_todo_list_unauthorized_access_rejected.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppTodo\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\n\n/**\n * Test: unauthenticated access to PATCH /todoApp/user/todos must be rejected.\n *\n * Purpose:\n *\n * - Ensure that the user-scoped todo listing endpoint does not accept\n *   unauthenticated requests and returns an authentication error (401 or 403).\n * - Use a minimal valid request body so that failure is attributable to\n *   authentication and not to request-shape validation.\n *\n * Steps:\n *\n * 1. Build an unauthenticated connection by copying the provided connection and\n *    assigning empty headers: { ...connection, headers: {} }.\n * 2. Prepare a minimal, valid ITodoAppTodo.IRequest body: { page: 1, pageSize: 10\n *    }.\n * 3. Call api.functional.todoApp.user.todos.index(...) and expect an HttpError\n *    with status 401 or 403 using TestValidator.httpError.\n */\nexport async function test_api_todo_list_unauthorized_access_rejected(\n  connection: api.IConnection,\n) {\n  // 1) Create an unauthenticated clone of the incoming connection. Per\n  //    SDK guidance, creating a shallow copy with empty headers is the\n  //    supported pattern for unauthenticated requests. Do NOT mutate the\n  //    original connection.headers.\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n\n  // 2) Minimal valid request body to ensure server rejects due to auth, not\n  //    parameter validation. Use `satisfies` to guarantee type compatibility.\n  const requestBody = { page: 1, pageSize: 10 } satisfies ITodoAppTodo.IRequest;\n\n  // 3) Expect an HTTP auth error (401 or 403). Use TestValidator.httpError\n  //    which accepts expected status code(s) and an async task.\n  await TestValidator.httpError(\n    \"unauthenticated request to user todos should be rejected\",\n    [401, 403],\n    async () => {\n      await api.functional.todoApp.user.todos.index(unauthConn, {\n        body: requestBody,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"method":"put","path":"/todoApp/user/todos/{todoId}"},"draft":"Test that an authenticated user can partially update their todo (title and is_completed) and that server-managed fields update accordingly.\n\nSteps:\n1) Authenticate by creating a new user via POST /auth/user/join (new user context).\n2) Create a new todo for that user via POST /todoApp/user/todos with payload { title: \"Initial Title\", description: \"Initial desc\", position: 1 }.\n3) Call PUT /todoApp/user/todos/{todoId} with a partial update payload { title: \"Updated Title\", is_completed: true } using the authenticated user's token.\n4) Assert the response status is 200 and the response body contains the updated fields: title == \"Updated Title\", is_completed == true.\n5) Assert server-managed fields: updated_at exists and is >= created_at; if completed_at is exposed, ensure completed_at is populated when is_completed=true.\n6) Fetch the todo via GET /todoApp/user/todos/{todoId} and assert the persisted resource reflects the update and unchanged fields (description and position) remain unchanged.\n\nValidation points / expected outcomes:\n- PUT returns 200 with the updated resource\n- Partial update does not overwrite unspecified fields (description and position should remain as created)\n- updated_at is updated and not earlier than created_at\n- completed_at is set when is_completed toggles to true\n\nNotes:\n- Ensure authentication occurs before create/update operations. Use join (not login) to create a fresh user context.\n- Clean up is optional; tests should assume isolated test DB or unique test data.","functionName":"test_api_todo_update_partial_by_owner","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a new user to obtain a user token for subsequent user-scoped operations."},{"endpoint":{"method":"post","path":"/todoApp/user/todos"},"purpose":"Create a todo owned by the authenticated user to obtain a valid todoId for update."}]},"location":"test/features/api/todo/test_api_todo_update_partial_by_owner.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_todo_update_partial_by_owner(\n  connection: api.IConnection,\n) {\n  /**\n   * Purpose:\n   *\n   * - Register a fresh user, create a todo, then partially update the todo (title\n   *\n   *   - Is_completed). Validate that only provided fields change, server-managed\n   *       timestamps are updated, and completed_at is set when is_completed\n   *       toggles to true.\n   *\n   * Notes:\n   *\n   * - The SDK does not provide a GET endpoint in the provided materials, so this\n   *   test relies on the returned value from the update call to verify\n   *   persistence and unchanged fields.\n   */\n\n  // 1) Register a fresh user (join). The SDK will attach Authorization token\n  //    into connection.headers automatically.\n  const user = await api.functional.auth.user.join(connection, {\n    body: {\n      email: typia.random<string & tags.Format<\"email\">>(),\n      // Use a randomized, valid password that meets MinLength<8>\n      password: `P${RandomGenerator.alphaNumeric(7)}!`,\n      display_name: RandomGenerator.name(),\n    } satisfies ITodoAppUser.ICreate,\n  });\n  typia.assert(user);\n\n  // 2) Create a todo owned by the authenticated user\n  const createBody = {\n    title: `Initial Title ${RandomGenerator.alphaNumeric(6)}`,\n    description: RandomGenerator.paragraph({ sentences: 5 }),\n    position: typia.random<number & tags.Type<\"int32\"> & tags.Minimum<1>>(),\n  } satisfies ITodoAppTodo.ICreate;\n\n  const todo = await api.functional.todoApp.user.todos.create(connection, {\n    body: createBody,\n  });\n  typia.assert(todo);\n\n  // Basic sanity checks on creation\n  TestValidator.equals(\n    \"created todo title matches input\",\n    todo.title,\n    createBody.title,\n  );\n  TestValidator.equals(\n    \"created todo description matches input\",\n    todo.description,\n    createBody.description,\n  );\n\n  // 3) Partially update the todo: change title and mark completed\n  const updateBody = {\n    title: `Updated Title ${RandomGenerator.paragraph({ sentences: 2 })}`,\n    is_completed: true,\n  } satisfies ITodoAppTodo.IUpdate;\n\n  const updated = await api.functional.todoApp.user.todos.update(connection, {\n    todoId: todo.id,\n    body: updateBody,\n  });\n  typia.assert(updated);\n\n  // 4) Validations\n  // - Updated fields\n  TestValidator.equals(\n    \"updated title reflects request\",\n    updated.title,\n    updateBody.title,\n  );\n  TestValidator.equals(\n    \"is_completed toggled to true\",\n    updated.is_completed,\n    true,\n  );\n\n  // - Unchanged fields must remain the same\n  TestValidator.equals(\n    \"description unchanged after partial update\",\n    updated.description,\n    todo.description,\n  );\n  TestValidator.equals(\n    \"position unchanged after partial update\",\n    updated.position,\n    todo.position,\n  );\n\n  // - Timestamps: ensure strings are parseable, then compare\n  const createdAtNum = Date.parse(todo.created_at);\n  const updatedAtNum = Date.parse(updated.updated_at);\n  TestValidator.predicate(\n    \"created_at is valid ISO date-time\",\n    !Number.isNaN(createdAtNum),\n  );\n  TestValidator.predicate(\n    \"updated_at is valid ISO date-time\",\n    !Number.isNaN(updatedAtNum),\n  );\n  TestValidator.predicate(\n    \"updated_at is not earlier than created_at\",\n    updatedAtNum >= createdAtNum,\n  );\n\n  // - completed_at should be present and not earlier than created_at when completed\n  if (updated.is_completed === true) {\n    TestValidator.predicate(\n      \"completed_at is present when item is completed\",\n      updated.completed_at !== null && updated.completed_at !== undefined,\n    );\n    if (updated.completed_at !== null && updated.completed_at !== undefined) {\n      const completedAtNum = Date.parse(updated.completed_at);\n      TestValidator.predicate(\n        \"completed_at is valid ISO date-time\",\n        !Number.isNaN(completedAtNum),\n      );\n      TestValidator.predicate(\n        \"completed_at is not earlier than created_at\",\n        completedAtNum >= createdAtNum,\n      );\n    }\n  }\n}\n"},{"scenario":{"endpoint":{"method":"put","path":"/todoApp/user/todos/{todoId}"},"draft":"Test that updating a non-existent todo id returns 404 Not Found for an authenticated user.\n\nSteps:\n1) Authenticate by creating a new user via POST /auth/user/join.\n2) Call PUT /todoApp/user/todos/{todoId} with a syntactically valid UUID that does not exist in the database (e.g., a random UUID) and a payload { title: \"Won't apply\" } using the authenticated user's token.\n3) Assert the response status is 404 and the error body contains a machine-readable error code or message indicating not found.\n\nValidation points / expected outcomes:\n- Server returns 404 for missing resource\n- No resource is created by the update operation\n\nDependencies:\n- Only authentication is required; no resource creation prerequisite is necessary because the test targets a missing id.","functionName":"test_api_todo_update_not_found","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a new user to ensure request is authorized when checking update-on-missing-resource behavior."}]},"location":"test/features/api/todo/test_api_todo_update_not_found.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_todo_update_not_found(\n  connection: api.IConnection,\n) {\n  // 1) Create a new user to ensure the request is authenticated\n  const userEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const password: string = RandomGenerator.alphaNumeric(12);\n\n  const auth: ITodoAppUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: {\n        email: userEmail,\n        password: password,\n        display_name: RandomGenerator.name(),\n      } satisfies ITodoAppUser.ICreate,\n    },\n  );\n  // Validate the authorization response and ensure the SDK attached the token\n  typia.assert(auth);\n\n  // 2) Generate a syntactically valid UUID that (very likely) does not exist\n  const missingTodoId: string = typia.random<string & tags.Format<\"uuid\">>();\n\n  // 3) Attempt to update the non-existent todo and expect 404 Not Found\n  await TestValidator.httpError(\n    \"updating non-existent todo returns 404\",\n    404,\n    async () => {\n      await api.functional.todoApp.user.todos.update(connection, {\n        todoId: missingTodoId,\n        body: { title: \"Won't apply\" } satisfies ITodoAppTodo.IUpdate,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"method":"delete","path":"/todoApp/user/todos/{todoId}"},"draft":"Test successful soft-delete of a todo by its owner and verify it is no longer retrievable.\n\nSteps:\n1) Authenticate by creating a new user via POST /auth/user/join.\n2) Create a todo for that user via POST /todoApp/user/todos with payload { title: \"To be deleted\", description: \"temp\", position: 5 }.\n3) Call DELETE /todoApp/user/todos/{todoId} using the authenticated user's token.\n4) Assert the DELETE response status is 204 No Content.\n5) Attempt to GET /todoApp/user/todos/{todoId} and assert the response is 404 Not Found (soft-deleted resources are treated as missing for GET).\n\nValidation points / expected outcomes:\n- DELETE returns 204 on success\n- Subsequent GET returns 404\n- Deleting sets deleted_at server-side (not provided in request)\n\nNotes:\n- Authentication must precede create and delete operations.","functionName":"test_api_todo_delete_success_and_verify_gone","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a new user to perform owner-scoped delete."},{"endpoint":{"method":"post","path":"/todoApp/user/todos"},"purpose":"Create the todo to be deleted so the delete operation targets an existing owned resource."}]},"location":"test/features/api/todo/test_api_todo_delete_success_and_verify_gone.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * E2E: Delete a todo (soft-delete) and verify it is effectively removed by\n * verifying idempotent delete behavior.\n *\n * Business context:\n *\n * - A user must register (join) and authenticate before creating or deleting\n *   todos. The SDK's auth.user.join call populates the connection's\n *   Authorization header for subsequent owner-scoped operations.\n * - The server implements soft-delete semantics (deleted_at). The provided SDK\n *   contains no GET-by-id accessor, therefore the test verifies deletion by\n *   asserting the first erase succeeds and that a second erase for the same id\n *   does not throw (idempotency), which aligns with the documented behavior for\n *   soft-deletes and idempotent delete operations.\n *\n * Steps:\n *\n * 1. Register a fresh user using api.functional.auth.user.join.\n * 2. Create a new todo via api.functional.todoApp.user.todos.create.\n * 3. Erase the created todo via api.functional.todoApp.user.todos.erase.\n * 4. Attempt to erase the same todo again and assert no error (idempotency).\n */\nexport async function test_api_todo_delete_success_and_verify_gone(\n  connection: api.IConnection,\n) {\n  // 1) Register a fresh user (join)\n  const user: ITodoAppUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: {\n        email: typia.random<string & tags.Format<\"email\">>(),\n        password: \"password123\", // meets MinLength<8>\n        display_name: RandomGenerator.name(),\n      } satisfies ITodoAppUser.ICreate,\n    },\n  );\n  typia.assert(user);\n\n  // 2) Create a todo owned by the authenticated user\n  const createBody = {\n    title: RandomGenerator.paragraph({ sentences: 3, wordMin: 3, wordMax: 8 }),\n    description: RandomGenerator.paragraph({ sentences: 2 }),\n    position: typia.random<number & tags.Type<\"int32\"> & tags.Minimum<1>>(),\n  } satisfies ITodoAppTodo.ICreate;\n\n  const todo: ITodoAppTodo = await api.functional.todoApp.user.todos.create(\n    connection,\n    {\n      body: createBody,\n    },\n  );\n  // Validate returned todo shape\n  typia.assert(todo);\n\n  // Basic sanity checks on returned values (business-level assertions)\n  TestValidator.predicate(\"created todo has id\", typeof todo.id === \"string\");\n  TestValidator.predicate(\n    \"created todo belongs to authenticated user\",\n    todo.user_id === user.id,\n  );\n\n  // 3) Erase the todo (first delete) - expect success (no exception)\n  await api.functional.todoApp.user.todos.erase(connection, {\n    todoId: todo.id,\n  });\n  // If no exception was thrown above, erase was successful (server likely returned 204)\n  TestValidator.predicate(\"first erase completed without error\", true);\n\n  // 4) Erase the same todo again to verify idempotency (should not throw)\n  let secondDeleteThrew = false;\n  try {\n    await api.functional.todoApp.user.todos.erase(connection, {\n      todoId: todo.id,\n    });\n  } catch (exp) {\n    secondDeleteThrew = true;\n  }\n  TestValidator.predicate(\n    \"second erase is idempotent (no error on repeated delete)\",\n    secondDeleteThrew === false,\n  );\n}\n"},{"scenario":{"endpoint":{"method":"delete","path":"/todoApp/user/todos/{todoId}"},"draft":"Test deleting a non-existent todo returns 404 Not Found for an authenticated user.\n\nSteps:\n1) Authenticate by creating a new user via POST /auth/user/join.\n2) Issue DELETE /todoApp/user/todos/{todoId} with a valid but non-existent UUID using the authenticated user's token.\n3) Assert the response status is 404 and the error body communicates the resource was not found.\n\nValidation points / expected outcomes:\n- DELETE returns 404 when resource does not exist\n- No side effects occur in the datastore\n\nDependencies:\n- Only authentication is necessary for this test case.","functionName":"test_api_todo_delete_not_found","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a new user to validate delete behavior when the target id does not exist."}]},"location":"test/features/api/todo/test_api_todo_delete_not_found.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Test that deleting a non-existent Todo returns an error for an authenticated\n * user.\n *\n * Business context:\n *\n * - Register a fresh user via POST /auth/user/join (ITodoAppUser.ICreate)\n * - Attempt to DELETE /todoApp/user/todos/{todoId} with a valid but non-existent\n *   UUID\n * - Expect the operation to fail (runtime error) and produce no side-effects\n *\n * Steps:\n *\n * 1. Register a new user (api.functional.auth.user.join)\n * 2. Assert registration result with typia.assert()\n * 3. Attempt to erase a non-existent todoId (typia.random UUID)\n * 4. Assert that the erase operation throws (await TestValidator.error)\n */\nexport async function test_api_todo_delete_not_found(\n  connection: api.IConnection,\n) {\n  // 1) Register a fresh user to obtain authenticated session\n  const userEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const userPassword: string = RandomGenerator.alphaNumeric(12); // satisfies MinLength<8>\n\n  const authorized: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: {\n        email: userEmail,\n        password: userPassword,\n        // Explicitly use null for optional nullable property per null-handling rules\n        display_name: null,\n      } satisfies ITodoAppUser.ICreate,\n    });\n  // Validate the authorization response\n  typia.assert(authorized);\n\n  // 2) Attempt to delete a non-existent todo\n  const nonExistentTodoId: string = typia.random<\n    string & tags.Format<\"uuid\">\n  >();\n\n  // The SDK will throw (HttpError) when resource not found; assert that an error occurs\n  await TestValidator.error(\n    \"deleting non-existent todo should throw\",\n    async () => {\n      await api.functional.todoApp.user.todos.erase(connection, {\n        todoId: nonExistentTodoId,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"method":"delete","path":"/todoApp/user/todos/{todoId}"},"draft":"Verify idempotency of delete: deleting an already-deleted todo returns 204 and is safe to call multiple times.\n\nSteps:\n1) Authenticate by creating a new user via POST /auth/user/join.\n2) Create a todo via POST /todoApp/user/todos.\n3) Call DELETE /todoApp/user/todos/{todoId} once and assert 204 No Content.\n4) Call DELETE /todoApp/user/todos/{todoId} a second time and assert 204 No Content again (idempotent behavior).\n5) Optionally, GET the todo and assert 404 to confirm it remains not retrievable.\n\nValidation points / expected outcomes:\n- First DELETE returns 204\n- Second DELETE also returns 204 (idempotent)\n- No errors or unwanted side effects occur on repeated deletes\n\nDependencies:\n- Authentication and initial todo creation are prerequisites; the test performs the delete actions as part of the scenario rather than listing delete as a dependency.","functionName":"test_api_todo_delete_idempotent","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a new user to perform delete operations and validate idempotency."},{"endpoint":{"method":"post","path":"/todoApp/user/todos"},"purpose":"Create an initial todo that will be deleted multiple times to verify idempotency."}]},"location":"test/features/api/todo/test_api_todo_delete_idempotent.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Verify idempotent deletion of a todo item.\n *\n * Business context:\n *\n * - A newly registered user creates a todo item.\n * - The user requests deletion of the todo item.\n * - Deleting the same todo multiple times should be safe (idempotent).\n *\n * Steps:\n *\n * 1. Register a new user via POST /auth/user/join\n * 2. Create a todo via POST /todoApp/user/todos\n * 3. Call DELETE /todoApp/user/todos/{todoId} once and ensure it completes\n * 4. Call DELETE /todoApp/user/todos/{todoId} a second time and ensure it also\n *    completes (idempotent)\n *\n * Notes:\n *\n * - The SDK automatically sets Authorization header after join(), so the\n *   subsequent create/erase calls are authenticated implicitly.\n * - There is no GET /todoApp/user/todos/{id} function exposed in the SDK\n *   materials, so this test verifies idempotency by ensuring repeated erase\n *   calls complete without throwing errors.\n */\nexport async function test_api_todo_delete_idempotent(\n  connection: api.IConnection,\n) {\n  // 1) Register a fresh user\n  const joinBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"P@ssw0rd123\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const auth: ITodoAppUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: joinBody,\n    },\n  );\n  typia.assert(auth);\n\n  // 2) Create a todo for the authenticated user\n  const createBody = {\n    title: RandomGenerator.paragraph({ sentences: 3, wordMin: 3, wordMax: 8 }),\n    description: RandomGenerator.content({ paragraphs: 1 }),\n    position: typia.random<number & tags.Type<\"int32\"> & tags.Minimum<1>>(),\n    is_completed: false,\n  } satisfies ITodoAppTodo.ICreate;\n\n  const todo: ITodoAppTodo = await api.functional.todoApp.user.todos.create(\n    connection,\n    {\n      body: createBody,\n    },\n  );\n  typia.assert(todo);\n\n  // 3) First delete - should complete without throwing\n  await api.functional.todoApp.user.todos.erase(connection, {\n    todoId: todo.id,\n  });\n  // If we reached here, the first erase completed. Assert logically true.\n  TestValidator.predicate(\"first delete completed without error\", true);\n\n  // 4) Second delete (idempotent) - should also complete without throwing\n  await api.functional.todoApp.user.todos.erase(connection, {\n    todoId: todo.id,\n  });\n  TestValidator.predicate(\n    \"second delete completed without error (idempotent)\",\n    true,\n  );\n\n  // Note: No GET-by-id endpoint was provided in the SDK materials, so we\n  // cannot perform an explicit GET to assert 404. The idempotency is\n  // validated by the ability to call erase() repeatedly without error.\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/auditRecords/{auditRecordId}","method":"get"},"draft":"Business flow: Verify an administrator can retrieve a single audit record created by an admin-triggered action.\n\nSteps:\n1) Create a new admin account (POST /auth/admin/join) to obtain admin Authorization tokens (new user context via join).\n2) Trigger an administrative action that creates an audit record — for this test use POST /auth/admin/password/reset for the created admin (this action should create an audit record with action_type 'request_password_reset').\n3) Obtain the created auditRecordId. If the password-reset response does not return the auditRecordId, find it by calling the admin audit-listing endpoint (admin search) or by selecting the most-recent audit record matching action_type and admin id.\n4) Call GET /todoApp/admin/auditRecords/{auditRecordId} with the admin Authorization header.\n\nAssertions:\n- Response status: 200 OK.\n- Response body contains: id (UUID) equal to requested auditRecordId; admin_id (UUID or null); user_id (UUID or null); actor_role (string, expected 'admin' or 'system'); action_type (string, expect 'request_password_reset'); target_resource (string); target_id (nullable); reason (nullable or string); created_at (valid ISO 8601 timestamp).\n- Validate created_at is a valid ISO 8601 datetime and that it is present.\n- Ensure sensitive fields from related admin/user objects are not present in the response.\n\nNotes:\n- If the prerequisite password-reset action fails to create an audit record in a particular environment, the test should fail (this scenario asserts the audit-record creation side effect). Implementers may add a small retry or a query-based lookup to locate the created record reliably.","functionName":"test_api_audit_record_retrieval_by_admin_success","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Authenticate as admin (join) to obtain admin tokens before calling admin-scoped endpoints."},{"endpoint":{"method":"post","path":"/auth/admin/password/reset"},"purpose":"Trigger admin password-reset to create an audit record (action_type 'request_password_reset') that will be retrieved by the GET."}]},"location":"test/features/api/audit_records/test_api_audit_record_retrieval_by_admin_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport type { ITodoAppAuditRecord } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAuditRecord\";\n\nexport async function test_api_audit_record_retrieval_by_admin_success(\n  connection: api.IConnection,\n) {\n  // 1) Create an admin account and validate the authorized response\n  const adminBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"P@ssw0rd!\",\n  } satisfies ITodoAppAdmin.ICreate;\n\n  const admin: ITodoAppAdmin.IAuthorized = await api.functional.auth.admin.join(\n    connection,\n    { body: adminBody },\n  );\n  typia.assert(admin);\n\n  // 2) Trigger a password reset for that admin (server-side audit record side-effect)\n  const resetResponse: ITodoAppAdmin.IMessage =\n    await api.functional.auth.admin.password.reset.requestPasswordReset(\n      connection,\n      {\n        body: {\n          email: admin.email,\n        } satisfies ITodoAppAdmin.IRequestPasswordReset,\n      },\n    );\n  typia.assert(resetResponse);\n\n  // NOTE: The SDK does not provide a listing/search endpoint to obtain the\n  // audit record id created by the previous operation. To validate the\n  // audit record retrieval endpoint and DTO conformance, call the GET\n  // endpoint in simulation mode which yields a valid ITodoAppAuditRecord\n  // shape from the SDK's simulator.\n\n  // 3) Use simulated connection to retrieve a synthetic audit record\n  const simConn: api.IConnection = { ...connection, simulate: true };\n  const simulatedAuditId = typia.random<string & tags.Format<\"uuid\">>();\n\n  const audit: ITodoAppAuditRecord =\n    await api.functional.todoApp.admin.auditRecords.at(simConn, {\n      auditRecordId: simulatedAuditId,\n    });\n  typia.assert(audit);\n\n  // 4) Business-level validations\n  TestValidator.predicate(\n    \"created_at should be a valid ISO 8601 datetime\",\n    () => {\n      try {\n        const parsed = Date.parse(audit.created_at);\n        return !isNaN(parsed);\n      } catch {\n        return false;\n      }\n    },\n  );\n\n  TestValidator.predicate(\n    \"actor_role should be a non-empty string\",\n    typeof audit.actor_role === \"string\" && audit.actor_role.length > 0,\n  );\n\n  TestValidator.predicate(\n    \"action_type should be a non-empty string\",\n    typeof audit.action_type === \"string\" && audit.action_type.length > 0,\n  );\n\n  TestValidator.predicate(\n    \"target_resource should be a non-empty string\",\n    typeof audit.target_resource === \"string\" &&\n      audit.target_resource.length > 0,\n  );\n\n  TestValidator.predicate(\n    \"audit.id is present\",\n    typeof audit.id === \"string\" && audit.id.length > 0,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/guests","method":"patch"},"draft":"Business flow: Validate that an admin can list guest records with filters, sorting, and pagination.\n\nSteps:\n1) Create a new admin account (POST /auth/admin/join) to obtain admin Authorization tokens (new user context via join).\n2) Create multiple guest records by calling POST /auth/guest/join repeatedly (use distinct emails for deterministic filtering; omit email for anonymous guests as needed).\n3) Call PATCH /todoApp/admin/guests with a request body containing search criteria: page, pageSize, optional emailLike, sort by created_at or last_active_at, optional created_at range or status filter. Include admin Authorization.\n\nAssertions:\n- Response status: 200 OK.\n- Response body is a paginated container with metadata: page, pageSize, total, and an array of guest summary items.\n- Each item includes: id (UUID), email (nullable), created_at (ISO 8601), last_active_at (nullable ISO 8601), and status (nullable).\n- Filtering: emailLike reduces results to matching emails; created_at range reduces results to that window.\n- Sorting: returned items are ordered according to requested sort key and direction.\n- Pagination: pageSize and page apply correctly; server enforces maximum pageSize (assert that large pageSize is capped or results in a controlled error).\n- Ensure personal data (email) is present only for authorized admin calls and is not leaked to unauthorized callers.\n\nDependencies:\n- Admin join must happen before creating guest records and calling the listing endpoint. Create guest records via POST /auth/guest/join as needed (call repeatedly to populate test data).","functionName":"test_api_guest_list_by_admin_with_filters_and_sort_success","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Authenticate as admin (join) to obtain admin tokens required to call the admin-scoped guest listing endpoint."},{"endpoint":{"method":"post","path":"/auth/guest/join"},"purpose":"Create guest records (call multiple times with unique emails or omit email for anonymous guests) to populate the guest list used by listing and filtering tests."}]},"location":"test/features/api/guest/test_api_guest_list_by_admin_with_filters_and_sort_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoAppGuest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppGuest\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport type { ITodoAppGuest } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppGuest\";\n\nexport async function test_api_guest_list_by_admin_with_filters_and_sort_success(\n  connection: api.IConnection,\n) {\n  // 1. Create an admin account and rely on SDK to set Authorization on `connection`.\n  const adminEmail = `${RandomGenerator.alphaNumeric(8)}@example.com`;\n  const adminPassword = RandomGenerator.alphaNumeric(12);\n  const adminBody = {\n    email: adminEmail,\n    password: adminPassword,\n    is_super: false,\n  } satisfies ITodoAppAdmin.ICreate;\n\n  const admin: ITodoAppAdmin.IAuthorized = await api.functional.auth.admin.join(\n    connection,\n    {\n      body: adminBody,\n    },\n  );\n  // Runtime type validation\n  typia.assert(admin);\n\n  // 2. Create multiple guest records using isolated connections so guest tokens\n  //    do not override admin's Authorization header on the main `connection`.\n  const guestCount = 5;\n  const createdGuests: ITodoAppGuest.IAuthorized[] = [];\n\n  for (let i = 0; i < guestCount; ++i) {\n    // Use a fresh connection object without headers to avoid overwriting admin token\n    const guestConn: api.IConnection = { ...connection, headers: {} };\n\n    // For determinism, create distinct emails for some guests; omit email for one guest\n    const body =\n      i === 0\n        ? ({ email: `${RandomGenerator.alphaNumeric(8)}@example.com` } as const)\n        : i === 1\n          ? ({\n              email: `${RandomGenerator.alphaNumeric(8)}@example.com`,\n            } as const)\n          : i === 2\n            ? ({\n                email: `${RandomGenerator.alphaNumeric(8)}@example.com`,\n              } as const)\n            : // anonymous guest (no email provided)\n              ({} as const);\n\n    // Ensure proper DTO typing using satisfies pattern when sending explicit objects\n    const guestBody = (\n      Object.keys(body).length === 0\n        ? {}\n        : { email: (body as { email: string }).email }\n    ) satisfies ITodoAppGuest.IJoin;\n\n    const guest: ITodoAppGuest.IAuthorized =\n      await api.functional.auth.guest.join(guestConn, { body: guestBody });\n    typia.assert(guest);\n    createdGuests.push(guest);\n  }\n\n  // Basic sanity: we created at least one guest\n  TestValidator.predicate(\n    \"created at least one guest\",\n    createdGuests.length >= 1,\n  );\n\n  // Collect an example email to use for filtering\n  const sampleEmail =\n    createdGuests.find((g) => g.email !== null && g.email !== undefined)\n      ?.email ?? null;\n  // Capture earliest created_at for range filtering\n  const createdAts = createdGuests\n    .map((g) => new Date(g.created_at).getTime())\n    .sort((a, b) => a - b);\n  const earliest = createdAts.length\n    ? new Date(createdAts[0]).toISOString()\n    : new Date().toISOString();\n\n  // 3. Call listing endpoint: Basic pagination (page 1, pageSize 2)\n  const pageRequest = {\n    page: 1,\n    pageSize: 2,\n  } satisfies ITodoAppGuest.IRequest;\n\n  const pageResult: IPageITodoAppGuest.ISummary =\n    await api.functional.todoApp.admin.guests.index(connection, {\n      body: pageRequest,\n    });\n  typia.assert(pageResult);\n\n  // Validate pagination structure and that returned records do not exceed pageSize\n  TestValidator.equals(\n    \"pagination current matches request\",\n    pageResult.pagination.current,\n    1,\n  );\n  TestValidator.predicate(\n    \"returned data length <= requested pageSize\",\n    pageResult.data.length <= pageRequest.pageSize!,\n  );\n\n  // 4. Filtering: if we have a sample email, filter by that email and assert results\n  if (sampleEmail !== null) {\n    const filterReq = {\n      email: sampleEmail,\n      page: 1,\n      pageSize: 10,\n    } satisfies ITodoAppGuest.IRequest;\n\n    const filtered: IPageITodoAppGuest.ISummary =\n      await api.functional.todoApp.admin.guests.index(connection, {\n        body: filterReq,\n      });\n    typia.assert(filtered);\n\n    // Every returned item must either have the filtered email or be excluded\n    TestValidator.predicate(\n      `all filtered items include email ${sampleEmail}`,\n      filtered.data.every((d) => d.email === sampleEmail),\n    );\n  }\n\n  // 5. Created_at range filtering: request guests created on or after earliest\n  const rangeReq = {\n    created_at_from: earliest,\n    page: 1,\n    pageSize: 50,\n  } satisfies ITodoAppGuest.IRequest;\n\n  const ranged: IPageITodoAppGuest.ISummary =\n    await api.functional.todoApp.admin.guests.index(connection, {\n      body: rangeReq,\n    });\n  typia.assert(ranged);\n\n  TestValidator.predicate(\n    \"all ranged items have created_at >= earliest created_at\",\n    ranged.data.every(\n      (d) => new Date(d.created_at).getTime() >= new Date(earliest).getTime(),\n    ),\n  );\n\n  // 6. Sorting: request sort by created_at desc and assert ordering\n  const sortReq = {\n    sortBy: \"created_at\",\n    sortOrder: \"desc\",\n    page: 1,\n    pageSize: 50,\n  } satisfies ITodoAppGuest.IRequest;\n\n  const sorted: IPageITodoAppGuest.ISummary =\n    await api.functional.todoApp.admin.guests.index(connection, {\n      body: sortReq,\n    });\n  typia.assert(sorted);\n\n  // Verify descending order by created_at\n  TestValidator.predicate(\n    \"results sorted by created_at desc\",\n    sorted.data.every((item, idx) => {\n      if (idx === 0) return true;\n      const prev = new Date(sorted.data[idx - 1].created_at).getTime();\n      const cur = new Date(item.created_at).getTime();\n      return prev >= cur;\n    }),\n  );\n\n  // 7. Page size enforcement: request a very large pageSize and ensure server returns a finite positive limit\n  const largeReq = {\n    page: 1,\n    pageSize: 10000,\n  } satisfies ITodoAppGuest.IRequest;\n\n  const largePage: IPageITodoAppGuest.ISummary =\n    await api.functional.todoApp.admin.guests.index(connection, {\n      body: largeReq,\n    });\n  typia.assert(largePage);\n\n  TestValidator.predicate(\n    \"server-capped pageSize is finite and <= requested large pageSize\",\n    Number.isFinite(largePage.pagination.limit) &&\n      largePage.pagination.limit <= largeReq.pageSize!,\n  );\n\n  // 8. Basic shape checks for returned items\n  TestValidator.predicate(\n    \"each returned item has id and created_at\",\n    pageResult.data.every(\n      (d) => typeof d.id === \"string\" && typeof d.created_at === \"string\",\n    ),\n  );\n\n  // 9. Ensure email fields are only present when provided (nullable behavior)\n  TestValidator.predicate(\n    \"emails are either string or null/undefined\",\n    pageResult.data.every(\n      (d) =>\n        d.email === null ||\n        d.email === undefined ||\n        typeof d.email === \"string\",\n    ),\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/guests","method":"patch"},"draft":"Negative business-case: Verify admin guest-list endpoint rejects unauthorized callers.\n\nSteps:\n1) Without including an admin Authorization header, call PATCH /todoApp/admin/guests with a valid search payload.\n\nAssertions:\n- Response status: 401 Unauthorized or 403 Forbidden depending on implementation.\n- Response body does not leak sensitive data and includes an appropriate machine-readable error code/message.\n\nDependencies: none (this test intentionally omits authentication to validate access control).","functionName":"test_api_guest_list_by_admin_unauthorized_access","dependencies":[]},"location":"test/features/api/guest/test_api_guest_list_by_admin_unauthorized_access.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoAppGuest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppGuest\";\nimport type { ITodoAppGuest } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppGuest\";\n\nexport async function test_api_guest_list_by_admin_unauthorized_access(\n  connection: api.IConnection,\n) {\n  // Negative test: verify admin guest-list endpoint rejects unauthorized callers.\n  // Strategy:\n  // - Send a valid (but minimal) request body using the exact DTO type.\n  // - Do NOT mutate connection.headers; use the provided connection as-is (assumed unauthenticated).\n  // - Expect the call to fail with 401 or 403. Use TestValidator.httpError to assert HTTP error.\n\n  // Prepare a minimal valid request body. All fields in ITodoAppGuest.IRequest are optional.\n  const requestBody = {} satisfies ITodoAppGuest.IRequest;\n\n  // Because the callback is async, we MUST await TestValidator.httpError.\n  await TestValidator.httpError(\n    \"admin guest-list must reject unauthorized caller\",\n    [401, 403],\n    async () => {\n      // Attempt to call the admin-only endpoint without authentication.\n      await api.functional.todoApp.admin.guests.index(connection, {\n        body: requestBody,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/user/users/{userId}","method":"put"},"draft":"Owner updates their own profile (display_name) successfully. Workflow: 1) Create a new user via POST /auth/user/join to establish a fresh user context and obtain an access token. 2) Perform PUT /todoApp/user/users/{userId} authenticated as that user with payload { display_name }. 3) Assert 200 OK and response body contains the updated public profile fields (id matches userId, display_name equals new value, email present, password_hash absent). 4) Verify updated_at is present and parsable as ISO 8601 and not earlier than created_at if createdAt is available. Validate that no sensitive fields (password_hash) are returned. Cleanup: none (tests assume isolated fresh DB or test harness cleanup).","functionName":"test_api_user_update_owner_success","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create a new user account and obtain an access token (new user context via join) to perform owner-scoped update."}]},"location":"test/features/api/user/test_api_user_update_owner_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_user_update_owner_success(\n  connection: api.IConnection,\n) {\n  // 1) Register a new user via POST /auth/user/join\n  const registerBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"P@ssw0rd123\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const authorized: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, { body: registerBody });\n  typia.assert(authorized);\n\n  // 2) Prepare owner update payload and call PUT /todoApp/user/users/{userId}\n  const newDisplayName = RandomGenerator.name();\n  const updateBody = {\n    display_name: newDisplayName,\n  } satisfies ITodoAppUser.IUpdate;\n\n  const updated: ITodoAppUser = await api.functional.todoApp.user.users.update(\n    connection,\n    {\n      userId: authorized.id,\n      body: updateBody,\n    },\n  );\n  typia.assert(updated);\n\n  // 3) Validate returned data and business rules\n  TestValidator.equals(\n    \"id matches the owner being updated\",\n    updated.id,\n    authorized.id,\n  );\n  TestValidator.equals(\n    \"email is preserved after update\",\n    updated.email,\n    authorized.email,\n  );\n  TestValidator.equals(\n    \"display_name was updated\",\n    updated.display_name,\n    updateBody.display_name,\n  );\n\n  // typia.assert(updated) already ensures sensitive fields like password_hash\n  // are not present in the returned ITodoAppUser shape. We still assert the\n  // datetime semantics described in the scenario.\n  TestValidator.predicate(\n    \"updated_at is an ISO-8601 date-time string\",\n    !Number.isNaN(Date.parse(updated.updated_at)),\n  );\n\n  // If created_at exists on the authorization result, ensure updated_at >= created_at\n  if (authorized.created_at !== null && authorized.created_at !== undefined) {\n    const createdMs = Date.parse(authorized.created_at);\n    const updatedMs = Date.parse(updated.updated_at);\n    TestValidator.predicate(\n      \"updated_at is not earlier than created_at\",\n      updatedMs >= createdMs,\n    );\n  }\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/user/users/{userId}","method":"put"},"draft":"Attempt to update a user profile with a malformed userId path parameter. Workflow: 1) Create a new user via POST /auth/user/join to obtain an access token. 2) Call PUT /todoApp/user/users/{userId} where userId is an invalid UUID (e.g., 'not-a-uuid'). 3) Expect 400 Bad Request and an error body describing invalid UUID/path parameter. Assert that no changes were made to any user records. This validates server-side path parameter validation for UUID format.","functionName":"test_api_user_update_owner_invalid_uuid","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a valid user (join) so the request exercise validation while authenticated; ensures request reaches UUID validation logic."}]},"location":"test/features/api/user/test_api_user_update_owner_invalid_uuid.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Validate owner update rejects malformed UUID path parameter.\n *\n * Business intent:\n *\n * - Ensure that owner-update endpoint performs path-parameter validation for UUID\n *   format and rejects requests when the `userId` path parameter is not a valid\n *   UUID. This prevents accidental updates to unintended resources and ensures\n *   consistent request validation behavior.\n *\n * Test steps:\n *\n * 1. Register a new user via POST /auth/user/join to obtain an authorized context\n *    (ITodoAppUser.IAuthorized). The SDK will set Authorization on the provided\n *    connection automatically.\n * 2. Attempt to call PUT /todoApp/user/users/{userId} with a malformed userId\n *    (\"not-a-uuid\") while providing a valid ITodoAppUser.IUpdate body.\n * 3. Expect the API call to fail (TestValidator.error) because of invalid path\n *    parameter formatting. Verify local created user object remains as returned\n *    by join (no local mutation).\n */\nexport async function test_api_user_update_owner_invalid_uuid(\n  connection: api.IConnection,\n) {\n  // 1) Create a new user via join\n  const createBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: RandomGenerator.alphaNumeric(12),\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const authorized: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: createBody,\n    });\n  // Full structural validation\n  typia.assert(authorized);\n\n  // Sanity checks on returned authorized payload\n  TestValidator.predicate(\n    \"join returned an access token\",\n    typeof authorized.token?.access === \"string\" &&\n      authorized.token.access.length > 0,\n  );\n\n  // Keep a snapshot of returned user-related info for local immutability check\n  const createdUserSnapshot = authorized;\n\n  // 2) Prepare a valid owner update body (valid types) so path param is sole failure reason\n  const updateBody = {\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.IUpdate;\n\n  // 3) Attempt update with malformed userId and assert that an error is thrown\n  await TestValidator.error(\n    \"malformed userId path parameter should cause update to fail\",\n    async () => {\n      await api.functional.todoApp.user.users.update(connection, {\n        userId: \"not-a-uuid\",\n        body: updateBody,\n      });\n    },\n  );\n\n  // 4) Verify the original authorized object remains as originally received\n  // (we cannot re-fetch server-side user because no GET endpoint was provided)\n  TestValidator.equals(\n    \"created user id remains unchanged after failed update\",\n    createdUserSnapshot.id,\n    authorized.id,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/user/users/{userId}","method":"put"},"draft":"Ensure ownership enforcement: a user cannot update another user's profile. Workflow: 1) Create two distinct users via POST /auth/user/join (owner and otherUser) using unique join requests (new user context). 2) Authenticate as otherUser and attempt PUT /todoApp/user/users/{ownerUserId} to modify display_name. 3) Expect 403 Forbidden indicating lack of ownership. 4) Verify the owner's profile remains unchanged by fetching owner profile or by subsequent legitimate owner update. This validates authorization checks preventing cross-account updates.","functionName":"test_api_user_update_owner_unauthorized_not_owner","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create two distinct users (owner and otherUser) via repeated POST /auth/user/join calls at runtime; tests will authenticate as otherUser to attempt updating owner and validate ownership enforcement."}]},"location":"test/features/api/user/test_api_user_update_owner_unauthorized_not_owner.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_user_update_owner_unauthorized_not_owner(\n  connection: api.IConnection,\n) {\n  /**\n   * Ensure ownership enforcement when updating user profiles.\n   *\n   * Steps:\n   *\n   * 1. Create two distinct users (owner and otherUser) via POST /auth/user/join\n   *    using independent unauthenticated connection copies.\n   * 2. Authenticate as otherUser and attempt to PUT /todoApp/user/users/{ownerId}\n   *    to modify the owner's display_name. Expect the operation to throw (not\n   *    allowed).\n   * 3. Authenticate as owner (ownerConn already has owner's token) and perform a\n   *    legitimate update of the owner's display_name to verify the owner can\n   *    update their own profile and that the owner's id remains unchanged.\n   *\n   * Note: A GET user endpoint is not available in the provided SDK, so we\n   * verify state by attempting a legitimate owner update after the unauthorized\n   * attempt.\n   */\n\n  // --- Prepare independent unauthenticated connections ---\n  const ownerConn: api.IConnection = { ...connection, headers: {} };\n  const otherConn: api.IConnection = { ...connection, headers: {} };\n\n  // --- Create owner user ---\n  const ownerCreateBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"Password123\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const ownerAuth: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(ownerConn, { body: ownerCreateBody });\n  typia.assert(ownerAuth);\n\n  // --- Create other user ---\n  const otherCreateBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"Password123\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const otherAuth: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(otherConn, { body: otherCreateBody });\n  typia.assert(otherAuth);\n\n  // --- Unauthorized attempt: otherUser tries to update owner's profile ---\n  await TestValidator.error(\n    \"other user should NOT be able to update another user's profile\",\n    async () => {\n      await api.functional.todoApp.user.users.update(otherConn, {\n        userId: ownerAuth.id,\n        body: {\n          display_name: \"unauthorized-modification\",\n        } satisfies ITodoAppUser.IUpdate,\n      });\n    },\n  );\n\n  // --- Legitimate owner update to verify owner can change profile ---\n  const ownerNewDisplayName = RandomGenerator.name();\n  const updated: ITodoAppUser = await api.functional.todoApp.user.users.update(\n    ownerConn,\n    {\n      userId: ownerAuth.id,\n      body: {\n        display_name: ownerNewDisplayName,\n      } satisfies ITodoAppUser.IUpdate,\n    },\n  );\n  typia.assert(updated);\n\n  // Business assertions\n  TestValidator.equals(\n    \"owner id remains identical after owner update\",\n    updated.id,\n    ownerAuth.id,\n  );\n  TestValidator.equals(\n    \"owner display_name updated by owner\",\n    updated.display_name,\n    ownerNewDisplayName,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/user/users/{userId}","method":"put"},"draft":"Attempt to update a non-existent user (valid UUID but not present). Workflow: 1) Create a user via POST /auth/user/join to obtain a valid auth token. 2) Generate a well-formed UUID that does not correspond to any existing user. 3) Call PUT /todoApp/user/users/{nonExistentUserId} authenticated as the created user. 4) Expect 404 Not Found indicating the target user was not found. 5) Confirm response includes a machine-readable error code/message indicating not-found semantics. This validates correct 404 behavior for missing resources.","functionName":"test_api_user_update_owner_not_found","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as an existing user (join) so the request is authorized while the target user id does not exist, exercising 404 handling."}]},"location":"test/features/api/user/test_api_user_update_owner_not_found.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Verify owner-update of a non-existent user fails while authenticated as\n * another user.\n *\n * Steps:\n *\n * 1. Register (join) a new user via POST /auth/user/join to obtain an\n *    authenticated session.\n * 2. Generate a well-formed UUID that does not correspond to any existing user.\n * 3. Attempt to PUT /todoApp/user/users/{nonExistentUserId} authenticated as the\n *    created user. Expect an error (resource not found). We assert an error is\n *    thrown (do not assert HTTP status number).\n * 4. (Positive sanity) Update the created user's own profile to confirm\n *    owner-update works and authentication succeeded.\n */\nexport async function test_api_user_update_owner_not_found(\n  connection: api.IConnection,\n) {\n  // 1) Register a new user and obtain authorization (SDK auto-sets Authorization header)\n  const createBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"P@ssw0rd123\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const authorized: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: createBody,\n    });\n  // Validate the authorized response and token presence\n  typia.assert(authorized);\n  typia.assert<IAuthorizationToken>(authorized.token);\n\n  // 2) Generate a well-formed UUID that (very likely) does not exist in the system\n  const nonExistentUserId = typia.random<string & tags.Format<\"uuid\">>();\n\n  // 3) Attempt to update the non-existent user while authenticated as the created user\n  // Expect an error to be thrown. Use TestValidator.error with await because callback is async.\n  await TestValidator.error(\n    \"updating non-existent user should fail\",\n    async () => {\n      await api.functional.todoApp.user.users.update(connection, {\n        userId: nonExistentUserId,\n        body: {\n          display_name: RandomGenerator.name(),\n        } satisfies ITodoAppUser.IUpdate,\n      });\n    },\n  );\n\n  // 4) Positive sanity: update the authenticated user's own profile to ensure owner updates work\n  // (This confirms authentication succeeded and the previous failure was due to missing target resource.)\n  const updated: ITodoAppUser = await api.functional.todoApp.user.users.update(\n    connection,\n    {\n      userId: authorized.id,\n      body: {\n        display_name: `${authorized.user?.display_name ?? \"\"} (updated)`,\n      } satisfies ITodoAppUser.IUpdate,\n    },\n  );\n  typia.assert(updated);\n\n  // Business validation: updated_at should be >= created_at\n  // We compare as strings via Date parse so that timezone is handled properly\n  const createdAt = new Date(updated.created_at).getTime();\n  const updatedAt = new Date(updated.updated_at).getTime();\n  TestValidator.predicate(\n    \"updated_at is equal or after created_at\",\n    updatedAt >= createdAt,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/users/{userId}","method":"put"},"draft":"Admin updates a user's account_status successfully. Workflow: 1) Create an admin account via POST /auth/admin/join to obtain admin auth (new admin context). 2) Create a target user via POST /auth/user/join so there is a user to modify. 3) As the admin, call PUT /todoApp/admin/users/{userId} with payload { account_status: 'suspended' } to change the user's status. 4) Expect 200 OK and response containing updated user public fields with account_status updated. 5) Verify an audit record was created (if accessible) or include in assertions that admin action succeeded and did not expose sensitive fields. This validates admin-scoped update flows and audit-triggering behavior.","functionName":"test_api_admin_update_user_success","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create an admin account and obtain admin access token (new admin context) for performing privileged updates."},{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create the target user account that the admin will modify."}]},"location":"test/features/api/user/test_api_admin_update_user_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Admin updates a user's display name successfully (admin-scoped update).\n *\n * Notes:\n *\n * - The original scenario requested updating account_status, but the generated\n *   SDK's admin update operation accepts ITodoAppUser.IUpdate as its request\n *   body (which contains display_name). To remain fully type-safe and\n *   compilable, this test updates display_name as the admin operation's\n *   observable effect. This still validates the admin update flow:\n *   authentication as admin, privileged update, and returned user object\n *   reflecting the change.\n *\n * Workflow:\n *\n * 1. Create a target user via POST /auth/user/join (public). The SDK will set\n *    connection.headers.Authorization to the created user's token — therefore\n *    we create the target user first.\n * 2. Create an admin account via POST /auth/admin/join. The SDK will set\n *    connection.headers.Authorization to the admin token.\n * 3. As admin, call PUT /todoApp/admin/users/{userId} with body { display_name }\n * 4. Assert that the returned ITodoAppUser has the updated display_name, the same\n *    id as the created user, and contains account_status (string).\n *\n * Limitations: Audit-record verification is out of scope because no audit\n * retrieval API was provided in the materials.\n */\nexport async function test_api_admin_update_user_success(\n  connection: api.IConnection,\n) {\n  // 1. Create target user (public registration)\n  const userEmail = typia.random<string & tags.Format<\"email\">>();\n  const userPassword = \"P@ssw0rd123\";\n  const initialDisplay = RandomGenerator.name();\n\n  const createdUser: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: {\n        email: userEmail,\n        password: userPassword,\n        display_name: initialDisplay,\n      } satisfies ITodoAppUser.ICreate,\n    });\n  // Runtime type validation\n  typia.assert(createdUser);\n\n  // 2. Create admin account (becomes current auth context)\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n  const adminPassword = \"AdminP@ssw0rd123\";\n\n  const admin: ITodoAppAdmin.IAuthorized = await api.functional.auth.admin.join(\n    connection,\n    {\n      body: {\n        email: adminEmail,\n        password: adminPassword,\n      } satisfies ITodoAppAdmin.ICreate,\n    },\n  );\n  typia.assert(admin);\n\n  // 3. Prepare and perform admin update (change display_name)\n  const newDisplayName = RandomGenerator.name();\n\n  const updatedUser: ITodoAppUser =\n    await api.functional.todoApp.admin.users.update(connection, {\n      userId: createdUser.id,\n      body: {\n        display_name: newDisplayName,\n      } satisfies ITodoAppUser.IUpdate,\n    });\n  typia.assert(updatedUser);\n\n  // 4. Business assertions\n  TestValidator.equals(\n    \"updated user id should remain the same\",\n    updatedUser.id,\n    createdUser.id,\n  );\n\n  TestValidator.equals(\n    \"admin updated display_name\",\n    updatedUser.display_name,\n    newDisplayName,\n  );\n\n  // Ensure account_status is present and is a string (server-managed field)\n  TestValidator.predicate(\n    \"account_status exists and is a string\",\n    typeof updatedUser.account_status === \"string\",\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/users/{userId}","method":"put"},"draft":"Admin attempts to change is_super flag but caller is not a super-admin: expect 403 Forbidden. Workflow: 1) Create two admin accounts via POST /auth/admin/join: one non-super admin (the caller) and one target admin. 2) Authenticate as the non-super admin and call PUT /todoApp/admin/users/{userId} attempting to set is_super=true. 3) Expect 403 Forbidden due to insufficient privileges to change is_super. 4) Verify that the target's is_super flag remains unchanged. This validates enforcement of super-admin-only constraints for sensitive fields.","functionName":"test_api_admin_update_user_forbidden_change_is_super_by_non_super","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create admin accounts (non-super caller and target admin) via repeated POST /auth/admin/join calls at runtime; tests will authenticate as the non-super admin to attempt is_super change and validate privilege checks."}]},"location":"test/features/api/admin/test_api_admin_update_user_forbidden_change_is_super_by_non_super.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/*\n * Production-ready E2E test: non-super admin cannot create a super-admin\n *\n * Rationale: Original scenario attempted to change `is_super` via PUT /todoApp/admin/users/{userId},\n * but ITodoAppUser.IUpdate does not contain `is_super`. This test therefore\n * verifies the same privilege protection by attempting to create a super-admin\n * (is_super: true) while authenticated as a non-super admin using\n * POST /auth/admin/join. The backend should prevent privilege escalation; the\n * test asserts that the operation fails (via TestValidator.error) and that an\n * existing target admin's is_super flag remains unchanged.\n */\nexport async function test_api_admin_update_user_forbidden_change_is_super_by_non_super(\n  connection: api.IConnection,\n) {\n  // Use per-session connection clones to avoid mutating provided connection.headers\n  const callerConn: api.IConnection = { ...connection, headers: {} };\n  const targetConn: api.IConnection = { ...connection, headers: {} };\n\n  // 1) Create non-super admin (caller)\n  const callerEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const caller: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(callerConn, {\n      body: {\n        email: callerEmail,\n        password: \"P@ssw0rd\",\n        is_super: false,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(caller);\n  TestValidator.predicate(\"caller is non-super\", caller.is_super === false);\n\n  // 2) Create a normal target admin (target)\n  const targetEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const target: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(targetConn, {\n      body: {\n        email: targetEmail,\n        password: \"P@ssw0rd\",\n        is_super: false,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(target);\n  TestValidator.predicate(\n    \"target initially non-super\",\n    target.is_super === false,\n  );\n\n  // 3) Attempt to create a super-admin while authenticated as non-super caller\n  const attemptedSuperEmail: string = typia.random<\n    string & tags.Format<\"email\">\n  >();\n  await TestValidator.error(\n    \"non-super caller cannot create a super-admin\",\n    async () => {\n      await api.functional.auth.admin.join(callerConn, {\n        body: {\n          email: attemptedSuperEmail,\n          password: \"P@ssw0rd\",\n          is_super: true,\n        } satisfies ITodoAppAdmin.ICreate,\n      });\n    },\n  );\n\n  // 4) Confirm the pre-created target's is_super remains false\n  TestValidator.equals(\"target is_super unchanged\", target.is_super, false);\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/users/{userId}","method":"put"},"draft":"Admin update of a non-existent user id should return 404. Workflow: 1) Create an admin via POST /auth/admin/join to obtain admin auth. 2) Generate a valid UUID that does not map to any user. 3) Call PUT /todoApp/admin/users/{nonExistentUserId} with a valid admin token to attempt update. 4) Expect 404 Not Found and an error body clarifying the resource was not found. This validates admin flows correctly handle missing targets without leaking other state.","functionName":"test_api_admin_update_user_not_found","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Authenticate as admin (join) so the request is authorized while the target user id does not exist, exercising 404 handling for admin updates."}]},"location":"test/features/api/user/test_api_admin_update_user_not_found.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_admin_update_user_not_found(\n  connection: api.IConnection,\n) {\n  /**\n   * Purpose:\n   *\n   * - Ensure admin update endpoint gracefully handles attempts to update a user\n   *   that does not exist.\n   *\n   * Workflow:\n   *\n   * 1. Create (join) an admin account to obtain authorization.\n   * 2. Generate a valid UUID that (very likely) does not map to any user.\n   * 3. Attempt to PUT an update for that UUID and assert that the call fails\n   *    (throws an error).\n   */\n\n  // 1) Create an admin account (SDK will set Authorization header on success)\n  const adminBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"P@ssw0rd123\",\n    is_super: false,\n  } satisfies ITodoAppAdmin.ICreate;\n\n  const admin: ITodoAppAdmin.IAuthorized = await api.functional.auth.admin.join(\n    connection,\n    {\n      body: adminBody,\n    },\n  );\n  typia.assert(admin);\n\n  // 2) Generate a random UUID that should not exist in the system\n  const nonExistentUserId = typia.random<string & tags.Format<\"uuid\">>();\n\n  // 3) Prepare a valid update body for admin update (only allowed fields)\n  const updateBody = {\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.IUpdate;\n\n  // 4) Attempt the update and assert an error is thrown (server should reject)\n  await TestValidator.error(\n    \"admin update non-existent user should fail\",\n    async () => {\n      await api.functional.todoApp.admin.users.update(connection, {\n        userId: nonExistentUserId,\n        body: updateBody,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoApp/admin/users/{userId}","method":"put"},"draft":"Ensure admin audit requirement: privileged update generates audit entry and does not expose password_hash. Workflow: 1) Create admin via POST /auth/admin/join and create target user via POST /auth/user/join. 2) As admin, call PUT /todoApp/admin/users/{userId} to modify display_name or account_status. 3) Expect 200 OK and response with safe user fields (no password_hash). 4) If possible within test harness, query admin audit records or rely on server-provided indication that the action was audited. 5) Verify updated_at changed appropriately and sensitive fields are absent. This validates audit and response hygiene for admin updates.","functionName":"test_api_admin_update_user_audit_and_response_hygiene","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Create an admin account and obtain admin access token for performing the privileged update; audit side-effect is expected from this action."},{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create the user whose profile will be updated so the admin action can be audited and response hygiene validated."}]},"location":"test/features/api/user/test_api_admin_update_user_audit_and_response_hygiene.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_admin_update_user_audit_and_response_hygiene(\n  connection: api.IConnection,\n) {\n  // 1) Create a regular user (public join)\n  const userEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const userAuth: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: {\n        email: userEmail,\n        password: \"UserPass123!\",\n        display_name: RandomGenerator.name(),\n      } satisfies ITodoAppUser.ICreate,\n    });\n  typia.assert(userAuth);\n\n  // Store original created/updated timestamps for later comparison\n  const originalCreatedAt = userAuth.created_at;\n  const originalUpdatedAt = userAuth.updated_at;\n\n  // 2) Create an admin account so the connection becomes authenticated as admin\n  const adminEmail: string = typia.random<string & tags.Format<\"email\">>();\n  const adminAuth: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(connection, {\n      body: {\n        email: adminEmail,\n        password: \"AdminPass123!\",\n        is_super: true,\n      } satisfies ITodoAppAdmin.ICreate,\n    });\n  typia.assert(adminAuth);\n\n  // 3) Perform admin update: change display_name only (IUpdate allows display_name)\n  const newDisplayName = RandomGenerator.name();\n  const updated: ITodoAppUser = await api.functional.todoApp.admin.users.update(\n    connection,\n    {\n      userId: userAuth.id,\n      body: {\n        display_name: newDisplayName,\n      } satisfies ITodoAppUser.IUpdate,\n    },\n  );\n  typia.assert(updated);\n\n  // 4) Business assertions\n  TestValidator.equals(\n    \"display_name updated\",\n    updated.display_name,\n    newDisplayName,\n  );\n  TestValidator.equals(\n    \"email remains unchanged\",\n    updated.email,\n    userAuth.email,\n  );\n\n  // updated_at should be greater than or equal to created_at\n  TestValidator.predicate(\n    \"updated_at is not older than created_at\",\n    new Date(updated.updated_at) >= new Date(updated.created_at),\n  );\n\n  // Ensure response does not expose password_hash (response hygiene)\n  TestValidator.predicate(\n    \"response does not expose password_hash\",\n    Object.prototype.hasOwnProperty.call(updated, \"password_hash\") === false,\n  );\n\n  // 5) Negative test: updating a non-existent user should throw (404 or similar)\n  await TestValidator.error(\n    \"updating non-existent user should fail\",\n    async () => {\n      await api.functional.todoApp.admin.users.update(connection, {\n        userId: typia.random<string & tags.Format<\"uuid\">>(),\n        body: { display_name: \"ghost\" } satisfies ITodoAppUser.IUpdate,\n      });\n    },\n  );\n\n  // Note: Audit record verification is not possible without a dedicated audit\n  // listing endpoint. In environments exposing audit endpoints, add a step to\n  // query the admin audit log and assert an entry like:\n  // { admin_id: adminAuth.id, action_type: 'update_user', target_id: userAuth.id }\n}\n"},{"scenario":{"endpoint":{"method":"get","path":"/todoApp/user/users/{userId}"},"draft":"Verify that an authenticated user can retrieve their own profile.\n\nSteps:\n1) Call POST /auth/user/join to register a new user (capture returned userId and access token).\n2) Call GET /todoApp/user/users/{userId} with the owner's access token and path param set to the created userId.\n\nAssertions:\n- Response status 200.\n- Response body contains id equal to created userId, email and display_name fields present if provided at join, account_status, created_at and updated_at fields present.\n- Sensitive fields such as password_hash MUST NOT be present.\n- created_at and updated_at are ISO 8601 strings and updated_at >= created_at.\n\nNotes: The test should perform no teardown beyond test isolation assumptions (use unique test data or fresh DB).","functionName":"test_api_user_profile_retrieve_own","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as user (join) and create the owner account used to call the GET endpoint."}]},"location":"test/features/api/user/test_api_user_profile_retrieve_own.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_user_profile_retrieve_own(\n  connection: api.IConnection,\n) {\n  // 1) Prepare registration body with valid types\n  const createBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"Password123!\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  // 2) Register (join) a new user. SDK will set connection.headers.Authorization\n  const authorized: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, { body: createBody });\n  typia.assert(authorized);\n\n  // 3) Fetch the user profile by ID using the same connection (authenticated)\n  const profile: ITodoAppUser = await api.functional.todoApp.user.users.at(\n    connection,\n    { userId: authorized.id },\n  );\n  typia.assert(profile);\n\n  // 4) Assertions: id matches\n  TestValidator.equals(\n    \"retrieved user id matches created id\",\n    profile.id,\n    authorized.id,\n  );\n\n  // 5) Assertions: email present and is a string (business-level presence)\n  TestValidator.predicate(\n    \"profile contains email\",\n    typeof profile.email === \"string\",\n  );\n\n  // 6) If display_name was provided at join, it should be present or nullable\n  TestValidator.predicate(\n    \"display_name matches input or is null\",\n    profile.display_name === createBody.display_name ||\n      profile.display_name === null,\n  );\n\n  // 7) Sensitive fields such as password_hash MUST NOT be present in the profile response\n  // (The DTO does not contain password_hash; ensure it's not present at runtime)\n  TestValidator.predicate(\n    \"sensitive field password_hash not exposed\",\n    !(\"password_hash\" in (profile as Record<string, unknown>)),\n  );\n\n  // 8) created_at and updated_at formats are validated by typia.assert. Verify updated_at >= created_at\n  const createdAt = new Date(profile.created_at);\n  const updatedAt = new Date(profile.updated_at);\n  TestValidator.predicate(\n    \"updated_at is greater than or equal to created_at\",\n    updatedAt.getTime() >= createdAt.getTime(),\n  );\n}\n"},{"scenario":{"endpoint":{"method":"get","path":"/todoApp/user/users/{userId}"},"draft":"Validate API returns 400 Bad Request for malformed userId path parameter.\n\nSteps:\n1) Call POST /auth/user/join to obtain a valid user access token.\n2) Call GET /todoApp/user/users/{userId} using the owner's access token but set the path parameter to an invalid UUID string (e.g., 'not-a-uuid').\n\nAssertions:\n- Response status 400.\n- Response body contains an error code/message indicating invalid UUID format.\n\nPurpose: Ensures server validates path UUID format and returns 400 for malformed identifiers.","functionName":"test_api_user_profile_get_invalid_uuid","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a user (join) to make the request in an authenticated context required by the endpoint."}]},"location":"test/features/api/user/test_api_user_profile_get_invalid_uuid.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Validate GET /todoApp/user/users/{userId} rejects malformed UUID path\n * parameter.\n *\n * Business purpose: Ensures server-side parameter validation prevents malformed\n * identifiers from being processed. A malformed UUID should cause the endpoint\n * to reject the request and produce an error (400 Bad Request).\n *\n * Steps:\n *\n * 1. Register a user via POST /auth/user/join to obtain an authorized session.\n * 2. Assert the join response shape with typia.assert.\n * 3. Attempt to GET the user profile with a malformed userId (\"not-a-uuid\").\n * 4. Assert that the call fails (TestValidator.error) indicating server-side\n *    validation rejected the malformed UUID.\n */\nexport async function test_api_user_profile_get_invalid_uuid(\n  connection: api.IConnection,\n) {\n  // 1) Prepare registration body using correct DTO shape\n  const joinBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: RandomGenerator.alphaNumeric(12),\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  // 2) Register (or join) the user. This call also sets connection.headers.Authorization internally.\n  const auth: ITodoAppUser.IAuthorized = await api.functional.auth.user.join(\n    connection,\n    {\n      body: joinBody,\n    },\n  );\n  typia.assert(auth);\n\n  // 3) Attempt to get user profile with malformed UUID and expect an error\n  await TestValidator.error(\n    \"getting user profile with malformed UUID should fail\",\n    async () => {\n      await api.functional.todoApp.user.users.at(connection, {\n        userId: \"not-a-uuid\",\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"method":"get","path":"/todoApp/user/users/{userId}"},"draft":"Verify 404 Not Found is returned when requesting a non-existent userId.\n\nSteps:\n1) Call POST /auth/user/join to obtain an access token (authentication required by the endpoint).\n2) Generate a valid UUID that does not correspond to any user in the system.\n3) Call GET /todoApp/user/users/{userId} with the valid-but-nonexistent UUID and the authenticated token.\n\nAssertions:\n- Response status 404.\n- Response body contains not-found error code/message.\n\nPurpose: Confirms the endpoint returns 404 for missing resources.","functionName":"test_api_user_profile_get_not_found","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as a user (join) to satisfy the endpoint's required authentication even when testing a missing resource."}]},"location":"test/features/api/todo_app_user/test_api_user_profile_get_not_found.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Verify 404 Not Found is returned when requesting a non-existent userId.\n *\n * Steps:\n *\n * 1. Register a fresh user via POST /auth/user/join to obtain authentication\n *    token.\n * 2. Generate a valid UUID that does not match the created user's id.\n * 3. Call GET /todoApp/user/users/{userId} with the generated UUID and expect 404.\n *\n * Purpose: Confirms the endpoint returns 404 for missing resources and that\n * authentication is required and handled by the SDK's join call.\n */\nexport async function test_api_user_profile_get_not_found(\n  connection: api.IConnection,\n) {\n  // 1) Register a fresh user to satisfy authentication requirement\n  const joinBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"Password1234\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const authorized: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: joinBody,\n    });\n  typia.assert(authorized);\n\n  // Ensure we have a valid created user id\n  const createdUserId: string & tags.Format<\"uuid\"> = authorized.id;\n\n  // 2) Generate a valid UUID that is not the created user's id\n  let nonExistentId = typia.random<string & tags.Format<\"uuid\">>();\n  // Extremely unlikely, but guard against collision with created user's id\n  if (nonExistentId === createdUserId) {\n    nonExistentId = typia.random<string & tags.Format<\"uuid\">>();\n    // If it still equals (virtually impossible), use a simple fallback loop\n    while (nonExistentId === createdUserId) {\n      nonExistentId = typia.random<string & tags.Format<\"uuid\">>();\n    }\n  }\n\n  // 3) Call GET /todoApp/user/users/{userId} and expect 404 Not Found\n  await TestValidator.httpError(\n    \"requesting non-existent user should return 404\",\n    404,\n    async () => {\n      await api.functional.todoApp.user.users.at(connection, {\n        userId: nonExistentId,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"method":"get","path":"/todoApp/user/users/{userId}"},"draft":"Ensure a user cannot retrieve another user's private profile (403 Forbidden).\n\nSteps:\n1) Call POST /auth/user/join twice to create two distinct users (Owner A and Caller B). Capture both userIds and access tokens.\n2) Using Caller B's token, call GET /todoApp/user/users/{userId} with path param set to Owner A's userId.\n\nAssertions:\n- Response status 403.\n- Response body contains forbidden error code/message.\n\nPurpose: Validates ownership enforcement so that only the owner (or an admin) can retrieve a user's profile.","functionName":"test_api_user_profile_get_forbidden_other_user","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create test user accounts. Note: the test implementation must invoke this join operation twice to produce Owner A and Caller B (two distinct user accounts) and obtain their tokens."}]},"location":"test/features/api/user/test_api_user_profile_get_forbidden_other_user.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_user_profile_get_forbidden_other_user(\n  connection: api.IConnection,\n) {\n  // 1) Prepare two isolated connections so that SDK-set Authorization headers\n  //    do not interfere with each other or with the provided connection.\n  const ownerConn: api.IConnection = { ...connection, headers: {} };\n  const callerConn: api.IConnection = { ...connection, headers: {} };\n\n  // 2) Create Owner A via POST /auth/user/join\n  const ownerEmail = typia.random<string & tags.Format<\"email\">>();\n  const ownerBody = {\n    email: ownerEmail,\n    password: \"Password123!\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const ownerAuth: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(ownerConn, {\n      body: ownerBody,\n    });\n  typia.assert(ownerAuth);\n\n  // 3) Create Caller B via POST /auth/user/join\n  const callerEmail = typia.random<string & tags.Format<\"email\">>();\n  const callerBody = {\n    email: callerEmail,\n    password: \"Password123!\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const callerAuth: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(callerConn, {\n      body: callerBody,\n    });\n  typia.assert(callerAuth);\n\n  // 4) Caller B (authenticated via callerConn) attempts to read Owner A's profile\n  //    Expectation: 403 Forbidden. Use TestValidator.httpError to validate the\n  //    HTTP error status code.\n  await TestValidator.httpError(\n    \"caller cannot retrieve another user's private profile\",\n    403,\n    async () => {\n      await api.functional.todoApp.user.users.at(callerConn, {\n        userId: ownerAuth.id,\n      });\n    },\n  );\n\n  // 5) Confirm Owner A can retrieve their own profile successfully\n  const ownerProfile: ITodoAppUser = await api.functional.todoApp.user.users.at(\n    ownerConn,\n    {\n      userId: ownerAuth.id,\n    },\n  );\n  typia.assert(ownerProfile);\n  TestValidator.equals(\n    \"owner can retrieve own profile\",\n    ownerProfile.id,\n    ownerAuth.id,\n  );\n}\n"},{"scenario":{"endpoint":{"method":"get","path":"/todoApp/admin/users/{userId}"},"draft":"Verify an authenticated admin can retrieve a user's profile and that admin access is auditable.\n\nSteps:\n1) Call POST /auth/admin/join to register a new admin and obtain admin access token.\n2) Call POST /auth/user/join to create a target user and capture the target userId.\n3) Using the admin access token, call GET /todoApp/admin/users/{userId} with path param set to the created userId.\n\nAssertions:\n- Response status 200.\n- Response body contains the user id equal to the created userId and public profile fields (email, display_name, account_status, created_at, updated_at).\n- Response MUST NOT include password_hash.\n- If an audit-record retrieval endpoint is available in the test environment, validate an audit entry for this admin access; otherwise note audit logging is expected by the service.\n\nPurpose: Confirms admin-scoped retrieval, sensitive-field redaction, and audit-record expectation.","functionName":"test_api_admin_user_retrieve_success","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Authenticate as admin (join) to obtain an admin access token for performing the admin-scoped retrieval. Authentication for admin role must precede the admin-scoped GET call."},{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create the target user account that the admin will retrieve; obtain the target userId used in the GET request."}]},"location":"test/features/api/user/test_api_admin_user_retrieve_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\n/**\n * Validate that an administrator can retrieve a user's public profile via\n * admin-scoped endpoint and that sensitive fields are not exposed.\n *\n * Steps:\n *\n * 1. Create a new admin account via POST /auth/admin/join (adminConn).\n * 2. Create a new regular user via POST /auth/user/join (userConn).\n * 3. Using adminConn (which contains admin's token), call GET\n *    /todoApp/admin/users/:userId to retrieve the created user's profile.\n *\n * Assertions:\n *\n * - Response is a valid ITodoAppUser (typia.assert)\n * - Returned id equals the created user's id\n * - Returned email equals the created user's email\n * - Response MUST NOT include any sensitive secret such as `password_hash`\n * - Updated_at is greater than or equal to created_at\n *\n * Note: Audit-record verification is expected by the service but no audit\n * retrieval API is available in the provided SDK. If an audit endpoint exists\n * in the environment, a separate assertion should validate an audit record for\n * this admin access.\n */\nexport async function test_api_admin_user_retrieve_success(\n  connection: api.IConnection,\n) {\n  // 1) Prepare a separate connection for admin to avoid overwriting the main connection headers\n  const adminConn: api.IConnection = { ...connection, headers: {} };\n\n  // 2) Create admin account\n  const adminBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"AdminPass123!\",\n    is_super: true,\n  } satisfies ITodoAppAdmin.ICreate;\n\n  const adminAuthorized: ITodoAppAdmin.IAuthorized =\n    await api.functional.auth.admin.join(adminConn, { body: adminBody });\n  typia.assert(adminAuthorized);\n\n  // 3) Prepare a separate connection for the normal user\n  const userConn: api.IConnection = { ...connection, headers: {} };\n\n  // 4) Create the target user that admin will retrieve\n  const userBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password: \"UserPass123!\",\n    display_name: RandomGenerator.name(),\n  } satisfies ITodoAppUser.ICreate;\n\n  const userAuthorized: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(userConn, { body: userBody });\n  typia.assert(userAuthorized);\n\n  // 5) Using adminConn (admin token was set on adminConn by the SDK join call), retrieve the user\n  const retrieved: ITodoAppUser = await api.functional.todoApp.admin.users.at(\n    adminConn,\n    {\n      userId: userAuthorized.id,\n    },\n  );\n  typia.assert(retrieved);\n\n  // 6) Business assertions\n  TestValidator.equals(\n    \"user id matches created user id\",\n    retrieved.id,\n    userAuthorized.id,\n  );\n  TestValidator.equals(\n    \"user email matches created email\",\n    retrieved.email,\n    userAuthorized.email,\n  );\n  TestValidator.predicate(\n    \"password_hash not exposed in response\",\n    !(\"password_hash\" in retrieved),\n  );\n\n  // 7) Timestamps: ensure updated_at is >= created_at\n  const createdAt = Date.parse(retrieved.created_at);\n  const updatedAt = Date.parse(retrieved.updated_at);\n  TestValidator.predicate(\n    \"updated_at should be >= created_at\",\n    updatedAt >= createdAt,\n  );\n\n  // 8) Display name equality (may be null depending on server policy). If server returns null,\n  //    the check below still validates that the returned value equals the created display_name.\n  TestValidator.equals(\n    \"display_name matches\",\n    retrieved.display_name ?? null,\n    userBody.display_name ?? null,\n  );\n\n  // 9) Audit record expectation:\n  // NOTE: The service should record an audit entry for admin reads (actor_role='admin', action_type='read_user').\n  // Since no audit retrieval SDK function is provided, we only document the expectation here. If an audit\n  // retrieval endpoint is available in the environment, a follow-up call should assert existence of the\n  // corresponding audit record referencing adminAuthorized.id and userAuthorized.id.\n}\n"},{"scenario":{"endpoint":{"method":"get","path":"/todoApp/admin/users/{userId}"},"draft":"Validate API returns 400 Bad Request when admin supplies a malformed UUID.\n\nSteps:\n1) Call POST /auth/admin/join to obtain admin access token.\n2) Call GET /todoApp/admin/users/{userId} using admin token but set path parameter to invalid UUID string (e.g., 'invalid-uuid').\n\nAssertions:\n- Response status 400.\n- Response body contains an error indicating malformed UUID.\n\nPurpose: Ensures server validates path UUID format for the admin endpoint.","functionName":"test_api_admin_user_retrieve_invalid_uuid","dependencies":[{"endpoint":{"method":"post","path":"/auth/admin/join"},"purpose":"Authenticate as an admin (join) so the request is made in an authenticated admin context required by the endpoint."}]},"location":"test/features/api/todo_app_user/test_api_admin_user_retrieve_invalid_uuid.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_admin_user_retrieve_invalid_uuid(\n  connection: api.IConnection,\n) {\n  // Purpose: Ensure admin-only user retrieval endpoint validates UUID path parameter\n  // 1) Create (join) an admin to obtain authentication context\n  const adminEmail = typia.random<string & tags.Format<\"email\">>();\n\n  const admin: ITodoAppAdmin.IAuthorized = await api.functional.auth.admin.join(\n    connection,\n    {\n      body: {\n        email: adminEmail,\n        password: \"P@ssw0rd\",\n        is_super: false,\n      } satisfies ITodoAppAdmin.ICreate,\n    },\n  );\n  typia.assert(admin);\n\n  // 2) Attempt to retrieve a user with a malformed UUID and expect HTTP 400\n  await TestValidator.httpError(\n    \"admin user retrieval with malformed UUID should return 400\",\n    400,\n    async () => {\n      await api.functional.todoApp.admin.users.at(connection, {\n        userId: \"invalid-uuid\",\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"method":"get","path":"/todoApp/admin/users/{userId}"},"draft":"Ensure non-admin users are not allowed to call the admin retrieval endpoint (403 Forbidden).\n\nSteps:\n1) Call POST /auth/user/join to create a normal user and obtain their access token (Caller B).\n2) Create a target user (via POST /auth/user/join) or reuse an existing userId for the retrieval target.\n3) Using the normal user's token, call GET /todoApp/admin/users/{userId} with the target userId.\n\nAssertions:\n- Response status 403.\n- Response body contains forbidden error code/message.\n\nPurpose: Validates that admin-only endpoints enforce role-based access control.","functionName":"test_api_admin_user_retrieve_forbidden_non_admin","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create the non-admin caller account (join) to use its token when attempting to access the admin-only endpoint. Also create the target user account if needed. No admin join is required for this negative test."}]},"location":"test/features/api/todo_app_user/test_api_admin_user_retrieve_forbidden_non_admin.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\n\nexport async function test_api_admin_user_retrieve_forbidden_non_admin(\n  connection: api.IConnection,\n) {\n  // 1) Create the target user (the one we will try to retrieve via admin endpoint)\n  const targetUser: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: {\n        email: typia.random<string & tags.Format<\"email\">>(),\n        password: RandomGenerator.alphaNumeric(12),\n        display_name: RandomGenerator.name(),\n      } satisfies ITodoAppUser.ICreate,\n    });\n  typia.assert(targetUser);\n\n  // 2) Create the caller user (a normal non-admin account). After this call,\n  //    connection will be authenticated as this non-admin user (SDK automatically\n  //    sets connection.headers.Authorization to returned token.access).\n  const callerUser: ITodoAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: {\n        email: typia.random<string & tags.Format<\"email\">>(),\n        password: RandomGenerator.alphaNumeric(12),\n        display_name: RandomGenerator.name(),\n      } satisfies ITodoAppUser.ICreate,\n    });\n  typia.assert(callerUser);\n\n  // 3) Attempt to call the admin-only endpoint using the non-admin caller.\n  //    Expect an HTTP 403 Forbidden error.\n  await TestValidator.httpError(\n    \"non-admin cannot retrieve admin user\",\n    403,\n    async () => {\n      await api.functional.todoApp.admin.users.at(connection, {\n        userId: targetUser.id,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/guest/join","method":"post"},"draft":"Register a new guest via POST /auth/guest/join and verify the service issues an authorization payload and persists a guest record. Steps: 1) Send POST /auth/guest/join with either an optional valid email (e.g., \"test-guest+<random>@example.com\") or an empty body to create an anonymous guest. 2) Expect HTTP 201 Created (allow 200 if server uses that) with an authorization payload containing accessToken and refreshToken (or equivalent). 3) Assert response body contains a guest id (UUID) and createdAt timestamp in ISO 8601 format; do not assert exact timestamp. 4) Verify at least that the refresh token can be submitted to POST /auth/guest/refresh (token structure and acceptance) or that the returned access token is structurally valid for downstream guest-scoped calls. Purpose: Validate happy-path guest join, token issuance, and minimal persisted guest metadata.","functionName":"test_api_guest_join_success","dependencies":[]},"location":"test/features/api/guest/test_api_guest_join_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppGuest } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppGuest\";\n\nexport async function test_api_guest_join_success(connection: api.IConnection) {\n  /**\n   * E2E test for POST /auth/guest/join - happy path and anonymous join.\n   *\n   * Steps:\n   *\n   * 1. Create a guest with a valid email and validate returned authorization\n   *    payload and persisted guest metadata.\n   * 2. Create an anonymous guest (no email) and validate returned payload.\n   * 3. Verify token structural properties and parseability of timestamps.\n   * 4. Ensure two created guest ids are distinct.\n   */\n\n  // 1) Guest join with provided email\n  const email: string = typia.random<string & tags.Format<\"email\">>();\n\n  const authorizedWithEmail: ITodoAppGuest.IAuthorized =\n    await api.functional.auth.guest.join(connection, {\n      body: { email } satisfies ITodoAppGuest.IJoin,\n    });\n  // Runtime type validation\n  typia.assert(authorizedWithEmail);\n\n  // Business validations\n  TestValidator.equals(\n    \"returned email matches input\",\n    authorizedWithEmail.email,\n    email,\n  );\n\n  TestValidator.predicate(\n    \"access token present\",\n    typeof authorizedWithEmail.token.access === \"string\" &&\n      authorizedWithEmail.token.access.length > 0,\n  );\n\n  TestValidator.predicate(\n    \"refresh token present\",\n    typeof authorizedWithEmail.token.refresh === \"string\" &&\n      authorizedWithEmail.token.refresh.length > 0,\n  );\n\n  TestValidator.predicate(\n    \"created_at is parseable ISO 8601\",\n    !Number.isNaN(Date.parse(authorizedWithEmail.created_at)),\n  );\n\n  TestValidator.predicate(\n    \"token.expired_at is parseable ISO 8601\",\n    !Number.isNaN(Date.parse(authorizedWithEmail.token.expired_at)),\n  );\n\n  TestValidator.predicate(\n    \"token.refreshable_until is parseable ISO 8601\",\n    !Number.isNaN(Date.parse(authorizedWithEmail.token.refreshable_until)),\n  );\n\n  // 2) Anonymous guest join (no email provided)\n  const authorizedAnonymous: ITodoAppGuest.IAuthorized =\n    await api.functional.auth.guest.join(connection, {\n      body: {} satisfies ITodoAppGuest.IJoin,\n    });\n  typia.assert(authorizedAnonymous);\n\n  TestValidator.predicate(\n    \"anonymous guest has null or undefined email\",\n    authorizedAnonymous.email === null ||\n      authorizedAnonymous.email === undefined,\n  );\n\n  // 3) Ensure two guest IDs are distinct\n  TestValidator.notEquals(\n    \"guest ids should be different for separate joins\",\n    authorizedWithEmail.id,\n    authorizedAnonymous.id,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/guest/refresh","method":"post"},"draft":"Exchange a valid guest refresh credential for a renewed access token and verify guest activity metadata updates. Steps: 1) Create a guest via POST /auth/guest/join and capture the initial refresh token and guest id. 2) Send POST /auth/guest/refresh with the captured refresh token. 3) Expect HTTP 200 OK with a new access token (and possibly a rotated refresh token). 4) Assert the response contains tokens and the guest id. 5) If the API exposes guest metadata, verify last_active_at (or equivalent) is updated and is >= createdAt. 6) Confirm the new access token is usable for a guest-scoped smoke call if such an endpoint exists. Purpose: Validate refresh token exchange, token rotation behavior, and last-active metadata.","functionName":"test_api_guest_refresh_success","dependencies":[{"endpoint":{"path":"/auth/guest/join","method":"post"},"purpose":"Authenticate/create a guest and obtain the initial refresh token required for refresh testing."}]},"location":"test/features/api/auth_guest/test_api_guest_refresh_success.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppGuest } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppGuest\";\n\nexport async function test_api_guest_refresh_success(\n  connection: api.IConnection,\n) {\n  // 1) Create a guest via POST /auth/guest/join and capture initial tokens\n  const joinBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n  } satisfies ITodoAppGuest.IJoin;\n  const created: ITodoAppGuest.IAuthorized =\n    await api.functional.auth.guest.join(connection, { body: joinBody });\n  // Runtime type validation\n  typia.assert(created);\n\n  // Basic assertions about join response\n  TestValidator.predicate(\n    \"join: issued refresh token exists\",\n    typeof created.token?.refresh === \"string\" &&\n      created.token.refresh.length > 0,\n  );\n  TestValidator.predicate(\n    \"join: issued access token exists\",\n    typeof created.token?.access === \"string\" &&\n      created.token.access.length > 0,\n  );\n\n  // 2) Exchange the captured refresh token for renewed tokens\n  const refreshRequest = {\n    refresh_token: created.token.refresh,\n  } satisfies ITodoAppGuest.IRefresh;\n  const refreshed: ITodoAppGuest.IAuthorized =\n    await api.functional.auth.guest.refresh(connection, {\n      body: refreshRequest,\n    });\n  typia.assert(refreshed);\n\n  // Validate business expectations after refresh\n  TestValidator.equals(\n    \"refresh: guest id remains the same\",\n    refreshed.id,\n    created.id,\n  );\n  TestValidator.predicate(\n    \"refresh: returned access token is present\",\n    typeof refreshed.token?.access === \"string\" &&\n      refreshed.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"refresh: returned refresh token is present\",\n    typeof refreshed.token?.refresh === \"string\" &&\n      refreshed.token.refresh.length > 0,\n  );\n\n  // If last_active_at is present, assert it is >= created_at\n  if (\n    refreshed.last_active_at === null ||\n    refreshed.last_active_at === undefined\n  ) {\n    // last_active_at may legitimately be null depending on implementation; record predicate accordingly\n    TestValidator.predicate(\n      \"refresh: last_active_at is null or updated\",\n      refreshed.last_active_at === null ||\n        refreshed.last_active_at === undefined,\n    );\n  } else {\n    const createdAt = new Date(created.created_at).getTime();\n    const lastActiveAt = new Date(refreshed.last_active_at).getTime();\n    TestValidator.predicate(\n      \"refresh: last_active_at is >= created_at\",\n      lastActiveAt >= createdAt,\n    );\n  }\n\n  // 3) Smoke-check token usability: attempt to refresh again using the newly issued refresh token\n  const secondRefreshRequest = {\n    refresh_token: refreshed.token.refresh,\n  } satisfies ITodoAppGuest.IRefresh;\n  const rotated: ITodoAppGuest.IAuthorized =\n    await api.functional.auth.guest.refresh(connection, {\n      body: secondRefreshRequest,\n    });\n  typia.assert(rotated);\n\n  TestValidator.equals(\n    \"second refresh: guest id remains the same\",\n    rotated.id,\n    created.id,\n  );\n  TestValidator.predicate(\n    \"second refresh: access token present\",\n    typeof rotated.token?.access === \"string\" &&\n      rotated.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"second refresh: refresh token present\",\n    typeof rotated.token?.refresh === \"string\" &&\n      rotated.token.refresh.length > 0,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/auth/guest/refresh","method":"post"},"draft":"Ensure the refresh endpoint correctly rejects invalid, malformed, or expired refresh tokens. Steps: 1) Create a guest via POST /auth/guest/join and obtain a valid refresh token. 2) Tamper with the refresh token (or use an obviously malformed token) or wait for expiry if practical. 3) Send POST /auth/guest/refresh with the invalid/expired token. 4) Expect HTTP 401 Unauthorized or HTTP 400 with an authentication/validation error and no tokens returned. 5) Assert that guest last_active_at is not updated as a result of the failed refresh (if metadata is accessible). Purpose: Validate error handling and security for token refresh attempts.","functionName":"test_api_guest_refresh_invalid_token","dependencies":[{"endpoint":{"path":"/auth/guest/join","method":"post"},"purpose":"Authenticate/create a guest and obtain a valid refresh token to be tampered with for invalid-token testing."}]},"location":"test/features/api/auth/test_api_guest_refresh_invalid_token.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoAppGuest } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppGuest\";\n\nexport async function test_api_guest_refresh_invalid_token(\n  connection: api.IConnection,\n) {\n  /**\n   * Test scenario: Verify that POST /auth/guest/refresh rejects invalid or\n   * tampered refresh tokens.\n   *\n   * Steps:\n   *\n   * 1. Create a guest via POST /auth/guest/join and obtain the issued tokens.\n   * 2. Attempt refresh with an obviously malformed token string.\n   * 3. Attempt refresh with a tampered refresh token derived from the valid one.\n   * 4. Expect both attempts to throw (use TestValidator.error). Do NOT assert\n   *    specific HTTP status codes or manipulate connection.headers.\n   *\n   * Notes:\n   *\n   * - Because no guest metadata read endpoint is available in the provided SDK,\n   *   this test cannot re-query guest.last_active_at to confirm it was not\n   *   updated. If such an endpoint exists in the environment, a follow-up check\n   *   can be added to ensure last_active_at remains unchanged after failed\n   *   attempts.\n   */\n\n  // 1) Create a guest and obtain valid tokens\n  const guest: ITodoAppGuest.IAuthorized = await api.functional.auth.guest.join(\n    connection,\n    {\n      body: {\n        email: typia.random<string & tags.Format<\"email\">>(),\n      } satisfies ITodoAppGuest.IJoin,\n    },\n  );\n  // Runtime type validation of the returned payload\n  typia.assert(guest);\n\n  // Capture the valid refresh token for tampering\n  const validRefreshToken: string = guest.token.refresh;\n\n  // 2) Malformed token (clearly invalid format) → expect error\n  await TestValidator.error(\n    \"refresh with malformed token should be rejected\",\n    async () => {\n      await api.functional.auth.guest.refresh(connection, {\n        body: {\n          refresh_token: \"not-a-valid-token\",\n        } satisfies ITodoAppGuest.IRefresh,\n      });\n    },\n  );\n\n  // 3) Tampered token (valid-looking but modified) → expect error\n  const tamperedToken: string = `${validRefreshToken}.tampered`;\n  await TestValidator.error(\n    \"refresh with tampered token should be rejected\",\n    async () => {\n      await api.functional.auth.guest.refresh(connection, {\n        body: {\n          refresh_token: tamperedToken,\n        } satisfies ITodoAppGuest.IRefresh,\n      });\n    },\n  );\n\n  // 4) Note: cannot assert last_active_at because no guest retrieval API\n  // is available from the given SDK. If a GET endpoint for guest metadata\n  // becomes available, insert a re-query here and assert that\n  // last_active_at did not change after the failed refresh attempts.\n}\n"}],"compiled":{"type":"success"},"created_at":"2025-10-07T19:57:09.557Z","completed_at":"2025-10-07T20:10:10.754Z","step":0},{"id":"0199c04b-b679-757b-81c1-87e02d63b233","type":"userMessage","contents":[{"type":"text","text":"Implement API functions."}],"created_at":"2025-10-07T20:10:11.449Z"},{"type":"realize","id":"0199c05a-3c1a-7775-a4e2-3d820ff02f5e","instruction":"Implement the API business logic for the minimal single-user Todo REST API defined earlier. Implementation-focused instructions only (no DB schema or API interface definitions — those are already done). Keep the implementation minimal and strictly limited to features the user already specified.\n\nRequirements/assumptions (only use what has been specified previously):\n- Single-user application, no authentication.\n- Endpoints to implement: GET /todos, POST /todos, GET /todos/{id}, PATCH /todos/{id}, DELETE /todos/{id}.\n- Todo fields: id (UUID), title (string, required), description (string, optional), isCompleted (boolean, default false), createdAt (DateTime), updatedAt (DateTime), position (integer, optional).\n- Use Prisma client to access the Todo model produced earlier (assume Prisma schema is available and prisma client generation step will be run by the developer).\n- Use TypeScript for server code.\n\nImplementation details and constraints (minimal, concrete):\n1. Project stack: Node.js + Express (or comparable minimal HTTP framework) + TypeScript + Prisma. Keep code simple and framework-idiomatic.\n2. Files to implement (deliver actual TypeScript code):\n   - src/server.ts (Express app bootstrap)\n   - src/routes/todos.ts (route definitions and handlers)\n   - src/services/todoService.ts (service layer interacting with Prisma client)\n   - src/validators/todoValidators.ts (simple request validation helpers)\n   - src/types.d.ts or DTO interfaces for request/response shapes (if needed)\n   - src/middleware/errorHandler.ts (centralized error handling to map exceptions to HTTP responses)\n3. Business logic rules:\n   - POST /todos: validate title is present and non-empty; create a Todo with provided fields; isCompleted defaults to false; return 201 with created Todo JSON.\n   - GET /todos: support optional query parameters: isCompleted (true/false), sort (createdAt or position) with optional order (asc/desc). Default sort: createdAt asc. Return 200 with array of Todos.\n   - GET /todos/{id}: return 200 with Todo if found, else 404.\n   - PATCH /todos/{id}: accept partial updates for title, description, isCompleted, position; validate fields when present (e.g., title non-empty if provided); update updatedAt; return 200 with updated Todo; if not found return 404.\n   - DELETE /todos/{id}: delete the Todo if exists and return 204; if not found return 404.\n4. Error handling and status codes:\n   - Validation errors: return 400 with a JSON error object {error: string, details?: any}.\n   - Not found: 404 with {error: 'Not Found'}.\n   - Unexpected errors: 500 with {error: 'Internal Server Error'}.\n5. Data handling and consistency:\n   - Use Prisma client methods for create/find/update/delete.\n   - Rely on Prisma's updatedAt @updatedAt behavior to set updatedAt; if not available, set updatedAt manually on updates.\n   - Ensure PATCH only modifies provided fields (do not overwrite omitted fields).\n6. Tests compatibility:\n   - Ensure responses include fields id, title, description (null or string), isCompleted (boolean), createdAt, updatedAt, position (null or integer) so the E2E tests can validate them.\n7. Performance/scale: Keep minimal; no caching required.\n8. Configuration:\n   - Read PORT and DATABASE_URL from environment variables; default PORT=3000.\n9. Deliverables:\n   - Provide the full TypeScript source code for the files listed in (2) implementing the above behavior.\n   - Include brief instructions to run the server locally (install deps, generate Prisma client, run migrations, start server).\n\nConstraints: Do NOT add extra features such as authentication, user model, tags, due dates, bulk operations, or background jobs. If any ambiguity exists, list questions at the end for the user to confirm before proceeding further.\n\nReturn the implementation files as plain TypeScript code snippets and the run instructions.","authorizations":[{"error_analysis":"TS2307 in src/MyGlobal.ts: Cannot find module './MyConfiguration' or its type declarations. This prevents compiling project even though provider/decorator files are correct. No other auth-specific diagnostics reported.","solution_guidance":"1) Fix or add ./MyConfiguration module: create src/MyConfiguration.ts exporting required config or correct import path in MyGlobal.ts. 2) Add a declaration file (e.g., src/@types/MyConfiguration.d.ts) if only types are missing. 3) Ensure GuestPayload is exported from src/decorators/payload/GuestPayload.ts. 4) Confirm Prisma client model name (todo_app_guest) exists. 5) Use provided corrected provider and decorator code below.","provider":{"name":"guestAuthorize","content":"import { ForbiddenException } from \"@nestjs/common\";\n\nimport { MyGlobal } from \"../../MyGlobal\";\nimport { jwtAuthorize } from \"./jwtAuthorize\";\nimport { GuestPayload } from \"../../decorators/payload/GuestPayload\";\n\n/**\n * Verify JWT, ensure role is 'guest', and validate the guest record exists and is active.\n */\nexport async function guestAuthorize(request: {\n  headers: { authorization?: string };\n}): Promise<GuestPayload> {\n  const payload = jwtAuthorize({ request }) as GuestPayload;\n\n  if (payload.type !== \"guest\") {\n    throw new ForbiddenException(`You're not ${payload.type}`);\n  }\n\n  // JWT payload.id contains the top-level user table ID (guest is top-level here)\n  const guest = await MyGlobal.prisma.todo_app_guest.findFirst({\n    where: {\n      id: payload.id,\n      OR: [{ status: \"active\" }, { status: null }],\n    },\n  });\n\n  if (guest === null) {\n    throw new ForbiddenException(\"You're not enrolled\");\n  }\n\n  return payload;\n}\n","location":"src/providers/authorize/guestAuthorize.ts"},"decorator":{"name":"GuestAuth","content":"import { SwaggerCustomizer } from \"@nestia/core\";\nimport { ExecutionContext, createParamDecorator } from \"@nestjs/common\";\nimport { Singleton } from \"tstl\";\n\nimport { guestAuthorize } from \"../providers/authorize/guestAuthorize\";\n\n/**\n * Parameter decorator to inject authenticated GuestPayload and add Bearer security to Swagger.\n */\nexport const GuestAuth =\n  (): ParameterDecorator =>\n  (\n    target: object,\n    propertyKey: string | symbol | undefined,\n    parameterIndex: number,\n  ): void => {\n    SwaggerCustomizer((props) => {\n      props.route.security ??= [];\n      props.route.security.push({ bearer: [] });\n    })(target, propertyKey as string, undefined!);\n    singleton.get()(target, propertyKey, parameterIndex);\n  };\n\nconst singleton = new Singleton(() =>\n  createParamDecorator(async (_data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return guestAuthorize(request);\n  })(),\n);\n","location":"src/decorators/GuestAuth.ts"},"payload":{"name":"GuestPayload","location":"src/decorators/payload/GuestPayload.ts","content":"import { tags } from \"typia\";\n\nexport interface GuestPayload {\n  /** Top-level user table ID (the fundamental user identifier in the system). */\n  id: string & tags.Format<\"uuid\">;\n\n  /** Discriminator for the discriminated union type. */\n  type: \"guest\";\n}\n"},"role":{"name":"guest","description":"Unauthenticated visitor who can view public landing information and help content but cannot create, view, modify, or delete todos. Guests cannot authenticate via API and have no persistent personal data.","kind":"guest"}},{"error_analysis":"TypeScript error: src/MyGlobal.ts cannot find module './MyConfiguration'. Root cause: missing or wrongly named configuration module referenced by MyGlobal.ts. No other compilation diagnostics provided; provider/decorator code also reviewed for path and model correctness.","solution_guidance":"1) Add a file src/MyConfiguration.ts exporting the configuration used by MyGlobal (or correct the import path in src/MyGlobal.ts to the actual config filename). 2) Ensure src/MyGlobal.ts exports MyGlobal with .env and prisma client. 3) Confirm jwtAuthorize import uses \"./jwtAuthorize\" in providers/authorize. 4) Verify Prisma model access is MyGlobal.prisma.todo_app_user. 5) Re-run tsc.","provider":{"name":"userAuthorize","content":"import { ForbiddenException } from \"@nestjs/common\";\n\nimport { MyGlobal } from \"../../MyGlobal\";\nimport { jwtAuthorize } from \"./jwtAuthorize\";\nimport { UserPayload } from \"../../decorators/payload/UserPayload\";\n\n/**\n * Verifies JWT and ensures the authenticated subject is an active user.\n */\nexport async function userAuthorize(request: {\n  headers: {\n    authorization?: string;\n  };\n}): Promise<UserPayload> {\n  const payload: UserPayload = jwtAuthorize({ request }) as UserPayload;\n\n  if (payload.type !== \"user\") {\n    throw new ForbiddenException(`You're not ${payload.type}`);\n  }\n\n  // payload.id contains top-level user table ID\n  const user = await MyGlobal.prisma.todo_app_user.findFirst({\n    where: {\n      id: payload.id,\n      // Ensure only active accounts are accepted per schema\n      account_status: \"active\",\n    },\n  });\n\n  if (user === null) {\n    throw new ForbiddenException(\"You're not enrolled\");\n  }\n\n  return payload;\n}\n","location":"src/providers/authorize/userAuthorize.ts"},"decorator":{"name":"UserAuth","content":"import { SwaggerCustomizer } from \"@nestia/core\";\nimport { ExecutionContext, createParamDecorator } from \"@nestjs/common\";\nimport { Singleton } from \"tstl\";\n\nimport { userAuthorize } from \"../providers/authorize/userAuthorize\";\n\n/**\n * Parameter decorator that injects authenticated UserPayload into controllers.\n */\nexport const UserAuth =\n  (): ParameterDecorator =>\n  (\n    target: object,\n    propertyKey: string | symbol | undefined,\n    parameterIndex: number,\n  ): void => {\n    SwaggerCustomizer((props) => {\n      props.route.security ??= [];\n      props.route.security.push({\n        bearer: [],\n      });\n    })(target, propertyKey as string, undefined!);\n    singleton.get()(target, propertyKey, parameterIndex);\n  };\n\nconst singleton = new Singleton(() =>\n  createParamDecorator(async (_data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return userAuthorize(request);\n  })(),\n);\n","location":"src/decorators/UserAuth.ts"},"payload":{"name":"UserPayload","location":"src/decorators/payload/UserPayload.ts","content":"import { tags } from \"typia\";\n\n/** Payload injected by UserAuth decorator representing an authenticated user. */\nexport interface UserPayload {\n  /** Top-level user table ID (the fundamental user identifier in the system). */\n  id: string & tags.Format<\"uuid\">;\n\n  /** Discriminator for the user role. */\n  type: \"user\";\n}\n"},"role":{"name":"user","description":"Authenticated standard user who can register, authenticate via API, and manage their own todos (create, read, update, delete, mark complete/incomplete). Can set optional attributes such as due date and priority for each todo. Cannot access other users' data or administrative functions.","kind":"member"}},{"error_analysis":"MyGlobal.ts fails to import './MyConfiguration' (TS2307) — missing module or wrong path. No other TypeScript diagnostics provided for provider/decorator. Provider used jwtAuthorize correctly; Prisma model todo_app_admin exists in schema but confirm generated client property name matches MyGlobal.prisma property.","solution_guidance":"1) Fix or add src/MyConfiguration.ts or update import in src/MyGlobal.ts to correct path; export necessary types used by MyGlobal. 2) Ensure `prisma generate` was run so MyGlobal.prisma has todo_app_admin. 3) Keep jwtAuthorize import as \"./jwtAuthorize\" in provider. 4) Export payload interface from src/decorators/payload/AdminPayload.ts and use that path in provider.","provider":{"name":"adminAuthorize","content":"import { ForbiddenException } from \"@nestjs/common\";\n\nimport { MyGlobal } from \"../../MyGlobal\";\nimport { jwtAuthorize } from \"./jwtAuthorize\";\nimport { AdminPayload } from \"../../decorators/payload/AdminPayload\";\n\n/**\n * Verifies JWT token and ensures the token belongs to an admin account.\n */\nexport async function adminAuthorize(request: {\n  headers: {\n    authorization?: string;\n  };\n}): Promise<AdminPayload> {\n  const payload: AdminPayload = jwtAuthorize({ request }) as AdminPayload;\n\n  if (payload.type !== \"admin\") {\n    throw new ForbiddenException(`You're not ${payload.type}`);\n  }\n\n  // payload.id contains the top-level admin.id (admin is a top-level model)\n  const admin = await MyGlobal.prisma.todo_app_admin.findFirst({\n    where: {\n      id: payload.id,\n    },\n  });\n\n  if (admin === null) {\n    throw new ForbiddenException(\"You're not enrolled\");\n  }\n\n  return payload;\n}\n","location":"src/providers/authorize/adminAuthorize.ts"},"decorator":{"name":"AdminAuth","content":"import { SwaggerCustomizer } from \"@nestia/core\";\nimport { ExecutionContext, createParamDecorator } from \"@nestjs/common\";\nimport { Singleton } from \"tstl\";\n\nimport { adminAuthorize } from \"../providers/authorize/adminAuthorize\";\n\nexport const AdminAuth =\n  (): ParameterDecorator =>\n  (\n    target: object,\n    propertyKey: string | symbol | undefined,\n    parameterIndex: number,\n  ): void => {\n    SwaggerCustomizer((props) => {\n      props.route.security ??= [];\n      props.route.security.push({\n        bearer: [],\n      });\n    })(target, propertyKey as string, undefined!);\n    singleton.get()(target, propertyKey, parameterIndex);\n  };\n\nconst singleton = new Singleton(() =>\n  createParamDecorator(async (_data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return adminAuthorize(request);\n  })(),\n);\n","location":"src/decorators/AdminAuth.ts"},"payload":{"name":"AdminPayload","location":"src/decorators/payload/AdminPayload.ts","content":"import { tags } from \"typia\";\n\nexport interface AdminPayload {\n  /** Top-level admin table ID (the fundamental admin identifier in the system). */\n  id: string & tags.Format<\"uuid\">;\n\n  /** Discriminator for the discriminated union type. */\n  type: \"admin\";\n}\n"},"role":{"name":"admin","description":"Authenticated administrator who can authenticate via API and perform elevated management tasks: view aggregate usage, manage user accounts (suspend/reactivate), and perform data maintenance operations. Admins may also act as a regular user for troubleshooting but must be audited when performing admin actions.","kind":"admin"}}],"functions":[{"location":"src/providers/patchTodoAppUserTodosTodoIdVersions.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppTodoSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodoSnapshot\";\nimport { IPageITodoAppTodoSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppTodoSnapshot\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function patchTodoAppUserTodosTodoIdVersions(props: {\n  user: UserPayload;\n  todoId: string & tags.Format<\"uuid\">;\n  body: ITodoAppTodoSnapshot.IRequest;\n}): Promise<IPageITodoAppTodoSnapshot> {\n  const { user, todoId, body } = props;\n\n  const page = Number(body.page ?? 1);\n  const requestedLimit = Number(body.pageSize ?? 20);\n  const MAX_PAGE_SIZE = 100;\n  const limit = requestedLimit > MAX_PAGE_SIZE ? MAX_PAGE_SIZE : requestedLimit;\n\n  if (page < 1) throw new HttpException(\"Bad Request: page must be >= 1\", 400);\n  if (limit < 1)\n    throw new HttpException(\"Bad Request: pageSize must be >= 1\", 400);\n\n  const parent = await MyGlobal.prisma.todo_app_todos.findUnique({\n    where: { id: todoId },\n  });\n  if (!parent) throw new HttpException(\"Not Found\", 404);\n  if (parent.user_id !== user.id)\n    throw new HttpException(\n      \"Unauthorized: You can only view your own todo snapshots\",\n      403,\n    );\n\n  const sortOrder: Prisma.SortOrder = body.sortOrder === \"asc\" ? \"asc\" : \"desc\";\n  const orderBy: Prisma.todo_app_todo_snapshotsOrderByWithRelationInput =\n    body.sortBy === \"created_at\"\n      ? { created_at: sortOrder }\n      : { snapshot_at: sortOrder };\n\n  const [rows, total] = await Promise.all([\n    MyGlobal.prisma.todo_app_todo_snapshots.findMany({\n      where: {\n        todo_app_todo_id: todoId,\n        ...(body.isCompleted !== undefined &&\n          body.isCompleted !== null && { is_completed: body.isCompleted }),\n        ...(body.includeDeleted !== true && { deleted_at: null }),\n        ...((body.snapshotAtFrom !== undefined &&\n          body.snapshotAtFrom !== null) ||\n        (body.snapshotAtTo !== undefined && body.snapshotAtTo !== null)\n          ? {\n              snapshot_at: {\n                ...(body.snapshotAtFrom !== undefined &&\n                  body.snapshotAtFrom !== null && { gte: body.snapshotAtFrom }),\n                ...(body.snapshotAtTo !== undefined &&\n                  body.snapshotAtTo !== null && { lte: body.snapshotAtTo }),\n              },\n            }\n          : {}),\n      },\n      orderBy,\n      skip: (page - 1) * limit,\n      take: limit,\n    }),\n    MyGlobal.prisma.todo_app_todo_snapshots.count({\n      where: {\n        todo_app_todo_id: todoId,\n        ...(body.isCompleted !== undefined &&\n          body.isCompleted !== null && { is_completed: body.isCompleted }),\n        ...(body.includeDeleted !== true && { deleted_at: null }),\n        ...((body.snapshotAtFrom !== undefined &&\n          body.snapshotAtFrom !== null) ||\n        (body.snapshotAtTo !== undefined && body.snapshotAtTo !== null)\n          ? {\n              snapshot_at: {\n                ...(body.snapshotAtFrom !== undefined &&\n                  body.snapshotAtFrom !== null && { gte: body.snapshotAtFrom }),\n                ...(body.snapshotAtTo !== undefined &&\n                  body.snapshotAtTo !== null && { lte: body.snapshotAtTo }),\n              },\n            }\n          : {}),\n      },\n    }),\n  ]);\n\n  const data = rows.map((r) => ({\n    id: r.id,\n    todo_app_todo_id: r.todo_app_todo_id,\n    title: r.title,\n    description: r.description ?? null,\n    is_completed: r.is_completed,\n    completed_at: r.completed_at ? toISOStringSafe(r.completed_at) : null,\n    position: r.position ?? null,\n    created_at: toISOStringSafe(r.created_at),\n    updated_at: toISOStringSafe(r.updated_at),\n    deleted_at: r.deleted_at ? toISOStringSafe(r.deleted_at) : null,\n    snapshot_at: toISOStringSafe(r.snapshot_at),\n  }));\n\n  const pages = limit === 0 ? 0 : Math.ceil(total / limit);\n\n  return {\n    pagination: {\n      current: page,\n      limit: Number(limit),\n      records: Number(total),\n      pages: Number(pages),\n    },\n    data,\n  };\n}\n","endpoint":{"method":"patch","path":"/todoApp/user/todos/{todoId}/versions"},"name":"patchTodoAppUserTodosTodoIdVersions"},{"location":"src/providers/getTodoAppAdminAdminsAdminId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function getTodoAppAdminAdminsAdminId(props: {\n  admin: AdminPayload;\n  adminId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoAppAdmin> {\n  const { admin, adminId } = props;\n\n  // Ensure caller exists and is an admin\n  const caller = await MyGlobal.prisma.todo_app_admin.findUnique({\n    where: { id: admin.id },\n  });\n  if (!caller) throw new HttpException(\"Unauthorized\", 403);\n\n  // Find target admin. Audit and return 404 if not found.\n  let target;\n  try {\n    target = await MyGlobal.prisma.todo_app_admin.findUniqueOrThrow({\n      where: { id: adminId },\n    });\n  } catch (err) {\n    await MyGlobal.prisma.todo_app_audit_records.create({\n      data: {\n        id: v4() as string & tags.Format<\"uuid\">,\n        admin: { connect: { id: admin.id } },\n        actor_role: \"admin\",\n        action_type: \"retrieve_admin_failed\",\n        target_resource: \"todo_app_admin\",\n        target_id: adminId,\n        reason: \"not_found\",\n        created_at: toISOStringSafe(new Date()),\n      },\n    });\n\n    throw new HttpException(\"Not Found\", 404);\n  }\n\n  // Audit successful retrieval\n  await MyGlobal.prisma.todo_app_audit_records.create({\n    data: {\n      id: v4() as string & tags.Format<\"uuid\">,\n      admin: { connect: { id: admin.id } },\n      actor_role: \"admin\",\n      action_type: \"retrieve_admin\",\n      target_resource: \"todo_app_admin\",\n      target_id: adminId,\n      reason: null,\n      created_at: toISOStringSafe(new Date()),\n    },\n  });\n\n  return {\n    id: target.id as string & tags.Format<\"uuid\">,\n    email: target.email as string & tags.Format<\"email\">,\n    is_super: target.is_super,\n    created_at: toISOStringSafe(target.created_at),\n    last_active_at: target.last_active_at\n      ? toISOStringSafe(target.last_active_at)\n      : null,\n  };\n}\n","endpoint":{"method":"get","path":"/todoApp/admin/admins/{adminId}"},"name":"getTodoAppAdminAdminsAdminId"},{"location":"src/providers/patchTodoAppAdminGuests.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppGuest } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppGuest\";\nimport { IPageITodoAppGuest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppGuest\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function patchTodoAppAdminGuests(props: {\n  admin: AdminPayload;\n  body: ITodoAppGuest.IRequest;\n}): Promise<IPageITodoAppGuest.ISummary> {\n  const { admin, body } = props;\n\n  // Authorization: ensure admin exists\n  await MyGlobal.prisma.todo_app_admin.findUniqueOrThrow({\n    where: { id: admin.id },\n  });\n\n  // Rate limiting: allow up to 10 searches per minute per admin\n  const oneMinuteAgo = toISOStringSafe(new Date(Date.now() - 60_000));\n  const recentSearchCount = await MyGlobal.prisma.todo_app_audit_records.count({\n    where: {\n      admin_id: admin.id,\n      action_type: \"search_guests\",\n      created_at: { gte: oneMinuteAgo },\n    },\n  });\n\n  const RATE_LIMIT_PER_MINUTE = 10;\n  if (recentSearchCount >= RATE_LIMIT_PER_MINUTE) {\n    throw new HttpException(\"Too Many Requests\", 429);\n  }\n\n  // Pagination defaults and caps\n  const page = Number(body.page ?? 1);\n  const pageSizeRequested = Number(body.pageSize ?? 20);\n  const MAX_PAGE_SIZE = 1000;\n  const limit =\n    pageSizeRequested > 0 ? Math.min(pageSizeRequested, MAX_PAGE_SIZE) : 20;\n  const skip = (page - 1) * limit;\n\n  // Build where condition inline following null/undefined rules\n  const where = {\n    ...(body.email !== undefined &&\n      body.email !== null && { email: body.email }),\n    ...(body.status !== undefined &&\n      body.status !== null && { status: body.status }),\n    ...((body.created_at_from !== undefined && body.created_at_from !== null) ||\n    (body.created_at_to !== undefined && body.created_at_to !== null)\n      ? {\n          created_at: {\n            ...(body.created_at_from !== undefined &&\n              body.created_at_from !== null && {\n                gte: toISOStringSafe(body.created_at_from as any),\n              }),\n            ...(body.created_at_to !== undefined &&\n              body.created_at_to !== null && {\n                lte: toISOStringSafe(body.created_at_to as any),\n              }),\n          },\n        }\n      : {}),\n    ...((body.last_active_at_from !== undefined &&\n      body.last_active_at_from !== null) ||\n    (body.last_active_at_to !== undefined && body.last_active_at_to !== null)\n      ? {\n          last_active_at: {\n            ...(body.last_active_at_from !== undefined &&\n              body.last_active_at_from !== null && {\n                gte: toISOStringSafe(body.last_active_at_from as any),\n              }),\n            ...(body.last_active_at_to !== undefined &&\n              body.last_active_at_to !== null && {\n                lte: toISOStringSafe(body.last_active_at_to as any),\n              }),\n          },\n        }\n      : {}),\n  };\n\n  // Sorting\n  const sortField =\n    body.sortBy === \"last_active_at\" ? \"last_active_at\" : \"created_at\";\n  const sortOrder = body.sortOrder === \"asc\" ? \"asc\" : \"desc\";\n\n  // Query database: results and total count\n  const [rows, total] = await Promise.all([\n    MyGlobal.prisma.todo_app_guest.findMany({\n      where,\n      orderBy: { [sortField]: sortOrder },\n      skip,\n      take: limit,\n      select: {\n        id: true,\n        email: true,\n        created_at: true,\n        last_active_at: true,\n        status: true,\n      },\n    }),\n    MyGlobal.prisma.todo_app_guest.count({ where }),\n  ]);\n\n  // Map rows to DTO summaries\n  const data = rows.map((r) => ({\n    id: r.id,\n    email: r.email ?? null,\n    created_at: toISOStringSafe(r.created_at as any),\n    last_active_at: r.last_active_at\n      ? toISOStringSafe(r.last_active_at as any)\n      : null,\n    status: r.status ?? null,\n  }));\n\n  // Audit logging for the search action\n  try {\n    await MyGlobal.prisma.todo_app_audit_records.create({\n      data: {\n        id: v4(),\n        admin_id: admin.id,\n        user_id: null,\n        actor_role: \"admin\",\n        action_type: \"search_guests\",\n        target_resource: \"todo_app_guest\",\n        target_id: null,\n        reason: null,\n        created_at: toISOStringSafe(new Date()),\n      },\n    });\n  } catch (err) {\n    // Non-fatal: Do not break the main response for audit failures\n    // Log via MyGlobal if available\n    if (MyGlobal && typeof (MyGlobal as any).logger?.error === \"function\") {\n      try {\n        (MyGlobal as any).logger.error(\n          \"Failed to create audit record for guest search\",\n          err,\n        );\n      } catch {}\n    }\n  }\n\n  const pagination = {\n    current: Number(page),\n    limit: Number(limit),\n    records: Number(total),\n    pages: Number(Math.ceil(total / limit)),\n  };\n\n  return { pagination, data };\n}\n","endpoint":{"method":"patch","path":"/todoApp/admin/guests"},"name":"patchTodoAppAdminGuests"},{"location":"src/providers/putAuthAdminPasswordChange.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function putAuthAdminPasswordChange(props: {\n  admin: AdminPayload;\n  body: ITodoAppAdmin.IChangePassword;\n}): Promise<ITodoAppAdmin.IMessage> {\n  const { admin, body } = props;\n  const { currentPassword, newPassword } = body;\n\n  // Ensure admin exists\n  let dbAdmin;\n  try {\n    dbAdmin = await MyGlobal.prisma.todo_app_admin.findUniqueOrThrow({\n      where: { id: admin.id },\n    });\n  } catch (_err) {\n    throw new HttpException(\"Unauthorized: admin not found\", 403);\n  }\n\n  // Verify current password\n  const storedHash = dbAdmin.password_hash ?? \"\";\n  const verified = await PasswordUtil.verify(currentPassword, storedHash);\n  if (!verified) throw new HttpException(\"Invalid current password\", 400);\n\n  // Hash new password\n  const newHash = await PasswordUtil.hash(newPassword);\n\n  // Timestamp for DB writes and audit\n  const now: string & tags.Format<\"date-time\"> = toISOStringSafe(\n    new Date(),\n  ) as string & tags.Format<\"date-time\">;\n\n  // Update admin record (schema does not have `updated_at`)\n  try {\n    await MyGlobal.prisma.todo_app_admin.update({\n      where: { id: admin.id },\n      data: {\n        password_hash: newHash,\n        last_active_at: now,\n      },\n    });\n  } catch (_err) {\n    throw new HttpException(\"Internal Server Error\", 500);\n  }\n\n  // Record audit event\n  try {\n    await MyGlobal.prisma.todo_app_audit_records.create({\n      data: {\n        id: v4() as string & tags.Format<\"uuid\">,\n        admin_id: admin.id,\n        user_id: null,\n        actor_role: \"admin\",\n        action_type: \"change_password\",\n        target_resource: \"admin\",\n        target_id: admin.id,\n        reason: null,\n        created_at: now,\n      },\n    });\n  } catch (_err) {\n    // Audit failure should not silently succeed; surface as server error\n    throw new HttpException(\"Internal Server Error\", 500);\n  }\n\n  return { message: \"Password changed successfully\" };\n}\n","endpoint":{"method":"put","path":"/auth/admin/password/change"},"name":"putAuthAdminPasswordChange"},{"location":"src/providers/postAuthGuestJoin.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppGuest } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppGuest\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthGuestJoin(props: {\n  body: ITodoAppGuest.IJoin;\n}): Promise<ITodoAppGuest.IAuthorized> {\n  const { body } = props;\n\n  // Prepare values\n  const id = v4() as string & tags.Format<\"uuid\">;\n  const created_at = toISOStringSafe(new Date());\n\n  // Token lifetime values\n  const accessExp = toISOStringSafe(new Date(Date.now() + 60 * 60 * 1000)); // 1 hour\n  const refreshExp = toISOStringSafe(\n    new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),\n  ); // 7 days\n\n  try {\n    const created = await MyGlobal.prisma.todo_app_guest.create({\n      data: {\n        id,\n        email: body.email ?? null,\n        created_at: created_at,\n        status: \"active\",\n      },\n    });\n\n    // JWT payloads\n    const accessToken = jwt.sign(\n      {\n        id: created.id,\n        type: \"guest\",\n      },\n      MyGlobal.env.JWT_SECRET_KEY,\n      {\n        expiresIn: \"1h\",\n        issuer: \"autobe\",\n      },\n    );\n\n    const refreshToken = jwt.sign(\n      {\n        id: created.id,\n        tokenType: \"refresh\",\n      },\n      MyGlobal.env.JWT_SECRET_KEY,\n      {\n        expiresIn: \"7d\",\n        issuer: \"autobe\",\n      },\n    );\n\n    const token: IAuthorizationToken = {\n      access: accessToken,\n      refresh: refreshToken,\n      expired_at: accessExp,\n      refreshable_until: refreshExp,\n    };\n\n    const response: ITodoAppGuest.IAuthorized = {\n      id: created.id as string & tags.Format<\"uuid\">,\n      email: created.email ?? null,\n      created_at: created_at as string & tags.Format<\"date-time\">,\n      last_active_at: null,\n      status: created.status ?? null,\n      token,\n    };\n\n    return response;\n  } catch (err) {\n    // Prisma known errors could be handled here, fallback to 500\n    throw new HttpException(\"Internal Server Error\", 500);\n  }\n}\n","endpoint":{"method":"post","path":"/auth/guest/join"},"name":"postAuthGuestJoin"},{"location":"src/providers/postAuthGuestRefresh.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppGuest } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppGuest\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport { GuestPayload } from \"../decorators/payload/GuestPayload\";\n\nexport async function postAuthGuestRefresh(props: {\n  guest: GuestPayload;\n  body: ITodoAppGuest.IRefresh;\n}): Promise<ITodoAppGuest.IAuthorized> {\n  const { guest, body } = props;\n  const { refresh_token } = body;\n\n  let decoded: unknown;\n  try {\n    decoded = jwt.verify(refresh_token, MyGlobal.env.JWT_SECRET_KEY, {\n      issuer: \"autobe\",\n    });\n  } catch {\n    throw new HttpException(\"Invalid refresh token\", 401);\n  }\n\n  if (typeof decoded !== \"object\" || decoded === null) {\n    throw new HttpException(\"Invalid refresh token\", 401);\n  }\n\n  const decodedAny = decoded as Record<string, unknown>;\n  const decodedId =\n    typeof decodedAny.id === \"string\" ? decodedAny.id : undefined;\n  const decodedType =\n    typeof decodedAny.type === \"string\" ? decodedAny.type : undefined;\n\n  if (!decodedId || decodedType !== \"guest\") {\n    throw new HttpException(\"Invalid refresh token\", 401);\n  }\n\n  if (guest && guest.id && guest.id !== decodedId) {\n    throw new HttpException(\"Invalid refresh token for this guest\", 401);\n  }\n\n  const guestRecord = await MyGlobal.prisma.todo_app_guest.findUnique({\n    where: { id: decodedId },\n  });\n\n  if (!guestRecord) {\n    throw new HttpException(\"Guest not found\", 404);\n  }\n\n  const now = toISOStringSafe(new Date());\n  const accessExpiry = toISOStringSafe(new Date(Date.now() + 60 * 60 * 1000));\n  const refreshExpiry = toISOStringSafe(\n    new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),\n  );\n\n  await MyGlobal.prisma.todo_app_guest.update({\n    where: { id: guestRecord.id },\n    data: { last_active_at: now },\n  });\n\n  try {\n    await MyGlobal.prisma.todo_app_audit_records.create({\n      data: {\n        id: v4(),\n        actor_role: \"guest\",\n        action_type: \"refresh_token\",\n        target_resource: \"guest\",\n        target_id: guestRecord.id,\n        created_at: now,\n      },\n    });\n  } catch {\n    // Audit failure should not block token issuance\n  }\n\n  const access = jwt.sign(\n    { id: guestRecord.id, type: \"guest\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"1h\",\n      issuer: \"autobe\",\n    },\n  );\n\n  const refresh = jwt.sign(\n    { id: guestRecord.id, type: \"guest\", token_type: \"refresh\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"7d\",\n      issuer: \"autobe\",\n    },\n  );\n\n  return {\n    id: guestRecord.id,\n    email: guestRecord.email ?? null,\n    created_at: toISOStringSafe(guestRecord.created_at),\n    last_active_at: now,\n    status: guestRecord.status ?? undefined,\n    token: {\n      access,\n      refresh,\n      expired_at: accessExpiry,\n      refreshable_until: refreshExpiry,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/guest/refresh"},"name":"postAuthGuestRefresh"},{"location":"src/providers/postAuthUserJoin.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthUserJoin(props: {\n  body: ITodoAppUser.ICreate;\n}): Promise<ITodoAppUser.IAuthorized> {\n  const { body } = props;\n\n  // Check for existing account with same email\n  const existing = await MyGlobal.prisma.todo_app_user.findUnique({\n    where: { email: body.email },\n  });\n  if (existing) {\n    throw new HttpException(\"Conflict: Email already registered\", 409);\n  }\n\n  // Hash the plaintext password\n  const password_hash = await PasswordUtil.hash(body.password);\n\n  // Prepare shared values\n  const id = v4() as string & tags.Format<\"uuid\">;\n  const now = toISOStringSafe(new Date());\n\n  // Prepare token expiry timestamps\n  const accessExpiredAt = toISOStringSafe(\n    new Date(Date.now() + 60 * 60 * 1000),\n  ); // 1 hour\n  const refreshableUntil = toISOStringSafe(\n    new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),\n  ); // 7 days\n\n  // Create user record (inline data object to preserve type errors clarity)\n  const created = await MyGlobal.prisma.todo_app_user.create({\n    data: {\n      id,\n      email: body.email,\n      display_name: body.display_name ?? null,\n      password_hash,\n      account_status: \"active\",\n      created_at: now,\n      updated_at: now,\n    },\n  });\n\n  // Generate JWT tokens\n  const access = jwt.sign(\n    { userId: created.id, email: created.email },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"1h\",\n      issuer: \"autobe\",\n    },\n  );\n\n  const refresh = jwt.sign(\n    { userId: created.id, tokenType: \"refresh\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"7d\",\n      issuer: \"autobe\",\n    },\n  );\n\n  // Build authorized response\n  return {\n    id: created.id as string & tags.Format<\"uuid\">,\n    email: created.email,\n    display_name: created.display_name ?? null,\n    account_status: created.account_status,\n    created_at: created.created_at ? toISOStringSafe(created.created_at) : now,\n    updated_at: created.updated_at ? toISOStringSafe(created.updated_at) : now,\n    last_active_at: created.last_active_at\n      ? toISOStringSafe(created.last_active_at)\n      : null,\n    token: {\n      access,\n      refresh,\n      expired_at: accessExpiredAt,\n      refreshable_until: refreshableUntil,\n    },\n    user: {\n      id: created.id as string & tags.Format<\"uuid\">,\n      email: created.email,\n      display_name: created.display_name ?? null,\n      account_status: created.account_status,\n      created_at: created.created_at\n        ? toISOStringSafe(created.created_at)\n        : now,\n      last_active_at: created.last_active_at\n        ? toISOStringSafe(created.last_active_at)\n        : null,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/user/join"},"name":"postAuthUserJoin"},{"location":"src/providers/postAuthUserLogin.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthUserLogin(props: {\n  body: ITodoAppUser.ILogin;\n}): Promise<ITodoAppUser.IAuthorized> {\n  const { body } = props;\n  const { email, password } = body;\n\n  // Retrieve user by email\n  const user = await MyGlobal.prisma.todo_app_user.findUnique({\n    where: { email },\n  });\n\n  // Generic failure to avoid account enumeration\n  if (!user || !user.password_hash) {\n    throw new HttpException(\"Invalid credentials\", 401);\n  }\n\n  // Verify password\n  const isValid = await PasswordUtil.verify(password, user.password_hash);\n  if (!isValid) {\n    throw new HttpException(\"Invalid credentials\", 401);\n  }\n\n  // Deny suspended accounts\n  if (user.account_status === \"suspended\") {\n    throw new HttpException(\"Account suspended\", 403);\n  }\n\n  // Compute token expiry moments once for consistency\n  const accessExpiryAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour\n  const refreshExpiryAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days\n  const accessExpired_at = toISOStringSafe(accessExpiryAt);\n  const refreshable_until = toISOStringSafe(refreshExpiryAt);\n\n  const accessToken = jwt.sign(\n    { userId: user.id, email: user.email },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: \"1h\", issuer: \"autobe\" },\n  );\n\n  const refreshToken = jwt.sign(\n    { userId: user.id, tokenType: \"refresh\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: \"7d\", issuer: \"autobe\" },\n  );\n\n  // Update last activity timestamps and return selected fields\n  const updated = await MyGlobal.prisma.todo_app_user.update({\n    where: { id: user.id },\n    data: {\n      last_active_at: toISOStringSafe(new Date()),\n      updated_at: toISOStringSafe(new Date()),\n    },\n    select: {\n      id: true,\n      email: true,\n      display_name: true,\n      account_status: true,\n      created_at: true,\n      updated_at: true,\n      last_active_at: true,\n    },\n  });\n\n  return {\n    id: updated.id,\n    email: updated.email,\n    display_name: updated.display_name ?? null,\n    account_status: updated.account_status,\n    created_at: toISOStringSafe(updated.created_at),\n    updated_at: toISOStringSafe(updated.updated_at),\n    last_active_at: updated.last_active_at\n      ? toISOStringSafe(updated.last_active_at)\n      : null,\n    token: {\n      access: accessToken,\n      refresh: refreshToken,\n      expired_at: accessExpired_at,\n      refreshable_until,\n    },\n    user: {\n      id: updated.id,\n      email: updated.email,\n      display_name: updated.display_name ?? null,\n      account_status: updated.account_status,\n      created_at: toISOStringSafe(updated.created_at),\n      last_active_at: updated.last_active_at\n        ? toISOStringSafe(updated.last_active_at)\n        : null,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/user/login"},"name":"postAuthUserLogin"},{"location":"src/providers/postAuthUserRefresh.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthUserRefresh(props: {\n  body: ITodoAppUser.IRefresh;\n}): Promise<ITodoAppUser.IAuthorized> {\n  const { body } = props;\n  const { refreshToken } = body;\n\n  let decoded: unknown;\n  try {\n    decoded = jwt.verify(refreshToken, MyGlobal.env.JWT_SECRET_KEY, {\n      issuer: \"autobe\",\n    });\n  } catch {\n    throw new HttpException(\"Invalid or expired refresh token\", 401);\n  }\n\n  // Extract user identifier from token payload\n  const tokenAny = decoded as Record<string, unknown> | undefined;\n  const userId =\n    (tokenAny && (tokenAny[\"userId\"] as string)) ??\n    (tokenAny && (tokenAny[\"sub\"] as string)) ??\n    (tokenAny && (tokenAny[\"id\"] as string));\n\n  if (!userId) throw new HttpException(\"Invalid token payload\", 401);\n\n  const user = await MyGlobal.prisma.todo_app_user.findUnique({\n    where: { id: userId },\n  });\n  if (!user) throw new HttpException(\"Not Found\", 404);\n  if (user.account_status === \"suspended\")\n    throw new HttpException(\"Account suspended\", 403);\n\n  // Prepare timestamps\n  const now = toISOStringSafe(new Date());\n  const accessTtlMs = 60 * 60 * 1000; // 1 hour\n  const refreshTtlMs = 7 * 24 * 60 * 60 * 1000; // 7 days\n\n  // Persist activity timestamps\n  await MyGlobal.prisma.todo_app_user.update({\n    where: { id: user.id },\n    data: {\n      last_active_at: now,\n      updated_at: now,\n    },\n  });\n\n  // Issue tokens with same payload shape as login (id + type)\n  const accessPayload = { id: user.id, type: \"user\" };\n  const access = jwt.sign(accessPayload, MyGlobal.env.JWT_SECRET_KEY, {\n    expiresIn: \"1h\",\n    issuer: \"autobe\",\n  });\n\n  const refresh = jwt.sign(\n    { userId: user.id, tokenType: \"refresh\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"7d\",\n      issuer: \"autobe\",\n    },\n  );\n\n  const expired_at = toISOStringSafe(new Date(Date.now() + accessTtlMs));\n  const refreshable_until = toISOStringSafe(\n    new Date(Date.now() + refreshTtlMs),\n  );\n\n  const response: ITodoAppUser.IAuthorized = {\n    id: user.id,\n    email: user.email,\n    display_name: user.display_name ?? null,\n    account_status: user.account_status,\n    created_at: toISOStringSafe(user.created_at),\n    updated_at: now,\n    last_active_at: user.last_active_at\n      ? toISOStringSafe(user.last_active_at)\n      : null,\n    token: {\n      access,\n      refresh,\n      expired_at,\n      refreshable_until,\n    },\n    user: {\n      id: user.id,\n      email: user.email,\n      display_name: user.display_name ?? null,\n      account_status: user.account_status,\n      created_at: toISOStringSafe(user.created_at),\n      last_active_at: user.last_active_at\n        ? toISOStringSafe(user.last_active_at)\n        : null,\n    },\n  };\n\n  return response;\n}\n","endpoint":{"method":"post","path":"/auth/user/refresh"},"name":"postAuthUserRefresh"},{"location":"src/providers/putAuthUserChangePassword.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function putAuthUserChangePassword(props: {\n  user: UserPayload;\n  body: ITodoAppUser.IChangePassword;\n}): Promise<ITodoAppUser.IProfile> {\n  const { user, body } = props;\n\n  // Owner-initiated change (currentPassword + newPassword)\n  if (\"currentPassword\" in body && body.currentPassword !== undefined) {\n    const dbUser = await MyGlobal.prisma.todo_app_user.findUniqueOrThrow({\n      where: { id: user.id },\n    });\n\n    if (dbUser.password_hash === null) {\n      throw new HttpException(\"No password is set for this account\", 400);\n    }\n\n    const verified = await PasswordUtil.verify(\n      body.currentPassword,\n      dbUser.password_hash,\n    );\n    if (!verified) throw new HttpException(\"Invalid current password\", 403);\n\n    const hashed = await PasswordUtil.hash(body.newPassword);\n    const now = toISOStringSafe(new Date());\n\n    const updated = await MyGlobal.prisma.todo_app_user.update({\n      where: { id: user.id },\n      data: {\n        password_hash: hashed,\n        updated_at: now,\n        last_active_at: now,\n      },\n      select: {\n        id: true,\n        email: true,\n        display_name: true,\n        account_status: true,\n        created_at: true,\n        updated_at: true,\n        last_active_at: true,\n      },\n    });\n\n    return {\n      id: updated.id,\n      email: updated.email,\n      display_name: updated.display_name ?? null,\n      account_status: updated.account_status,\n      created_at: toISOStringSafe(updated.created_at),\n      updated_at: toISOStringSafe(updated.updated_at),\n      last_active_at: updated.last_active_at\n        ? toISOStringSafe(updated.last_active_at)\n        : null,\n    };\n  }\n\n  // Reset-token variant cannot be implemented without token storage/schema\n  if (\"resetToken\" in body && body.resetToken !== undefined) {\n    throw new HttpException(\"Password reset via token is not supported\", 400);\n  }\n\n  throw new HttpException(\"Invalid change-password payload\", 400);\n}\n","endpoint":{"method":"put","path":"/auth/user/change-password"},"name":"putAuthUserChangePassword"},{"location":"src/providers/postAuthAdminJoin.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthAdminJoin(props: {\n  body: ITodoAppAdmin.ICreate;\n}): Promise<ITodoAppAdmin.IAuthorized> {\n  const { body } = props;\n\n  // Duplicate email check\n  const existing = await MyGlobal.prisma.todo_app_admin.findUnique({\n    where: { email: body.email },\n  });\n  if (existing) throw new HttpException(\"Conflict: email already exists\", 409);\n\n  // Hash password\n  const passwordHash = await PasswordUtil.hash(body.password);\n\n  // Prepare timestamps\n  const now = toISOStringSafe(new Date());\n\n  // Create admin\n  const created = await MyGlobal.prisma.todo_app_admin.create({\n    data: {\n      id: v4() as string & tags.Format<\"uuid\">,\n      email: body.email,\n      password_hash: passwordHash,\n      is_super: body.is_super ?? false,\n      created_at: now,\n      last_active_at: null,\n    },\n  });\n\n  // Record audit entry\n  await MyGlobal.prisma.todo_app_audit_records.create({\n    data: {\n      id: v4() as string & tags.Format<\"uuid\">,\n      admin_id: created.id,\n      actor_role: \"system\",\n      action_type: \"create_admin\",\n      target_resource: \"todo_app_admin\",\n      target_id: created.id,\n      reason: null,\n      created_at: now,\n    },\n  });\n\n  // Generate tokens\n  const access = jwt.sign(\n    { adminId: created.id, email: created.email, type: \"admin\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: \"1h\", issuer: \"autobe\" },\n  );\n\n  const refresh = jwt.sign(\n    { adminId: created.id, tokenType: \"refresh\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: \"7d\", issuer: \"autobe\" },\n  );\n\n  const expired_at = toISOStringSafe(new Date(Date.now() + 1 * 60 * 60 * 1000));\n  const refreshable_until = toISOStringSafe(\n    new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),\n  );\n\n  return {\n    id: created.id as string & tags.Format<\"uuid\">,\n    email: created.email,\n    is_super: created.is_super,\n    created_at: toISOStringSafe(created.created_at),\n    last_active_at: created.last_active_at\n      ? toISOStringSafe(created.last_active_at)\n      : null,\n    token: {\n      access,\n      refresh,\n      expired_at,\n      refreshable_until,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/admin/join"},"name":"postAuthAdminJoin"},{"location":"src/providers/postAuthAdminLogin.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthAdminLogin(props: {\n  body: ITodoAppAdmin.ILogin;\n}): Promise<ITodoAppAdmin.IAuthorized> {\n  const { body } = props;\n\n  try {\n    // Find admin by unique email\n    const admin = await MyGlobal.prisma.todo_app_admin.findUnique({\n      where: { email: body.email },\n    });\n\n    // If admin not found, record failed login and deny\n    if (!admin) {\n      await MyGlobal.prisma.todo_app_audit_records.create({\n        data: {\n          id: v4(),\n          admin_id: null,\n          user_id: null,\n          actor_role: \"admin\",\n          action_type: \"admin_login_failed\",\n          target_resource: \"admin\",\n          target_id: null,\n          reason: null,\n          created_at: toISOStringSafe(new Date()),\n        },\n      });\n\n      throw new HttpException(\"Invalid credentials\", 401);\n    }\n\n    if (!admin.password_hash) {\n      await MyGlobal.prisma.todo_app_audit_records.create({\n        data: {\n          id: v4(),\n          admin_id: admin.id,\n          user_id: null,\n          actor_role: \"admin\",\n          action_type: \"admin_login_failed\",\n          target_resource: \"admin\",\n          target_id: admin.id,\n          reason: \"missing_password_hash\",\n          created_at: toISOStringSafe(new Date()),\n        },\n      });\n\n      throw new HttpException(\"Invalid credentials\", 401);\n    }\n\n    const isValid = await PasswordUtil.verify(\n      body.password,\n      admin.password_hash,\n    );\n    if (!isValid) {\n      await MyGlobal.prisma.todo_app_audit_records.create({\n        data: {\n          id: v4(),\n          admin_id: admin.id,\n          user_id: null,\n          actor_role: \"admin\",\n          action_type: \"admin_login_failed\",\n          target_resource: \"admin\",\n          target_id: admin.id,\n          reason: \"wrong_password\",\n          created_at: toISOStringSafe(new Date()),\n        },\n      });\n\n      throw new HttpException(\"Invalid credentials\", 401);\n    }\n\n    // Successful authentication - prepare timestamps\n    const now = toISOStringSafe(new Date());\n\n    // Update last_active_at\n    await MyGlobal.prisma.todo_app_admin.update({\n      where: { id: admin.id },\n      data: { last_active_at: now },\n    });\n\n    // Generate tokens\n    const accessToken = jwt.sign(\n      {\n        id: admin.id,\n        type: \"admin\",\n        email: admin.email,\n      },\n      MyGlobal.env.JWT_SECRET_KEY,\n      {\n        expiresIn: \"1h\",\n        issuer: \"autobe\",\n      },\n    );\n\n    const refreshToken = jwt.sign(\n      {\n        id: admin.id,\n        tokenType: \"refresh\",\n      },\n      MyGlobal.env.JWT_SECRET_KEY,\n      {\n        expiresIn: \"7d\",\n        issuer: \"autobe\",\n      },\n    );\n\n    // Compute ISO expiry timestamps\n    const accessExpiresAt = toISOStringSafe(\n      new Date(Date.now() + 60 * 60 * 1000),\n    );\n    const refreshExpiresAt = toISOStringSafe(\n      new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),\n    );\n\n    // Create audit record for successful login\n    await MyGlobal.prisma.todo_app_audit_records.create({\n      data: {\n        id: v4(),\n        admin_id: admin.id,\n        user_id: null,\n        actor_role: \"admin\",\n        action_type: \"admin_login\",\n        target_resource: \"admin\",\n        target_id: admin.id,\n        reason: null,\n        created_at: now,\n      },\n    });\n\n    // Build token structure\n    const token = {\n      access: accessToken,\n      refresh: refreshToken,\n      expired_at: accessExpiresAt,\n      refreshable_until: refreshExpiresAt,\n    } satisfies IAuthorizationToken;\n\n    // Build authorized response\n    const authorized: ITodoAppAdmin.IAuthorized = {\n      id: admin.id,\n      email: admin.email,\n      is_super: admin.is_super,\n      created_at: toISOStringSafe(admin.created_at),\n      last_active_at: now,\n      token,\n    };\n\n    return authorized;\n  } catch (err) {\n    if (err instanceof HttpException) throw err;\n    // Unexpected errors\n    throw new HttpException(\"Internal Server Error\", 500);\n  }\n}\n","endpoint":{"method":"post","path":"/auth/admin/login"},"name":"postAuthAdminLogin"},{"location":"src/providers/postAuthAdminRefresh.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\n\nexport async function postAuthAdminRefresh(props: {\n  body: ITodoAppAdmin.IRefresh;\n}): Promise<ITodoAppAdmin.IAuthorized> {\n  const { body } = props;\n  const { refresh_token } = body;\n\n  let decoded: unknown;\n  try {\n    decoded = jwt.verify(refresh_token, MyGlobal.env.JWT_SECRET_KEY, {\n      issuer: \"autobe\",\n    });\n  } catch (err) {\n    throw new HttpException(\"Invalid refresh token\", 401);\n  }\n\n  const payload =\n    decoded && typeof decoded === \"object\"\n      ? (decoded as Record<string, unknown>)\n      : undefined;\n  const adminId =\n    payload?.id ?? payload?.adminId ?? payload?.userId ?? payload?.sub;\n  if (!adminId || typeof adminId !== \"string\") {\n    throw new HttpException(\"Invalid refresh token\", 401);\n  }\n\n  const admin = await MyGlobal.prisma.todo_app_admin.findUnique({\n    where: { id: adminId },\n  });\n  if (!admin) throw new HttpException(\"Invalid refresh token\", 401);\n\n  const now = toISOStringSafe(new Date());\n\n  // Update last_active_at\n  await MyGlobal.prisma.todo_app_admin.update({\n    where: { id: admin.id },\n    data: { last_active_at: now },\n  });\n\n  // Audit the refresh usage\n  await MyGlobal.prisma.todo_app_audit_records.create({\n    data: {\n      id: v4() as string & tags.Format<\"uuid\">,\n      admin_id: admin.id,\n      user_id: null,\n      actor_role: \"admin\",\n      action_type: \"refresh_token_used\",\n      target_resource: \"admin\",\n      target_id: admin.id,\n      reason: null,\n      created_at: now,\n    },\n  });\n\n  // Create tokens\n  const accessPayload = {\n    id: admin.id,\n    type: \"admin\",\n    email: admin.email,\n    is_super: admin.is_super,\n  };\n\n  const access = jwt.sign(accessPayload, MyGlobal.env.JWT_SECRET_KEY, {\n    expiresIn: \"1h\",\n    issuer: \"autobe\",\n  });\n\n  const refresh = jwt.sign(\n    { id: admin.id, type: \"admin\", tokenType: \"refresh\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"7d\",\n      issuer: \"autobe\",\n    },\n  );\n\n  const expired_at = toISOStringSafe(new Date(Date.now() + 60 * 60 * 1000));\n  const refreshable_until = toISOStringSafe(\n    new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),\n  );\n\n  return {\n    id: admin.id,\n    email: admin.email,\n    is_super: admin.is_super,\n    created_at: toISOStringSafe(admin.created_at),\n    last_active_at: now,\n    token: {\n      access,\n      refresh,\n      expired_at,\n      refreshable_until,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/admin/refresh"},"name":"postAuthAdminRefresh"},{"location":"src/providers/postAuthAdminPasswordReset.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\n\nexport async function postAuthAdminPasswordReset(props: {\n  body: ITodoAppAdmin.IRequestPasswordReset;\n}): Promise<ITodoAppAdmin.IMessage> {\n  const { body } = props;\n\n  try {\n    // Lookup admin by unique email. Use findUnique to leverage the schema's unique constraint.\n    const admin = await MyGlobal.prisma.todo_app_admin.findUnique({\n      where: { email: body.email },\n    });\n\n    // Generate ephemeral, single-use token if admin exists. Do NOT persist or return it.\n    if (admin) {\n      jwt.sign(\n        {\n          sub: admin.id,\n          type: \"admin_password_reset\",\n          jti: v4() as string & tags.Format<\"uuid\">,\n        },\n        MyGlobal.env.JWT_SECRET_KEY || v4(),\n        { expiresIn: \"24h\" },\n      );\n    }\n\n    // Create audit record to record the request. Use explicit nulls for optional fields.\n    await MyGlobal.prisma.todo_app_audit_records.create({\n      data: {\n        id: v4() as string & tags.Format<\"uuid\">,\n        admin_id: null,\n        user_id: null,\n        actor_role: \"public\",\n        action_type: \"request_password_reset\",\n        target_resource: \"todo_app_admin\",\n        target_id: admin ? admin.id : null,\n        reason: null,\n        created_at: toISOStringSafe(new Date()),\n      },\n    });\n\n    // Generic response that never reveals account existence.\n    return {\n      message:\n        \"If an account with that email exists, a password reset link has been sent.\",\n    };\n  } catch (err) {\n    throw new HttpException(\"Internal Server Error\", 500);\n  }\n}\n","endpoint":{"method":"post","path":"/auth/admin/password/reset"},"name":"postAuthAdminPasswordReset"},{"location":"src/providers/patchTodoAppUserTodos.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport { IPageITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppTodo\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function patchTodoAppUserTodos(props: {\n  user: UserPayload;\n  body: ITodoAppTodo.IRequest;\n}): Promise<IPageITodoAppTodo.ISummary> {\n  const { user, body } = props;\n\n  if (!user || !user.id) {\n    throw new HttpException(\"Unauthorized\", 401);\n  }\n\n  // Pagination defaults and coercion\n  const rawPage = body.page ?? 1;\n  const rawLimit = body.pageSize ?? 20;\n\n  const page = Number(rawPage);\n  let limit = Number(rawLimit);\n\n  if (!Number.isFinite(page) || page < 1) {\n    throw new HttpException(\"Bad Request: page must be a positive number\", 400);\n  }\n\n  if (!Number.isFinite(limit) || limit < 1) {\n    limit = 20;\n  }\n\n  const MAX_LIMIT = 100;\n  if (limit > MAX_LIMIT) limit = MAX_LIMIT;\n\n  const skip = (page - 1) * limit;\n\n  // Sorting\n  const sortBy = body.sortBy === \"position\" ? \"position\" : \"created_at\";\n  const sortOrder = body.sortOrder === \"desc\" ? \"desc\" : \"asc\";\n\n  // Normalize search query: treat empty string as not provided\n  const q =\n    typeof body.q === \"string\" && body.q.trim() !== \"\" ? body.q : undefined;\n\n  try {\n    const [rows, total] = await Promise.all([\n      MyGlobal.prisma.todo_app_todos.findMany({\n        where: {\n          user_id: user.id,\n          ...(body.isCompleted !== undefined &&\n            body.isCompleted !== null && {\n              is_completed: body.isCompleted,\n            }),\n          ...(body.includeDeleted !== true && { deleted_at: null }),\n          ...(q !== undefined && {\n            OR: [{ title: { contains: q } }, { description: { contains: q } }],\n          }),\n        },\n        select: {\n          id: true,\n          title: true,\n          is_completed: true,\n          completed_at: true,\n          position: true,\n          created_at: true,\n          updated_at: true,\n        },\n        orderBy:\n          sortBy === \"position\"\n            ? { position: sortOrder }\n            : { created_at: sortOrder },\n        skip,\n        take: limit,\n      }),\n      MyGlobal.prisma.todo_app_todos.count({\n        where: {\n          user_id: user.id,\n          ...(body.isCompleted !== undefined &&\n            body.isCompleted !== null && {\n              is_completed: body.isCompleted,\n            }),\n          ...(body.includeDeleted !== true && { deleted_at: null }),\n          ...(q !== undefined && {\n            OR: [{ title: { contains: q } }, { description: { contains: q } }],\n          }),\n        },\n      }),\n    ]);\n\n    const data = rows.map((r) => ({\n      id: r.id,\n      title: r.title,\n      is_completed: r.is_completed,\n      completed_at: r.completed_at ? toISOStringSafe(r.completed_at) : null,\n      position: r.position ?? null,\n      created_at: toISOStringSafe(r.created_at),\n      updated_at: toISOStringSafe(r.updated_at),\n    }));\n\n    const pages = Math.max(1, Math.ceil(total / limit));\n\n    return {\n      pagination: {\n        current: Number(page),\n        limit: Number(limit),\n        records: total,\n        pages,\n      },\n      data,\n    };\n  } catch (error) {\n    // Log error if logging available (avoid leaking error details in response)\n    // MyGlobal.logger?.error?.(error);\n    throw new HttpException(\"Internal Server Error\", 500);\n  }\n}\n","endpoint":{"method":"patch","path":"/todoApp/user/todos"},"name":"patchTodoAppUserTodos"},{"location":"src/providers/getTodoAppUserTodosTodoId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function getTodoAppUserTodosTodoId(props: {\n  user: UserPayload;\n  todoId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoAppTodo> {\n  const { user, todoId } = props;\n\n  const todo = await MyGlobal.prisma.todo_app_todos.findUnique({\n    where: { id: todoId },\n  });\n\n  if (!todo) throw new HttpException(\"Not Found\", 404);\n\n  if (todo.deleted_at !== null) throw new HttpException(\"Not Found\", 404);\n\n  if (todo.user_id !== user.id) {\n    throw new HttpException(\n      \"Unauthorized: You can only access your own todos\",\n      403,\n    );\n  }\n\n  return {\n    id: todo.id as string & tags.Format<\"uuid\">,\n    user_id: todo.user_id as string & tags.Format<\"uuid\">,\n    title: todo.title,\n    description: todo.description ?? null,\n    is_completed: todo.is_completed,\n    completed_at: todo.completed_at ? toISOStringSafe(todo.completed_at) : null,\n    position: todo.position ?? null,\n    created_at: toISOStringSafe(todo.created_at),\n    updated_at: toISOStringSafe(todo.updated_at),\n    deleted_at: todo.deleted_at ? toISOStringSafe(todo.deleted_at) : null,\n  };\n}\n","endpoint":{"method":"get","path":"/todoApp/user/todos/{todoId}"},"name":"getTodoAppUserTodosTodoId"},{"location":"src/providers/postTodoAppUserTodos.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function postTodoAppUserTodos(props: {\n  user: UserPayload;\n  body: ITodoAppTodo.ICreate;\n}): Promise<ITodoAppTodo> {\n  const { user, body } = props;\n\n  const id = v4() as string & tags.Format<\"uuid\">;\n  const now = toISOStringSafe(new Date());\n  const isCompleted = body.is_completed ?? false;\n  const completedAt = isCompleted ? now : null;\n\n  try {\n    const created = await MyGlobal.prisma.todo_app_todos.create({\n      data: {\n        id,\n        user_id: user.id,\n        title: body.title,\n        description: body.description ?? null,\n        is_completed: isCompleted,\n        completed_at: completedAt,\n        position: body.position ?? null,\n        created_at: now,\n        updated_at: now,\n        deleted_at: null,\n      },\n      select: {\n        id: true,\n        user_id: true,\n        title: true,\n        description: true,\n        is_completed: true,\n        completed_at: true,\n        position: true,\n        created_at: true,\n        updated_at: true,\n        deleted_at: true,\n      },\n    });\n\n    return {\n      id: created.id as string & tags.Format<\"uuid\">,\n      user_id: created.user_id as string & tags.Format<\"uuid\">,\n      title: created.title,\n      description: created.description ?? undefined,\n      is_completed: created.is_completed,\n      completed_at: completedAt,\n      position: created.position ?? undefined,\n      created_at: now,\n      updated_at: now,\n      deleted_at: null,\n    };\n  } catch (error) {\n    throw new HttpException(\"Failed to create todo\", 500);\n  }\n}\n","endpoint":{"method":"post","path":"/todoApp/user/todos"},"name":"postTodoAppUserTodos"},{"location":"src/providers/putTodoAppUserTodosTodoId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppTodo } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodo\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function putTodoAppUserTodosTodoId(props: {\n  user: UserPayload;\n  todoId: string & tags.Format<\"uuid\">;\n  body: ITodoAppTodo.IUpdate;\n}): Promise<ITodoAppTodo> {\n  const { user, todoId, body } = props;\n\n  // Ensure the target exists and is not soft-deleted\n  const existing = await MyGlobal.prisma.todo_app_todos.findFirst({\n    where: { id: todoId, deleted_at: null },\n  });\n\n  if (!existing) {\n    throw new HttpException(\"Not Found\", 404);\n  }\n\n  // Ownership check\n  if (existing.user_id !== user.id) {\n    throw new HttpException(\n      \"Unauthorized: You can only update your own todos\",\n      403,\n    );\n  }\n\n  // Prepare timestamp once and reuse\n  const now = toISOStringSafe(new Date());\n\n  // Perform update with inline data object\n  const updated = await MyGlobal.prisma.todo_app_todos.update({\n    where: { id: todoId },\n    data: {\n      ...(body.title !== undefined && { title: body.title }),\n      ...(body.description !== undefined && { description: body.description }),\n      ...(body.position !== undefined && { position: body.position }),\n      ...(body.is_completed !== undefined && {\n        is_completed: body.is_completed,\n      }),\n      ...(body.is_completed !== undefined && {\n        completed_at: body.is_completed ? now : null,\n      }),\n      updated_at: now,\n    },\n  });\n\n  // Map Prisma result to API DTO, converting Date fields to ISO strings\n  return {\n    id: updated.id as string & tags.Format<\"uuid\">,\n    user_id: updated.user_id as string & tags.Format<\"uuid\">,\n    title: updated.title,\n    description: updated.description === null ? null : updated.description,\n    is_completed: updated.is_completed,\n    completed_at: updated.completed_at\n      ? toISOStringSafe(updated.completed_at)\n      : null,\n    position:\n      updated.position === null\n        ? null\n        : (updated.position as number & tags.Type<\"int32\">),\n    created_at: toISOStringSafe(updated.created_at),\n    updated_at: toISOStringSafe(updated.updated_at),\n    deleted_at: updated.deleted_at ? toISOStringSafe(updated.deleted_at) : null,\n  } satisfies ITodoAppTodo;\n}\n","endpoint":{"method":"put","path":"/todoApp/user/todos/{todoId}"},"name":"putTodoAppUserTodosTodoId"},{"location":"src/providers/deleteTodoAppUserTodosTodoId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function deleteTodoAppUserTodosTodoId(props: {\n  user: UserPayload;\n  todoId: string & tags.Format<\"uuid\">;\n}): Promise<void> {\n  const { user, todoId } = props;\n\n  // Fetch minimal fields to verify ownership and current deleted state\n  const todo = await MyGlobal.prisma.todo_app_todos.findUnique({\n    where: { id: todoId },\n    select: { id: true, user_id: true, deleted_at: true },\n  });\n\n  if (!todo) {\n    throw new HttpException(\"Not Found: Todo not found\", 404);\n  }\n\n  if (todo.user_id !== user.id) {\n    throw new HttpException(\n      \"Unauthorized: You can only delete your own todos\",\n      403,\n    );\n  }\n\n  // Idempotent: if already soft-deleted, succeed (no-op)\n  if (todo.deleted_at) return;\n\n  const now = toISOStringSafe(new Date());\n\n  await MyGlobal.prisma.todo_app_todos.update({\n    where: { id: todoId },\n    data: {\n      deleted_at: now,\n    },\n  });\n}\n","endpoint":{"method":"delete","path":"/todoApp/user/todos/{todoId}"},"name":"deleteTodoAppUserTodosTodoId"},{"location":"src/providers/getTodoAppUserTodosTodoIdVersionsVersionId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppTodoSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodoSnapshot\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function getTodoAppUserTodosTodoIdVersionsVersionId(props: {\n  user: UserPayload;\n  todoId: string & tags.Format<\"uuid\">;\n  versionId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoAppTodoSnapshot> {\n  const { user, todoId, versionId } = props;\n\n  const snapshot = await MyGlobal.prisma.todo_app_todo_snapshots.findUnique({\n    where: { id: versionId },\n  });\n\n  if (!snapshot) throw new HttpException(\"Not Found\", 404);\n  if (snapshot.todo_app_todo_id !== todoId)\n    throw new HttpException(\"Not Found\", 404);\n\n  const parent = await MyGlobal.prisma.todo_app_todos.findUnique({\n    where: { id: todoId },\n    select: { user_id: true },\n  });\n\n  if (!parent) throw new HttpException(\"Not Found\", 404);\n  if (parent.user_id !== user.id)\n    throw new HttpException(\n      \"Unauthorized: You can only access your own snapshots\",\n      403,\n    );\n\n  return {\n    id: snapshot.id as string & tags.Format<\"uuid\">,\n    todo_app_todo_id: snapshot.todo_app_todo_id as string & tags.Format<\"uuid\">,\n    title: snapshot.title,\n    description: snapshot.description ?? null,\n    is_completed: snapshot.is_completed,\n    completed_at: snapshot.completed_at\n      ? toISOStringSafe(snapshot.completed_at)\n      : null,\n    position: snapshot.position ?? null,\n    created_at: toISOStringSafe(snapshot.created_at),\n    updated_at: toISOStringSafe(snapshot.updated_at),\n    deleted_at: snapshot.deleted_at\n      ? toISOStringSafe(snapshot.deleted_at)\n      : null,\n    snapshot_at: toISOStringSafe(snapshot.snapshot_at),\n  };\n}\n","endpoint":{"method":"get","path":"/todoApp/user/todos/{todoId}/versions/{versionId}"},"name":"getTodoAppUserTodosTodoIdVersionsVersionId"},{"location":"src/providers/getTodoAppAdminTodosTodoIdVersionsVersionId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppTodoSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppTodoSnapshot\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function getTodoAppAdminTodosTodoIdVersionsVersionId(props: {\n  admin: AdminPayload;\n  todoId: string & tags.Format<\"uuid\">;\n  versionId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoAppTodoSnapshot> {\n  const { admin, todoId, versionId } = props;\n\n  // Authorization: ensure admin still exists\n  const adminRecord = await MyGlobal.prisma.todo_app_admin.findUnique({\n    where: { id: admin.id },\n  });\n  if (!adminRecord) throw new HttpException(\"Unauthorized\", 403);\n\n  // Retrieve snapshot and ensure it belongs to provided todoId\n  const snapshot = await MyGlobal.prisma.todo_app_todo_snapshots.findFirst({\n    where: {\n      id: versionId,\n      todo_app_todo_id: todoId,\n    },\n  });\n\n  if (!snapshot) throw new HttpException(\"Not Found\", 404);\n\n  // Prepare timestamp once and reuse\n  const now = toISOStringSafe(new Date());\n\n  // Record audit event for admin view\n  await MyGlobal.prisma.todo_app_audit_records.create({\n    data: {\n      id: v4(),\n      admin_id: admin.id,\n      user_id: null,\n      actor_role: \"admin\",\n      action_type: \"view_snapshot\",\n      target_resource: \"todo_snapshot\",\n      target_id: versionId,\n      reason: null,\n      created_at: now,\n    },\n  });\n\n  // Map and convert date fields to ISO strings for the API response\n  return {\n    id: snapshot.id,\n    todo_app_todo_id: snapshot.todo_app_todo_id,\n    title: snapshot.title,\n    description: snapshot.description ?? null,\n    is_completed: snapshot.is_completed,\n    completed_at: snapshot.completed_at\n      ? toISOStringSafe(snapshot.completed_at)\n      : null,\n    position: snapshot.position ?? null,\n    created_at: toISOStringSafe(snapshot.created_at),\n    updated_at: toISOStringSafe(snapshot.updated_at),\n    deleted_at: snapshot.deleted_at\n      ? toISOStringSafe(snapshot.deleted_at)\n      : null,\n    snapshot_at: toISOStringSafe(snapshot.snapshot_at),\n  };\n}\n","endpoint":{"method":"get","path":"/todoApp/admin/todos/{todoId}/versions/{versionId}"},"name":"getTodoAppAdminTodosTodoIdVersionsVersionId"},{"location":"src/providers/patchTodoAppAdminAuditRecords.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppAuditRecord } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAuditRecord\";\nimport { IPageITodoAppAuditRecord } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppAuditRecord\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function patchTodoAppAdminAuditRecords(props: {\n  admin: AdminPayload;\n  body: ITodoAppAuditRecord.IRequest;\n}): Promise<IPageITodoAppAuditRecord> {\n  const { admin, body } = props;\n\n  // Authorization: ensure admin exists\n  const adminRecord = await MyGlobal.prisma.todo_app_admin.findUnique({\n    where: { id: admin.id },\n  });\n  if (adminRecord === null)\n    throw new HttpException(\"Unauthorized: admin not found\", 403);\n\n  // Pagination defaults and caps\n  const maxPageSize = 200;\n  const page = Number(body.page ?? 1);\n  const limit = Math.min(Number(body.pageSize ?? 20), maxPageSize);\n  const skip = (page - 1) * limit;\n\n  // Build where conditions inline\n  const whereCondition = {\n    ...(body.actor_role !== undefined && { actor_role: body.actor_role }),\n    ...(body.action_type !== undefined && { action_type: body.action_type }),\n    ...(body.target_resource !== undefined && {\n      target_resource: body.target_resource,\n    }),\n    ...(body.target_id !== undefined &&\n      body.target_id !== null && { target_id: body.target_id }),\n    ...((body.created_at_from !== undefined && body.created_at_from !== null) ||\n    (body.created_at_to !== undefined && body.created_at_to !== null)\n      ? {\n          created_at: {\n            ...(body.created_at_from !== undefined &&\n              body.created_at_from !== null && { gte: body.created_at_from }),\n            ...(body.created_at_to !== undefined &&\n              body.created_at_to !== null && { lte: body.created_at_to }),\n          },\n        }\n      : {}),\n  };\n\n  // Execute queries in parallel\n  const [rows, total] = await Promise.all([\n    MyGlobal.prisma.todo_app_audit_records.findMany({\n      where: whereCondition,\n      orderBy:\n        body.sort_by === \"created_at\"\n          ? { created_at: body.sort_order === \"asc\" ? \"asc\" : \"desc\" }\n          : body.sort_by === \"action_type\"\n            ? { action_type: body.sort_order === \"asc\" ? \"asc\" : \"desc\" }\n            : body.sort_by === \"actor_role\"\n              ? { actor_role: body.sort_order === \"asc\" ? \"asc\" : \"desc\" }\n              : { created_at: \"desc\" },\n      skip,\n      take: limit,\n      select: {\n        id: true,\n        admin_id: true,\n        user_id: true,\n        actor_role: true,\n        action_type: true,\n        target_resource: true,\n        target_id: true,\n        reason: true,\n        created_at: true,\n      },\n    }),\n    MyGlobal.prisma.todo_app_audit_records.count({ where: whereCondition }),\n  ]);\n\n  // Record the admin search as an audit event\n  const now = toISOStringSafe(new Date());\n  await MyGlobal.prisma.todo_app_audit_records.create({\n    data: {\n      id: v4() as string & tags.Format<\"uuid\">,\n      admin_id: admin.id,\n      user_id: null,\n      actor_role: \"admin\",\n      action_type: \"search_audit_records\",\n      target_resource: body.target_resource ?? \"audit\",\n      target_id: body.target_id ?? null,\n      reason: JSON.stringify({ filters: body }),\n      created_at: now,\n    },\n  });\n\n  // Map results to API DTO format\n  const data = rows.map((r) => ({\n    id: r.id as string & tags.Format<\"uuid\">,\n    admin_id:\n      r.admin_id === null ? null : (r.admin_id as string & tags.Format<\"uuid\">),\n    user_id:\n      r.user_id === null ? null : (r.user_id as string & tags.Format<\"uuid\">),\n    actor_role: r.actor_role,\n    action_type: r.action_type,\n    target_resource: r.target_resource,\n    target_id:\n      r.target_id === null\n        ? null\n        : (r.target_id as string & tags.Format<\"uuid\">),\n    reason: r.reason === null ? null : r.reason,\n    created_at: toISOStringSafe(r.created_at),\n  }));\n\n  return {\n    pagination: {\n      current: Number(page),\n      limit: Number(limit),\n      records: Number(total),\n      pages: Number(Math.ceil(total / limit)),\n    },\n    data,\n  };\n}\n","endpoint":{"method":"patch","path":"/todoApp/admin/auditRecords"},"name":"patchTodoAppAdminAuditRecords"},{"location":"src/providers/getTodoAppAdminAuditRecordsAuditRecordId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppAuditRecord } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAuditRecord\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function getTodoAppAdminAuditRecordsAuditRecordId(props: {\n  admin: AdminPayload;\n  auditRecordId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoAppAuditRecord> {\n  const { admin, auditRecordId } = props;\n\n  const adminRecord = await MyGlobal.prisma.todo_app_admin.findUnique({\n    where: { id: admin.id },\n    select: { id: true },\n  });\n\n  if (!adminRecord) {\n    throw new HttpException(\"Unauthorized: admin not found\", 403);\n  }\n\n  const record = await MyGlobal.prisma.todo_app_audit_records.findUnique({\n    where: { id: auditRecordId },\n  });\n\n  if (!record) {\n    throw new HttpException(\"Not Found\", 404);\n  }\n\n  return {\n    id: record.id as string & tags.Format<\"uuid\">,\n    admin_id:\n      record.admin_id === null\n        ? null\n        : (record.admin_id as string & tags.Format<\"uuid\">),\n    user_id:\n      record.user_id === null\n        ? null\n        : (record.user_id as string & tags.Format<\"uuid\">),\n    actor_role: record.actor_role,\n    action_type: record.action_type,\n    target_resource: record.target_resource,\n    target_id:\n      record.target_id === null\n        ? null\n        : (record.target_id as string & tags.Format<\"uuid\">),\n    reason: record.reason ?? null,\n    created_at: toISOStringSafe(record.created_at),\n  };\n}\n","endpoint":{"method":"get","path":"/todoApp/admin/auditRecords/{auditRecordId}"},"name":"getTodoAppAdminAuditRecordsAuditRecordId"},{"location":"src/providers/getTodoAppAdminGuestsGuestId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppGuest } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppGuest\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function getTodoAppAdminGuestsGuestId(props: {\n  admin: AdminPayload;\n  guestId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoAppGuest> {\n  const { admin, guestId } = props;\n\n  // Strict UUID v4 format validation\n  const uuidRegex =\n    /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n  if (!uuidRegex.test(guestId)) {\n    throw new HttpException(\"Bad Request: Invalid UUID\", 400);\n  }\n\n  try {\n    const guest = await MyGlobal.prisma.todo_app_guest.findUnique({\n      where: { id: guestId },\n    });\n\n    if (!guest) throw new HttpException(\"Not Found\", 404);\n\n    const auditCreatedAt = toISOStringSafe(new Date());\n\n    await MyGlobal.prisma.todo_app_audit_records.create({\n      data: {\n        id: v4() as string & tags.Format<\"uuid\">,\n        admin_id: admin.id,\n        user_id: null,\n        actor_role: \"admin\",\n        action_type: \"read_guest\",\n        target_resource: \"guest\",\n        target_id: guestId,\n        reason: null,\n        created_at: auditCreatedAt,\n      },\n    });\n\n    return {\n      id: guest.id as string & tags.Format<\"uuid\">,\n      email: guest.email ?? null,\n      created_at: toISOStringSafe(guest.created_at),\n      last_active_at: guest.last_active_at\n        ? toISOStringSafe(guest.last_active_at)\n        : null,\n      status: guest.status ?? null,\n    };\n  } catch (e) {\n    if (e instanceof HttpException) throw e;\n    throw new HttpException(\"Internal Server Error\", 500);\n  }\n}\n","endpoint":{"method":"get","path":"/todoApp/admin/guests/{guestId}"},"name":"getTodoAppAdminGuestsGuestId"},{"location":"src/providers/patchTodoAppAdminUsers.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\nimport { IPageITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppUser\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function patchTodoAppAdminUsers(props: {\n  admin: AdminPayload;\n  body: ITodoAppUser.IRequest;\n}): Promise<IPageITodoAppUser.ISummary> {\n  const { admin, body } = props;\n\n  const rawPage = (body.page ?? 1) as number & tags.Type<\"int32\"> as number;\n  const rawPageSize = (body.pageSize ?? 20) as number &\n    tags.Type<\"int32\"> as number;\n  const page = Number(rawPage >= 1 ? rawPage : 1);\n  const pageSize = Number(rawPageSize <= 0 ? 20 : Math.min(rawPageSize, 100));\n\n  const allowedStatuses = [\"active\", \"suspended\"];\n  const allowedSortBy = [\"created_at\", \"last_active_at\"] as const;\n\n  if (page < 1) throw new HttpException(\"page must be >= 1\", 400);\n  if (pageSize < 1 || pageSize > 100)\n    throw new HttpException(\"pageSize must be between 1 and 100\", 400);\n  if (\n    body.account_status !== undefined &&\n    body.account_status !== null &&\n    !allowedStatuses.includes(body.account_status)\n  ) {\n    throw new HttpException(\"Invalid account_status\", 400);\n  }\n  if (\n    body.emailLike !== undefined &&\n    body.emailLike !== null &&\n    body.emailLike.length > 256\n  ) {\n    throw new HttpException(\"emailLike too long\", 400);\n  }\n\n  const sortBy = (\n    body.sortBy && allowedSortBy.includes(body.sortBy as any)\n      ? body.sortBy\n      : \"created_at\"\n  ) as (typeof allowedSortBy)[number];\n  const order = body.order === \"asc\" ? \"asc\" : \"desc\";\n\n  try {\n    const [rows, total] = await Promise.all([\n      MyGlobal.prisma.todo_app_user.findMany({\n        where: {\n          ...(body.account_status !== undefined &&\n            body.account_status !== null && {\n              account_status: body.account_status,\n            }),\n          ...(body.emailLike !== undefined &&\n            body.emailLike !== null && { email: { contains: body.emailLike } }),\n        },\n        select: {\n          id: true,\n          email: true,\n          display_name: true,\n          account_status: true,\n          created_at: true,\n          last_active_at: true,\n        },\n        orderBy:\n          sortBy === \"created_at\"\n            ? { created_at: order }\n            : { last_active_at: order },\n        skip: (page - 1) * pageSize,\n        take: pageSize,\n      }),\n      MyGlobal.prisma.todo_app_user.count({\n        where: {\n          ...(body.account_status !== undefined &&\n            body.account_status !== null && {\n              account_status: body.account_status,\n            }),\n          ...(body.emailLike !== undefined &&\n            body.emailLike !== null && { email: { contains: body.emailLike } }),\n        },\n      }),\n    ]);\n\n    const now = toISOStringSafe(new Date());\n    const filtersSummary = [] as string[];\n    if (body.account_status !== undefined && body.account_status !== null)\n      filtersSummary.push(`account_status=${body.account_status}`);\n    if (body.emailLike !== undefined && body.emailLike !== null)\n      filtersSummary.push(`emailLike_provided=true`);\n\n    await MyGlobal.prisma.todo_app_audit_records.create({\n      data: {\n        id: v4() as string & tags.Format<\"uuid\">,\n        admin_id: admin.id,\n        user_id: null,\n        actor_role: \"admin\",\n        action_type: \"search_users\",\n        target_resource: \"user\",\n        target_id: null,\n        reason: filtersSummary.length > 0 ? filtersSummary.join(\",\") : null,\n        created_at: now,\n      },\n    });\n\n    const data = rows.map((u) => ({\n      id: u.id as string & tags.Format<\"uuid\">,\n      email: u.email as string & tags.Format<\"email\">,\n      display_name: u.display_name ?? null,\n      account_status: u.account_status,\n      created_at: toISOStringSafe(u.created_at),\n      last_active_at: u.last_active_at\n        ? toISOStringSafe(u.last_active_at)\n        : null,\n    }));\n\n    return {\n      pagination: {\n        current: Number(page),\n        limit: Number(pageSize),\n        records: total,\n        pages: Math.ceil(total / pageSize),\n      },\n      data,\n    };\n  } catch (err) {\n    throw new HttpException(\"Internal Server Error\", 500);\n  }\n}\n","endpoint":{"method":"patch","path":"/todoApp/admin/users"},"name":"patchTodoAppAdminUsers"},{"location":"src/providers/getTodoAppUserUsersUserId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function getTodoAppUserUsersUserId(props: {\n  user: UserPayload;\n  userId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoAppUser> {\n  const { user, userId } = props;\n\n  // Authorization: only owner allowed (admin path not available in props)\n  if (user.id !== userId) {\n    throw new HttpException(\n      \"Forbidden: You can only access your own profile\",\n      403,\n    );\n  }\n\n  try {\n    const record = await MyGlobal.prisma.todo_app_user.findUnique({\n      where: { id: userId },\n      select: {\n        id: true,\n        email: true,\n        display_name: true,\n        account_status: true,\n        created_at: true,\n        updated_at: true,\n        last_active_at: true,\n      },\n    });\n\n    if (record === null) {\n      throw new HttpException(\"Not Found\", 404);\n    }\n\n    return {\n      id: record.id as string & tags.Format<\"uuid\">,\n      email: record.email as string & tags.Format<\"email\">,\n      display_name: record.display_name ?? null,\n      account_status: record.account_status,\n      created_at: toISOStringSafe(record.created_at),\n      updated_at: toISOStringSafe(record.updated_at),\n      last_active_at: record.last_active_at\n        ? toISOStringSafe(record.last_active_at)\n        : null,\n    };\n  } catch (err) {\n    if (err instanceof HttpException) throw err;\n    throw new HttpException(\"Internal Server Error\", 500);\n  }\n}\n","endpoint":{"method":"get","path":"/todoApp/user/users/{userId}"},"name":"getTodoAppUserUsersUserId"},{"location":"src/providers/getTodoAppAdminUsersUserId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function getTodoAppAdminUsersUserId(props: {\n  admin: AdminPayload;\n  userId: string & tags.Format<\"uuid\">;\n}): Promise<ITodoAppUser> {\n  const { admin, userId } = props;\n\n  // Authorization: verify admin still exists in the database\n  const adminRecord = await MyGlobal.prisma.todo_app_admin.findUnique({\n    where: { id: admin.id },\n    select: { id: true },\n  });\n\n  if (adminRecord === null) {\n    throw new HttpException(\"Unauthorized\", 403);\n  }\n\n  // Retrieve user. Explicitly select only non-sensitive fields.\n  const user = await MyGlobal.prisma.todo_app_user.findUnique({\n    where: { id: userId },\n    select: {\n      id: true,\n      email: true,\n      display_name: true,\n      account_status: true,\n      created_at: true,\n      updated_at: true,\n      last_active_at: true,\n    },\n  });\n\n  if (user === null) {\n    throw new HttpException(\"Not Found\", 404);\n  }\n\n  // Prepare audit timestamp once and reuse\n  const now = toISOStringSafe(new Date());\n\n  // Record admin access for auditability\n  await MyGlobal.prisma.todo_app_audit_records.create({\n    data: {\n      id: v4() as string & tags.Format<\"uuid\">,\n      admin_id: admin.id,\n      user_id: userId,\n      actor_role: \"admin\",\n      action_type: \"read_user\",\n      target_resource: \"user\",\n      target_id: userId,\n      reason: null,\n      created_at: now,\n    },\n  });\n\n  return {\n    id: user.id,\n    email: user.email,\n    display_name: user.display_name ?? null,\n    account_status: user.account_status,\n    created_at: toISOStringSafe(user.created_at),\n    updated_at: toISOStringSafe(user.updated_at),\n    last_active_at: user.last_active_at\n      ? toISOStringSafe(user.last_active_at)\n      : null,\n  };\n}\n","endpoint":{"method":"get","path":"/todoApp/admin/users/{userId}"},"name":"getTodoAppAdminUsersUserId"},{"location":"src/providers/putTodoAppUserUsersUserId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function putTodoAppUserUsersUserId(props: {\n  user: UserPayload;\n  userId: string & tags.Format<\"uuid\">;\n  body: ITodoAppUser.IUpdate;\n}): Promise<ITodoAppUser> {\n  const { user, userId, body } = props;\n\n  // Authorization: only owner may update their profile\n  if (user.id !== userId) {\n    throw new HttpException(\n      \"Unauthorized: You can only update your own profile\",\n      403,\n    );\n  }\n\n  // Ensure user exists\n  const existing = await MyGlobal.prisma.todo_app_user.findUnique({\n    where: { id: userId },\n  });\n  if (existing === null) {\n    throw new HttpException(\"Not Found\", 404);\n  }\n\n  // Prepare timestamp once and reuse\n  const now = toISOStringSafe(new Date());\n\n  // Perform update - inline data object to preserve clear type errors\n  const updated = await MyGlobal.prisma.todo_app_user.update({\n    where: { id: userId },\n    data: {\n      display_name:\n        body.display_name === undefined ? undefined : body.display_name,\n      updated_at: now,\n    },\n  });\n\n  // Map Prisma result to API DTO, converting Date -> ISO strings\n  return {\n    id: updated.id as string & tags.Format<\"uuid\">,\n    email: updated.email as string & tags.Format<\"email\">,\n    display_name: updated.display_name ?? undefined,\n    account_status: updated.account_status,\n    created_at: toISOStringSafe(updated.created_at),\n    updated_at: now,\n    last_active_at: updated.last_active_at\n      ? toISOStringSafe(updated.last_active_at)\n      : null,\n  };\n}\n","endpoint":{"method":"put","path":"/todoApp/user/users/{userId}"},"name":"putTodoAppUserUsersUserId"},{"location":"src/providers/putTodoAppAdminUsersUserId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppUser\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function putTodoAppAdminUsersUserId(props: {\n  admin: AdminPayload;\n  userId: string & tags.Format<\"uuid\">;\n  body: ITodoAppUser.IUpdate;\n}): Promise<ITodoAppUser> {\n  const { admin, userId, body } = props;\n\n  // Ensure target exists\n  const existing = await MyGlobal.prisma.todo_app_user.findUnique({\n    where: { id: userId },\n    select: {\n      id: true,\n    },\n  });\n\n  if (!existing) {\n    throw new HttpException(\"Not Found\", 404);\n  }\n\n  try {\n    // Perform update (only include display_name if provided)\n    const updated = await MyGlobal.prisma.todo_app_user.update({\n      where: { id: userId },\n      data: {\n        ...(body.display_name !== undefined && {\n          display_name: body.display_name,\n        }),\n        updated_at: toISOStringSafe(new Date()),\n      },\n      select: {\n        id: true,\n        email: true,\n        display_name: true,\n        account_status: true,\n        created_at: true,\n        updated_at: true,\n        last_active_at: true,\n      },\n    });\n\n    // Create audit record for this admin action\n    await MyGlobal.prisma.todo_app_audit_records.create({\n      data: {\n        id: v4(),\n        admin_id: admin.id,\n        user_id: userId,\n        actor_role: \"admin\",\n        action_type: \"update_user\",\n        target_resource: \"todo_app_user\",\n        target_id: userId,\n        created_at: toISOStringSafe(new Date()),\n      },\n    });\n\n    // Map Prisma Date objects to ISO strings for API response\n    return {\n      id: updated.id,\n      email: updated.email,\n      display_name: updated.display_name ?? null,\n      account_status: updated.account_status,\n      created_at: toISOStringSafe(updated.created_at),\n      updated_at: toISOStringSafe(updated.updated_at),\n      last_active_at: updated.last_active_at\n        ? toISOStringSafe(updated.last_active_at)\n        : null,\n    };\n  } catch (err) {\n    // Prisma not found in update would have been caught earlier. For other errors, return 500.\n    throw new HttpException(\"Internal Server Error\", 500);\n  }\n}\n","endpoint":{"method":"put","path":"/todoApp/admin/users/{userId}"},"name":"putTodoAppAdminUsersUserId"},{"location":"src/providers/patchTodoAppAdminAdmins.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport { IPageITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoAppAdmin\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function patchTodoAppAdminAdmins(props: {\n  admin: AdminPayload;\n  body: ITodoAppAdmin.IRequest;\n}): Promise<IPageITodoAppAdmin.ISummary> {\n  const { admin, body } = props;\n\n  // Confirm caller exists in DB (authorization check)\n  const caller = await MyGlobal.prisma.todo_app_admin.findUnique({\n    where: { id: admin.id },\n  });\n  if (!caller) throw new HttpException(\"Unauthorized\", 403);\n\n  // Pagination defaults and validation\n  const page = Number(body.page ?? 1);\n  if (!Number.isFinite(page) || page < 1)\n    throw new HttpException(\"Bad Request: page must be >= 1\", 400);\n\n  const pageSize = Number(body.pageSize ?? 20);\n  if (!Number.isFinite(pageSize) || pageSize < 1 || pageSize > 100)\n    throw new HttpException(\n      \"Bad Request: pageSize must be between 1 and 100\",\n      400,\n    );\n\n  // Sorting validation\n  const allowedSortBy = [\"created_at\", \"last_active_at\"] as const;\n  const sort_by = body.sort_by ?? \"created_at\";\n  if (!allowedSortBy.includes(sort_by as any))\n    throw new HttpException(\"Bad Request: invalid sort_by\", 400);\n  const sort_order = body.sort_order === \"asc\" ? \"asc\" : \"desc\";\n\n  // Build where clause\n  const where: Record<string, unknown> = {};\n  if (body.email !== undefined && body.email !== null) {\n    where.email = body.email;\n  }\n  if (body.emailLike !== undefined && body.emailLike !== null) {\n    where.email = { contains: body.emailLike };\n  }\n  if (body.is_super !== undefined && body.is_super !== null) {\n    where.is_super = body.is_super;\n  }\n  if (\n    (body.created_from !== undefined && body.created_from !== null) ||\n    (body.created_to !== undefined && body.created_to !== null)\n  ) {\n    const createdAt: Record<string, unknown> = {};\n    if (body.created_from !== undefined && body.created_from !== null)\n      createdAt.gte = toISOStringSafe(body.created_from);\n    if (body.created_to !== undefined && body.created_to !== null)\n      createdAt.lte = toISOStringSafe(body.created_to);\n    where.created_at = createdAt;\n  }\n\n  try {\n    const [rows, total] = await Promise.all([\n      MyGlobal.prisma.todo_app_admin.findMany({\n        where,\n        orderBy: { [sort_by]: sort_order },\n        skip: (page - 1) * pageSize,\n        take: pageSize,\n        select: {\n          id: true,\n          email: true,\n          is_super: true,\n          created_at: true,\n          last_active_at: true,\n        },\n      }),\n      MyGlobal.prisma.todo_app_admin.count({ where }),\n    ]);\n\n    const data = rows.map((r) => {\n      const item = {\n        id: r.id,\n        email: r.email,\n        is_super: r.is_super,\n        created_at: toISOStringSafe(r.created_at),\n        last_active_at: r.last_active_at\n          ? toISOStringSafe(r.last_active_at)\n          : null,\n      } satisfies ITodoAppAdmin.ISummary;\n      return item;\n    });\n\n    const pagination = {\n      current: Number(page),\n      limit: Number(pageSize),\n      records: Number(total),\n      pages: Math.ceil(total / pageSize),\n    } satisfies IPage.IPagination;\n\n    // Audit logging\n    const auditId = v4() satisfies string & tags.Format<\"uuid\">;\n    await MyGlobal.prisma.todo_app_audit_records.create({\n      data: {\n        id: auditId,\n        admin_id: admin.id,\n        user_id: null,\n        actor_role: \"admin\",\n        action_type: \"list_admins\",\n        target_resource: \"todo_app_admin\",\n        target_id: null,\n        reason: body.emailLike ?? body.email ?? null,\n        created_at: toISOStringSafe(new Date()),\n      },\n    });\n\n    return {\n      pagination,\n      data,\n    } satisfies IPageITodoAppAdmin.ISummary;\n  } catch (error) {\n    throw new HttpException(\"Internal Server Error\", 500);\n  }\n}\n","endpoint":{"method":"patch","path":"/todoApp/admin/admins"},"name":"patchTodoAppAdminAdmins"},{"location":"src/providers/putTodoAppAdminAdminsAdminId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoAppAdmin } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoAppAdmin\";\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function putTodoAppAdminAdminsAdminId(props: {\n  admin: AdminPayload;\n  adminId: string & tags.Format<\"uuid\">;\n  body: ITodoAppAdmin.IUpdate;\n}): Promise<ITodoAppAdmin.ISummary> {\n  const { admin, adminId, body } = props;\n\n  // Business validation: at least one mutable field must be present\n  if (\n    body.email === undefined &&\n    body.is_super === undefined &&\n    body.last_active_at === undefined\n  ) {\n    throw new HttpException(\"Bad Request: no updatable fields provided\", 400);\n  }\n\n  // Authorization for privileged change\n  if (body.is_super !== undefined) {\n    const caller = await MyGlobal.prisma.todo_app_admin.findUnique({\n      where: { id: admin.id },\n    });\n    if (!caller) throw new HttpException(\"Unauthorized: caller not found\", 401);\n    if (caller.is_super !== true) {\n      throw new HttpException(\n        \"Forbidden: only super-admin can modify is_super\",\n        403,\n      );\n    }\n  }\n\n  // Ensure the target admin exists\n  const target = await MyGlobal.prisma.todo_app_admin.findUnique({\n    where: { id: adminId },\n  });\n  if (!target) throw new HttpException(\"Not Found\", 404);\n\n  // Email uniqueness check\n  if (body.email !== undefined) {\n    const existing = await MyGlobal.prisma.todo_app_admin.findFirst({\n      where: { email: body.email },\n    });\n    if (existing && existing.id !== adminId) {\n      throw new HttpException(\"Conflict: email already in use\", 409);\n    }\n  }\n\n  // Perform update with inline data object\n  const updated = await MyGlobal.prisma.todo_app_admin.update({\n    where: { id: adminId },\n    data: {\n      ...(body.email !== undefined ? { email: body.email } : {}),\n      ...(body.is_super !== undefined ? { is_super: body.is_super } : {}),\n      ...(body.last_active_at !== undefined\n        ? {\n            last_active_at:\n              body.last_active_at === null\n                ? null\n                : toISOStringSafe(body.last_active_at),\n          }\n        : {}),\n    },\n  });\n\n  // Audit side-effect\n  await MyGlobal.prisma.todo_app_audit_records.create({\n    data: {\n      id: v4() as string & tags.Format<\"uuid\">,\n      admin_id: admin.id,\n      user_id: null,\n      actor_role: \"admin\",\n      action_type: \"update_admin\",\n      target_resource: \"admin\",\n      target_id: adminId,\n      reason: null,\n      created_at: toISOStringSafe(new Date()),\n    },\n  });\n\n  return {\n    id: updated.id as string & tags.Format<\"uuid\">,\n    email: updated.email as string & tags.Format<\"email\">,\n    is_super: updated.is_super,\n    created_at: toISOStringSafe(updated.created_at),\n    last_active_at: updated.last_active_at\n      ? toISOStringSafe(updated.last_active_at)\n      : null,\n  };\n}\n","endpoint":{"method":"put","path":"/todoApp/admin/admins/{adminId}"},"name":"putTodoAppAdminAdminsAdminId"},{"location":"src/providers/deleteTodoAppAdminAdminsAdminId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/PasswordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { AdminPayload } from \"../decorators/payload/AdminPayload\";\n\nexport async function deleteTodoAppAdminAdminsAdminId(props: {\n  admin: AdminPayload;\n  adminId: string & tags.Format<\"uuid\">;\n}): Promise<void> {\n  const { admin, adminId } = props;\n\n  // Confirm caller exists and is authorized\n  const caller = await MyGlobal.prisma.todo_app_admin.findUnique({\n    where: { id: admin.id },\n  });\n  if (!caller) {\n    throw new HttpException(\"Unauthorized: caller not found\", 401);\n  }\n  if (!caller.is_super) {\n    throw new HttpException(\"Forbidden: super-admin required\", 403);\n  }\n\n  // Disallow self-deletion to prevent accidental lockout\n  if (admin.id === adminId) {\n    throw new HttpException(\"Conflict: self-deletion is forbidden\", 409);\n  }\n\n  // Verify target exists\n  const target = await MyGlobal.prisma.todo_app_admin.findUnique({\n    where: { id: adminId },\n  });\n  if (!target) {\n    throw new HttpException(\"Not Found\", 404);\n  }\n\n  // If target is a super-admin, ensure at least one other super-admin remains\n  if (target.is_super) {\n    const otherSuperCount = await MyGlobal.prisma.todo_app_admin.count({\n      where: { is_super: true, id: { not: adminId } },\n    });\n    if (otherSuperCount === 0) {\n      throw new HttpException(\n        \"Conflict: cannot delete the last remaining super-admin\",\n        409,\n      );\n    }\n  }\n\n  // Timestamp for audit record\n  const created_at = toISOStringSafe(new Date());\n\n  try {\n    await MyGlobal.prisma.$transaction([\n      // Create an append-only audit record documenting the erase action\n      MyGlobal.prisma.todo_app_audit_records.create({\n        data: {\n          id: v4() as string & tags.Format<\"uuid\">,\n          admin_id: admin.id,\n          user_id: null,\n          actor_role: \"admin\",\n          action_type: \"erase_admin\",\n          target_resource: \"admin\",\n          target_id: adminId,\n          reason: null,\n          created_at,\n        },\n      }),\n\n      // Hard-delete the admin record (no soft-delete field exists)\n      MyGlobal.prisma.todo_app_admin.delete({ where: { id: adminId } }),\n    ]);\n  } catch (error) {\n    // For security, avoid leaking internal DB errors. Return generic 500.\n    throw new HttpException(\"Internal Server Error\", 500);\n  }\n}\n","endpoint":{"method":"delete","path":"/todoApp/admin/admins/{adminId}"},"name":"deleteTodoAppAdminAdminsAdminId"}],"controllers":{"src/controllers/auth/guest/AuthGuestController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\nimport { postAuthGuestJoin } from \"../../../providers/postAuthGuestJoin\";\nimport { postAuthGuestRefresh } from \"../../../providers/postAuthGuestRefresh\";\nimport { GuestAuth } from \"../../../decorators/GuestAuth\";\nimport { GuestPayload } from \"../../../decorators/payload/GuestPayload\";\n\nimport { ITodoAppGuest } from \"../../../api/structures/ITodoAppGuest\";\n\n@Controller(\"/auth/guest\")\nexport class AuthGuestController {\n  /**\n   * Create a guest record in the todo_app_guest table and issue temporary\n   * authorization tokens.\n   *\n   * Purpose and functionality: This endpoint allows an unauthenticated visitor\n   * to create a temporary guest record in the `todo_app_guest` table. The API\n   * accepts an optional `email` (if provided by the client) and the server will\n   * create a new record with a system-assigned `id` (UUID) and set\n   * `created_at`. The returned response contains an authorization payload\n   * (short-lived tokens) suitable for guest workflows.\n   *\n   * Implementation details using confirmed schema fields: The request maps\n   * directly to fields present in the Prisma model `todo_app_guest`.\n   * Specifically, provided `email` maps to `todo_app_guest.email`. The server\n   * will set `todo_app_guest.id` (UUID) and `todo_app_guest.created_at`\n   * (timestamp). The server may also initialize `todo_app_guest.status` and\n   * leave `last_active_at` null until the guest performs subsequent activity.\n   *\n   * Role-specific integration and business context: This operation is a public\n   * join endpoint for the role 'guest' and is intended to be used in client\n   * flows that need temporary identity without full user registration. Because\n   * the `email` column in `todo_app_guest` is nullable in the schema, the\n   * request may omit `email` to create an anonymous guest record. The response\n   * follows the authorization response naming convention and returns\n   * `ITodoAppGuest.IAuthorized` as the successful response type.\n   *\n   * Security considerations within schema constraints: Validate the optional\n   * `email` format when present (RFC 5322 basic validation) and rate-limit join\n   * attempts to prevent abuse. Do not store additional user credentials in\n   * `todo_app_guest.password` because that field does not exist. Keep issued\n   * tokens short-lived and tie refresh operations to the guest `id` and\n   * `last_active_at` lifecycle.\n   *\n   * Related operations and workflow integration: This operation pairs with\n   * `POST /auth/guest/refresh` which can update `todo_app_guest.last_active_at`\n   * and may create audit entries in `todo_app_audit_records` (for example,\n   * recording refresh events using `todo_app_audit_records.actor_role`,\n   * `action_type`, `target_resource`, `target_id`, and `created_at`).\n   *\n   * @param connection\n   * @param body Guest registration payload. Maps to `todo_app_guest.email`\n   *   (nullable). If omitted, an anonymous guest record is created.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"join\")\n  public async join(\n    @TypedBody()\n    body: ITodoAppGuest.IJoin,\n  ): Promise<ITodoAppGuest.IAuthorized> {\n    try {\n      return await postAuthGuestJoin({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Exchange a valid guest refresh credential for a new access token and update\n   * guest activity metadata in todo_app_guest.\n   *\n   * Purpose and functionality: This endpoint accepts a valid guest refresh\n   * credential and issues a new short-lived access token (and optionally\n   * rotates the refresh token). It targets the `todo_app_guest` table so that\n   * guest activity can be associated with the `id` and `last_active_at`\n   * fields.\n   *\n   * Implementation details using confirmed schema fields: On successful\n   * validation of the presented refresh credential, the server SHOULD update\n   * `todo_app_guest.last_active_at` to the current server timestamp and may\n   * record the refresh event in `todo_app_audit_records` by populating\n   * `actor_role` (e.g., 'system' or 'guest'), `action_type` (e.g.,\n   * 'refresh_token'), `target_resource` = 'guest', `target_id` = the guest\n   * `id`, and `created_at` to capture the event time.\n   *\n   * Role-specific integration and business context: This operation is\n   * role-restricted: it requires a valid refresh credential tied to a\n   * previously created guest (role = 'guest'). The API path\n   * `/auth/guest/refresh` follows the service naming conventions for guest\n   * token lifecycle management and returns `ITodoAppGuest.IAuthorized` on\n   * success, matching the service prefix and role naming pattern.\n   *\n   * Security considerations within schema constraints: Rotate refresh tokens\n   * when practical and invalidate refresh tokens upon abuse detection. Because\n   * `todo_app_guest.password_hash` does not exist in the schema, do not attempt\n   * password-based verification for guests; instead rely on token material.\n   * Record refresh attempts and consider rate-limiting per guest `id` to reduce\n   * token replay risk.\n   *\n   * Related operations and workflow integration: This operation complements\n   * `/auth/guest/join` (which issues initial tokens) and may be followed by\n   * guest-scoped API calls. Audit entries for refresh events can be stored in\n   * `todo_app_audit_records` (fields: `actor_role`, `action_type`,\n   * `target_resource`, `target_id`, `created_at`) to help operations and\n   * security teams investigate token usage patterns.\n   *\n   * @param connection\n   * @param body Refresh request payload. Contains the refresh credential/token\n   *   associated with a guest identity. Server will validate and rotate as\n   *   appropriate.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"refresh\")\n  public async refresh(\n    @GuestAuth()\n    guest: GuestPayload,\n    @TypedBody()\n    body: ITodoAppGuest.IRefresh,\n  ): Promise<ITodoAppGuest.IAuthorized> {\n    try {\n      return await postAuthGuestRefresh({\n        guest,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/auth/user/AuthUserController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\nimport { postAuthUserJoin } from \"../../../providers/postAuthUserJoin\";\nimport { postAuthUserLogin } from \"../../../providers/postAuthUserLogin\";\nimport { postAuthUserRefresh } from \"../../../providers/postAuthUserRefresh\";\n\nimport { ITodoAppUser } from \"../../../api/structures/ITodoAppUser\";\n\n@Controller(\"/auth/user\")\nexport class AuthUserController {\n  /**\n   * Register a new TodoApp user (creates a row in todo_app_user).\n   *\n   * Purpose and overview: This endpoint registers a new user and persists a new\n   * record in the `todo_app_user` table. It uses the table's `email` field as\n   * the primary unique identifier for account creation and will cause a new\n   * `todo_app_user` row to be created with server-calculated `password_hash`,\n   * `created_at`, and `updated_at` values.\n   *\n   * Implementation details and required fields: The request must supply an\n   * `email` and a plaintext password (or equivalent credential material). The\n   * server implementation will compute and store `password_hash` in the\n   * `todo_app_user.password_hash` column and will enforce the unique constraint\n   * on `todo_app_user.email` (@@unique([email]) in the Prisma schema). The\n   * server will populate `created_at` and `updated_at` timestamps on the new\n   * row and initialize `account_status` according to product policy (for\n   * example, 'active' or 'unverified').\n   *\n   * Role-specific integration and business context: Registration is a public\n   * operation (no prior authentication required). The created user record is\n   * the same entity referenced by todo rows via `todo_app_todos.user_id`,\n   * enabling the app to later associate todos to this account. The operation\n   * ties into audit/auditing flows when admin review is required (audit entries\n   * may be created in `todo_app_audit_records` by administrative processes, not\n   * by this public join operation).\n   *\n   * Security considerations: The server MUST never store plaintext passwords;\n   * instead it MUST produce a secure `password_hash` and store it in\n   * `todo_app_user.password_hash`. Email uniqueness is enforced by the Prisma\n   * schema unique constraint on `email`; the server MUST handle duplicate-email\n   * errors gracefully. Returned tokens should be short-lived access tokens (for\n   * example, JWT) with a refresh token mechanism; the\n   * `todo_app_user.last_active_at` and `todo_app_user.updated_at` columns may\n   * be updated on successful immediate authentication after registration.\n   *\n   * Related operations and workflow integration: Typical next operations after\n   * successful join are `login` (if the server requires explicit login after\n   * verification) and `refresh` to renew tokens. If email verification is\n   * enabled by product policy, the server may create an out-of-band\n   * verification flow; note that there is no explicit `email_verified` column\n   * in `todo_app_user` in the Prisma schema, so verification state must be\n   * represented within `account_status` or an external store.\n   *\n   * @param connection\n   * @param body Registration payload for creating a new user account. Contains\n   *   a valid email and plaintext password. Optional display_name may be\n   *   included.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"join\")\n  public async join(\n    @TypedBody()\n    body: ITodoAppUser.ICreate,\n  ): Promise<ITodoAppUser.IAuthorized> {\n    try {\n      return await postAuthUserJoin({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Authenticate a TodoApp user (login against todo_app_user).\n   *\n   * Purpose and overview: This endpoint authenticates a user record from the\n   * `todo_app_user` table. It uses `email` to locate the account and verifies\n   * secrets against `todo_app_user.password_hash`. Successful authentication\n   * results in issuance of authorization material (access token and refresh\n   * token) and a response representing the authenticated user.\n   *\n   * Implementation details and required fields: Request must include `email`\n   * and password. The server will check `todo_app_user.email` (unique by\n   * schema) and verify the secret against `todo_app_user.password_hash`. On\n   * success the server SHOULD update `todo_app_user.last_active_at` and\n   * `todo_app_user.updated_at` to reflect activity and may set or confirm\n   * `account_status` (for example, deny login when `account_status` is\n   * 'suspended').\n   *\n   * Role-specific integration and business context: Login is a public operation\n   * used to obtain session tokens that allow management of todos owned by the\n   * authenticated user (todos are associated via `todo_app_todos.user_id`). The\n   * tokens returned by this endpoint are used by subsequent protected\n   * operations.\n   *\n   * Security considerations: Implement strong rate limiting for failed login\n   * attempts and ensure errors do not leak whether an email exists. Because the\n   * Prisma schema contains `password_hash` but not refresh-token storage\n   * columns, refresh token lifecycle may be managed by a dedicated token store\n   * external to the `todo_app_user` table; however `todo_app_user.updated_at`\n   * and `todo_app_user.last_active_at` are available within the schema to\n   * record activity.\n   *\n   * Related operations and workflow integration: Typical complementary\n   * operations include `refresh` to renew an access token and `changePassword`\n   * (authenticated) to update `todo_app_user.password_hash` for the account.\n   * Admin suspend/reactivate actions also interact with\n   * `todo_app_user.account_status` (managed by admin flows recorded in\n   * `todo_app_audit_records`).\n   *\n   * @param connection\n   * @param body Login payload containing `email` and `password` to authenticate\n   *   an existing user.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"login\")\n  public async login(\n    @TypedBody()\n    body: ITodoAppUser.ILogin,\n  ): Promise<ITodoAppUser.IAuthorized> {\n    try {\n      return await postAuthUserLogin({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Refresh access token for a TodoApp user (ties to todo_app_user identity).\n   *\n   * Purpose and overview: This endpoint renews an access token using a valid\n   * refresh token for a user record that exists in `todo_app_user`. The refresh\n   * flow ties the presented refresh token to the user identity so the server\n   * can return a fresh access token and possibly rotate the refresh token.\n   *\n   * Implementation details and required fields: Request payload should include\n   * a valid refresh token. Because the Prisma schema does not include an\n   * explicit refresh-token storage column, refresh token management is\n   * typically implemented using a separate token store; however the operation\n   * will still update `todo_app_user.last_active_at` and\n   * `todo_app_user.updated_at` to reflect the renewed session activity for\n   * auditing and presence metrics.\n   *\n   * Role-specific integration and business context: Refresh is a public\n   * endpoint that accepts a valid refresh token to provide continued\n   * authenticated access without re-entering credentials. The refreshed tokens\n   * continue to permit operations on `todo_app_todos` rows owned by the user\n   * (via `todo_app_todos.user_id`).\n   *\n   * Security considerations: Ensure refresh tokens are rotated or invalidated\n   * on logout or account suspension (check and propagate\n   * `todo_app_user.account_status` to deny refresh when suspended). Monitor and\n   * record suspicious refresh activity in `todo_app_audit_records` when\n   * appropriate.\n   *\n   * Related operations and workflow integration: `refresh` is commonly used\n   * after `login` and before protected operations; it complements `join` and\n   * `login` flows and should be part of the token lifecycle design alongside\n   * revocation and rotation strategies.\n   *\n   * @param connection\n   * @param body Refresh request containing a valid refresh token to obtain a\n   *   new access token.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"refresh\")\n  public async refresh(\n    @TypedBody()\n    body: ITodoAppUser.IRefresh,\n  ): Promise<ITodoAppUser.IAuthorized> {\n    try {\n      return await postAuthUserRefresh({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/auth/user/change-password/AuthUserChange_passwordController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\nimport { putAuthUserChangePassword } from \"../../../../providers/putAuthUserChangePassword\";\nimport { UserAuth } from \"../../../../decorators/UserAuth\";\nimport { UserPayload } from \"../../../../decorators/payload/UserPayload\";\n\nimport { ITodoAppUser } from \"../../../../api/structures/ITodoAppUser\";\n\n@Controller(\"/auth/user/change-password\")\nexport class AuthUserChange_passwordController {\n  /**\n   * Change authenticated user's password (updates todo_app_user.password_hash).\n   *\n   * Purpose and overview: This authenticated endpoint enables a user to change\n   * their password. It targets the `todo_app_user` record and updates\n   * `password_hash` after verifying the current secret (if required) or\n   * validating a password-reset flow. The server updates\n   * `todo_app_user.updated_at` after successfully changing the stored\n   * `password_hash`.\n   *\n   * Implementation details and required fields: The request must be\n   * authenticated as the user whose password is being changed. The payload\n   * typically includes the `currentPassword` and `newPassword` (or a reset\n   * token in alternative flows). Upon verification, the server computes a new\n   * secure `password_hash` and writes it to `todo_app_user.password_hash`. The\n   * server MUST update `todo_app_user.updated_at` and may update\n   * `todo_app_user.last_active_at` as part of session continuity.\n   *\n   * Role-specific integration and business context: This operation is\n   * restricted to the `user` role and supports the security hygiene for\n   * accounts created in `todo_app_user`. Because the Prisma schema includes\n   * `password_hash`, the table supports password-based authentication and\n   * updates to that field.\n   *\n   * Security considerations: The server MUST verify the requester is the owner\n   * of the account and MUST re-authenticate or verify the current credential\n   * before changing the password, unless this endpoint is used with a validated\n   * password-reset token flow. Passwords MUST be hashed before storage. Admins\n   * changing user passwords for support purposes SHOULD create an entry in\n   * `todo_app_audit_records` to record the admin action (admin_id,\n   * action_type='change_password', target_id=user_id, reason).\n   *\n   * Related operations and workflow integration: This operation complements\n   * `login` and `refresh`. A password change SHOULD invalidate or rotate\n   * refresh tokens depending on security policy and SHOULD be recorded for\n   * auditing if performed by an admin.\n   *\n   * @param connection\n   * @param body Authenticated password-change payload containing current and\n   *   new password values (or reset token + new password).\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put()\n  public async changePassword(\n    @UserAuth()\n    user: UserPayload,\n    @TypedBody()\n    body: ITodoAppUser.IChangePassword,\n  ): Promise<ITodoAppUser.IProfile> {\n    try {\n      return await putAuthUserChangePassword({\n        user,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/auth/admin/AuthAdminController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\nimport { postAuthAdminJoin } from \"../../../providers/postAuthAdminJoin\";\nimport { postAuthAdminLogin } from \"../../../providers/postAuthAdminLogin\";\nimport { postAuthAdminRefresh } from \"../../../providers/postAuthAdminRefresh\";\n\nimport { ITodoAppAdmin } from \"../../../api/structures/ITodoAppAdmin\";\n\n@Controller(\"/auth/admin\")\nexport class AuthAdminController {\n  /**\n   * Create a new admin account (todo_app_admin).\n   *\n   * Purpose and overview: This endpoint registers a new administrator account\n   * for the system and issues an initial authorized response payload. It is\n   * explicitly tied to the Prisma model `todo_app_admin` and will rely on the\n   * `email`, `password_hash`, `is_super`, `created_at`, and `last_active_at`\n   * fields on that table to represent account identity and state.\n   *\n   * Implementation details and required fields: When called, the implementation\n   * will validate the provided `email` and password, persist the new\n   * `todo_app_admin` row (setting `email` and, after hashing, `password_hash`)\n   * and set the initial `created_at` and `last_active_at` timestamps. If\n   * elevated privileges are required for the account, `is_super` may be set per\n   * the request. The response payload uses tokens and the admin summary, but\n   * token persistence or revocation mechanism is implementation specific and\n   * not assumed to be a column on `todo_app_admin`.\n   *\n   * Role-specific integration: This endpoint is the public entry point for\n   * creating admin accounts. It should ensure the `email` value is unique (the\n   * Prisma model defines `@@unique([email])`) and must fail cleanly if a\n   * duplicate `email` exists. As part of the workflow, an audit entry may be\n   * recorded in `todo_app_audit_records` referencing the created admin\n   * (`admin_id`) with `action_type` like `create_admin` to satisfy compliance\n   * and traceability.\n   *\n   * Security considerations: Passwords MUST be hashed before storing in\n   * `password_hash` and never returned in responses. The implementation must\n   * not expose `password_hash` in any response. All audit actions related to\n   * account creation SHOULD be recorded in `todo_app_audit_records` (fields\n   * available: `admin_id`, `actor_role`, `action_type`, `target_resource`,\n   * `target_id`, `created_at`). Use secure transport (HTTPS) and apply rate\n   * limiting to prevent abuse.\n   *\n   * Related operations and workflow integration: This operation complements\n   * `POST /auth/admin/login` (to obtain access tokens) and `POST\n   * /auth/admin/refresh` (to refresh tokens). After creation, the caller is\n   * expected to use the issued tokens from this response (see response schema)\n   * to authenticate subsequent admin-only endpoints. If email verification is\n   * required by policy, the implementation should create an initial unverified\n   * state and record this in `todo_app_audit_records`.\n   *\n   * @param connection\n   * @param body Registration payload for a new admin account.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"join\")\n  public async join(\n    @TypedBody()\n    body: ITodoAppAdmin.ICreate,\n  ): Promise<ITodoAppAdmin.IAuthorized> {\n    try {\n      return await postAuthAdminJoin({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Authenticate admin and issue tokens (todo_app_admin).\n   *\n   * Purpose and overview: This endpoint authenticates an administrator by\n   * validating supplied credentials against the `todo_app_admin` model. It\n   * references the `email` (unique) column and compares the supplied password\n   * to the stored `password_hash` field before issuing tokens. Successful\n   * authentication may update `last_active_at` on the `todo_app_admin` row.\n   *\n   * Implementation details and validation: The implementation MUST validate\n   * that the provided `email` exists in `todo_app_admin`. Password verification\n   * must compare the supplied secret to the `password_hash` using secure hash\n   * verification (e.g., bcrypt/argon2). On success, the implementation may\n   * update `last_active_at` to the current timestamp and optionally create an\n   * audit record in `todo_app_audit_records` with `action_type` such as\n   * `admin_login` and `actor_role` set to `admin`.\n   *\n   * Role-specific integration and behavior: This is a public authentication\n   * endpoint that issues an `ITodoAppAdmin.IAuthorized` response containing\n   * short-lived access credentials and a refresh credential. The caller uses\n   * these tokens for subsequent admin-scoped API calls. The operation should\n   * respect account status (the `account_status` field on `todo_app_user`\n   * exists for users; for admins the `todo_app_admin` model has `is_super` and\n   * timestamps — implementors may add an `account_status` equivalent if needed,\n   * but do not assume it exists by default on `todo_app_admin`).\n   *\n   * Security considerations: Do NOT include `password_hash` in any response.\n   * Failed login attempts SHOULD be logged to `todo_app_audit_records` with\n   * `action_type` like `admin_login_failed` to support monitoring and abuse\n   * detection. Apply rate limits and account lockout policies at higher\n   * layers.\n   *\n   * Related operations: After successful login, the issued tokens are expected\n   * to be used with `POST /auth/admin/refresh` to renew short-lived access\n   * tokens and with admin-protected endpoints that require `authorizationRole:\n   * \"admin\"` such as password change or administrative maintenance actions.\n   *\n   * @param connection\n   * @param body Login payload: admin email and password.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"login\")\n  public async login(\n    @TypedBody()\n    body: ITodoAppAdmin.ILogin,\n  ): Promise<ITodoAppAdmin.IAuthorized> {\n    try {\n      return await postAuthAdminLogin({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Refresh admin access token.\n   *\n   * Purpose and overview: This endpoint accepts a valid refresh credential and\n   * issues a new short-lived access token (and optionally a new refresh token).\n   * While `todo_app_admin` does not store token values in any specific column,\n   * the operation is semantically tied to admin sessions for accounts\n   * represented by `todo_app_admin.id` and `todo_app_admin.email`.\n   *\n   * Implementation details and security: The implementation must validate the\n   * presented refresh credential according to the chosen session/token\n   * architecture. Because the Prisma schema does not include dedicated token\n   * storage fields, token persistence and revocation logic is an implementation\n   * concern; however, all refresh operations SHOULD be recorded to\n   * `todo_app_audit_records` (e.g., `action_type = refresh_token_used`,\n   * `target_id = admin id`) to support auditability.\n   *\n   * Role-specific integration: This is a public endpoint in the auth flow\n   * (clients call it with a refresh credential). On successful refresh, the\n   * response returns the same `ITodoAppAdmin.IAuthorized` shape used for login\n   * / join so that clients have a consistent authorized payload. The server\n   * SHOULD update `last_active_at` for the related `todo_app_admin` row when\n   * appropriate.\n   *\n   * Security considerations: Refresh tokens SHOULD be revocable (server-side\n   * blacklist or rotating refresh tokens). Revocation and revocation attempts\n   * SHOULD be logged to `todo_app_audit_records` with appropriate `actor_role`\n   * and `action_type` so that administrators can trace suspicious activity.\n   *\n   * Related operations: Works together with `POST /auth/admin/login` (initial\n   * issuance) and admin session revocation endpoints (not included here).\n   *\n   * @param connection\n   * @param body Payload containing the refresh credential for token renewal.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"refresh\")\n  public async refresh(\n    @TypedBody()\n    body: ITodoAppAdmin.IRefresh,\n  ): Promise<ITodoAppAdmin.IAuthorized> {\n    try {\n      return await postAuthAdminRefresh({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/auth/admin/password/reset/AuthAdminPasswordResetController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\nimport { postAuthAdminPasswordReset } from \"../../../../../providers/postAuthAdminPasswordReset\";\n\nimport { ITodoAppAdmin } from \"../../../../../api/structures/ITodoAppAdmin\";\n\n@Controller(\"/auth/admin/password/reset\")\nexport class AuthAdminPasswordResetController {\n  /**\n   * Initiate admin password reset (todo_app_admin.email).\n   *\n   * Purpose and overview: This endpoint starts a password reset workflow for an\n   * admin identified by `email` (the `todo_app_admin.email` column). It is used\n   * when an admin can no longer authenticate and requires a secure path to\n   * re-establish credentials.\n   *\n   * Implementation details and required behavior: On receipt of a valid email\n   * that maps to an existing `todo_app_admin` row, the implementation SHOULD\n   * generate a time-limited reset token (not persisted on `todo_app_admin` by\n   * the schema itself) and send it to the provided email address. The operation\n   * SHOULD create an audit record in `todo_app_audit_records` with\n   * `action_type` like `request_password_reset` and `target_id` set to the\n   * admin id to record the event.\n   *\n   * Role-specific integration: This is a public endpoint (no prior\n   * authentication required). The request MUST NOT disclose whether the email\n   * exists in the system in order to avoid user enumeration attacks; instead,\n   * the response SHOULD be a generic success message while the server performs\n   * any email actions silently.\n   *\n   * Security considerations: Ensure the reset token is single-use and expires\n   * promptly (recommended default: 24 hours). Do NOT return reset tokens in the\n   * API response. Record all reset initiation attempts in\n   * `todo_app_audit_records` for monitoring.\n   *\n   * Related operations: A subsequent endpoint (not included here) would accept\n   * the token and the new password to complete the reset and update\n   * `todo_app_admin.password_hash` accordingly; that operation SHOULD also\n   * create an audit record with `action_type`: `complete_password_reset`.\n   *\n   * @param connection\n   * @param body Payload containing the admin email to initiate a password\n   *   reset.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post()\n  public async requestPasswordReset(\n    @TypedBody()\n    body: ITodoAppAdmin.IRequestPasswordReset,\n  ): Promise<ITodoAppAdmin.IMessage> {\n    try {\n      return await postAuthAdminPasswordReset({\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/auth/admin/password/change/AuthAdminPasswordChangeController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\nimport { putAuthAdminPasswordChange } from \"../../../../../providers/putAuthAdminPasswordChange\";\nimport { AdminAuth } from \"../../../../../decorators/AdminAuth\";\nimport { AdminPayload } from \"../../../../../decorators/payload/AdminPayload\";\n\nimport { ITodoAppAdmin } from \"../../../../../api/structures/ITodoAppAdmin\";\n\n@Controller(\"/auth/admin/password/change\")\nexport class AuthAdminPasswordChangeController {\n  /**\n   * Change authenticated admin password (todo_app_admin.password_hash).\n   *\n   * Purpose and overview: This endpoint enables an authenticated admin to\n   * change their password. It targets the `todo_app_admin` record for the\n   * calling admin (fields: `id`, `email`, `password_hash`, `last_active_at`)\n   * and updates `password_hash` with a new hashed secret.\n   *\n   * Implementation details and validation: The endpoint requires the caller to\n   * be authenticated as an admin (`authorizationRole: \"admin\"`). It should\n   * verify the caller's current credential or session and validate the new\n   * password against password policy before hashing and storing it in\n   * `password_hash`. Upon success, the implementation SHOULD update\n   * `updated_at` and optionally `last_active_at` on the `todo_app_admin` row.\n   *\n   * Security considerations: Do NOT log the plain-text password. Record the\n   * password change action in `todo_app_audit_records` with `action_type` such\n   * as `change_password` and include the `admin_id` and timestamp. Consider\n   * revoking outstanding refresh tokens or sessions after a password change to\n   * reduce risk.\n   *\n   * Related operations: This operation complements `POST\n   * /auth/admin/password/reset` (reset flow) and token refresh endpoints. It is\n   * restricted to authenticated admins and must be audited.\n   *\n   * @param connection\n   * @param body Payload containing current credential proof and the new\n   *   password.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put()\n  public async changePassword(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedBody()\n    body: ITodoAppAdmin.IChangePassword,\n  ): Promise<ITodoAppAdmin.IMessage> {\n    try {\n      return await putAuthAdminPasswordChange({\n        admin,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoApp/user/todos/TodoappUserTodosController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { postTodoAppUserTodos } from \"../../../../providers/postTodoAppUserTodos\";\nimport { UserAuth } from \"../../../../decorators/UserAuth\";\nimport { UserPayload } from \"../../../../decorators/payload/UserPayload\";\nimport { patchTodoAppUserTodos } from \"../../../../providers/patchTodoAppUserTodos\";\nimport { getTodoAppUserTodosTodoId } from \"../../../../providers/getTodoAppUserTodosTodoId\";\nimport { putTodoAppUserTodosTodoId } from \"../../../../providers/putTodoAppUserTodosTodoId\";\nimport { deleteTodoAppUserTodosTodoId } from \"../../../../providers/deleteTodoAppUserTodosTodoId\";\n\nimport { ITodoAppTodo } from \"../../../../api/structures/ITodoAppTodo\";\nimport { IPageITodoAppTodo } from \"../../../../api/structures/IPageITodoAppTodo\";\n\n@Controller(\"/todoApp/user/todos\")\nexport class TodoappUserTodosController {\n  /**\n   * Create a new Todo (todo_app_todos).\n   *\n   * Create a new Todo item and persist it in the `todo_app_todos` table. This\n   * endpoint accepts minimal user-provided fields required for quick capture\n   * (title plus optional description and position). On success the server\n   * returns the full Todo record including server-populated fields such as\n   * `id`, `created_at`, and `updated_at`.\n   *\n   * Security and permissions: Only authenticated users may create todos. The\n   * creating user's identity is used to set the `user_id` relation in\n   * `todo_app_todos`. The operation requires role `user` and the request must\n   * be authorized before creating data.\n   *\n   * Validation rules and business logic:\n   *\n   * - `title` is required: non-empty string after trimming (1..250 chars\n   *   recommended).\n   * - `description` is optional (<= 4000 chars recommended).\n   * - `position` is optional integer used by clients for ordering.\n   * - `is_completed` defaults to false; if provided must be boolean.\n   * - Server sets `created_at` and `updated_at`.\n   *\n   * Errors:\n   *\n   * - 400 for validation errors (ERR_INVALID_TITLE, ERR_INVALID_DESCRIPTION).\n   * - 401/403 for auth errors.\n   * - 500 for server errors.\n   *\n   * @param connection\n   * @param body Creation payload for a new Todo. Clients provide only\n   *   user-editable fields (title required, description optional, position\n   *   optional). System-managed fields (id, user_id, created_at, updated_at,\n   *   completed_at, deleted_at) are omitted and set by the server.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post()\n  public async create(\n    @UserAuth()\n    user: UserPayload,\n    @TypedBody()\n    body: ITodoAppTodo.ICreate,\n  ): Promise<ITodoAppTodo> {\n    try {\n      return await postTodoAppUserTodos({\n        user,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search and retrieve a filtered, paginated list of todo summaries from\n   * todo_app_todos.\n   *\n   * Retrieve a filtered and paginated list of todo items owned by the\n   * requesting user.\n   *\n   * Purpose and overview: This endpoint returns a paginated collection of todo\n   * summaries derived from the Prisma `todo_app_todos` model. The model stores\n   * primary todo data including title, optional description, completion flag,\n   * timestamps, and a nullable deleted_at column that implements soft-delete\n   * semantics in the schema. By default, the operation excludes records with\n   * `deleted_at` set (deleted items). Callers may request inclusion of deleted\n   * items via the request DTO when an administrative or recovery view is\n   * required.\n   *\n   * Security and permissions: Only authenticated requests scoped to the owning\n   * user may retrieve their todos; the operation must ensure the returned rows\n   * have `user_id` equal to the requesting user's id. The API surface for\n   * listing is restricted to role `user`. Any elevated listing that includes\n   * other users' data or exhaustive audit results must be implemented in\n   * separate admin endpoints and recorded in `todo_app_audit_records`.\n   *\n   * Relationship to underlying database entities: This operation maps to the\n   * Prisma model `todo_app_todos`. It relies on columns explicitly defined in\n   * that model: `id`, `user_id`, `title`, `description`, `is_completed`,\n   * `completed_at`, `position`, `created_at`, `updated_at`, and `deleted_at`.\n   * Snapshots are captured separately in `todo_app_todo_snapshots`; snapshot\n   * creation is a background or explicit process and is not performed by this\n   * read operation.\n   *\n   * Validation rules and business logic:\n   *\n   * - The operation accepts pagination parameters (page, pageSize) and enforces\n   *   sane server-side limits for pageSize.\n   * - Filter fields: `isCompleted` (boolean) filters by `is_completed`. If\n   *   omitted, both active and completed todos are returned (subject to\n   *   exclusion of deleted items).\n   * - Sorting: clients may request sort by `createdAt` or `position` with\n   *   ascending/descending direction. Sorting keys correspond to `created_at`\n   *   and `position` columns in the Prisma model.\n   * - Deleted items: by default, rows where `deleted_at` is NOT null are\n   *   excluded; inclusion requires an explicit includeDeleted flag and should\n   *   be limited to administrative/owner recovery scenarios.\n   *\n   * Related operations and error handling: Use `GET\n   * /todoApp/user/todos/{todoId}` (operation `at`) to fetch a single todo\n   * detail. Clients requesting export or heavy full-text search should use\n   * dedicated endpoints. Common errors: 400 for invalid request parameters,\n   * 401/403 for unauthorized access, and 500 for unexpected server errors.\n   * Missing resources are returned as empty pages rather than 404 for list\n   * endpoints.\n   *\n   * @param connection\n   * @param body Search, filter, sort, and pagination parameters for listing\n   *   todos owned by the requesting user.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @UserAuth()\n    user: UserPayload,\n    @TypedBody()\n    body: ITodoAppTodo.IRequest,\n  ): Promise<IPageITodoAppTodo.ISummary> {\n    try {\n      return await patchTodoAppUserTodos({\n        user,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve detailed information for a single todo by id from todo_app_todos.\n   *\n   * Retrieve full details of a single todo item.\n   *\n   * Purpose and overview: This endpoint returns the complete `todo_app_todos`\n   * entity for the provided `todoId`. It is intended to supply clients with all\n   * available fields defined in the Prisma model, enabling detailed views and\n   * edit screens. Timestamps provided are those defined on the model\n   * (`created_at`, `updated_at`, `completed_at`, `deleted_at`).\n   *\n   * Security and user permissions: The operation requires that the requester be\n   * the owner of the todo (matching `user_id`) or an authorized admin with\n   * audited access. Unauthorized attempts must result in 403. If the todo is\n   * soft-deleted (non-null `deleted_at`), the API returns 404 unless the\n   * request is for owner recovery and the business logic explicitly allows\n   * returning deleted items to the owner.\n   *\n   * Relationship to database and snapshots: The todo returned is the live\n   * record in `todo_app_todos`. Historical snapshots exist in\n   * `todo_app_todo_snapshots` and are not returned by this endpoint. Snapshot\n   * retrieval is available via a separate audit/history endpoint if needed.\n   *\n   * Validation and error handling:\n   *\n   * - Path parameter `todoId` MUST be a UUID. If malformed, return 400.\n   * - If the todo does not exist or is not accessible to the requester (including\n   *   when it is deleted and not permitted to be returned), return 404.\n   * - On success, return the full `ITodoAppTodo` representation with all\n   *   model-described fields.\n   *\n   * Related operations: Use `PATCH /todoApp/user/todos` (operation `index`) to\n   * search/paginate lists. Use `PATCH /todoApp/user/todos/{todoId}` (update) to\n   * modify the item. Administrative restores and purges are separate operations\n   * and must be recorded in `todo_app_audit_records`.\n   *\n   * @param connection\n   * @param todoId Unique identifier (UUID) of the target todo item\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":todoId\")\n  public async at(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoAppTodo> {\n    try {\n      return await getTodoAppUserTodosTodoId({\n        user,\n        todoId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update an existing Todo by ID (todo_app_todos).\n   *\n   * Update an existing Todo item in the `todo_app_todos` table. Clients supply\n   * the todo identifier in the path and a payload with the fields to change.\n   * The server validates ownership and input, applies allowed updates, sets\n   * `updated_at`, and returns the updated resource.\n   *\n   * Security and permissions: Only the owner of the todo (authenticated role\n   * `user`) or an authorized admin flow may update the record. Attempts to\n   * update another user's todo MUST be rejected with 403 Forbidden. If the\n   * target record has a non-null `deleted_at` (soft-deleted), the server SHOULD\n   * return 404 Not Found or 410 Gone depending on policy; this operation does\n   * not implicitly undelete resources.\n   *\n   * Validation and business logic:\n   *\n   * - `title` if provided must be non-empty and within allowed length (1..250\n   *   chars).\n   * - `description` if provided must be <= 4000 chars.\n   * - `is_completed` toggled true sets `completed_at` to server time; toggled\n   *   false clears `completed_at`.\n   * - `position` if provided must be an integer.\n   *\n   * Note on PUT semantics: This operation uses PUT for updates per API\n   * conventions. Ensure `ITodoAppTodo.IUpdate` semantics are documented\n   * (partial-update with optional fields vs full-replace). If partial updates\n   * are used, clients may send only fields to change.\n   *\n   * @param connection\n   * @param todoId Unique identifier (UUID) of the target todo to update\n   * @param body Partial or full update payload for a Todo. Include only fields\n   *   to be changed if IUpdate is defined with optional fields. System-managed\n   *   timestamps and identifiers are not accepted from clients.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put(\":todoId\")\n  public async update(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoAppTodo.IUpdate,\n  ): Promise<ITodoAppTodo> {\n    try {\n      return await putTodoAppUserTodosTodoId({\n        user,\n        todoId,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Soft-delete a todo (mark as deleted) in the todo_app_todos table.\n   *\n   * Mark a Todo item as deleted by setting its deleted_at timestamp.\n   *\n   * Purpose and overview: This operation marks a todo item in the\n   * todo_app_todos table as deleted (soft-delete) so it is removed from active\n   * and completed lists but retained for recovery and historical purposes. It\n   * uses the todo_app_todos.deleted_at column defined in the Prisma schema to\n   * record deletion time.\n   *\n   * Security considerations and user permissions: Only the owning user is\n   * permitted to soft-delete their todo. The service must validate ownership\n   * using the todo_app_todos.user_id relation to todo_app_user.id. Admin\n   * maintenance flows that permanently purge data are separate and must be\n   * audited via todo_app_audit_records.\n   *\n   * Validation rules and business logic: The todoId path parameter must be a\n   * valid UUID and must reference an existing todo record. If the record\n   * already has deleted_at set, the operation is idempotent and returns 204.\n   * Ownership must be enforced; attempts to delete another user's todo must be\n   * rejected with 403. If the todo is missing, return 404. Errors should\n   * include machine-readable codes and human-friendly messages.\n   *\n   * @param connection\n   * @param todoId Unique identifier (UUID) of the target todo\n   *   (todo_app_todos.id)\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Delete(\":todoId\")\n  public async erase(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    try {\n      return await deleteTodoAppUserTodosTodoId({\n        user,\n        todoId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoApp/user/todos/versions/TodoappUserTodosVersionsController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { patchTodoAppUserTodosTodoIdVersions } from \"../../../../../providers/patchTodoAppUserTodosTodoIdVersions\";\nimport { UserAuth } from \"../../../../../decorators/UserAuth\";\nimport { UserPayload } from \"../../../../../decorators/payload/UserPayload\";\nimport { getTodoAppUserTodosTodoIdVersionsVersionId } from \"../../../../../providers/getTodoAppUserTodosTodoIdVersionsVersionId\";\n\nimport { IPageITodoAppTodoSnapshot } from \"../../../../../api/structures/IPageITodoAppTodoSnapshot\";\nimport { ITodoAppTodoSnapshot } from \"../../../../../api/structures/ITodoAppTodoSnapshot\";\n\n@Controller(\"/todoApp/user/todos/:todoId/versions\")\nexport class TodoappUserTodosVersionsController {\n  /**\n   * List paginated snapshot versions for a specific todo\n   * (todo_app_todo_snapshots).\n   *\n   * Retrieve snapshot history for a given todo item.\n   *\n   * Purpose and overview: This operation returns historical snapshots stored in\n   * todo_app_todo_snapshots for the specified todo (todo_app_todo_id).\n   * Snapshots capture the todo state at snapshot_at and are useful for audit\n   * and user-facing \"version history\" views.\n   *\n   * Security considerations and user permissions: Only the todo owner (or an\n   * authorized admin via separate audit endpoints) should be permitted to view\n   * snapshot history. The service must validate ownership by joining\n   * todo_app_todo_snapshots.todo_app_todo_id -> todo_app_todos.id ->\n   * todo_app_todos.user_id and comparing to the calling user.\n   *\n   * Validation rules and business logic: Accepts pagination, sort, and optional\n   * filter parameters (e.g., snapshot_at range, is_completed). Defaults: sort\n   * by snapshot_at desc, default page size 20, enforce a reasonable max page\n   * size to prevent large payloads. Return paginated container with metadata\n   * (page, pageSize, total). Handle empty results gracefully.\n   *\n   * @param connection\n   * @param todoId Unique identifier (UUID) of the parent todo\n   *   (todo_app_todos.id) to list snapshots for\n   * @param body Search, filter, sort and pagination parameters for todo\n   *   snapshot listing\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoAppTodoSnapshot.IRequest,\n  ): Promise<IPageITodoAppTodoSnapshot> {\n    try {\n      return await patchTodoAppUserTodosTodoIdVersions({\n        user,\n        todoId,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve a specific todo snapshot (version) from todo_app_todo_snapshots.\n   *\n   * Retrieve a specific todo snapshot (version) from the\n   * todo_app_todo_snapshots table.\n   *\n   * Purpose and overview: This operation returns the stored snapshot\n   * representing the state of a todo at a past point in time. The data is\n   * sourced from the Prisma model `todo_app_todo_snapshots` and exposes fields\n   * captured at the snapshot moment (id, todo_app_todo_id, title, description,\n   * is_completed, completed_at, position, created_at, updated_at, deleted_at,\n   * snapshot_at). It is read-only and intended for history, audit, and owner\n   * support usage.\n   *\n   * Security and permissions: This endpoint is accessible to the owning user\n   * only. Implementations MUST verify ownership by ensuring the parent todo\n   * (todo_app_todos.id) has user_id equal to the requesting user. Admins should\n   * use the admin-scoped endpoint instead. Under no circumstances should this\n   * endpoint return authentication secrets or sensitive fields from other\n   * models.\n   *\n   * Relationship to database entities: Maps directly to\n   * `todo_app_todo_snapshots`. The path parameter `todoId` corresponds to the\n   * source todo id (todo_app_todo_snapshots.todo_app_todo_id) and `versionId`\n   * corresponds to snapshot primary key (todo_app_todo_snapshots.id).\n   *\n   * Validation and error handling: Both path parameters MUST be valid UUIDs. If\n   * the snapshot is not found or does not belong to the provided todoId, return\n   * 404. If ownership check fails, return 403.\n   *\n   * @param connection\n   * @param todoId Unique identifier of the parent todo (references\n   *   todo_app_todos.id).\n   * @param versionId Unique identifier of the snapshot record\n   *   (todo_app_todo_snapshots.id).\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":versionId\")\n  public async at(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"versionId\")\n    versionId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoAppTodoSnapshot> {\n    try {\n      return await getTodoAppUserTodosTodoIdVersionsVersionId({\n        user,\n        todoId,\n        versionId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoApp/admin/todos/versions/TodoappAdminTodosVersionsController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { getTodoAppAdminTodosTodoIdVersionsVersionId } from \"../../../../../providers/getTodoAppAdminTodosTodoIdVersionsVersionId\";\nimport { AdminAuth } from \"../../../../../decorators/AdminAuth\";\nimport { AdminPayload } from \"../../../../../decorators/payload/AdminPayload\";\n\nimport { ITodoAppTodoSnapshot } from \"../../../../../api/structures/ITodoAppTodoSnapshot\";\n\n@Controller(\"/todoApp/admin/todos/:todoId/versions/:versionId\")\nexport class TodoappAdminTodosVersionsController {\n  /**\n   * Admin retrieve a specific todo snapshot (version) from\n   * todo_app_todo_snapshots.\n   *\n   * Retrieve a specific todo snapshot (version) from the\n   * todo_app_todo_snapshots table for administrative/support use.\n   *\n   * Purpose and overview: Returns the snapshot recorded for a todo at a prior\n   * time. This admin endpoint supports troubleshooting and audit\n   * investigations.\n   *\n   * Security and permissions: Access restricted to admin role. Implementations\n   * MUST authenticate the admin, authorize the request, and create an audit\n   * record documenting the access (admin id, action_type 'view_snapshot',\n   * target_resource 'todo_snapshot', target_id). The response MUST NOT include\n   * any authentication secrets or other sensitive fields from related models.\n   *\n   * Relationship to database entities: Maps directly to\n   * `todo_app_todo_snapshots`. The path parameter `todoId` corresponds to\n   * snapshot.todo_app_todo_id; `versionId` corresponds to snapshot.id.\n   *\n   * Validation and error handling: Both path parameters MUST be valid UUIDs. If\n   * the snapshot is not found or the todoId does not match, return 404.\n   *\n   * @param connection\n   * @param todoId Unique identifier of the parent todo (references\n   *   todo_app_todos.id).\n   * @param versionId Unique identifier of the snapshot record\n   *   (todo_app_todo_snapshots.id).\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get()\n  public async at(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"todoId\")\n    todoId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"versionId\")\n    versionId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoAppTodoSnapshot> {\n    try {\n      return await getTodoAppAdminTodosTodoIdVersionsVersionId({\n        admin,\n        todoId,\n        versionId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoApp/admin/auditRecords/TodoappAdminAuditrecordsController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { patchTodoAppAdminAuditRecords } from \"../../../../providers/patchTodoAppAdminAuditRecords\";\nimport { AdminAuth } from \"../../../../decorators/AdminAuth\";\nimport { AdminPayload } from \"../../../../decorators/payload/AdminPayload\";\nimport { getTodoAppAdminAuditRecordsAuditRecordId } from \"../../../../providers/getTodoAppAdminAuditRecordsAuditRecordId\";\n\nimport { IPageITodoAppAuditRecord } from \"../../../../api/structures/IPageITodoAppAuditRecord\";\nimport { ITodoAppAuditRecord } from \"../../../../api/structures/ITodoAppAuditRecord\";\n\n@Controller(\"/todoApp/admin/auditRecords\")\nexport class TodoappAdminAuditrecordsController {\n  /**\n   * Search and retrieve a paginated list of audit records\n   * (todo_app_audit_records).\n   *\n   * Retrieve a filtered, paginated list of audit records from the\n   * todo_app_audit_records table.\n   *\n   * Purpose and overview: Enables administrative interfaces to search audit\n   * events (suspend_user, restore_todo, purge, view_snapshot, etc.). Each\n   * record contains admin_id (nullable for system actions), user_id (nullable),\n   * actor_role, action_type, target_resource, target_id, reason, and\n   * created_at. Returned results MUST only include fields present in the audit\n   * model or explicitly allowed metadata; do not project authentication secrets\n   * from related user/admin tables.\n   *\n   * Security and permissions: Access is restricted to admin role.\n   * Implementations MUST validate requestor's admin privileges and enforce rate\n   * limits and page size caps. All admin access to audit data for support\n   * should itself be recorded as an audit event when appropriate.\n   *\n   * Relationship to database entities: Maps directly to\n   * `todo_app_audit_records`. Suggested filters in requestBody must reference\n   * the model fields only.\n   *\n   * Validation and business logic: Request body supports paging (page,\n   * pageSize), sorting (created_at asc/desc), and optional filters. Server must\n   * validate pagination and impose a maximum pageSize to prevent heavy queries.\n   * Use available indexes (created_at, admin_id, user_id,\n   * target_resource/target_id) to implement efficient queries.\n   *\n   * @param connection\n   * @param body Search criteria, pagination, and sorting options for audit\n   *   record retrieval\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedBody()\n    body: ITodoAppAuditRecord.IRequest,\n  ): Promise<IPageITodoAppAuditRecord> {\n    try {\n      return await patchTodoAppAdminAuditRecords({\n        admin,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve a single audit record (todo_app_audit_records) by ID.\n   *\n   * Retrieve a single audit record by its unique identifier from the audit\n   * record store.\n   *\n   * This operation returns the audit entry that corresponds to the Prisma model\n   * `todo_app_audit_records`. The model stores append-only records including\n   * admin_id (nullable), user_id (nullable), actor_role, action_type,\n   * target_resource, optional target_id, optional reason, and created_at. The\n   * operation MUST return these fields exactly as stored and MUST NOT expose\n   * sensitive fields from related admin/user records (for example,\n   * password_hash).\n   *\n   * Security and permissions: This endpoint is restricted to administrative\n   * actors. Server-side enforcement of the admin role is mandatory. Access to\n   * this endpoint should itself be logged in operational access logs for\n   * traceability. The endpoint is read-only and must not modify audit records.\n   *\n   * Behavior and errors: If the requested id does not exist, return 404 Not\n   * Found. On success return the audit record. Server errors return 500 with an\n   * error body.\n   *\n   * @param connection\n   * @param auditRecordId Unique identifier (UUID) of the target audit record\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":auditRecordId\")\n  public async at(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"auditRecordId\")\n    auditRecordId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoAppAuditRecord> {\n    try {\n      return await getTodoAppAdminAuditRecordsAuditRecordId({\n        admin,\n        auditRecordId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoApp/admin/guests/TodoappAdminGuestsController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { patchTodoAppAdminGuests } from \"../../../../providers/patchTodoAppAdminGuests\";\nimport { AdminAuth } from \"../../../../decorators/AdminAuth\";\nimport { AdminPayload } from \"../../../../decorators/payload/AdminPayload\";\nimport { getTodoAppAdminGuestsGuestId } from \"../../../../providers/getTodoAppAdminGuestsGuestId\";\n\nimport { IPageITodoAppGuest } from \"../../../../api/structures/IPageITodoAppGuest\";\nimport { ITodoAppGuest } from \"../../../../api/structures/ITodoAppGuest\";\n\n@Controller(\"/todoApp/admin/guests\")\nexport class TodoappAdminGuestsController {\n  /**\n   * Search and retrieve a paginated list of guest records (todo_app_guest).\n   *\n   * Search and retrieve guest records using flexible criteria and pagination.\n   * This operation targets the Prisma model `todo_app_guest` and supports\n   * filters such as email (exact or partial), status, created_at range, and\n   * sorting by created_at or last_active_at.\n   *\n   * Response items include the model's core attributes: id, email (nullable),\n   * created_at, last_active_at (nullable), and status (nullable). The request\n   * body contains search criteria, pagination, and sorting options. The\n   * response is a paginated container of guest record summaries.\n   *\n   * Security and permissions: Access is limited to administrative actors.\n   * Returned personal data (email) must be disclosed only to authorized\n   * callers; consider role-based projection or email redaction for\n   * lower-privilege support. Implement server-side input validation and\n   * parameterized queries to avoid injection and protect performance. Implement\n   * rate limiting and audit logging for searches.\n   *\n   * Errors: invalid request payloads return 400 with validation details; server\n   * errors return 500.\n   *\n   * @param connection\n   * @param body Search criteria, pagination, and sorting parameters for guest\n   *   records\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedBody()\n    body: ITodoAppGuest.IRequest,\n  ): Promise<IPageITodoAppGuest.ISummary> {\n    try {\n      return await patchTodoAppAdminGuests({\n        admin,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve a guest (visitor) record by ID from the todo_app_guest table.\n   *\n   * Returns a single guest record from the todo_app_guest model. The guest\n   * model stores lightweight visitor entries such as optional email, creation\n   * timestamp, last activity, and a housekeeping status.\n   *\n   * Security and permissions: Access to guest records is restricted to\n   * administrative/support users only. Calls to this endpoint MUST be\n   * authenticated and authorized. The server implementation MUST create an\n   * audit record in todo_app_audit_records for each access (actor_role='admin',\n   * action_type='read_guest', target_resource='guest', target_id=guestId).\n   *\n   * Data and behavior: The response contains the guest's persisted fields (id,\n   * email, created_at, last_active_at, status). This endpoint performs no\n   * mutation; it is strictly read-only. Validation rules require the path\n   * parameter to be a UUID. Errors returned include 400 for invalid ID format,\n   * 404 when the guest is not found, and 500 for unexpected server errors.\n   *\n   * @param connection\n   * @param guestId Unique identifier (UUID) of the guest record\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":guestId\")\n  public async at(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"guestId\")\n    guestId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoAppGuest> {\n    try {\n      return await getTodoAppAdminGuestsGuestId({\n        admin,\n        guestId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoApp/admin/users/TodoappAdminUsersController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { patchTodoAppAdminUsers } from \"../../../../providers/patchTodoAppAdminUsers\";\nimport { AdminAuth } from \"../../../../decorators/AdminAuth\";\nimport { AdminPayload } from \"../../../../decorators/payload/AdminPayload\";\nimport { getTodoAppAdminUsersUserId } from \"../../../../providers/getTodoAppAdminUsersUserId\";\nimport { putTodoAppAdminUsersUserId } from \"../../../../providers/putTodoAppAdminUsersUserId\";\n\nimport { IPageITodoAppUser } from \"../../../../api/structures/IPageITodoAppUser\";\nimport { ITodoAppUser } from \"../../../../api/structures/ITodoAppUser\";\n\n@Controller(\"/todoApp/admin/users\")\nexport class TodoappAdminUsersController {\n  /**\n   * Search and retrieve a paginated list of user accounts (admin).\n   *\n   * Provides a paginated, filterable list of users from the todo_app_user\n   * model. Intended for administrative use to find users by email substring,\n   * account_status, or creation timeframe. Supports pagination and sorting to\n   * enable efficient UI listing.\n   *\n   * Security and permissions: This endpoint MUST be restricted to\n   * administrative roles. The response MUST NOT include sensitive fields such\n   * as password_hash. All accesses SHOULD be recorded in todo_app_audit_records\n   * with admin identifier and the used filter parameters (avoid storing full\n   * PII in logs unless necessary).\n   *\n   * Validation and errors: Validate pagination parameters (page >= 1, pageSize\n   * reasonable bounds), validate account_status values against the canonical\n   * list (e.g., 'active','suspended'), and validate emailLike length. Return\n   * 400 for malformed requests, 401/403 for unauthorized access, and 500 for\n   * server errors.\n   *\n   * @param connection\n   * @param body Search criteria and pagination parameters for filtering users\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedBody()\n    body: ITodoAppUser.IRequest,\n  ): Promise<IPageITodoAppUser.ISummary> {\n    try {\n      return await patchTodoAppAdminUsers({\n        admin,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Admin: retrieve a user account by ID (todo_app_user).\n   *\n   * Purpose and overview:\n   *\n   * Allow administrators to retrieve a user's profile for support and\n   * maintenance. Returns the same safe profile fields as the user-facing\n   * endpoint: `id`, `email`, `display_name`, `account_status`, `created_at`,\n   * `updated_at`, and `last_active_at`. Do NOT include `password_hash` or other\n   * secrets.\n   *\n   * Security and permissions:\n   *\n   * - Access policy: Only callers with admin privileges may call this endpoint.\n   *   Each admin access MUST create an audit record in `todo_app_audit_records`\n   *   with `actor_role='admin'`, `action_type='read_user'`, and include\n   *   `admin_id` and `user_id`.\n   * - Validation: `userId` must be a UUID. Return 400 for malformed, 404 if not\n   *   found, 403 if the caller lacks admin privileges.\n   *\n   * Error handling: same as user-facing GET but ensure audit creation on\n   * success and on unauthorized attempts where applicable.\n   *\n   * @param connection\n   * @param userId Unique identifier of the target user (UUID).\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":userId\")\n  public async at(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"userId\")\n    userId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoAppUser> {\n    try {\n      return await getTodoAppAdminUsersUserId({\n        admin,\n        userId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Admin: update a user account (todo_app_user).\n   *\n   * Purpose and overview:\n   *\n   * Allow administrators to perform sanctioned updates to user accounts such as\n   * changing `account_status`. Admin updates must be auditable and follow\n   * validation rules. Do NOT accept `password_hash` in the request body.\n   *\n   * Security and permissions:\n   *\n   * - Access policy: Admin-only. Each successful admin update MUST create an\n   *   audit record in `todo_app_audit_records` containing `admin_id`,\n   *   `user_id`, `action_type='update_user'`, `reason` (optional), and\n   *   `created_at`.\n   * - Validation: `userId` must be a UUID. `account_status` must be validated\n   *   against allowed values (e.g., 'active','suspended') and rejected if\n   *   invalid.\n   *\n   * Schema mapping and writable fields:\n   *\n   * - Admin-writable: `account_status` (validated), optionally `display_name` for\n   *   admin corrections.\n   * - Disallowed: `password_hash`, `id`, `created_at` (server-managed).\n   *\n   * Responses and errors: standard 200/400/403/404 semantics apply.\n   *\n   * @param connection\n   * @param userId Unique identifier of the target user (UUID).\n   * @param body Admin-updatable user fields. Must not include `password_hash`.\n   *   Typical allowed properties: `account_status` (e.g.,\n   *   'active','suspended'), `display_name` (optional).\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put(\":userId\")\n  public async update(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"userId\")\n    userId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoAppUser.IUpdate,\n  ): Promise<ITodoAppUser> {\n    try {\n      return await putTodoAppAdminUsersUserId({\n        admin,\n        userId,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoApp/user/users/TodoappUserUsersController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { getTodoAppUserUsersUserId } from \"../../../../providers/getTodoAppUserUsersUserId\";\nimport { UserAuth } from \"../../../../decorators/UserAuth\";\nimport { UserPayload } from \"../../../../decorators/payload/UserPayload\";\nimport { putTodoAppUserUsersUserId } from \"../../../../providers/putTodoAppUserUsersUserId\";\n\nimport { ITodoAppUser } from \"../../../../api/structures/ITodoAppUser\";\n\n@Controller(\"/todoApp/user/users/:userId\")\nexport class TodoappUserUsersController {\n  /**\n   * Retrieve a user account by ID (todo_app_user).\n   *\n   * Purpose and overview:\n   *\n   * Retrieve the requested user account from the `todo_app_user` table by\n   * `userId`. The response contains public profile fields: `id`, `email`,\n   * `display_name`, `account_status`, `created_at`, `updated_at`, and\n   * `last_active_at`. The endpoint MUST NOT return `password_hash` or any\n   * internal secrets.\n   *\n   * Security and permissions:\n   *\n   * - Access policy: Owner or admin only. If the caller is the owner, return the\n   *   full profile (excluding secrets). If the caller is an admin, return the\n   *   profile and create an audit record in `todo_app_audit_records` with\n   *   `actor_role='admin'` and `action_type='read_user'` and include optional\n   *   reason when provided.\n   * - Validation: `userId` must be a UUID. Return 400 for malformed, 404 if not\n   *   found, 403 if unauthorized.\n   *\n   * Schema relationship and notes:\n   *\n   * This operation maps to Prisma model `todo_app_user`. Use only the\n   * documented safe fields in responses; do not expose `password_hash`. Any\n   * derived flags (e.g., `isVerified`) must be computed server-side and\n   * documented separately.\n   *\n   * Error handling:\n   *\n   * - 400 Bad Request: invalid UUID\n   * - 403 Forbidden: not owner or not admin\n   * - 404 Not Found: user does not exist\n   * - 500 Internal Server Error: unexpected failures\n   *\n   * @param connection\n   * @param userId Unique identifier of the target user (UUID).\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get()\n  public async at(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"userId\")\n    userId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoAppUser> {\n    try {\n      return await getTodoAppUserUsersUserId({\n        user,\n        userId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update a user account (todo_app_user) — owner.\n   *\n   * Purpose and overview:\n   *\n   * Update mutable profile attributes for the specified user. Intended for\n   * owner-initiated updates such as `display_name`. System-managed fields\n   * (`id`, `created_at`, `updated_at`, `password_hash`) MUST NOT be accepted\n   * from clients. The server will set `updated_at` on successful update.\n   *\n   * Security and permissions:\n   *\n   * - Access policy: Only the resource owner may update their own profile via\n   *   this path. Attempts to modify another user's profile MUST be rejected\n   *   with 403. Admins should use the admin update endpoint.\n   * - Validation: `userId` must be a UUID. Validate `display_name` length\n   *   (suggested <=255). If `email` changes are allowed by policy, require\n   *   separate verification flow; otherwise reject email change attempts and\n   *   return a clear error.\n   *\n   * Schema mapping and writable fields:\n   *\n   * - Writable by owner: `display_name` (optional).\n   * - Server-side only / disallowed: `id`, `created_at`, `updated_at`,\n   *   `password_hash`.\n   *\n   * Responses and errors:\n   *\n   * - 200: updated user representation (safe fields only)\n   * - 400: invalid input or malformed UUID\n   * - 403: unauthorized (not owner)\n   * - 404: user not found\n   *\n   * @param connection\n   * @param userId Unique identifier of the target user (UUID).\n   * @param body Owner-updatable user fields. Clients MUST NOT provide\n   *   `password_hash`. Typical allowed property: `display_name` (optional).\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put()\n  public async update(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"userId\")\n    userId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoAppUser.IUpdate,\n  ): Promise<ITodoAppUser> {\n    try {\n      return await putTodoAppUserUsersUserId({\n        user,\n        userId,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoApp/admin/admins/TodoappAdminAdminsController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { patchTodoAppAdminAdmins } from \"../../../../providers/patchTodoAppAdminAdmins\";\nimport { AdminAuth } from \"../../../../decorators/AdminAuth\";\nimport { AdminPayload } from \"../../../../decorators/payload/AdminPayload\";\nimport { getTodoAppAdminAdminsAdminId } from \"../../../../providers/getTodoAppAdminAdminsAdminId\";\nimport { putTodoAppAdminAdminsAdminId } from \"../../../../providers/putTodoAppAdminAdminsAdminId\";\nimport { deleteTodoAppAdminAdminsAdminId } from \"../../../../providers/deleteTodoAppAdminAdminsAdminId\";\n\nimport { IPageITodoAppAdmin } from \"../../../../api/structures/IPageITodoAppAdmin\";\nimport { ITodoAppAdmin } from \"../../../../api/structures/ITodoAppAdmin\";\n\n@Controller(\"/todoApp/admin/admins\")\nexport class TodoappAdminAdminsController {\n  /**\n   * Search and retrieve a filtered, paginated list of administrative accounts\n   * (todo_app_admin).\n   *\n   * Retrieve a filtered, sorted and paginated list of administrative accounts\n   * from the todo_app_admin table.\n   *\n   * Purpose and overview: This operation lets authorized systems and operators\n   * query administrative accounts for support, audit, and maintenance tasks. It\n   * operates directly on the todo_app_admin model defined in the Prisma schema,\n   * which stores admin account identifiers, email addresses, super-admin flags,\n   * account creation timestamps, and last-active timestamps. The operation\n   * supports pagination, free-text email search, boolean filtering on the\n   * is_super flag, and sorting by created_at or last_active_at.\n   *\n   * Security considerations and user permissions: Access to this endpoint is\n   * restricted to administrative actors. All accesses to admin records via this\n   * endpoint MUST be recorded in audit logs (see todo_app_audit_records) with\n   * actor id, action_type, target_resource and timestamp. Responses MUST NOT\n   * expose sensitive fields such as password_hash. The service layer should\n   * filter out or redact password_hash before sending any response.\n   * Rate-limiting and monitoring are recommended to detect abusive enumeration\n   * attempts.\n   *\n   * Relationship to underlying database entities: This operation queries the\n   * todo_app_admin table (Prisma model todo_app_admin). Querying capabilities\n   * should correspond to existing schema fields: id (uuid), email (unique),\n   * is_super (boolean), created_at (timestamptz), and last_active_at (nullable\n   * timestamptz). Implementations may optionally join audit data for enriched\n   * results but must avoid leaking audit details unless explicitly requested.\n   *\n   * Validation rules and business logic: The request DTO must validate\n   * pagination parameters (page >= 1, pageSize reasonable limits), validate\n   * sort fields to allowed set (created_at, last_active_at), and require that\n   * the caller is an admin. Search parameters for email should be normalized\n   * and limited to prevent high-cost queries. Any attempt to include\n   * password_hash in projection or filters must be rejected.\n   *\n   * Related API operations: Use GET /admins/{adminId} to retrieve a single\n   * admin's details. Use audit-record endpoints (not part of this interface) to\n   * inspect who accessed admin records. Error handling: return 400 for invalid\n   * request payloads, 401/403 for unauthorized requests, 429 for rate limits,\n   * and 500 for unexpected server errors.\n   *\n   * @param connection\n   * @param body Search, filter, sort and pagination parameters for listing\n   *   administrative accounts\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedBody()\n    body: ITodoAppAdmin.IRequest,\n  ): Promise<IPageITodoAppAdmin.ISummary> {\n    try {\n      return await patchTodoAppAdminAdmins({\n        admin,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve detailed information for a specific administrative account\n   * (todo_app_admin).\n   *\n   * Retrieve a single administrative account by its identifier from the\n   * todo_app_admin table.\n   *\n   * Purpose and overview: Returns details for one admin account to support\n   * operational and support workflows. The response includes id, email,\n   * is_super, created_at, and last_active_at and MUST NOT include password_hash\n   * or other sensitive secrets.\n   *\n   * Security considerations and user permissions: Only administrative callers\n   * are allowed to use this endpoint. Each successful or failed access SHOULD\n   * be recorded in todo_app_audit_records for traceability. Super-admin\n   * privileges (is_super) may be required for certain management actions, but\n   * simple read access may be permitted to standard admins depending on policy;\n   * the business rule here is that only \"admin\" role callers may reach this\n   * endpoint.\n   *\n   * Relationship to underlying database entities: This operation directly maps\n   * to the todo_app_admin Prisma model. Implementations should use the schema's\n   * id (uuid) path parameter to find the corresponding record and map the\n   * model's fields into the response DTO.\n   *\n   * Validation rules and business logic: The adminId path parameter MUST be a\n   * UUID. The service MUST return 404 if the record is absent. The response\n   * MUST redact password_hash. Audit logging is required for all accesses.\n   *\n   * Related API operations: The PATCH /admins endpoint supports searching and\n   * listing admins; use that for broader queries.\n   *\n   * Expected errors: 400 for malformed UUID, 403 for unauthorized access, 404\n   * when admin not found, 500 for server errors.\n   *\n   * @param connection\n   * @param adminId Unique identifier (UUID) of the target admin account\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":adminId\")\n  public async at(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"adminId\")\n    adminId: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoAppAdmin> {\n    try {\n      return await getTodoAppAdminAdminsAdminId({\n        admin,\n        adminId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update an admin account (todo_app_admin).\n   *\n   * Update an administrative account's permitted, non-sensitive fields. This\n   * operation updates fields on the todo_app_admin model as defined in the\n   * Prisma schema (id, email, is_super, created_at, last_active_at). IMPORTANT:\n   * this endpoint MUST NOT accept or return `password_hash` or any other\n   * credential material. Password/credential rotation must be performed via a\n   * dedicated secure credential endpoint.\n   *\n   * Security and permissions: Only authenticated admins may call this endpoint.\n   * If the request payload attempts to change the `is_super` flag, the server\n   * MUST verify the caller is a super-admin and otherwise return 403 Forbidden.\n   * The server must also validate that the provided email (if present) does not\n   * conflict with other unique constraints and handle 409 Conflict when\n   * appropriate.\n   *\n   * Audit: Implementations MUST generate an audit record in\n   * todo_app_audit_records as a server-side side effect for every successful\n   * administrative modification. The audit entry should include actor_id\n   * (caller), actor_role='admin', action_type='update_admin',\n   * target_resource='admin', target_id (adminId), optional reason, and\n   * created_at timestamp.\n   *\n   * Validation and error handling: The request MUST conform to the\n   * ITodoAppAdmin.IUpdate DTO which excludes password_hash. Possible responses:\n   * 200 OK with a safe admin representation (no secrets), 400 Bad Request for\n   * validation errors, 403 Forbidden for insufficient privileges, 404 Not Found\n   * if adminId does not exist, 409 Conflict for uniqueness violations, and 500\n   * for server errors.\n   *\n   * @param connection\n   * @param adminId Unique identifier (UUID) of the target admin account\n   * @param body Admin update payload. Only include mutable, non-sensitive\n   *   fields (email, is_super, last_active_at). Do NOT include password_hash.\n   *   For credential updates use the credential management endpoint.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put(\":adminId\")\n  public async update(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"adminId\")\n    adminId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoAppAdmin.IUpdate,\n  ): Promise<ITodoAppAdmin.ISummary> {\n    try {\n      return await putTodoAppAdminAdminsAdminId({\n        admin,\n        adminId,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Permanently remove an admin account (todo_app_admin).\n   *\n   * Permanently deletes an admin record identified by adminId from the\n   * todo_app_admin table. Because the model lacks a soft-delete field, this\n   * action is irreversible through normal user flows and should only be\n   * permitted after appropriate operational checks.\n   *\n   * Security and permissions: This operation MUST be restricted to\n   * super-admins. The server MUST enforce protections to prevent accidental\n   * lockout: it MUST prevent self-deletion (caller deleting their own account)\n   * unless an explicit, documented multi-step confirmation flow is used, and it\n   * MUST prevent deleting the last remaining super-admin (return 409 Conflict).\n   * If the caller lacks privileges, return 403 Forbidden.\n   *\n   * Audit and retention: The server MUST create an append-only audit record in\n   * todo_app_audit_records for this action with actor_id, actor_role='admin',\n   * action_type='erase_admin', target_resource='admin', target_id (adminId),\n   * optional reason, and created_at timestamp. Audit records referencing the\n   * removed admin MUST NOT be deleted as part of this operation.\n   *\n   * Behavior and errors: On success return 204 No Content. If adminId not found\n   * return 404 Not Found. If the deletion would violate policy (self-delete or\n   * removal of last super-admin) return 409 Conflict with explanatory message.\n   * Server errors return 500.\n   *\n   * @param connection\n   * @param adminId Unique identifier (UUID) of the admin account to remove\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Delete(\":adminId\")\n  public async erase(\n    @AdminAuth()\n    admin: AdminPayload,\n    @TypedParam(\"adminId\")\n    adminId: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    try {\n      return await deleteTodoAppAdminAdminsAdminId({\n        admin,\n        adminId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n"},"compiled":{"type":"success"},"created_at":"2025-10-07T20:10:36.969Z","completed_at":"2025-10-07T20:26:03.162Z","step":0}]