import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthGuestJoin } from "../../../providers/postAuthGuestJoin";
import { postAuthGuestRefresh } from "../../../providers/postAuthGuestRefresh";
import { GuestAuth } from "../../../decorators/GuestAuth";
import { GuestPayload } from "../../../decorators/payload/GuestPayload";

import { ITodoAppGuest } from "../../../api/structures/ITodoAppGuest";

@Controller("/auth/guest")
export class AuthGuestController {
  /**
   * Create a guest record in the todo_app_guest table and issue temporary
   * authorization tokens.
   *
   * Purpose and functionality: This endpoint allows an unauthenticated visitor
   * to create a temporary guest record in the `todo_app_guest` table. The API
   * accepts an optional `email` (if provided by the client) and the server will
   * create a new record with a system-assigned `id` (UUID) and set
   * `created_at`. The returned response contains an authorization payload
   * (short-lived tokens) suitable for guest workflows.
   *
   * Implementation details using confirmed schema fields: The request maps
   * directly to fields present in the Prisma model `todo_app_guest`.
   * Specifically, provided `email` maps to `todo_app_guest.email`. The server
   * will set `todo_app_guest.id` (UUID) and `todo_app_guest.created_at`
   * (timestamp). The server may also initialize `todo_app_guest.status` and
   * leave `last_active_at` null until the guest performs subsequent activity.
   *
   * Role-specific integration and business context: This operation is a public
   * join endpoint for the role 'guest' and is intended to be used in client
   * flows that need temporary identity without full user registration. Because
   * the `email` column in `todo_app_guest` is nullable in the schema, the
   * request may omit `email` to create an anonymous guest record. The response
   * follows the authorization response naming convention and returns
   * `ITodoAppGuest.IAuthorized` as the successful response type.
   *
   * Security considerations within schema constraints: Validate the optional
   * `email` format when present (RFC 5322 basic validation) and rate-limit join
   * attempts to prevent abuse. Do not store additional user credentials in
   * `todo_app_guest.password` because that field does not exist. Keep issued
   * tokens short-lived and tie refresh operations to the guest `id` and
   * `last_active_at` lifecycle.
   *
   * Related operations and workflow integration: This operation pairs with
   * `POST /auth/guest/refresh` which can update `todo_app_guest.last_active_at`
   * and may create audit entries in `todo_app_audit_records` (for example,
   * recording refresh events using `todo_app_audit_records.actor_role`,
   * `action_type`, `target_resource`, `target_id`, and `created_at`).
   *
   * @param connection
   * @param body Guest registration payload. Maps to `todo_app_guest.email`
   *   (nullable). If omitted, an anonymous guest record is created.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ITodoAppGuest.IJoin,
  ): Promise<ITodoAppGuest.IAuthorized> {
    try {
      return await postAuthGuestJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Exchange a valid guest refresh credential for a new access token and update
   * guest activity metadata in todo_app_guest.
   *
   * Purpose and functionality: This endpoint accepts a valid guest refresh
   * credential and issues a new short-lived access token (and optionally
   * rotates the refresh token). It targets the `todo_app_guest` table so that
   * guest activity can be associated with the `id` and `last_active_at`
   * fields.
   *
   * Implementation details using confirmed schema fields: On successful
   * validation of the presented refresh credential, the server SHOULD update
   * `todo_app_guest.last_active_at` to the current server timestamp and may
   * record the refresh event in `todo_app_audit_records` by populating
   * `actor_role` (e.g., 'system' or 'guest'), `action_type` (e.g.,
   * 'refresh_token'), `target_resource` = 'guest', `target_id` = the guest
   * `id`, and `created_at` to capture the event time.
   *
   * Role-specific integration and business context: This operation is
   * role-restricted: it requires a valid refresh credential tied to a
   * previously created guest (role = 'guest'). The API path
   * `/auth/guest/refresh` follows the service naming conventions for guest
   * token lifecycle management and returns `ITodoAppGuest.IAuthorized` on
   * success, matching the service prefix and role naming pattern.
   *
   * Security considerations within schema constraints: Rotate refresh tokens
   * when practical and invalidate refresh tokens upon abuse detection. Because
   * `todo_app_guest.password_hash` does not exist in the schema, do not attempt
   * password-based verification for guests; instead rely on token material.
   * Record refresh attempts and consider rate-limiting per guest `id` to reduce
   * token replay risk.
   *
   * Related operations and workflow integration: This operation complements
   * `/auth/guest/join` (which issues initial tokens) and may be followed by
   * guest-scoped API calls. Audit entries for refresh events can be stored in
   * `todo_app_audit_records` (fields: `actor_role`, `action_type`,
   * `target_resource`, `target_id`, `created_at`) to help operations and
   * security teams investigate token usage patterns.
   *
   * @param connection
   * @param body Refresh request payload. Contains the refresh credential/token
   *   associated with a guest identity. Server will validate and rotate as
   *   appropriate.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @GuestAuth()
    guest: GuestPayload,
    @TypedBody()
    body: ITodoAppGuest.IRefresh,
  ): Promise<ITodoAppGuest.IAuthorized> {
    try {
      return await postAuthGuestRefresh({
        guest,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
