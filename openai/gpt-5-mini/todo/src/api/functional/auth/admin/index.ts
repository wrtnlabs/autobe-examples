import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppAdmin } from "../../../structures/ITodoAppAdmin";
export * as password from "./password/index";

/**
 * Create a new admin account (todo_app_admin).
 *
 * Purpose and overview: This endpoint registers a new administrator account for
 * the system and issues an initial authorized response payload. It is
 * explicitly tied to the Prisma model `todo_app_admin` and will rely on the
 * `email`, `password_hash`, `is_super`, `created_at`, and `last_active_at`
 * fields on that table to represent account identity and state.
 *
 * Implementation details and required fields: When called, the implementation
 * will validate the provided `email` and password, persist the new
 * `todo_app_admin` row (setting `email` and, after hashing, `password_hash`)
 * and set the initial `created_at` and `last_active_at` timestamps. If elevated
 * privileges are required for the account, `is_super` may be set per the
 * request. The response payload uses tokens and the admin summary, but token
 * persistence or revocation mechanism is implementation specific and not
 * assumed to be a column on `todo_app_admin`.
 *
 * Role-specific integration: This endpoint is the public entry point for
 * creating admin accounts. It should ensure the `email` value is unique (the
 * Prisma model defines `@@unique([email])`) and must fail cleanly if a
 * duplicate `email` exists. As part of the workflow, an audit entry may be
 * recorded in `todo_app_audit_records` referencing the created admin
 * (`admin_id`) with `action_type` like `create_admin` to satisfy compliance and
 * traceability.
 *
 * Security considerations: Passwords MUST be hashed before storing in
 * `password_hash` and never returned in responses. The implementation must not
 * expose `password_hash` in any response. All audit actions related to account
 * creation SHOULD be recorded in `todo_app_audit_records` (fields available:
 * `admin_id`, `actor_role`, `action_type`, `target_resource`, `target_id`,
 * `created_at`). Use secure transport (HTTPS) and apply rate limiting to
 * prevent abuse.
 *
 * Related operations and workflow integration: This operation complements `POST
 * /auth/admin/login` (to obtain access tokens) and `POST /auth/admin/refresh`
 * (to refresh tokens). After creation, the caller is expected to use the issued
 * tokens from this response (see response schema) to authenticate subsequent
 * admin-only endpoints. If email verification is required by policy, the
 * implementation should create an initial unverified state and record this in
 * `todo_app_audit_records`.
 *
 * @param props.connection
 * @param props.body Registration payload for a new admin account.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/join
 * @accessor api.functional.auth.admin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Registration payload for a new admin account. */
    body: ITodoAppAdmin.ICreate;
  };
  export type Body = ITodoAppAdmin.ICreate;
  export type Response = ITodoAppAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/join";
  export const random = (): ITodoAppAdmin.IAuthorized =>
    typia.random<ITodoAppAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate admin and issue tokens (todo_app_admin).
 *
 * Purpose and overview: This endpoint authenticates an administrator by
 * validating supplied credentials against the `todo_app_admin` model. It
 * references the `email` (unique) column and compares the supplied password to
 * the stored `password_hash` field before issuing tokens. Successful
 * authentication may update `last_active_at` on the `todo_app_admin` row.
 *
 * Implementation details and validation: The implementation MUST validate that
 * the provided `email` exists in `todo_app_admin`. Password verification must
 * compare the supplied secret to the `password_hash` using secure hash
 * verification (e.g., bcrypt/argon2). On success, the implementation may update
 * `last_active_at` to the current timestamp and optionally create an audit
 * record in `todo_app_audit_records` with `action_type` such as `admin_login`
 * and `actor_role` set to `admin`.
 *
 * Role-specific integration and behavior: This is a public authentication
 * endpoint that issues an `ITodoAppAdmin.IAuthorized` response containing
 * short-lived access credentials and a refresh credential. The caller uses
 * these tokens for subsequent admin-scoped API calls. The operation should
 * respect account status (the `account_status` field on `todo_app_user` exists
 * for users; for admins the `todo_app_admin` model has `is_super` and
 * timestamps â€” implementors may add an `account_status` equivalent if needed,
 * but do not assume it exists by default on `todo_app_admin`).
 *
 * Security considerations: Do NOT include `password_hash` in any response.
 * Failed login attempts SHOULD be logged to `todo_app_audit_records` with
 * `action_type` like `admin_login_failed` to support monitoring and abuse
 * detection. Apply rate limits and account lockout policies at higher layers.
 *
 * Related operations: After successful login, the issued tokens are expected to
 * be used with `POST /auth/admin/refresh` to renew short-lived access tokens
 * and with admin-protected endpoints that require `authorizationRole: "admin"`
 * such as password change or administrative maintenance actions.
 *
 * @param props.connection
 * @param props.body Login payload: admin email and password.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/login
 * @accessor api.functional.auth.admin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Login payload: admin email and password. */
    body: ITodoAppAdmin.ILogin;
  };
  export type Body = ITodoAppAdmin.ILogin;
  export type Response = ITodoAppAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/login";
  export const random = (): ITodoAppAdmin.IAuthorized =>
    typia.random<ITodoAppAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh admin access token.
 *
 * Purpose and overview: This endpoint accepts a valid refresh credential and
 * issues a new short-lived access token (and optionally a new refresh token).
 * While `todo_app_admin` does not store token values in any specific column,
 * the operation is semantically tied to admin sessions for accounts represented
 * by `todo_app_admin.id` and `todo_app_admin.email`.
 *
 * Implementation details and security: The implementation must validate the
 * presented refresh credential according to the chosen session/token
 * architecture. Because the Prisma schema does not include dedicated token
 * storage fields, token persistence and revocation logic is an implementation
 * concern; however, all refresh operations SHOULD be recorded to
 * `todo_app_audit_records` (e.g., `action_type = refresh_token_used`,
 * `target_id = admin id`) to support auditability.
 *
 * Role-specific integration: This is a public endpoint in the auth flow
 * (clients call it with a refresh credential). On successful refresh, the
 * response returns the same `ITodoAppAdmin.IAuthorized` shape used for login /
 * join so that clients have a consistent authorized payload. The server SHOULD
 * update `last_active_at` for the related `todo_app_admin` row when
 * appropriate.
 *
 * Security considerations: Refresh tokens SHOULD be revocable (server-side
 * blacklist or rotating refresh tokens). Revocation and revocation attempts
 * SHOULD be logged to `todo_app_audit_records` with appropriate `actor_role`
 * and `action_type` so that administrators can trace suspicious activity.
 *
 * Related operations: Works together with `POST /auth/admin/login` (initial
 * issuance) and admin session revocation endpoints (not included here).
 *
 * @param props.connection
 * @param props.body Payload containing the refresh credential for token
 *   renewal.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/refresh
 * @accessor api.functional.auth.admin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Payload containing the refresh credential for token renewal. */
    body: ITodoAppAdmin.IRefresh;
  };
  export type Body = ITodoAppAdmin.IRefresh;
  export type Response = ITodoAppAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/refresh";
  export const random = (): ITodoAppAdmin.IAuthorized =>
    typia.random<ITodoAppAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
