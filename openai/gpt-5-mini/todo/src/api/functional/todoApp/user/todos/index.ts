import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppTodo } from "../../../../structures/ITodoAppTodo";
import { IPageITodoAppTodo } from "../../../../structures/IPageITodoAppTodo";
export * as versions from "./versions/index";

/**
 * Create a new Todo (todo_app_todos).
 *
 * Create a new Todo item and persist it in the `todo_app_todos` table. This
 * endpoint accepts minimal user-provided fields required for quick capture
 * (title plus optional description and position). On success the server returns
 * the full Todo record including server-populated fields such as `id`,
 * `created_at`, and `updated_at`.
 *
 * Security and permissions: Only authenticated users may create todos. The
 * creating user's identity is used to set the `user_id` relation in
 * `todo_app_todos`. The operation requires role `user` and the request must be
 * authorized before creating data.
 *
 * Validation rules and business logic:
 *
 * - `title` is required: non-empty string after trimming (1..250 chars
 *   recommended).
 * - `description` is optional (<= 4000 chars recommended).
 * - `position` is optional integer used by clients for ordering.
 * - `is_completed` defaults to false; if provided must be boolean.
 * - Server sets `created_at` and `updated_at`.
 *
 * Errors:
 *
 * - 400 for validation errors (ERR_INVALID_TITLE, ERR_INVALID_DESCRIPTION).
 * - 401/403 for auth errors.
 * - 500 for server errors.
 *
 * @param props.connection
 * @param props.body Creation payload for a new Todo. Clients provide only
 *   user-editable fields (title required, description optional, position
 *   optional). System-managed fields (id, user_id, created_at, updated_at,
 *   completed_at, deleted_at) are omitted and set by the server.
 * @path /todoApp/user/todos
 * @accessor api.functional.todoApp.user.todos.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Creation payload for a new Todo. Clients provide only user-editable
     * fields (title required, description optional, position optional).
     * System-managed fields (id, user_id, created_at, updated_at,
     * completed_at, deleted_at) are omitted and set by the server.
     */
    body: ITodoAppTodo.ICreate;
  };
  export type Body = ITodoAppTodo.ICreate;
  export type Response = ITodoAppTodo;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/user/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/user/todos";
  export const random = (): ITodoAppTodo => typia.random<ITodoAppTodo>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of todo summaries from
 * todo_app_todos.
 *
 * Retrieve a filtered and paginated list of todo items owned by the requesting
 * user.
 *
 * Purpose and overview: This endpoint returns a paginated collection of todo
 * summaries derived from the Prisma `todo_app_todos` model. The model stores
 * primary todo data including title, optional description, completion flag,
 * timestamps, and a nullable deleted_at column that implements soft-delete
 * semantics in the schema. By default, the operation excludes records with
 * `deleted_at` set (deleted items). Callers may request inclusion of deleted
 * items via the request DTO when an administrative or recovery view is
 * required.
 *
 * Security and permissions: Only authenticated requests scoped to the owning
 * user may retrieve their todos; the operation must ensure the returned rows
 * have `user_id` equal to the requesting user's id. The API surface for listing
 * is restricted to role `user`. Any elevated listing that includes other users'
 * data or exhaustive audit results must be implemented in separate admin
 * endpoints and recorded in `todo_app_audit_records`.
 *
 * Relationship to underlying database entities: This operation maps to the
 * Prisma model `todo_app_todos`. It relies on columns explicitly defined in
 * that model: `id`, `user_id`, `title`, `description`, `is_completed`,
 * `completed_at`, `position`, `created_at`, `updated_at`, and `deleted_at`.
 * Snapshots are captured separately in `todo_app_todo_snapshots`; snapshot
 * creation is a background or explicit process and is not performed by this
 * read operation.
 *
 * Validation rules and business logic:
 *
 * - The operation accepts pagination parameters (page, pageSize) and enforces
 *   sane server-side limits for pageSize.
 * - Filter fields: `isCompleted` (boolean) filters by `is_completed`. If omitted,
 *   both active and completed todos are returned (subject to exclusion of
 *   deleted items).
 * - Sorting: clients may request sort by `createdAt` or `position` with
 *   ascending/descending direction. Sorting keys correspond to `created_at` and
 *   `position` columns in the Prisma model.
 * - Deleted items: by default, rows where `deleted_at` is NOT null are excluded;
 *   inclusion requires an explicit includeDeleted flag and should be limited to
 *   administrative/owner recovery scenarios.
 *
 * Related operations and error handling: Use `GET /todoApp/user/todos/{todoId}`
 * (operation `at`) to fetch a single todo detail. Clients requesting export or
 * heavy full-text search should use dedicated endpoints. Common errors: 400 for
 * invalid request parameters, 401/403 for unauthorized access, and 500 for
 * unexpected server errors. Missing resources are returned as empty pages
 * rather than 404 for list endpoints.
 *
 * @param props.connection
 * @param props.body Search, filter, sort, and pagination parameters for listing
 *   todos owned by the requesting user.
 * @path /todoApp/user/todos
 * @accessor api.functional.todoApp.user.todos.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filter, sort, and pagination parameters for listing todos
     * owned by the requesting user.
     */
    body: ITodoAppTodo.IRequest;
  };
  export type Body = ITodoAppTodo.IRequest;
  export type Response = IPageITodoAppTodo.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/user/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/user/todos";
  export const random = (): IPageITodoAppTodo.ISummary =>
    typia.random<IPageITodoAppTodo.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a single todo by id from todo_app_todos.
 *
 * Retrieve full details of a single todo item.
 *
 * Purpose and overview: This endpoint returns the complete `todo_app_todos`
 * entity for the provided `todoId`. It is intended to supply clients with all
 * available fields defined in the Prisma model, enabling detailed views and
 * edit screens. Timestamps provided are those defined on the model
 * (`created_at`, `updated_at`, `completed_at`, `deleted_at`).
 *
 * Security and user permissions: The operation requires that the requester be
 * the owner of the todo (matching `user_id`) or an authorized admin with
 * audited access. Unauthorized attempts must result in 403. If the todo is
 * soft-deleted (non-null `deleted_at`), the API returns 404 unless the request
 * is for owner recovery and the business logic explicitly allows returning
 * deleted items to the owner.
 *
 * Relationship to database and snapshots: The todo returned is the live record
 * in `todo_app_todos`. Historical snapshots exist in `todo_app_todo_snapshots`
 * and are not returned by this endpoint. Snapshot retrieval is available via a
 * separate audit/history endpoint if needed.
 *
 * Validation and error handling:
 *
 * - Path parameter `todoId` MUST be a UUID. If malformed, return 400.
 * - If the todo does not exist or is not accessible to the requester (including
 *   when it is deleted and not permitted to be returned), return 404.
 * - On success, return the full `ITodoAppTodo` representation with all
 *   model-described fields.
 *
 * Related operations: Use `PATCH /todoApp/user/todos` (operation `index`) to
 * search/paginate lists. Use `PATCH /todoApp/user/todos/{todoId}` (update) to
 * modify the item. Administrative restores and purges are separate operations
 * and must be recorded in `todo_app_audit_records`.
 *
 * @param props.connection
 * @param props.todoId Unique identifier (UUID) of the target todo item
 * @path /todoApp/user/todos/:todoId
 * @accessor api.functional.todoApp.user.todos.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the target todo item */
    todoId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppTodo;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/user/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoAppTodo => typia.random<ITodoAppTodo>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing Todo by ID (todo_app_todos).
 *
 * Update an existing Todo item in the `todo_app_todos` table. Clients supply
 * the todo identifier in the path and a payload with the fields to change. The
 * server validates ownership and input, applies allowed updates, sets
 * `updated_at`, and returns the updated resource.
 *
 * Security and permissions: Only the owner of the todo (authenticated role
 * `user`) or an authorized admin flow may update the record. Attempts to update
 * another user's todo MUST be rejected with 403 Forbidden. If the target record
 * has a non-null `deleted_at` (soft-deleted), the server SHOULD return 404 Not
 * Found or 410 Gone depending on policy; this operation does not implicitly
 * undelete resources.
 *
 * Validation and business logic:
 *
 * - `title` if provided must be non-empty and within allowed length (1..250
 *   chars).
 * - `description` if provided must be <= 4000 chars.
 * - `is_completed` toggled true sets `completed_at` to server time; toggled false
 *   clears `completed_at`.
 * - `position` if provided must be an integer.
 *
 * Note on PUT semantics: This operation uses PUT for updates per API
 * conventions. Ensure `ITodoAppTodo.IUpdate` semantics are documented
 * (partial-update with optional fields vs full-replace). If partial updates are
 * used, clients may send only fields to change.
 *
 * @param props.connection
 * @param props.todoId Unique identifier (UUID) of the target todo to update
 * @param props.body Partial or full update payload for a Todo. Include only
 *   fields to be changed if IUpdate is defined with optional fields.
 *   System-managed timestamps and identifiers are not accepted from clients.
 * @path /todoApp/user/todos/:todoId
 * @accessor api.functional.todoApp.user.todos.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the target todo to update */
    todoId: string & tags.Format<"uuid">;

    /**
     * Partial or full update payload for a Todo. Include only fields to be
     * changed if IUpdate is defined with optional fields. System-managed
     * timestamps and identifiers are not accepted from clients.
     */
    body: ITodoAppTodo.IUpdate;
  };
  export type Body = ITodoAppTodo.IUpdate;
  export type Response = ITodoAppTodo;

  export const METADATA = {
    method: "PUT",
    path: "/todoApp/user/todos/:todoId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoAppTodo => typia.random<ITodoAppTodo>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a todo (mark as deleted) in the todo_app_todos table.
 *
 * Mark a Todo item as deleted by setting its deleted_at timestamp.
 *
 * Purpose and overview: This operation marks a todo item in the todo_app_todos
 * table as deleted (soft-delete) so it is removed from active and completed
 * lists but retained for recovery and historical purposes. It uses the
 * todo_app_todos.deleted_at column defined in the Prisma schema to record
 * deletion time.
 *
 * Security considerations and user permissions: Only the owning user is
 * permitted to soft-delete their todo. The service must validate ownership
 * using the todo_app_todos.user_id relation to todo_app_user.id. Admin
 * maintenance flows that permanently purge data are separate and must be
 * audited via todo_app_audit_records.
 *
 * Validation rules and business logic: The todoId path parameter must be a
 * valid UUID and must reference an existing todo record. If the record already
 * has deleted_at set, the operation is idempotent and returns 204. Ownership
 * must be enforced; attempts to delete another user's todo must be rejected
 * with 403. If the todo is missing, return 404. Errors should include
 * machine-readable codes and human-friendly messages.
 *
 * @param props.connection
 * @param props.todoId Unique identifier (UUID) of the target todo
 *   (todo_app_todos.id)
 * @path /todoApp/user/todos/:todoId
 * @accessor api.functional.todoApp.user.todos.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier (UUID) of the target todo (todo_app_todos.id) */
    todoId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoApp/user/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
