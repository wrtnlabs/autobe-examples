import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppAdmin } from "../../../../structures/ITodoAppAdmin";
import { IPageITodoAppAdmin } from "../../../../structures/IPageITodoAppAdmin";

/**
 * Search and retrieve a filtered, paginated list of administrative accounts
 * (todo_app_admin).
 *
 * Retrieve a filtered, sorted and paginated list of administrative accounts
 * from the todo_app_admin table.
 *
 * Purpose and overview: This operation lets authorized systems and operators
 * query administrative accounts for support, audit, and maintenance tasks. It
 * operates directly on the todo_app_admin model defined in the Prisma schema,
 * which stores admin account identifiers, email addresses, super-admin flags,
 * account creation timestamps, and last-active timestamps. The operation
 * supports pagination, free-text email search, boolean filtering on the
 * is_super flag, and sorting by created_at or last_active_at.
 *
 * Security considerations and user permissions: Access to this endpoint is
 * restricted to administrative actors. All accesses to admin records via this
 * endpoint MUST be recorded in audit logs (see todo_app_audit_records) with
 * actor id, action_type, target_resource and timestamp. Responses MUST NOT
 * expose sensitive fields such as password_hash. The service layer should
 * filter out or redact password_hash before sending any response. Rate-limiting
 * and monitoring are recommended to detect abusive enumeration attempts.
 *
 * Relationship to underlying database entities: This operation queries the
 * todo_app_admin table (Prisma model todo_app_admin). Querying capabilities
 * should correspond to existing schema fields: id (uuid), email (unique),
 * is_super (boolean), created_at (timestamptz), and last_active_at (nullable
 * timestamptz). Implementations may optionally join audit data for enriched
 * results but must avoid leaking audit details unless explicitly requested.
 *
 * Validation rules and business logic: The request DTO must validate pagination
 * parameters (page >= 1, pageSize reasonable limits), validate sort fields to
 * allowed set (created_at, last_active_at), and require that the caller is an
 * admin. Search parameters for email should be normalized and limited to
 * prevent high-cost queries. Any attempt to include password_hash in projection
 * or filters must be rejected.
 *
 * Related API operations: Use GET /admins/{adminId} to retrieve a single
 * admin's details. Use audit-record endpoints (not part of this interface) to
 * inspect who accessed admin records. Error handling: return 400 for invalid
 * request payloads, 401/403 for unauthorized requests, 429 for rate limits, and
 * 500 for unexpected server errors.
 *
 * @param props.connection
 * @param props.body Search, filter, sort and pagination parameters for listing
 *   administrative accounts
 * @path /todoApp/admin/admins
 * @accessor api.functional.todoApp.admin.admins.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filter, sort and pagination parameters for listing
     * administrative accounts
     */
    body: ITodoAppAdmin.IRequest;
  };
  export type Body = ITodoAppAdmin.IRequest;
  export type Response = IPageITodoAppAdmin.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/admin/admins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/admin/admins";
  export const random = (): IPageITodoAppAdmin.ISummary =>
    typia.random<IPageITodoAppAdmin.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific administrative account
 * (todo_app_admin).
 *
 * Retrieve a single administrative account by its identifier from the
 * todo_app_admin table.
 *
 * Purpose and overview: Returns details for one admin account to support
 * operational and support workflows. The response includes id, email, is_super,
 * created_at, and last_active_at and MUST NOT include password_hash or other
 * sensitive secrets.
 *
 * Security considerations and user permissions: Only administrative callers are
 * allowed to use this endpoint. Each successful or failed access SHOULD be
 * recorded in todo_app_audit_records for traceability. Super-admin privileges
 * (is_super) may be required for certain management actions, but simple read
 * access may be permitted to standard admins depending on policy; the business
 * rule here is that only "admin" role callers may reach this endpoint.
 *
 * Relationship to underlying database entities: This operation directly maps to
 * the todo_app_admin Prisma model. Implementations should use the schema's id
 * (uuid) path parameter to find the corresponding record and map the model's
 * fields into the response DTO.
 *
 * Validation rules and business logic: The adminId path parameter MUST be a
 * UUID. The service MUST return 404 if the record is absent. The response MUST
 * redact password_hash. Audit logging is required for all accesses.
 *
 * Related API operations: The PATCH /admins endpoint supports searching and
 * listing admins; use that for broader queries.
 *
 * Expected errors: 400 for malformed UUID, 403 for unauthorized access, 404
 * when admin not found, 500 for server errors.
 *
 * @param props.connection
 * @param props.adminId Unique identifier (UUID) of the target admin account
 * @path /todoApp/admin/admins/:adminId
 * @accessor api.functional.todoApp.admin.admins.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the target admin account */
    adminId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppAdmin;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/admin/admins/:adminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): ITodoAppAdmin => typia.random<ITodoAppAdmin>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an admin account (todo_app_admin).
 *
 * Update an administrative account's permitted, non-sensitive fields. This
 * operation updates fields on the todo_app_admin model as defined in the Prisma
 * schema (id, email, is_super, created_at, last_active_at). IMPORTANT: this
 * endpoint MUST NOT accept or return `password_hash` or any other credential
 * material. Password/credential rotation must be performed via a dedicated
 * secure credential endpoint.
 *
 * Security and permissions: Only authenticated admins may call this endpoint.
 * If the request payload attempts to change the `is_super` flag, the server
 * MUST verify the caller is a super-admin and otherwise return 403 Forbidden.
 * The server must also validate that the provided email (if present) does not
 * conflict with other unique constraints and handle 409 Conflict when
 * appropriate.
 *
 * Audit: Implementations MUST generate an audit record in
 * todo_app_audit_records as a server-side side effect for every successful
 * administrative modification. The audit entry should include actor_id
 * (caller), actor_role='admin', action_type='update_admin',
 * target_resource='admin', target_id (adminId), optional reason, and created_at
 * timestamp.
 *
 * Validation and error handling: The request MUST conform to the
 * ITodoAppAdmin.IUpdate DTO which excludes password_hash. Possible responses:
 * 200 OK with a safe admin representation (no secrets), 400 Bad Request for
 * validation errors, 403 Forbidden for insufficient privileges, 404 Not Found
 * if adminId does not exist, 409 Conflict for uniqueness violations, and 500
 * for server errors.
 *
 * @param props.connection
 * @param props.adminId Unique identifier (UUID) of the target admin account
 * @param props.body Admin update payload. Only include mutable, non-sensitive
 *   fields (email, is_super, last_active_at). Do NOT include password_hash. For
 *   credential updates use the credential management endpoint.
 * @path /todoApp/admin/admins/:adminId
 * @accessor api.functional.todoApp.admin.admins.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the target admin account */
    adminId: string & tags.Format<"uuid">;

    /**
     * Admin update payload. Only include mutable, non-sensitive fields
     * (email, is_super, last_active_at). Do NOT include password_hash. For
     * credential updates use the credential management endpoint.
     */
    body: ITodoAppAdmin.IUpdate;
  };
  export type Body = ITodoAppAdmin.IUpdate;
  export type Response = ITodoAppAdmin.ISummary;

  export const METADATA = {
    method: "PUT",
    path: "/todoApp/admin/admins/:adminId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): ITodoAppAdmin.ISummary =>
    typia.random<ITodoAppAdmin.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently remove an admin account (todo_app_admin).
 *
 * Permanently deletes an admin record identified by adminId from the
 * todo_app_admin table. Because the model lacks a soft-delete field, this
 * action is irreversible through normal user flows and should only be permitted
 * after appropriate operational checks.
 *
 * Security and permissions: This operation MUST be restricted to super-admins.
 * The server MUST enforce protections to prevent accidental lockout: it MUST
 * prevent self-deletion (caller deleting their own account) unless an explicit,
 * documented multi-step confirmation flow is used, and it MUST prevent deleting
 * the last remaining super-admin (return 409 Conflict). If the caller lacks
 * privileges, return 403 Forbidden.
 *
 * Audit and retention: The server MUST create an append-only audit record in
 * todo_app_audit_records for this action with actor_id, actor_role='admin',
 * action_type='erase_admin', target_resource='admin', target_id (adminId),
 * optional reason, and created_at timestamp. Audit records referencing the
 * removed admin MUST NOT be deleted as part of this operation.
 *
 * Behavior and errors: On success return 204 No Content. If adminId not found
 * return 404 Not Found. If the deletion would violate policy (self-delete or
 * removal of last super-admin) return 409 Conflict with explanatory message.
 * Server errors return 500.
 *
 * @param props.connection
 * @param props.adminId Unique identifier (UUID) of the admin account to remove
 * @path /todoApp/admin/admins/:adminId
 * @accessor api.functional.todoApp.admin.admins.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier (UUID) of the admin account to remove */
    adminId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoApp/admin/admins/:adminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/admin/admins/${encodeURIComponent(props.adminId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
