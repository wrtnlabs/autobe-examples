import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppGuest } from "../../../../structures/ITodoAppGuest";
import { IPageITodoAppGuest } from "../../../../structures/IPageITodoAppGuest";

/**
 * Search and retrieve a paginated list of guest records (todo_app_guest).
 *
 * Search and retrieve guest records using flexible criteria and pagination.
 * This operation targets the Prisma model `todo_app_guest` and supports filters
 * such as email (exact or partial), status, created_at range, and sorting by
 * created_at or last_active_at.
 *
 * Response items include the model's core attributes: id, email (nullable),
 * created_at, last_active_at (nullable), and status (nullable). The request
 * body contains search criteria, pagination, and sorting options. The response
 * is a paginated container of guest record summaries.
 *
 * Security and permissions: Access is limited to administrative actors.
 * Returned personal data (email) must be disclosed only to authorized callers;
 * consider role-based projection or email redaction for lower-privilege
 * support. Implement server-side input validation and parameterized queries to
 * avoid injection and protect performance. Implement rate limiting and audit
 * logging for searches.
 *
 * Errors: invalid request payloads return 400 with validation details; server
 * errors return 500.
 *
 * @param props.connection
 * @param props.body Search criteria, pagination, and sorting parameters for
 *   guest records
 * @path /todoApp/admin/guests
 * @accessor api.functional.todoApp.admin.guests.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search criteria, pagination, and sorting parameters for guest records */
    body: ITodoAppGuest.IRequest;
  };
  export type Body = ITodoAppGuest.IRequest;
  export type Response = IPageITodoAppGuest.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/admin/guests",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/admin/guests";
  export const random = (): IPageITodoAppGuest.ISummary =>
    typia.random<IPageITodoAppGuest.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a guest (visitor) record by ID from the todo_app_guest table.
 *
 * Returns a single guest record from the todo_app_guest model. The guest model
 * stores lightweight visitor entries such as optional email, creation
 * timestamp, last activity, and a housekeeping status.
 *
 * Security and permissions: Access to guest records is restricted to
 * administrative/support users only. Calls to this endpoint MUST be
 * authenticated and authorized. The server implementation MUST create an audit
 * record in todo_app_audit_records for each access (actor_role='admin',
 * action_type='read_guest', target_resource='guest', target_id=guestId).
 *
 * Data and behavior: The response contains the guest's persisted fields (id,
 * email, created_at, last_active_at, status). This endpoint performs no
 * mutation; it is strictly read-only. Validation rules require the path
 * parameter to be a UUID. Errors returned include 400 for invalid ID format,
 * 404 when the guest is not found, and 500 for unexpected server errors.
 *
 * @param props.connection
 * @param props.guestId Unique identifier (UUID) of the guest record
 * @path /todoApp/admin/guests/:guestId
 * @accessor api.functional.todoApp.admin.guests.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the guest record */
    guestId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppGuest;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/admin/guests/:guestId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/admin/guests/${encodeURIComponent(props.guestId ?? "null")}`;
  export const random = (): ITodoAppGuest => typia.random<ITodoAppGuest>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("guestId")(() => typia.assert(props.guestId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
