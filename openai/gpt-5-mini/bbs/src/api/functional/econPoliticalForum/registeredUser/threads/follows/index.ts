import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumThreadFollow } from "../../../../../structures/IEconPoliticalForumThreadFollow";

/**
 * Create a follow (subscribe) for the authenticated registered user on the
 * specified thread.
 *
 * Create a follow/subscription record that causes the authenticated registered
 * user to receive notifications and have the thread included in the user's
 * followed list. This writes a row to econ_political_forum_thread_follows with
 * thread_id and the server-derived registereduser_id, sets created_at (and
 * updated_at), and returns the follow summary.
 *
 * Security considerations and user permissions: Only authenticated registered
 * users may perform this action. The server MUST verify the caller's identity
 * and check that the account is not banned or locked (email_verified,
 * is_banned, banned_until, locked_until semantics in the registered user
 * model). Requests from unauthenticated callers return 401; forbidden callers
 * return 403.
 *
 * Validation and business logic:
 *
 * - ThreadId path parameter must be a UUID; verify the referenced thread exists
 *   and deleted_at is null.
 * - Enforce uniqueness: if a non-deleted follow already exists for the current
 *   user and thread, return the existing follow (200) to ensure idempotency;
 *   otherwise create and return 201 Created with Location header.
 * - Optional per-follow preferences (muted_until) may be accepted if allowed by
 *   product; validate such fields (ISO 8601 timestamp) and disallow setting
 *   another user's registereduser_id.
 * - Apply per-user rate limits to follow creation to prevent abuse; return 429
 *   with Retry-After when limits are exceeded.
 *
 * @param props.connection
 * @param props.threadId UUID of the thread to follow
 *   (econ_political_forum_threads.id)
 * @param props.body Optional follow preferences. The acting registered user is
 *   derived from the session; clients MUST NOT provide registereduser_id.
 * @path /econPoliticalForum/registeredUser/threads/:threadId/follows
 * @accessor api.functional.econPoliticalForum.registeredUser.threads.follows.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** UUID of the thread to follow (econ_political_forum_threads.id) */
    threadId: string & tags.Format<"uuid">;

    /**
     * Optional follow preferences. The acting registered user is derived
     * from the session; clients MUST NOT provide registereduser_id.
     */
    body: IEconPoliticalForumThreadFollow.ICreate;
  };
  export type Body = IEconPoliticalForumThreadFollow.ICreate;
  export type Response = IEconPoliticalForumThreadFollow;

  export const METADATA = {
    method: "POST",
    path: "/econPoliticalForum/registeredUser/threads/:threadId/follows",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econPoliticalForum/registeredUser/threads/${encodeURIComponent(props.threadId ?? "null")}/follows`;
  export const random = (): IEconPoliticalForumThreadFollow =>
    typia.random<IEconPoliticalForumThreadFollow>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove (soft-delete) a follow for the authenticated user on the specified
 * thread.
 *
 * Remove a follow by marking the corresponding
 * econ_political_forum_thread_follows.deleted_at timestamp. This preserves an
 * audit trail while removing the follow from normal listings.
 *
 * Security considerations and permissions: Authenticated registered users may
 * remove their own follows. The server MUST verify the acting user's identity
 * matches the follow.registereduser_id. Administrators may be allowed to remove
 * follows per policy; server logic should permit elevated roles where
 * appropriate but this endpoint is designed for registered users to erase their
 * own follows.
 *
 * Validation and business logic:
 *
 * - Both path parameters must be valid UUIDs.
 * - Validate follow exists, follow.thread_id equals threadId, and
 *   follow.deleted_at is null before updating.
 * - If the follow does not exist or is already soft-deleted, treat the request as
 *   idempotent and return 204 No Content.
 * - If the follow exists and belongs to the caller, set deleted_at and updated_at
 *   and create an immutable audit log entry (econ_political_forum_audit_logs)
 *   with action_type 'erase_follow' as a server-side effect.
 * - If a legal hold exists that prevents deletion, refuse permanent purge and
 *   record the attempted action in the audit logs.
 *
 * @param props.connection
 * @param props.threadId UUID of the thread the follow belongs to
 *   (econ_political_forum_threads.id)
 * @param props.followId UUID of the follow record to remove
 *   (econ_political_forum_thread_follows.id)
 * @path /econPoliticalForum/registeredUser/threads/:threadId/follows/:followId
 * @accessor api.functional.econPoliticalForum.registeredUser.threads.follows.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * UUID of the thread the follow belongs to
     * (econ_political_forum_threads.id)
     */
    threadId: string & tags.Format<"uuid">;

    /**
     * UUID of the follow record to remove
     * (econ_political_forum_thread_follows.id)
     */
    followId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/econPoliticalForum/registeredUser/threads/:threadId/follows/:followId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econPoliticalForum/registeredUser/threads/${encodeURIComponent(props.threadId ?? "null")}/follows/${encodeURIComponent(props.followId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.param("followId")(() => typia.assert(props.followId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
