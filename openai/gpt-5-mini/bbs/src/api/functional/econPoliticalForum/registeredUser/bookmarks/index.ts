import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumBookmark } from "../../../../structures/IEconPoliticalForumBookmark";
import { IPageIEconPoliticalForumBookmark } from "../../../../structures/IPageIEconPoliticalForumBookmark";

/**
 * Create a bookmark for the authenticated user.
 *
 * Creates a new bookmark linking the authenticated registered user to an
 * existing post.
 *
 * Purpose and overview: This operation persists a record in the
 * econ_political_forum_bookmarks table. Relevant model fields: id,
 * registereduser_id, post_id, created_at, updated_at, deleted_at. The API
 * accepts the target post identifier in the request body; the server derives
 * registereduser_id from the authenticated session and does not trust a
 * client-supplied owner id.
 *
 * Security and permissions: Only authenticated users with the registeredUser
 * role may call this endpoint. The server must verify the caller is not banned
 * or suspended and must validate that the target post
 * (econ_political_forum_posts) exists and is visible to the caller.
 * Unauthenticated requests must receive 401.
 *
 * Validation and expected behavior: Request must include a valid postId (UUID).
 * Responses: 201 Created with the created bookmark record on success; 400 for
 * invalid input; 404 if target post not found or inaccessible; 409 Conflict if
 * a non-restorable duplicate exists; 429 when rate limits apply. Implementers
 * SHOULD consider idempotency handling to avoid duplicate creations from
 * retries.
 *
 * @param props.connection
 * @param props.body Bookmark creation payload. The server uses the
 *   authenticated user as the bookmark owner; clients must supply the target
 *   post id only.
 * @path /econPoliticalForum/registeredUser/bookmarks
 * @accessor api.functional.econPoliticalForum.registeredUser.bookmarks.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Bookmark creation payload. The server uses the authenticated user as
     * the bookmark owner; clients must supply the target post id only.
     */
    body: IEconPoliticalForumBookmark.ICreate;
  };
  export type Body = IEconPoliticalForumBookmark.ICreate;
  export type Response = IEconPoliticalForumBookmark;

  export const METADATA = {
    method: "POST",
    path: "/econPoliticalForum/registeredUser/bookmarks",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econPoliticalForum/registeredUser/bookmarks";
  export const random = (): IEconPoliticalForumBookmark =>
    typia.random<IEconPoliticalForumBookmark>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated list of the user's bookmarks
 * (econ_political_forum_bookmarks).
 *
 * Retrieve a paginated, filterable list of bookmark summaries for the
 * requesting registered user.
 *
 * Purpose and overview: This operation allows an authenticated registered user
 * to search and list their saved bookmarks. It queries the
 * `econ_political_forum_bookmarks` table and returns summary items suitable for
 * list displays. Only fields present on the bookmark model are used by the
 * service logic. The response is a paginated summary view optimized for feeds
 * and bookmark management.
 *
 * Security and permissions: Access requires an authenticated account with the
 * registeredUser role. The endpoint returns only bookmarks that belong to the
 * requesting user (registereduser_id). The server must verify ownership and
 * deny access to other users' bookmarks. Records subject to legal holds must be
 * preserved by backend retention logic and not purged while under hold.
 *
 * Filtering, pagination, and sorting: The request body supports cursor or
 * page/limit pagination (client may pass page/limit or cursor), filters by
 * post_id or thread_id, created_at date ranges, includeDeleted (boolean), and
 * sort options (created_at desc by default). The server must enforce default
 * page size and maximum page size limits and must sanitize and validate all
 * filters.
 *
 * Business rules and error handling: Only bookmark records owned by the
 * requester will be returned. If the user has no bookmarks, an empty paginated
 * data set is returned. Validation errors return 400 with structured error
 * details. Unauthenticated requests return 401. Rate limits apply to this
 * endpoint to prevent abuse.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination parameters for bookmark
 *   listing (page/cursor, pageSize, filters: postId, threadId, createdFrom,
 *   createdTo, includeDeleted, sort).
 * @path /econPoliticalForum/registeredUser/bookmarks
 * @accessor api.functional.econPoliticalForum.registeredUser.bookmarks.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filter, and pagination parameters for bookmark listing
     * (page/cursor, pageSize, filters: postId, threadId, createdFrom,
     * createdTo, includeDeleted, sort).
     */
    body: IEconPoliticalForumBookmark.IRequest;
  };
  export type Body = IEconPoliticalForumBookmark.IRequest;
  export type Response = IPageIEconPoliticalForumBookmark.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/econPoliticalForum/registeredUser/bookmarks",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econPoliticalForum/registeredUser/bookmarks";
  export const random = (): IPageIEconPoliticalForumBookmark.ISummary =>
    typia.random<IPageIEconPoliticalForumBookmark.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single bookmark by id from econ_political_forum_bookmarks.
 *
 * Get detailed information for a single bookmark.
 *
 * Purpose and overview: Returns the full bookmark record representing a saved
 * post for the authenticated user. The underlying Prisma table is
 * `econ_political_forum_bookmarks`; the operation returns fields defined on
 * that model and does not invent additional properties.
 *
 * Security and permissions: Access requires an authenticated registeredUser.
 * The operation must verify that the bookmark's registereduser_id matches the
 * requesting user's id. If the bookmark does not belong to the requester,
 * return 403 Forbidden. If the bookmark cannot be found (no active record with
 * that id or it is soft-deleted and not visible per requester's permissions),
 * return 404 Not Found.
 *
 * Soft-delete and legal hold behavior: The model includes deleted_at; by
 * default the endpoint returns only active (deleted_at is null) bookmark
 * records. If privileged visibility is requested, server must verify the
 * caller's role and audit the access. Legal holds preventing deletion must be
 * enforced by backend retention logic and not bypassed by this endpoint.
 *
 * Validation and error handling: The path parameter bookmarkId must be a UUID.
 * Invalid format returns 400. Unauthenticated requests return 401. Unauthorized
 * access returns 403. Internal errors return 500 with a structured envelope.
 *
 * @param props.connection
 * @param props.bookmarkId Unique identifier (UUID) of the target bookmark
 * @path /econPoliticalForum/registeredUser/bookmarks/:bookmarkId
 * @accessor api.functional.econPoliticalForum.registeredUser.bookmarks.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the target bookmark */
    bookmarkId: string & tags.Format<"uuid">;
  };
  export type Response = IEconPoliticalForumBookmark;

  export const METADATA = {
    method: "GET",
    path: "/econPoliticalForum/registeredUser/bookmarks/:bookmarkId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econPoliticalForum/registeredUser/bookmarks/${encodeURIComponent(props.bookmarkId ?? "null")}`;
  export const random = (): IEconPoliticalForumBookmark =>
    typia.random<IEconPoliticalForumBookmark>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("bookmarkId")(() => typia.assert(props.bookmarkId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove (soft-delete) a bookmark owned by the caller.
 *
 * Marks the specified bookmark as deleted by setting deleted_at to the current
 * timestamp so it is hidden from normal listings while preserving an archived
 * copy for audit and potential restore.
 *
 * Purpose and overview: Operates on econ_political_forum_bookmarks (id,
 * registereduser_id, post_id, created_at, updated_at, deleted_at). The server
 * MUST verify the requesting registeredUser is the owner of the bookmark. If
 * the caller is not the owner, respond 403 Forbidden. If the bookmark is not
 * found or already deleted, respond 404.
 *
 * Security and user permissions: Only authenticated registeredUser callers may
 * remove their own bookmarks via this endpoint. Administrators must use
 * admin-scoped APIs for global removals. If a legal hold applies to the related
 * content, deletion must be blocked until the hold is cleared.
 *
 * Validation and expected behavior: Path parameter bookmarkId must be a UUID.
 * On successful soft-delete return 204 No Content. Errors: 400 for invalid id
 * format, 401 for unauthenticated, 403 for ownership failure, 404 if not
 * found/already deleted, 429 for rate limits, 500 for server errors.
 *
 * @param props.connection
 * @param props.bookmarkId Unique identifier of the bookmark to remove (UUID)
 * @path /econPoliticalForum/registeredUser/bookmarks/:bookmarkId
 * @accessor api.functional.econPoliticalForum.registeredUser.bookmarks.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the bookmark to remove (UUID) */
    bookmarkId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/econPoliticalForum/registeredUser/bookmarks/:bookmarkId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econPoliticalForum/registeredUser/bookmarks/${encodeURIComponent(props.bookmarkId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("bookmarkId")(() => typia.assert(props.bookmarkId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
