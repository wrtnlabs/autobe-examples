import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumNotificationPreferences } from "../../../../../structures/IEconPoliticalForumNotificationPreferences";

/**
 * Get a user's notification preferences (owner or admin).
 *
 * Purpose and overview:
 *
 * Return the notification settings for the specified user based on
 * econ_political_forum_notification_preferences. The response includes
 * channel-level toggles (in_app, email, push) and an optional
 * preferences_payload that contains per-type overrides. The payload is a
 * serialized JSON string; the implementation must validate and sanitize payload
 * contents and must not allow secrets (for example, webhook tokens) to be
 * stored in preferences_payload.
 *
 * Security and permissions:
 *
 * This endpoint requires authentication. The caller MUST be either the same
 * registered user (owner) or an administrator. If the caller is an
 * administrator, the service MUST create an immutable audit log entry recording
 * admin id, timestamp, target user id, and reason for access. Owners may view
 * and update their own preferences; administrators may view for support/audit
 * purposes only.
 *
 * Relationship to database entity:
 *
 * Operates on econ_political_forum_notification_preferences. Implementation
 * should query by registereduser_id matching the path userId and return the
 * mapped DTO IEconPoliticalForumNotificationPreferences. If the record is
 * soft-deleted (deleted_at not null), behavior should follow product policy
 * (recommended: return default preferences rather than 404) and be consistently
 * implemented.
 *
 * Validation and business rules:
 *
 * - Path parameter userId must be a UUID and must reference an existing
 *   registered user.
 * - Authorization: only the user themself or an administrator may retrieve this
 *   resource.
 * - Preferences_payload must be validated and must not contain secrets or tokens.
 * - Administrator reads MUST be recorded in an audit log (admin id, timestamp,
 *   target user id, and reason).
 *
 * Related operations:
 *
 * - PUT /econPoliticalForum/registeredUser/users/{userId}/notificationPreferences
 *   to update preferences (requires ownership or admin privileges per policy)
 * - GET /econPoliticalForum/users/{userId} to retrieve public profile summary
 *
 * Error handling:
 *
 * - 400: invalid UUID format
 * - 401: authentication required
 * - 403: caller not authorized to access these preferences
 * - 404: user not found (or preferences not found if product policy dictates)
 * - 429: rate limit exceeded
 * - 500: server error
 *
 * @param props.connection
 * @param props.userId Unique identifier (UUID) of the target registered user
 *   whose preferences are requested
 * @path /econPoliticalForum/registeredUser/users/:userId/notificationPreferences
 * @accessor api.functional.econPoliticalForum.registeredUser.users.notificationPreferences.atNotificationPreferences
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atNotificationPreferences(
  connection: IConnection,
  props: atNotificationPreferences.Props,
): Promise<atNotificationPreferences.Response> {
  return true === connection.simulate
    ? atNotificationPreferences.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atNotificationPreferences.METADATA,
          path: atNotificationPreferences.path(props),
          status: null,
        },
      );
}
export namespace atNotificationPreferences {
  export type Props = {
    /**
     * Unique identifier (UUID) of the target registered user whose
     * preferences are requested
     */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = IEconPoliticalForumNotificationPreferences;

  export const METADATA = {
    method: "GET",
    path: "/econPoliticalForum/registeredUser/users/:userId/notificationPreferences",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econPoliticalForum/registeredUser/users/${encodeURIComponent(props.userId ?? "null")}/notificationPreferences`;
  export const random = (): IEconPoliticalForumNotificationPreferences =>
    typia.random<IEconPoliticalForumNotificationPreferences>();
  export const simulate = (
    connection: IConnection,
    props: atNotificationPreferences.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atNotificationPreferences.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a registered user's notification preferences (in-app/email/push).
 *
 * Purpose and overview: This operation updates a registered user's notification
 * delivery preferences stored in the
 * econ_political_forum_notification_preferences table. Typical fields: in_app,
 * email, push, and an optional preferences_payload (JSON string) for per-type
 * overrides.
 *
 * Security and permissions: Only the owning registered user or an administrator
 * may perform this operation. Implementations MUST verify the authenticated
 * caller matches the path parameter userId or that the caller holds
 * administrator privileges. Under no circumstances should a user be allowed to
 * update another user's preferences unless they have administrator
 * authorization. All successful updates MUST generate an immutable audit entry
 * (system-generated) recording acting principal, action_type (e.g.,
 * 'update_notification_preferences'), target registereduser_id, and a brief
 * details payload.
 *
 * Behavior and business rules:
 *
 * - The endpoint supports upsert semantics if product policy allows
 *   create-on-update; otherwise the service SHOULD return 404 when no
 *   preferences row exists.
 * - Preferences_payload, when present, MUST be valid JSON and conform to the
 *   server-side preferences schema; implementations MUST enforce a maximum
 *   payload size and reject invalid payloads with 400.
 * - The endpoint MUST NOT allow modification of soft-delete fields; deleted
 *   preferences rows require administrative workflows.
 *
 * Validation and errors:
 *
 * - 400: malformed payload or invalid preference values
 * - 401: unauthenticated
 * - 403: authenticated but not owner and not administrator
 * - 404: userId not found (or preferences row not found if upsert is not allowed)
 * - 429: rate-limited updates
 *
 * @param props.connection
 * @param props.userId UUID of the registered user whose preferences will be
 *   updated (maps to
 *   econ_political_forum_notification_preferences.registereduser_id)
 * @param props.body Notification preference update payload. Fields correspond
 *   to econ_political_forum_notification_preferences columns (in_app, email,
 *   push, preferences_payload).
 * @path /econPoliticalForum/registeredUser/users/:userId/notificationPreferences
 * @accessor api.functional.econPoliticalForum.registeredUser.users.notificationPreferences.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * UUID of the registered user whose preferences will be updated (maps
     * to econ_political_forum_notification_preferences.registereduser_id)
     */
    userId: string & tags.Format<"uuid">;

    /**
     * Notification preference update payload. Fields correspond to
     * econ_political_forum_notification_preferences columns (in_app, email,
     * push, preferences_payload).
     */
    body: IEconPoliticalForumNotificationPreferences.IUpdate;
  };
  export type Body = IEconPoliticalForumNotificationPreferences.IUpdate;
  export type Response = IEconPoliticalForumNotificationPreferences;

  export const METADATA = {
    method: "PUT",
    path: "/econPoliticalForum/registeredUser/users/:userId/notificationPreferences",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econPoliticalForum/registeredUser/users/${encodeURIComponent(props.userId ?? "null")}/notificationPreferences`;
  export const random = (): IEconPoliticalForumNotificationPreferences =>
    typia.random<IEconPoliticalForumNotificationPreferences>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
