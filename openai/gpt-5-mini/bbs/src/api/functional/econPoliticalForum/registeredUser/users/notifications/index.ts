import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumNotification } from "../../../../../structures/IEconPoliticalForumNotification";
import { IPageIEconPoliticalForumNotification } from "../../../../../structures/IPageIEconPoliticalForumNotification";

/**
 * Search and list a user's notifications (paginated).
 *
 * List and search notifications for a given user.
 *
 * Purpose and overview: This operation provides a flexible search and
 * pagination interface for a user's notifications stored in
 * econ_political_forum_notifications. Clients may filter by read status,
 * notification type (mention, reply, moderation, system), date ranges
 * (created_at between), and related entity ids (related_thread_id,
 * related_post_id). Results are returned in a paginated container optimized for
 * UI lists.
 *
 * Security and permissions: Only the authenticated user identified by {userId}
 * or an administrator can retrieve this list. Implementations MUST enforce that
 * a registered user may only request their own notifications unless the caller
 * holds administrative privileges. The operation must respect per-user
 * notification preferences when computing delivery flags (for example, hide
 * items the user has opted out of via notification preferences if requested by
 * client).
 *
 * Relationship to DB entity: Maps to econ_political_forum_notifications. Key
 * columns used for filtering and projection: registereduser_id, type, is_read,
 * created_at, delivered_at, related_thread_id, related_post_id,
 * related_moderation_case_id, and payload. Returned summaries should include
 * id, type, title, body excerpt, is_read, created_at, and related ids for
 * client linking.
 *
 * Filtering, pagination, and sort rules:
 *
 * - Pagination supports cursor or page/limit patterns in the request payload.
 *   Default page size = 20; maximum page size = 100.
 * - Supported filters: is_read (boolean), type (string), since (ISO 8601), until
 *   (ISO 8601), related_thread_id, related_post_id.
 * - Sorting options: newest, oldest, unread_first, relevance (when full-text
 *   query provided in payload).
 *
 * Validation and behavior:
 *
 * - UserId path parameter must be a valid UUID.
 * - If a registeredUser requests notifications for a different userId, server
 *   returns 403 Forbidden.
 * - Empty result sets return an empty page container with appropriate pagination
 *   metadata.
 *
 * Related operations: Update single notification (PUT
 * /notifications/{notificationId}) for marking-as-read; real-time delivery
 * channels (SSE/WebSocket) are recommended to reduce polling.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the registered user whose
 *   notifications are requested
 * @param props.body Search and pagination parameters for notifications
 *   (filters, sort, pagination cursor or page/limit). Default page size=20,
 *   max=100.
 * @path /econPoliticalForum/registeredUser/users/:userId/notifications
 * @accessor api.functional.econPoliticalForum.registeredUser.users.notifications.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the registered user whose notifications are
     * requested
     */
    userId: string & tags.Format<"uuid">;

    /**
     * Search and pagination parameters for notifications (filters, sort,
     * pagination cursor or page/limit). Default page size=20, max=100.
     */
    body: IEconPoliticalForumNotification.IRequest;
  };
  export type Body = IEconPoliticalForumNotification.IRequest;
  export type Response = IPageIEconPoliticalForumNotification.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/econPoliticalForum/registeredUser/users/:userId/notifications",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econPoliticalForum/registeredUser/users/${encodeURIComponent(props.userId ?? "null")}/notifications`;
  export const random = (): IPageIEconPoliticalForumNotification.ISummary =>
    typia.random<IPageIEconPoliticalForumNotification.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a user's notification read state (mark read/unread) — owner only.
 *
 * Purpose and overview:
 *
 * This operation updates the read state (is_read) of a single notification for
 * its registered recipient. It maps to the econ_political_forum_notifications
 * model and permits only the user-managed field `is_read` to be changed. The
 * API enforces strict validation and rejects unknown keys to avoid accidental
 * mutation of system-managed notification data.
 *
 * Security considerations and user permissions:
 *
 * Only the authenticated recipient (the registered user whose id equals the
 * path parameter userId) may perform this operation on their own notifications.
 * The implementation MUST verify that the notification's registereduser_id
 * equals the authenticated caller's id and return 403 when ownership is not
 * established. Administrators have separate admin endpoints for broader
 * notification management. Any attempt to modify system-managed fields
 * (payload, delivered_at) via this endpoint must be rejected. If the
 * notification is connected to a moderation or legal case that is subject to a
 * legal hold (econ_political_forum_legal_holds.is_active), implementations
 * should apply policy to prevent prohibited modifications where applicable.
 *
 * Relationship to underlying database entities:
 *
 * This operation updates the `is_read` Boolean on
 * econ_political_forum_notifications. If the notification refers to a
 * moderation case (related_moderation_case_id) and the update should be
 * recorded for audit, the server MUST append an audit entry to
 * econ_political_forum_audit_logs capturing the acting user id, action_type
 * ('notification.mark_read'/'notification.mark_unread'), target identifiers,
 * and timestamp.
 *
 * Validation rules and business logic:
 *
 * - Path parameters (userId and notificationId) MUST be valid UUIDs.
 * - The notification must exist and belong to the provided userId; otherwise
 *   return 404.
 * - The request body MUST contain only the allowed property `is_read` (boolean).
 *   Unknown keys MUST be rejected with 400.
 * - The server MUST sanitize any minimal textual inputs (if any) and must not
 *   accept payload edits via this endpoint.
 *
 * Related operations:
 *
 * - GET /users/{userId}/notifications — list a user's notifications (paginated)
 * - PATCH /users/{userId}/notifications/{notificationId}/read-all — bulk
 *   mark-read (user convenience)
 * - GET /notifications/{id} — admin inspection of a single notification
 *   (admin-only)
 *
 * Expected behavior and error handling:
 *
 * - Success: returns 200 with the updated notification object
 *   (IEconPoliticalForumNotification) reflecting the committed `is_read`
 *   change.
 * - 400: validation errors (unknown fields or invalid value types).
 * - 401: unauthenticated caller.
 * - 403: caller is not the notification owner or action conflicts with legal-hold
 *   policy.
 * - 404: notification not found or does not belong to the user.
 * - 429: rate-limited (excessive updates).
 * - 500: unexpected server error.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the notification recipient
 *   (registered user)
 * @param props.notificationId Unique identifier of the notification to update
 * @param props.body Update payload for notification. Allowed field: is_read
 *   (boolean). Unknown fields are rejected. DTO reference:
 *   IEconPoliticalForumNotification.IUpdate
 * @path /econPoliticalForum/registeredUser/users/:userId/notifications/:notificationId
 * @accessor api.functional.econPoliticalForum.registeredUser.users.notifications.putByUseridAndNotificationid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putByUseridAndNotificationid(
  connection: IConnection,
  props: putByUseridAndNotificationid.Props,
): Promise<putByUseridAndNotificationid.Response> {
  return true === connection.simulate
    ? putByUseridAndNotificationid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByUseridAndNotificationid.METADATA,
          path: putByUseridAndNotificationid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putByUseridAndNotificationid {
  export type Props = {
    /** Unique identifier of the notification recipient (registered user) */
    userId: string & tags.Format<"uuid">;

    /** Unique identifier of the notification to update */
    notificationId: string & tags.Format<"uuid">;

    /**
     * Update payload for notification. Allowed field: is_read (boolean).
     * Unknown fields are rejected. DTO reference:
     * IEconPoliticalForumNotification.IUpdate
     */
    body: IEconPoliticalForumNotification.IUpdate;
  };
  export type Body = IEconPoliticalForumNotification.IUpdate;
  export type Response = IEconPoliticalForumNotification;

  export const METADATA = {
    method: "PUT",
    path: "/econPoliticalForum/registeredUser/users/:userId/notifications/:notificationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econPoliticalForum/registeredUser/users/${encodeURIComponent(props.userId ?? "null")}/notifications/${encodeURIComponent(props.notificationId ?? "null")}`;
  export const random = (): IEconPoliticalForumNotification =>
    typia.random<IEconPoliticalForumNotification>();
  export const simulate = (
    connection: IConnection,
    props: putByUseridAndNotificationid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByUseridAndNotificationid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("notificationId")(() => typia.assert(props.notificationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a user's notification (mark read/unread, mute, or update delivery
 * state).
 *
 * Purpose and overview:
 *
 * This operation updates a single notification record for a registered user. It
 * maps to the econ_political_forum_notifications model and updates fields that
 * are intended to be user-managed (for example: is_read, is_read timestamps,
 * muted_until, and lightweight payload adjustments). It preserves auditability
 * by creating corresponding audit log entries in
 * econ_political_forum_audit_logs when updates are related to moderation or
 * legal workflows.
 *
 * Security considerations and user permissions:
 *
 * Only the authenticated recipient (the registered user whose id equals the
 * path parameter userId) may perform this operation on their own notifications.
 * Administrators and moderators have separate admin endpoints for broader
 * notification management. The implementation MUST verify that the
 * notification's registereduser_id equals the authenticated caller's id and
 * return 403 when ownership is not established. Any attempt to perform
 * destructive operations on notifications that are subject to an active legal
 * hold (econ_political_forum_legal_holds.is_active) must be rejected with a 403
 * and an explanatory reason code.
 *
 * Relationship to underlying database entities:
 *
 * This operation updates fields defined on econ_political_forum_notifications
 * such as is_read (boolean), delivered_at (DateTime), payload (JSON string),
 * is_read flag, and related_* references (related_thread_id, related_post_id,
 * related_moderation_case_id). When an update concerns a moderation-related
 * notification (for example changes to related_moderation_case_id or payload
 * referencing a moderation case), the system MUST append an audit entry in
 * econ_political_forum_audit_logs documenting the actor, action_type, target
 * identifiers, and the rationale. The operation should consult
 * econ_political_forum_notification_preferences to respect user delivery
 * preferences when interpreting delivered_at or delivery changes.
 *
 * Validation rules and business logic:
 *
 * - Both path parameters (userId and notificationId) must be valid UUIDs.
 * - The notification must exist and belong to the provided userId; otherwise
 *   return 404.
 * - Only allowed fields in the IEconPoliticalForumNotification.IUpdate DTO are
 *   accepted; the server must reject unknown keys with 400.
 * - If a legal hold exists for the related thread/post/case the operation
 *   attempts to modify, the update must be rejected with 403 and a legal_hold
 *   reason.
 * - All incoming payload data must be sanitized for HTML/Markdown and must not
 *   contain executable scripts or unauthorized references.
 *
 * Related operations:
 *
 * - GET /users/{userId}/notifications — list a user's notifications (paginated)
 * - PATCH /users/{userId}/notifications/{notificationId}/read-all — bulk
 *   mark-read (user convenience)
 * - GET /notifications/{id} — admin inspection of a single notification
 *   (admin-only)
 *
 * Expected behavior and error handling:
 *
 * - Success: returns 200 with the updated notification object
 *   (IEconPoliticalForumNotification) reflecting committed changes.
 * - 400: validation errors (unknown fields, invalid date formats, or sanitized
 *   payload removed required data).
 * - 401: unauthenticated caller.
 * - 403: caller is not the notification owner or action conflicts with an active
 *   legal hold.
 * - 404: notification not found or does not belong to the user.
 * - 429: rate-limited (excessive updates).
 * - 500: unexpected server error.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the notification recipient
 *   (registered user)
 * @param props.notificationId Unique identifier of the notification to update
 * @param props.body Fields to update on the notification. Allowed updates
 *   include: is_read (boolean), delivered_at (ISO 8601 timestamp), muted_until
 *   (ISO 8601 timestamp or null), and limited payload changes (serialized JSON
 *   string) subject to server-side sanitization. Unknown fields are rejected.
 *   DTO reference: IEconPoliticalForumNotification.IUpdate
 * @path /econPoliticalForum/registeredUser/users/:userId/notifications/:notificationId
 * @accessor api.functional.econPoliticalForum.registeredUser.users.notifications.patchByUseridAndNotificationid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patchByUseridAndNotificationid(
  connection: IConnection,
  props: patchByUseridAndNotificationid.Props,
): Promise<patchByUseridAndNotificationid.Response> {
  return true === connection.simulate
    ? patchByUseridAndNotificationid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patchByUseridAndNotificationid.METADATA,
          path: patchByUseridAndNotificationid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace patchByUseridAndNotificationid {
  export type Props = {
    /** Unique identifier of the notification recipient (registered user) */
    userId: string & tags.Format<"uuid">;

    /** Unique identifier of the notification to update */
    notificationId: string & tags.Format<"uuid">;

    /**
     * Fields to update on the notification. Allowed updates include:
     * is_read (boolean), delivered_at (ISO 8601 timestamp), muted_until
     * (ISO 8601 timestamp or null), and limited payload changes (serialized
     * JSON string) subject to server-side sanitization. Unknown fields are
     * rejected. DTO reference: IEconPoliticalForumNotification.IUpdate
     */
    body: IEconPoliticalForumNotification.IUpdate;
  };
  export type Body = IEconPoliticalForumNotification.IUpdate;
  export type Response = IEconPoliticalForumNotification;

  export const METADATA = {
    method: "PATCH",
    path: "/econPoliticalForum/registeredUser/users/:userId/notifications/:notificationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econPoliticalForum/registeredUser/users/${encodeURIComponent(props.userId ?? "null")}/notifications/${encodeURIComponent(props.notificationId ?? "null")}`;
  export const random = (): IEconPoliticalForumNotification =>
    typia.random<IEconPoliticalForumNotification>();
  export const simulate = (
    connection: IConnection,
    props: patchByUseridAndNotificationid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patchByUseridAndNotificationid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("notificationId")(() => typia.assert(props.notificationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
