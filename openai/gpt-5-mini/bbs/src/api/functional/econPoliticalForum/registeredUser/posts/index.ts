import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumPost } from "../../../../structures/IEconPoliticalForumPost";
export * as revisions from "./revisions/index";
export * as votes from "./votes/index";

/**
 * Create a new post (thread root or reply).
 *
 * Create a new post that becomes part of an existing thread. Clients supply
 * thread_id and content; parent_id is optional for replies. The server sets
 * author_id from the authenticated session — clients MUST NOT provide or
 * override author_id. Service layer responsibilities: validate content length
 * (10–50,000 characters), enforce reply nesting depth (default up to 3 levels),
 * verify posting privileges (e.g., email_verified when
 * category.requires_verification is true), and check rate limits. If the
 * thread's category is moderated, the created post may initially be in a
 * pending state or hidden until moderator approval; this behavior is controlled
 * by moderator workflows and the post record's visibility flags (e.g.,
 * is_hidden) and NOT by client-supplied fields.
 *
 * Side effects: enqueue notifications for followers/mentions, add search
 * indexing job, create audit log entry in econ_political_forum_audit_logs. The
 * API returns the created post record (fields per econ_political_forum_posts)
 * but MUST not expose moderator-only internal notes.
 *
 * @param props.connection
 * @param props.body Post creation payload: required thread_id (UUID) and
 *   content (string). parent_id optional for replies. NOTE: Do NOT provide
 *   author_id; server will assign author_id from authenticated user. See
 *   IEconPoliticalForumPost.ICreate for field definitions.
 * @path /econPoliticalForum/registeredUser/posts
 * @accessor api.functional.econPoliticalForum.registeredUser.posts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Post creation payload: required thread_id (UUID) and content
     * (string). parent_id optional for replies. NOTE: Do NOT provide
     * author_id; server will assign author_id from authenticated user. See
     * IEconPoliticalForumPost.ICreate for field definitions.
     */
    body: IEconPoliticalForumPost.ICreate;
  };
  export type Body = IEconPoliticalForumPost.ICreate;
  export type Response = IEconPoliticalForumPost;

  export const METADATA = {
    method: "POST",
    path: "/econPoliticalForum/registeredUser/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econPoliticalForum/registeredUser/posts";
  export const random = (): IEconPoliticalForumPost =>
    typia.random<IEconPoliticalForumPost>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing post by postId.
 *
 * Update the content of an existing post. Only the original author may edit via
 * this endpoint and only within the allowed edit window (default 24 hours). The
 * server must verify the post exists and is not soft-deleted (deleted_at is
 * null). If an active moderation case or legal hold applies, the edit MUST be
 * denied. On successful edit the system sets is_edited=true and edited_at to
 * the update timestamp and appends a revision to
 * econ_political_forum_post_revisions for auditability. Moderation and
 * administrator edits must be performed via dedicated moderation endpoints and
 * recorded in moderation logs.
 *
 * Errors: 400 validation errors, 401 unauthenticated, 403 ownership or outside
 * edit window or author banned, 404 not found, 423 locked for moderation/hold,
 * 429 rate limit, 500 server error.
 *
 * @param props.connection
 * @param props.postId Unique identifier (UUID) of the target post to update
 * @param props.body Post update payload. See IEconPoliticalForumPost.IUpdate
 *   for fields. Note: author_id is not accepted; server derives editor id from
 *   authenticated principal. Authors may update content only; moderation
 *   adjustments use moderation APIs.
 * @path /econPoliticalForum/registeredUser/posts/:postId
 * @accessor api.functional.econPoliticalForum.registeredUser.posts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the target post to update */
    postId: string & tags.Format<"uuid">;

    /**
     * Post update payload. See IEconPoliticalForumPost.IUpdate for fields.
     * Note: author_id is not accepted; server derives editor id from
     * authenticated principal. Authors may update content only; moderation
     * adjustments use moderation APIs.
     */
    body: IEconPoliticalForumPost.IUpdate;
  };
  export type Body = IEconPoliticalForumPost.IUpdate;
  export type Response = IEconPoliticalForumPost;

  export const METADATA = {
    method: "PUT",
    path: "/econPoliticalForum/registeredUser/posts/:postId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econPoliticalForum/registeredUser/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): IEconPoliticalForumPost =>
    typia.random<IEconPoliticalForumPost>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove (soft-delete) a post by ID (econ_political_forum_posts).
 *
 * Purpose and overview: This endpoint performs a soft-delete of a post by
 * setting econ_political_forum_posts.deleted_at. It preserves the row for audit
 * and legal retention while removing the post from normal public listings.
 * Revision history (econ_political_forum_post_revisions), votes, and bookmarks
 * remain archived and accessible to authorized actors.
 *
 * Security considerations and user permissions: Primary caller: registeredUser
 * (post owner). Moderators and administrators may also perform deletions where
 * policy allows; the service layer must authorize and record elevated actions.
 * Before performing deletion the service MUST verify no active legal hold
 * applies (econ_political_forum_legal_holds.is_active) and must create an
 * immutable audit record in econ_political_forum_audit_logs. If a moderator or
 * admin performs the action, a moderation log
 * (econ_political_forum_moderation_logs) must be created with action_type,
 * reason_code, and rationale.
 *
 * Validation and business logic:
 *
 * - Path parameter postId must be a valid UUID corresponding to an existing post.
 * - If the caller is the author, allow soft-delete within policy constraints;
 *   moderators/admins may override subject to logging and escalation rules.
 * - If the post has child replies, public view replaces the top-level content
 *   with a standardized placeholder and preserves replies unless moderators
 *   take additional actions.
 * - If an active legal hold exists, return 423 Locked and record the attempt in
 *   audit logs.
 *
 * Responses:
 *
 * - 204 No Content — successful soft-delete
 * - 404 Not Found — post not found
 * - 403 Forbidden — caller unauthorized to delete
 * - 423 Locked — active legal hold prevents deletion (include case id if
 *   available)
 *
 * @param props.connection
 * @param props.postId Target post's ID (econ_political_forum_posts.id)
 * @path /econPoliticalForum/registeredUser/posts/:postId
 * @accessor api.functional.econPoliticalForum.registeredUser.posts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target post's ID (econ_political_forum_posts.id) */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/econPoliticalForum/registeredUser/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econPoliticalForum/registeredUser/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
