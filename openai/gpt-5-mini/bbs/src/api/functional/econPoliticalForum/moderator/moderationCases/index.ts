import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumModerationCase } from "../../../../structures/IEconPoliticalForumModerationCase";
import { IPageIEconPoliticalForumModerationCase } from "../../../../structures/IPageIEconPoliticalForumModerationCase";

/**
 * Create a moderation case (econ_political_forum_moderation_cases).
 *
 * Create a new moderation case to group related reports, coordinate
 * investigations, and track escalation/state.
 *
 * Security and permissions: Only authenticated callers with the moderator role
 * may invoke this endpoint. Implementations must verify caller role and perform
 * referential integrity checks for provided UUID references. The operation
 * returns 201 and the created moderation case on success.
 *
 * Validation and errors:
 *
 * - 400: validation failure (invalid UUID, missing required fields)
 * - 401: unauthenticated
 * - 403: insufficient role
 * - 409: case_number conflict
 * - 500: server error
 *
 * @param props.connection
 * @param props.body Moderation case creation payload
 * @path /econPoliticalForum/moderator/moderationCases
 * @accessor api.functional.econPoliticalForum.moderator.moderationCases.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Moderation case creation payload */
    body: IEconPoliticalForumModerationCase.ICreate;
  };
  export type Body = IEconPoliticalForumModerationCase.ICreate;
  export type Response = IEconPoliticalForumModerationCase;

  export const METADATA = {
    method: "POST",
    path: "/econPoliticalForum/moderator/moderationCases",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econPoliticalForum/moderator/moderationCases";
  export const random = (): IEconPoliticalForumModerationCase =>
    typia.random<IEconPoliticalForumModerationCase>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of moderation cases (moderator
 * scope).
 *
 * Retrieve a filtered, searchable and paginated list of moderation cases for
 * triage and administrative review.
 *
 * Purpose and overview: Provides moderators with the ability to list and search
 * moderation cases. Results are paginated and returned as concise summaries for
 * list views.
 *
 * Security considerations: Only authenticated users with the moderator role may
 * call this endpoint. The service MUST enforce role-based access and may scope
 * results to cases assigned to the caller unless the caller has administrator
 * privileges. Field-level redaction is required for PII when the caller lacks
 * admin privileges. All access MUST be audited.
 *
 * Business rules:
 *
 * - Default filter excludes records where deleted_at IS NOT NULL.
 * - Pagination: default page size 20, max 100. Either page+limit or opaque cursor
 *   is acceptable; the IRequest DTO should document the chosen approach.
 * - Filters: status, priority, assigned_moderator_id, owner_admin_id, legal_hold,
 *   created_at/updated_at/closed_at ranges.
 * - Sorting: created_at, priority, case_number.
 *
 * Errors: 400/401/403/429/500.
 *
 * @param props.connection
 * @param props.body Search, filter, sort and pagination parameters for
 *   moderation case listing (define cursor or page+limit format in the IRequest
 *   DTO)
 * @path /econPoliticalForum/moderator/moderationCases
 * @accessor api.functional.econPoliticalForum.moderator.moderationCases.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filter, sort and pagination parameters for moderation case
     * listing (define cursor or page+limit format in the IRequest DTO)
     */
    body: IEconPoliticalForumModerationCase.IRequest;
  };
  export type Body = IEconPoliticalForumModerationCase.IRequest;
  export type Response = IPageIEconPoliticalForumModerationCase.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/econPoliticalForum/moderator/moderationCases",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econPoliticalForum/moderator/moderationCases";
  export const random = (): IPageIEconPoliticalForumModerationCase.ISummary =>
    typia.random<IPageIEconPoliticalForumModerationCase.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single moderation case by ID (moderator scope).
 *
 * Get detailed moderation case information for review, escalation, and appeals.
 * The response includes case fields from econ_political_forum_moderation_cases
 * and id references to related reports and moderation logs. Access is
 * restricted to moderators and administrators; administrators may see
 * additional evidence fields per legal_hold rules. All accesses should be
 * recorded in audit logs.
 *
 * Behavior and validation:
 *
 * - Path parameter caseId must be a valid UUID.
 * - If deleted_at is set and caller is not an administrator requesting archived
 *   records, return 404.
 *
 * Errors: 400/401/403/404/500.
 *
 * @param props.connection
 * @param props.caseId Unique identifier (UUID) of the moderation case to
 *   retrieve
 * @path /econPoliticalForum/moderator/moderationCases/:caseId
 * @accessor api.functional.econPoliticalForum.moderator.moderationCases.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the moderation case to retrieve */
    caseId: string & tags.Format<"uuid">;
  };
  export type Response = IEconPoliticalForumModerationCase;

  export const METADATA = {
    method: "GET",
    path: "/econPoliticalForum/moderator/moderationCases/:caseId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econPoliticalForum/moderator/moderationCases/${encodeURIComponent(props.caseId ?? "null")}`;
  export const random = (): IEconPoliticalForumModerationCase =>
    typia.random<IEconPoliticalForumModerationCase>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("caseId")(() => typia.assert(props.caseId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a moderation case (econ_political_forum_moderation_cases).
 *
 * Modify an existing moderation case to reflect investigation progress,
 * assignment changes, escalation decisions, or closure.
 *
 * Security and permissions: Only authenticated callers with the moderator role
 * may update cases. Implementations must verify authorization (e.g., assigned
 * moderators or administrators) before applying updates. Updates must create
 * audit entries in econ_political_forum_audit_logs and moderation logs where
 * applicable.
 *
 * Validation and errors:
 *
 * - 400: validation failure (invalid UUID, invalid references)
 * - 401: unauthenticated
 * - 403: not authorized
 * - 404: case not found
 * - 409: case_number conflict
 * - 500: server error
 *
 * @param props.connection
 * @param props.caseId Target moderation case's ID
 * @param props.body Moderation case update payload (partial or full)
 * @path /econPoliticalForum/moderator/moderationCases/:caseId
 * @accessor api.functional.econPoliticalForum.moderator.moderationCases.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target moderation case's ID */
    caseId: string & tags.Format<"uuid">;

    /** Moderation case update payload (partial or full) */
    body: IEconPoliticalForumModerationCase.IUpdate;
  };
  export type Body = IEconPoliticalForumModerationCase.IUpdate;
  export type Response = IEconPoliticalForumModerationCase;

  export const METADATA = {
    method: "PUT",
    path: "/econPoliticalForum/moderator/moderationCases/:caseId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econPoliticalForum/moderator/moderationCases/${encodeURIComponent(props.caseId ?? "null")}`;
  export const random = (): IEconPoliticalForumModerationCase =>
    typia.random<IEconPoliticalForumModerationCase>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("caseId")(() => typia.assert(props.caseId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
