import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumThread } from "../../../../structures/IEconPoliticalForumThread";
import { IPageIEconPoliticalForumThread } from "../../../../structures/IPageIEconPoliticalForumThread";

/**
 * List and search threads for a specific tag with pagination and filters.
 *
 * Purpose and overview: Returns a filtered and paginated list of thread
 * summaries associated with the specified tag id. The operation sources
 * associations from econ_political_forum_thread_tags and thread metadata from
 * econ_political_forum_threads. Use this endpoint for tag landing pages and
 * tag-based discovery.
 *
 * Visibility and permissions: This is a public read operation by default (no
 * authentication required). Implementations MUST exclude soft-deleted threads
 * (threads.deleted_at IS NOT NULL) and soft-deleted tags (tags.deleted_at IS
 * NOT NULL) for unauthenticated or regular callers. Moderators and
 * administrators may request includeDeleted to view soft-deleted items for
 * triage.
 *
 * Filtering, sorting and performance notes:
 *
 * - Input filters: full-text query on thread.title, threads.category_id,
 *   threads.author_id, threads.created_at range, and membership via
 *   econ_political_forum_thread_tags.tag_id.
 * - Sorting by aggregated metrics such as "mostVoted" or "mostReplied" requires
 *   pre-computed aggregates (materialized views) or runtime aggregation across
 *   votes/posts; implementers should document expected performance and may
 *   restrict or disable these sorts if aggregates are not available.
 * - Default page size: 20. Maximum allowed page size: 100.
 *
 * Errors and edge cases:
 *
 * - 400: invalid filters (bad date format, unsupported sort value)
 * - 404: tag not found or tag soft-deleted (unless caller is admin/moderator and
 *   explicitly requested inclusion)
 * - 429: rate limiting on search endpoints
 *
 * @param props.connection
 * @param props.tagId UUID of the tag to filter threads by (maps to
 *   econ_political_forum_tags.id)
 * @param props.body Search, filtering and pagination parameters (full-text
 *   query, categoryId, authorId, created_from, created_to, sort, cursor or
 *   page/limit) scoped to the specified tag.
 * @path /econPoliticalForum/tags/:tagId/threads
 * @accessor api.functional.econPoliticalForum.tags.threads.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * UUID of the tag to filter threads by (maps to
     * econ_political_forum_tags.id)
     */
    tagId: string & tags.Format<"uuid">;

    /**
     * Search, filtering and pagination parameters (full-text query,
     * categoryId, authorId, created_from, created_to, sort, cursor or
     * page/limit) scoped to the specified tag.
     */
    body: IEconPoliticalForumThread.IRequest;
  };
  export type Body = IEconPoliticalForumThread.IRequest;
  export type Response = IPageIEconPoliticalForumThread.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/econPoliticalForum/tags/:tagId/threads",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econPoliticalForum/tags/${encodeURIComponent(props.tagId ?? "null")}/threads`;
  export const random = (): IPageIEconPoliticalForumThread.ISummary =>
    typia.random<IPageIEconPoliticalForumThread.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("tagId")(() => typia.assert(props.tagId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
