import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumTag } from "../../../structures/IEconPoliticalForumTag";
import { IPageIEconPoliticalForumTag } from "../../../structures/IPageIEconPoliticalForumTag";
export * as threads from "./threads/index";

/**
 * Search and retrieve paginated tag summaries (EconPoliticalForum.tags).
 *
 * Purpose and overview:
 *
 * Provide a flexible search and pagination endpoint to list tags used for
 * discovery and filtering across threads. The underlying Prisma entity is
 * econ_political_forum_tags. This operation accepts complex request criteria
 * (full-text search on name/description, slug filter, pagination cursor or
 * page/limit, sort options) and returns a paginated container of tag
 * summaries.
 *
 * Security and visibility:
 *
 * Tags are public by default. Soft-deleted tags (deleted_at set) are excluded
 * from results unless the requester is authorized to view deletions (for
 * example, administrators or moderation tools). Administrative filter options
 * (includeDeleted = true) MUST be restricted to privileged roles in server-side
 * logic.
 *
 * Relationship to DB entity and validation rules:
 *
 * Fields on the econ_political_forum_tags table relevant to this operation
 * include id (UUID), name (unique string), slug (unique string), description
 * (nullable), created_at, updated_at, and deleted_at (nullable soft-delete
 * timestamp). Search should use trigram/Gin indexes for partial matches;
 * request input must be validated for length and characters. Pagination should
 * use either page/limit (defaults applied) or a cursor token; page size
 * defaults to 20 with a configured maximum (for example, 100) enforced
 * server-side.
 *
 * Related operations and error handling:
 *
 * - Use PATCH /econPoliticalForum/tags for advanced search and listing; simple
 *   GET/list endpoints may be provided for lightweight clients.
 * - Error responses include 400 for invalid request shapes (e.g., page < 1, limit
 *   exceeding maximum), 429 for rate-limit breaches, and 500 for server
 *   errors.
 *
 * Expected behavior and edge cases:
 *
 * - When no filters are provided, return the first page of active tags ordered by
 *   name ascending.
 * - When a search term is provided, perform case-insensitive partial matching
 *   against name and description.
 * - When includeDeleted=true is requested by an authorized caller, include tags
 *   with deleted_at set and mark them accordingly in the summary response.
 *
 * @param props.connection
 * @param props.body Search, filter and pagination parameters for tag listing
 * @path /econPoliticalForum/tags
 * @accessor api.functional.econPoliticalForum.tags.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filter and pagination parameters for tag listing */
    body: IEconPoliticalForumTag.IRequest;
  };
  export type Body = IEconPoliticalForumTag.IRequest;
  export type Response = IPageIEconPoliticalForumTag.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/econPoliticalForum/tags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econPoliticalForum/tags";
  export const random = (): IPageIEconPoliticalForumTag.ISummary =>
    typia.random<IPageIEconPoliticalForumTag.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a tag by its ID from the econ_political_forum_tags table.
 *
 * Purpose and overview: Retrieve detailed information for a single tag
 * identified by its UUID. Tags are the normalized discovery labels used across
 * threads and are stored in the econ_political_forum_tags table in the Prisma
 * schema. This operation returns the canonical tag fields used by clients for
 * display and routing.
 *
 * Security considerations and permissions: This endpoint is public (no
 * authentication required) for read-only access. Internal moderation and
 * administrative UIs should use elevated API endpoints when they need to view
 * soft-deleted records. Public consumers should not see tags where deleted_at
 * is set.
 *
 * Relationship to database entity: This operation directly reads the
 * econ_political_forum_tags model (fields: id, name, slug, description,
 * created_at, updated_at, deleted_at). The response type IEconPoliticalForumTag
 * must reflect those fields. The service MUST treat deleted_at as the
 * soft-delete marker and SHOULD return 404 for records with deleted_at !=
 * null.
 *
 * Validation rules and business logic:
 *
 * - The path parameter tagId must be a UUID.
 * - If no tag exists with the given id, the API returns 404.
 * - If the tag exists but deleted_at is set, the API treats it as not found for
 *   public calls and returns 404 (moderator/admin endpoints may surface
 *   soft-deleted tags).
 *
 * Related operations and notes:
 *
 * - Related create: POST /econPoliticalForum/administrator/tags (creates a new
 *   tag record).
 * - Related list/search: GET /econPoliticalForum/tags (paginated listing/search
 *   endpoint) for tag discovery (not implemented here).
 *
 * Expected behavior and error handling:
 *
 * - 200: returns IEconPoliticalForumTag payload for active tags.
 * - 400: invalid UUID format for tagId.
 * - 404: tag not found or soft-deleted.
 * - 500: unexpected server error.
 *
 * @param props.connection
 * @param props.tagId Unique identifier (UUID) of the target tag
 * @path /econPoliticalForum/tags/:tagId
 * @accessor api.functional.econPoliticalForum.tags.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the target tag */
    tagId: string & tags.Format<"uuid">;
  };
  export type Response = IEconPoliticalForumTag;

  export const METADATA = {
    method: "GET",
    path: "/econPoliticalForum/tags/:tagId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econPoliticalForum/tags/${encodeURIComponent(props.tagId ?? "null")}`;
  export const random = (): IEconPoliticalForumTag =>
    typia.random<IEconPoliticalForumTag>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("tagId")(() => typia.assert(props.tagId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
