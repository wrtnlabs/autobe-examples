import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumTag } from "../../../../structures/IEconPoliticalForumTag";

/**
 * Create a new tag in econ_political_forum_tags (administrator only).
 *
 * Purpose and overview: Create a new normalized tag that can be attached to
 * threads for discovery and search. Tags are stored in the
 * econ_political_forum_tags table in the Prisma schema. The created resource
 * corresponds to IEconPoliticalForumTag and will contain the canonical fields
 * (id, name, slug, description, created_at, updated_at, deleted_at).
 *
 * Security considerations and permissions: Only platform administrators should
 * be allowed to create new tags to maintain taxonomy quality and avoid
 * fragmentation. The endpoint requires administrative authorization. Creation
 * attempts by non-administrators must return 403. Successful creations SHOULD
 * be recorded in audit/moderation logs for traceability.
 *
 * Relationship to database entity: This operation inserts a row into
 * econ_political_forum_tags. The application MUST enforce uniqueness of slug
 * and name at the business layer (the Prisma schema already defines unique
 * constraints on slug and name). The API should validate the slug is
 * URL-friendly before inserting.
 *
 * Validation rules and business logic:
 *
 * - Request must include required create fields (name and slug) as defined by
 *   IEconPoliticalForumTag.ICreate.
 * - The server must reject requests that violate unique constraints for slug or
 *   name with a 409 Conflict response indicating which field conflicts.
 * - Clients MUST NOT supply server-managed fields: id, created_at, updated_at, or
 *   deleted_at. These are set by the server.
 * - If provided, description is optional.
 * - If the operation is successful the server returns the newly created
 *   IEconPoliticalForumTag with 201 status and a Location header pointing to
 *   /econPoliticalForum/tags/{tagId}.
 *
 * Related operations and notes:
 *
 * - GET /econPoliticalForum/tags/{tagId} can be used to retrieve the created tag.
 * - Tag creation is an administrative action; consider logging the creation in
 *   moderation/audit logs for traceability.
 *
 * Expected behavior and error handling:
 *
 * - 201: returns created IEconPoliticalForumTag payload and Location header.
 * - 400: missing required fields or invalid slug format.
 * - 401: authentication required.
 * - 403: caller lacks administrator privileges.
 * - 409: uniqueness conflict on name or slug.
 * - 500: unexpected server error.
 *
 * @param props.connection
 * @param props.body Tag creation payload (IEconPoliticalForumTag.ICreate).
 *   Clients MUST provide name and slug; do not supply id or timestamp fields.
 * @path /econPoliticalForum/administrator/tags
 * @accessor api.functional.econPoliticalForum.administrator.tags.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Tag creation payload (IEconPoliticalForumTag.ICreate). Clients MUST
     * provide name and slug; do not supply id or timestamp fields.
     */
    body: IEconPoliticalForumTag.ICreate;
  };
  export type Body = IEconPoliticalForumTag.ICreate;
  export type Response = IEconPoliticalForumTag;

  export const METADATA = {
    method: "POST",
    path: "/econPoliticalForum/administrator/tags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econPoliticalForum/administrator/tags";
  export const random = (): IEconPoliticalForumTag =>
    typia.random<IEconPoliticalForumTag>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a tag in econ_political_forum_tags (IEconPoliticalForumTag).
 *
 * Purpose and overview: Update the mutable attributes of an existing tag
 * record. This operation allows administrators to correct or improve tag
 * metadata (name, slug, description) used for discovery and categorization
 * across threads.
 *
 * Security and permissions: Only users with the administrator role are
 * authorized to call this endpoint. All successful updates should be recorded
 * in system audit/moderation logs to preserve change history and support
 * rollback or review.
 *
 * Relationship to Prisma schema entity: This operation maps to the Prisma model
 * `econ_political_forum_tags`. Per the model comments, tags are a normalized
 * catalog used for discovery and search; the model enforces unique `name` and
 * `slug` constraints and supports soft-delete via `deleted_at`. Implementations
 * must respect those constraints and avoid modifying the tag `id` or removing
 * historical references.
 *
 * Validation rules and business logic:
 *
 * - `name` and `slug` must be unique among active (non-deleted) tags; uniqueness
 *   violations return 409 Conflict.
 * - `slug` should be a URL-safe, lower-case identifier (the application should
 *   normalize and validate input).
 * - Reasonable length limits should be enforced (for example: name 1-100 chars,
 *   slug 1-100 chars, description up to 2000 chars) and exceeded limits should
 *   return 400 with field details.
 * - If the target tag has `deleted_at` set (soft-deleted), the operation SHALL
 *   return 404 Not Found or 409 Conflict per policy (implementation choice)
 *   describing that the resource is not available for update.
 *
 * Related operations: Use GET /tags/{tagId} (not part of this generation) to
 * retrieve current tag details before updating; use POST /tags to create new
 * tags. When name/slug changes affect search indices, ensure any search index
 * materialized views or full-text indexes are refreshed.
 *
 * Expected behavior and error handling:
 *
 * - Success: returns the updated IEconPoliticalForumTag representation.
 * - 400: validation error (field-specific message describing constraint
 *   violation).
 * - 401/403: unauthorized or insufficient privileges.
 * - 404: tag not found or soft-deleted (if implementation chooses 404 for deleted
 *   resources).
 * - 409: unique constraint conflict (slug or name already used by an active tag).
 * - 500: internal server error for unexpected failures.
 *
 * @param props.connection
 * @param props.tagId Unique identifier (UUID) of the target tag
 *   (econ_political_forum_tags.id)
 * @param props.body Fields to update on the tag. Use
 *   IEconPoliticalForumTag.IUpdate structure. Immutable fields such as id are
 *   not accepted. Provide only fields you want to change.
 * @path /econPoliticalForum/administrator/tags/:tagId
 * @accessor api.functional.econPoliticalForum.administrator.tags.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier (UUID) of the target tag
     * (econ_political_forum_tags.id)
     */
    tagId: string & tags.Format<"uuid">;

    /**
     * Fields to update on the tag. Use IEconPoliticalForumTag.IUpdate
     * structure. Immutable fields such as id are not accepted. Provide only
     * fields you want to change.
     */
    body: IEconPoliticalForumTag.IUpdate;
  };
  export type Body = IEconPoliticalForumTag.IUpdate;
  export type Response = IEconPoliticalForumTag;

  export const METADATA = {
    method: "PUT",
    path: "/econPoliticalForum/administrator/tags/:tagId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econPoliticalForum/administrator/tags/${encodeURIComponent(props.tagId ?? "null")}`;
  export const random = (): IEconPoliticalForumTag =>
    typia.random<IEconPoliticalForumTag>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("tagId")(() => typia.assert(props.tagId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a tag from econ_political_forum_tags (set deleted_at).
 *
 * Purpose and overview: This operation marks a tag as deleted by setting its
 * `deleted_at` timestamp. Soft deletion preserves the record for audit,
 * moderation, and legal compliance while removing the tag from normal active
 * lists and preventing new assignments.
 *
 * Security and permissions: Only users with the administrator role are
 * permitted to perform this operation. Soft-deletes and the rationale for
 * deletion should be recorded in the audit logs so actions are traceable.
 *
 * Relationship to Prisma schema entity: This operation targets the Prisma model
 * `econ_political_forum_tags` which includes a `deleted_at` DateTime? column.
 * Because the schema supports soft-delete, this operation implements soft
 * deletion (not hard removal). Implementers should also consider handling the
 * related join table `econ_political_forum_thread_tags` per product policy
 * (either soft-delete the joins or leave them and exclude deleted tags from
 * active lookups).
 *
 * Validation rules and business logic:
 *
 * - If the tag does not exist or is already soft-deleted, return 404 Not Found.
 * - If a legal hold or retention constraint prevents deletion of the tag or
 *   related evidence, return 409 Conflict with details.
 * - The operation should be idempotent: repeated deletes on an already-deleted
 *   resource may return 204 No Content or 404 depending on chosen semantics;
 *   document chosen behavior in API docs.
 *
 * Related operations: Use GET /tags to list active tags, and POST /tags to
 * create a replacement tag if needed. Administrators may restore soft-deleted
 * tags using a restore endpoint (not included here) which would clear
 * deleted_at.
 *
 * Expected behavior and error handling:
 *
 * - Success: 204 No Content (or 200 with short confirmation payload) indicating
 *   tag is soft-deleted.
 * - 401/403: unauthorized or insufficient privileges.
 * - 404: tag not found or already deleted.
 * - 409: conflict due to legal hold or retention requirement.
 * - 500: internal server error for unexpected failures.
 *
 * @param props.connection
 * @param props.tagId Unique identifier (UUID) of the tag to delete
 *   (econ_political_forum_tags.id)
 * @path /econPoliticalForum/administrator/tags/:tagId
 * @accessor api.functional.econPoliticalForum.administrator.tags.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier (UUID) of the tag to delete
     * (econ_political_forum_tags.id)
     */
    tagId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/econPoliticalForum/administrator/tags/:tagId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econPoliticalForum/administrator/tags/${encodeURIComponent(props.tagId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("tagId")(() => typia.assert(props.tagId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
