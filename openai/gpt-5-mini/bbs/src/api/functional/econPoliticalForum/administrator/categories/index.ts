import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumCategory } from "../../../../structures/IEconPoliticalForumCategory";

/**
 * Create a new forum category (econ_political_forum_categories).
 *
 * Create a new discussion category.
 *
 * Purpose and overview: This operation creates a new row in the
 * `econ_political_forum_categories` table. Categories control thread grouping,
 * UI navigation ordering, moderation gating (via `is_moderated`), and whether
 * posting requires verified accounts (`requires_verification`). The API accepts
 * a JSON body describing the category and returns the stored category record
 * including system-generated fields (id, created_at, updated_at).
 *
 * Security and permissions: Only platform administrators (role:
 * "administrator") may create categories. The service enforces authorization
 * before validating the request body. Clients without the administrator role
 * receive 401 (unauthenticated) or 403 (forbidden) responses as applicable.
 *
 * Relationship to database entities: This operation maps to the Prisma model
 * `econ_political_forum_categories`. Threads reference categories by
 * `category_id`; creating or updating categories affects thread routing and
 * moderator assignment. Be mindful that `slug` has a unique constraint and
 * `code` is unique when present; the API returns a 409 Conflict when those
 * uniqueness constraints are violated.
 *
 * Validation rules and business logic: The API requires `name` and `slug`. The
 * `is_moderated` and `requires_verification` flags are boolean and must be
 * present so callers are explicit about the category behavior. `order` is an
 * integer hint for UI ordering. The server will generate `id`, `created_at`,
 * and `updated_at`. If the requester provides values for system-managed fields,
 * they will be ignored.
 *
 * Expected behavior and error handling: On success, returns the created
 * category record. Validation failures return 400 with field details. Unique
 * constraint violations on `slug` or `code` return 409 Conflict. Unauthorized
 * requests return 401 or 403. Unexpected server errors return 500.
 *
 * @param props.connection
 * @param props.body Category creation payload. Fields: name (required), slug
 *   (required, unique), code (optional, unique when present), description
 *   (optional), is_moderated (required boolean), requires_verification
 *   (required boolean), order (required integer display hint). Server generates
 *   id, created_at, updated_at.
 * @path /econPoliticalForum/administrator/categories
 * @accessor api.functional.econPoliticalForum.administrator.categories.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Category creation payload. Fields: name (required), slug (required,
     * unique), code (optional, unique when present), description
     * (optional), is_moderated (required boolean), requires_verification
     * (required boolean), order (required integer display hint). Server
     * generates id, created_at, updated_at.
     */
    body: IEconPoliticalForumCategory.ICreate;
  };
  export type Body = IEconPoliticalForumCategory.ICreate;
  export type Response = IEconPoliticalForumCategory;

  export const METADATA = {
    method: "POST",
    path: "/econPoliticalForum/administrator/categories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econPoliticalForum/administrator/categories";
  export const random = (): IEconPoliticalForumCategory =>
    typia.random<IEconPoliticalForumCategory>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update category metadata (econ_political_forum_categories).
 *
 * Update an existing discussion category by id.
 *
 * Purpose and overview: This operation allows authorized administrators to
 * change category metadata that affects thread classification and moderation
 * routing. Typical updates include name, slug, description, is_moderated,
 * requires_verification, and order. The API modifies the existing
 * `econ_political_forum_categories` row identified by `categoryId` and returns
 * the updated record.
 *
 * Security and permissions: Only administrators (role: "administrator") are
 * allowed to perform this update. The service requires authentication and role
 * validation prior to applying updates. Unauthorized requests result in 401 or
 * 403 responses.
 *
 * Relationship to underlying DB entity: This operation updates the Prisma model
 * `econ_political_forum_categories`. Threads that reference this category are
 * indirectly affected by changes in `is_moderated` or `requires_verification`
 * flags. The API must respect the model-level uniqueness constraints on `slug`
 * and `code` and should surface 409 Conflict when collisions occur.
 *
 * Validation rules and business logic: The `categoryId` path parameter must be
 * a valid UUID and refer to an existing category; otherwise the API returns 404
 * Not Found. The request body contains only mutable fields; system-managed
 * fields (id, created_at, updated_at, deleted_at) are not accepted for
 * modification. The API should validate that required business fields remain
 * present if the client submits partial payloads that would violate invariants
 * (for example, ensure `name` and `slug` are not cleared).
 *
 * Related operations: Create (POST /categories), list (GET /categories), and
 * retrieve (GET /categories/{categoryId}). Consider informing moderators when
 * `is_moderated` changes for an active category.
 *
 * Expected behavior and error handling: On success, returns the updated
 * category. If `categoryId` does not exist, returns 404. Validation errors
 * return 400 with field-level messages. Unique constraint violations return
 * 409. Server errors return 500.
 *
 * @param props.connection
 * @param props.categoryId Target category's UUID
 *   (econ_political_forum_categories.id)
 * @param props.body Category update payload. Accepts mutable fields: name,
 *   slug, code, description, is_moderated, requires_verification, order. Fields
 *   omitted are left unchanged.
 * @path /econPoliticalForum/administrator/categories/:categoryId
 * @accessor api.functional.econPoliticalForum.administrator.categories.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target category's UUID (econ_political_forum_categories.id) */
    categoryId: string & tags.Format<"uuid">;

    /**
     * Category update payload. Accepts mutable fields: name, slug, code,
     * description, is_moderated, requires_verification, order. Fields
     * omitted are left unchanged.
     */
    body: IEconPoliticalForumCategory.IUpdate;
  };
  export type Body = IEconPoliticalForumCategory.IUpdate;
  export type Response = IEconPoliticalForumCategory;

  export const METADATA = {
    method: "PUT",
    path: "/econPoliticalForum/administrator/categories/:categoryId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econPoliticalForum/administrator/categories/${encodeURIComponent(props.categoryId ?? "null")}`;
  export const random = (): IEconPoliticalForumCategory =>
    typia.random<IEconPoliticalForumCategory>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("categoryId")(() => typia.assert(props.categoryId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a category (econ_political_forum_categories).
 *
 * Purpose and overview: This operation marks the specified category record as
 * deleted by setting `deleted_at` on econ_political_forum_categories. This
 * removes the category from normal public navigation and listings while
 * preserving it for audit and moderator review.
 *
 * Security considerations and permissions: Only administrators
 * (authorizationRole: "administrator") may perform this operation. The API
 * layer MUST enforce RBAC, require authentication, and record an immutable
 * audit log entry that includes the acting administrator id, category id, and
 * reason. Non-admin callers must receive 403 Forbidden.
 *
 * Relationship to DB and business rules: The Prisma model
 * econ_political_forum_categories includes `deleted_at` (DateTime?). This
 * endpoint sets that timestamp. Before setting `deleted_at`, the service MUST
 * check for active legal holds (econ_political_forum_legal_holds) or open
 * moderation cases (econ_political_forum_moderation_cases) that reference the
 * category and block deletion; if blocked, return 403 with case ids. If the
 * category is already soft-deleted, return 409 Conflict. The endpoint does NOT
 * implicitly cascade changes to threads — thread handling must be explicit in
 * service logic and recorded in audit history.
 *
 * Validation and error handling:
 *
 * - 400 Bad Request: invalid UUID for categoryId
 * - 401 Unauthorized: missing/invalid authentication
 * - 403 Forbidden: caller not admin or category under legal/moderation hold
 * - 404 Not Found: no category with provided id
 * - 409 Conflict: category already soft-deleted
 * - 500 Internal Server Error: unexpected error
 *
 * Operational notes: Prefer returning 204 No Content on successful soft-delete.
 * Ensure audit and moderation logs record the action for compliance.
 *
 * @param props.connection
 * @param props.categoryId UUID of the target category
 *   (econ_political_forum_categories.id).
 * @path /econPoliticalForum/administrator/categories/:categoryId
 * @accessor api.functional.econPoliticalForum.administrator.categories.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the target category (econ_political_forum_categories.id). */
    categoryId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/econPoliticalForum/administrator/categories/:categoryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econPoliticalForum/administrator/categories/${encodeURIComponent(props.categoryId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("categoryId")(() => typia.assert(props.categoryId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
