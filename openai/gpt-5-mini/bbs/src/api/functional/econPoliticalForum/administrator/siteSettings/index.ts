import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumSiteSetting } from "../../../../structures/IEconPoliticalForumSiteSetting";

/**
 * Update site setting(s) (econ_political_forum_site_settings).
 *
 * Purpose and overview: This endpoint updates site-level configuration rows
 * stored in econ_political_forum_site_settings. Typical fields that may be
 * updated include `value`, `description`, `environment`, and `is_public`. The
 * operation must validate key uniqueness per environment and produce audit logs
 * recording changed keys and prior values (stored securely for compliance).
 *
 * Security considerations and permissions: Only administrators are permitted to
 * update site settings. Changes must be logged in the audit trail including
 * acting administrator id, changed key(s), previous values (stored in secure
 * audit), and timestamp. The service layer should prevent exposing sensitive
 * configuration values to non-admin callers even if `is_public` is toggled
 * incorrectly.
 *
 * Relationship to DB and business rules: Prisma model
 * econ_political_forum_site_settings includes: id, key (unique), value,
 * description, environment, is_public, created_at, updated_at, deleted_at. When
 * updating `key`, the service must ensure uniqueness within the specified
 * environment and must return 409 Conflict if the rename would create a
 * duplicate. If the update affects runtime behavior, the response should
 * include metadata advising whether a cache refresh or restart is recommended.
 *
 * Validation rules and business logic:
 *
 * - `key` follows a namespace.form pattern; if renaming, validate pattern and
 *   uniqueness.
 * - `is_public` changes should be audited and limited to administrators.
 * - If an update would violate uniqueness for (key, environment), return 409
 *   Conflict.
 * - Rate limit configuration changes to avoid accidental mass updates
 *   (service-layer policy).
 *
 * Recommended usage patterns:
 *
 * - Prefer updating a single setting by id. If bulk updates are supported by the
 *   implementation, the API must document transactional semantics and failure
 *   handling.
 *
 * Error handling:
 *
 * - 400 Bad Request: invalid payload or key format
 * - 401 Unauthorized: missing/invalid authentication
 * - 403 Forbidden: caller lacks administrator role
 * - 404 Not Found: referenced setting id does not exist
 * - 409 Conflict: attempted update causes duplicate key in same environment
 * - 429 Too Many Requests: rate limiting for high-frequency config edits
 * - 500 Internal Server Error: unexpected server error
 *
 * @param props.connection
 * @param props.body Partial update object for one or more site settings. Each
 *   item should reference the target `id` (UUID) and include only fields to be
 *   changed (for example: `value`, `description`, `environment`, `is_public`).
 * @path /econPoliticalForum/administrator/siteSettings
 * @accessor api.functional.econPoliticalForum.administrator.siteSettings.put
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function put(
  connection: IConnection,
  props: put.Props,
): Promise<put.Response> {
  return true === connection.simulate
    ? put.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...put.METADATA,
          path: put.path(),
          status: null,
        },
        props.body,
      );
}
export namespace put {
  export type Props = {
    /**
     * Partial update object for one or more site settings. Each item should
     * reference the target `id` (UUID) and include only fields to be
     * changed (for example: `value`, `description`, `environment`,
     * `is_public`).
     */
    body: IEconPoliticalForumSiteSetting.IUpdate;
  };
  export type Body = IEconPoliticalForumSiteSetting.IUpdate;
  export type Response = IEconPoliticalForumSiteSetting;

  export const METADATA = {
    method: "PUT",
    path: "/econPoliticalForum/administrator/siteSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econPoliticalForum/administrator/siteSettings";
  export const random = (): IEconPoliticalForumSiteSetting =>
    typia.random<IEconPoliticalForumSiteSetting>();
  export const simulate = (
    connection: IConnection,
    props: put.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: put.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update site setting(s) (econ_political_forum_site_settings).
 *
 * Purpose and overview: This endpoint updates site-level configuration rows
 * stored in `econ_political_forum_site_settings`. The model stores `key`,
 * `value`, optional `environment`, `description`, and `is_public` flags. The
 * operation supports partial updates so callers can change one or multiple
 * fields of an existing setting.
 *
 * Security considerations and user permissions: Only administrator roles may
 * update site settings. Changes are high-impact and must be logged in the audit
 * trail with the acting administrator id, changed keys, previous values, and
 * timestamp. For safety, implementations should enforce validation rules and
 * optionally require additional confirmation for keys that control moderation
 * thresholds or feature flags.
 *
 * Relationship to underlying database entities: The Prisma model
 * `econ_political_forum_site_settings` includes `id`, `key` (unique), `value`,
 * `description`, `environment`, `is_public`, `created_at`, `updated_at`, and
 * `deleted_at`. Business logic should ensure `key` uniqueness is not violated
 * when renaming keys and should validate that `environment` (if provided)
 * matches allowed environment identifiers used by the deployment.
 *
 * Validation rules and business logic:
 *
 * - The `key` follows a convention like `namespace.form` (for example
 *   `moderation.report_threshold`) â€” service-layer validation should verify the
 *   key pattern if renaming is supported.
 * - If the request attempts to update `key` to a value that already exists (same
 *   environment), the operation must return 409 Conflict.
 * - `is_public` controls whether non-admin clients may read the setting; changing
 *   this flag should be permitted only to administrators and must be audited.
 * - Changes that affect runtime behavior (for example enabling/disabling a
 *   feature) may require application cache/in-memory refresh; the API MUST
 *   return metadata indicating whether a restart or cache refresh is
 *   recommended.
 *
 * Related operations and expected behavior:
 *
 * - GET /siteSettings (not included here) should return settings filtered by
 *   `environment` and obey `is_public` for non-admin callers.
 * - A companion endpoint to create or delete keys may exist; this operation
 *   performs partial updates only.
 *
 * Error handling:
 *
 * - 400 Bad Request: invalid payload or key format.
 * - 401 Unauthorized: missing or invalid authentication.
 * - 403 Forbidden: caller lacks administrator role.
 * - 404 Not Found: referenced setting id does not exist.
 * - 409 Conflict: attempted update results in duplicate key for the same
 *   environment.
 * - 429 Too Many Requests: aggressive configuration changes limited by rate
 *   limiting policy.
 * - 500 Internal Server Error: unexpected server error.
 *
 * @param props.connection
 * @param props.body Partial update object for one or more site settings. Each
 *   item should reference the target `id` (UUID) and include only fields to be
 *   changed (for example: `value`, `description`, `environment`, `is_public`).
 * @path /econPoliticalForum/administrator/siteSettings
 * @accessor api.functional.econPoliticalForum.administrator.siteSettings.patch
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Partial update object for one or more site settings. Each item should
     * reference the target `id` (UUID) and include only fields to be
     * changed (for example: `value`, `description`, `environment`,
     * `is_public`).
     */
    body: IEconPoliticalForumSiteSetting.IUpdate;
  };
  export type Body = IEconPoliticalForumSiteSetting.IUpdate;
  export type Response = IEconPoliticalForumSiteSetting;

  export const METADATA = {
    method: "PATCH",
    path: "/econPoliticalForum/administrator/siteSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econPoliticalForum/administrator/siteSettings";
  export const random = (): IEconPoliticalForumSiteSetting =>
    typia.random<IEconPoliticalForumSiteSetting>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single site setting (IEconPoliticalForumSiteSetting) by ID from
 * econ_political_forum_site_settings.
 *
 * Retrieve a single site setting record by its unique identifier.
 *
 * Purpose and overview: This operation returns the canonical site configuration
 * entry stored in the econ_political_forum_site_settings table. The response
 * includes the configuration key, its current string value (when permitted), an
 * optional description, the environment scope (for example: 'production' or
 * 'staging'), a visibility flag (is_public), and timestamps for creation and
 * last update. This endpoint is intended for administrative inspection and
 * operational UIs.
 *
 * Security considerations and permissions: Access to the full site setting
 * record (including the raw 'value') is restricted to administrators. Server
 * MUST NOT return raw `value` to non-administrator callers. Any administrator
 * read of a setting classified as sensitive MUST be logged to
 * econ_political_forum_audit_logs with actor id, timestamp, request id, and
 * target id. Calling systems must avoid using this endpoint from public or
 * unauthenticated contexts.
 *
 * Relationship to database entity: This operation maps directly to the Prisma
 * model econ_political_forum_site_settings and returns fields: id, key, value
 * (subject to masking rules), description, environment, is_public, created_at,
 * updated_at, deleted_at.
 *
 * Validation rules and business logic: The path parameter siteSettingId must be
 * a UUID. If the record is soft-deleted (deleted_at not null), the operation
 * should return 404 unless the caller has an elevated audit role that is
 * allowed to view deleted entries. If the key is present but flagged is_public
 * = true, a separate public listing endpoint should be used for non-admin
 * consumers; this endpoint requires administrator role by default.
 *
 * Expected behavior and error handling: 200 returns the site setting object
 * (with `value` only for authorized admin callers). 400 for invalid UUID
 * format, 401/403 for unauthorized access, 404 if not found or not visible, 500
 * for server errors. All errors use the standard error envelope.
 *
 * @param props.connection
 * @param props.siteSettingId Unique identifier (UUID) of the target site
 *   setting
 * @path /econPoliticalForum/administrator/siteSettings/:siteSettingId
 * @accessor api.functional.econPoliticalForum.administrator.siteSettings.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the target site setting */
    siteSettingId: string & tags.Format<"uuid">;
  };
  export type Response = IEconPoliticalForumSiteSetting;

  export const METADATA = {
    method: "GET",
    path: "/econPoliticalForum/administrator/siteSettings/:siteSettingId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econPoliticalForum/administrator/siteSettings/${encodeURIComponent(props.siteSettingId ?? "null")}`;
  export const random = (): IEconPoliticalForumSiteSetting =>
    typia.random<IEconPoliticalForumSiteSetting>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("siteSettingId")(() => typia.assert(props.siteSettingId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
