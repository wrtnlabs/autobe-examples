import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumModerationCase } from "../../../../structures/IEconPoliticalForumModerationCase";
import { IPageIEconPoliticalForumModerationCase } from "../../../../structures/IPageIEconPoliticalForumModerationCase";

/**
 * Create a moderation case (econ_political_forum_moderation_cases).
 *
 * Create a new moderation case to group related reports, coordinate
 * investigations, and track escalation/state.
 *
 * Security and permissions: Only authenticated callers with the administrator
 * role may invoke this endpoint. Implementations must verify caller role and
 * perform referential integrity checks for provided UUID references. The
 * operation returns 201 and the created moderation case on success.
 *
 * Validation and errors:
 *
 * - 400: validation failure (invalid UUID, missing required fields)
 * - 401: unauthenticated
 * - 403: insufficient role
 * - 409: case_number conflict
 * - 500: server error
 *
 * @param props.connection
 * @param props.body Moderation case creation payload
 * @path /econPoliticalForum/administrator/moderationCases
 * @accessor api.functional.econPoliticalForum.administrator.moderationCases.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Moderation case creation payload */
    body: IEconPoliticalForumModerationCase.ICreate;
  };
  export type Body = IEconPoliticalForumModerationCase.ICreate;
  export type Response = IEconPoliticalForumModerationCase;

  export const METADATA = {
    method: "POST",
    path: "/econPoliticalForum/administrator/moderationCases",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econPoliticalForum/administrator/moderationCases";
  export const random = (): IEconPoliticalForumModerationCase =>
    typia.random<IEconPoliticalForumModerationCase>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of moderation cases
 * (administrator scope).
 *
 * Retrieve a filtered, searchable and paginated list of moderation cases for
 * triage, administrative review, and archived-case access.
 *
 * Purpose and overview: Provides administrators the ability to list and search
 * moderation cases, including archived cases when requested.
 *
 * Security considerations: Only authenticated users with administrator
 * privileges may call this endpoint. Administrators can request archived
 * records and may view additional evidence fields (subject to legal_hold
 * constraints). All accesses MUST be audited.
 *
 * Business rules:
 *
 * - Pagination: default page size 20, max 100. Define cursor or page+limit format
 *   in IRequest DTO.
 * - Filters and sorting same as moderator listing; administrators may request
 *   archived records via explicit parameter.
 *
 * Errors: 400/401/403/429/500.
 *
 * @param props.connection
 * @param props.body Search, filter, sort and pagination parameters for
 *   moderation case listing (define cursor or page+limit format in the IRequest
 *   DTO)
 * @path /econPoliticalForum/administrator/moderationCases
 * @accessor api.functional.econPoliticalForum.administrator.moderationCases.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filter, sort and pagination parameters for moderation case
     * listing (define cursor or page+limit format in the IRequest DTO)
     */
    body: IEconPoliticalForumModerationCase.IRequest;
  };
  export type Body = IEconPoliticalForumModerationCase.IRequest;
  export type Response = IPageIEconPoliticalForumModerationCase.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/econPoliticalForum/administrator/moderationCases",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econPoliticalForum/administrator/moderationCases";
  export const random = (): IPageIEconPoliticalForumModerationCase.ISummary =>
    typia.random<IPageIEconPoliticalForumModerationCase.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single moderation case by ID (administrator scope).
 *
 * Get detailed moderation case information for administrative review,
 * escalation, and appeals. The response includes case fields from
 * econ_political_forum_moderation_cases and id references to related reports
 * and moderation logs. Administrators may access archived records and evidence
 * fields per legal_hold rules. All accesses must be recorded in audit logs.
 *
 * Behavior and validation:
 *
 * - Path parameter caseId must be a valid UUID.
 * - If deleted_at is set and caller is administrator requesting archived records,
 *   the record may be returned; otherwise 404.
 *
 * Errors: 400/401/403/404/500.
 *
 * @param props.connection
 * @param props.caseId Unique identifier (UUID) of the moderation case to
 *   retrieve
 * @path /econPoliticalForum/administrator/moderationCases/:caseId
 * @accessor api.functional.econPoliticalForum.administrator.moderationCases.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the moderation case to retrieve */
    caseId: string & tags.Format<"uuid">;
  };
  export type Response = IEconPoliticalForumModerationCase;

  export const METADATA = {
    method: "GET",
    path: "/econPoliticalForum/administrator/moderationCases/:caseId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econPoliticalForum/administrator/moderationCases/${encodeURIComponent(props.caseId ?? "null")}`;
  export const random = (): IEconPoliticalForumModerationCase =>
    typia.random<IEconPoliticalForumModerationCase>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("caseId")(() => typia.assert(props.caseId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a moderation case (econ_political_forum_moderation_cases).
 *
 * Modify an existing moderation case to reflect investigation progress,
 * assignment changes, escalation decisions, or closure.
 *
 * Security and permissions: Only authenticated callers with the administrator
 * role may update cases. Implementations must verify authorization before
 * applying updates. Updates must create audit entries in
 * econ_political_forum_audit_logs and moderation logs where applicable.
 *
 * Validation and errors:
 *
 * - 400: validation failure (invalid UUID, invalid references)
 * - 401: unauthenticated
 * - 403: not authorized
 * - 404: case not found
 * - 409: case_number conflict
 * - 500: server error
 *
 * @param props.connection
 * @param props.caseId Target moderation case's ID
 * @param props.body Moderation case update payload (partial or full)
 * @path /econPoliticalForum/administrator/moderationCases/:caseId
 * @accessor api.functional.econPoliticalForum.administrator.moderationCases.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target moderation case's ID */
    caseId: string & tags.Format<"uuid">;

    /** Moderation case update payload (partial or full) */
    body: IEconPoliticalForumModerationCase.IUpdate;
  };
  export type Body = IEconPoliticalForumModerationCase.IUpdate;
  export type Response = IEconPoliticalForumModerationCase;

  export const METADATA = {
    method: "PUT",
    path: "/econPoliticalForum/administrator/moderationCases/:caseId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econPoliticalForum/administrator/moderationCases/${encodeURIComponent(props.caseId ?? "null")}`;
  export const random = (): IEconPoliticalForumModerationCase =>
    typia.random<IEconPoliticalForumModerationCase>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("caseId")(() => typia.assert(props.caseId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
