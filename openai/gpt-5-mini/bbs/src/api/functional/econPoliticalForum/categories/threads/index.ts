import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumThread } from "../../../../structures/IEconPoliticalForumThread";
import { IPageIEconPoliticalForumThread } from "../../../../structures/IPageIEconPoliticalForumThread";

/**
 * Search and retrieve a filtered, paginated list of threads inside a category
 * (econ_political_forum_threads).
 *
 * Purpose and overview: Retrieve a filtered, paginated list of discussion
 * threads that belong to the specified category. This endpoint is intended for
 * public browsing of category content and supports advanced filtering,
 * full-text title search, tag-based discovery, author filtering, status and
 * pinned filtering, and sorting. It is implemented against the
 * `econ_political_forum_threads` Prisma model which contains canonical thread
 * metadata.
 *
 * Security and permissions: This endpoint is public by default (no
 * authentication required) and returns only threads the caller is allowed to
 * see. Threads with `deleted_at` set are excluded from results. For categories
 * configured as moderated (`econ_political_forum_categories.is_moderated =
 * true`), threads whose `status` equals 'pending' should be excluded unless the
 * requester has moderator/admin privileges (this endpoint's default behavior
 * excludes 'pending' threads). Any moderator-only expansions must be gated
 * behind proper authentication and role checks.
 *
 * Relationship to the database and related entities: Records are drawn from
 * `econ_political_forum_threads` (fields used: category_id, author_id, title,
 * slug, status, pinned, created_at, updated_at, deleted_at). Tag-based
 * filtering uses the join table `econ_political_forum_thread_tags` and
 * `econ_political_forum_tags.slug` or id. The operation returns summary
 * representations optimized for listing; callers may request expanded details
 * via a separate thread detail endpoint.
 *
 * Validation rules and business logic:
 *
 * - The path parameter `categoryId` must be a UUID and correspond to an existing
 *   category (validate existence before executing the query).
 * - By default exclude threads with `deleted_at != null` and threads with `status
 *   = 'pending'` unless the caller is an authorized moderator/administrator.
 * - Search on title uses trigram / full-text indexing configured on the `title`
 *   column; results should be ranked by relevance when a query is provided.
 * - Pagination supports either cursor-based or page/limit patterns in the
 *   IEconPoliticalForumThread.IRequest DTO. Defaults: page=1, limit=20; maximum
 *   limit = 100.
 * - Sorting supports fields: relevance (when search provided), newest (created_at
 *   desc), oldest (created_at asc), updated (updated_at desc), pinned first.
 *
 * Related operations:
 *
 * - Use GET /econPoliticalForum/threads/{threadId} to fetch a single thread
 *   detail including posts.
 * - Use PATCH /econPoliticalForum/threads (search) for cross-category searches;
 *   this operation is scoped to a single category by path.
 *
 * Expected errors and handling:
 *
 * - 400 Bad Request for invalid UUIDs or malformed request body
 * - 401 Unauthorized when moderator-only expanded views are requested without
 *   authentication
 * - 403 Forbidden when the caller is authenticated but not permitted to view
 *   moderator-only threads
 * - 404 Not Found if the categoryId does not exist
 * - 429 Too Many Requests when rate limits are exceeded
 * - 500 Internal Server Error for unexpected failures (include correlation id in
 *   response)
 *
 * @param props.connection
 * @param props.categoryId UUID of the target category
 *   (econ_political_forum_categories.id)
 * @param props.body Search, filter and pagination parameters scoped to the
 *   target category
 * @path /econPoliticalForum/categories/:categoryId/threads
 * @accessor api.functional.econPoliticalForum.categories.threads.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** UUID of the target category (econ_political_forum_categories.id) */
    categoryId: string & tags.Format<"uuid">;

    /**
     * Search, filter and pagination parameters scoped to the target
     * category
     */
    body: IEconPoliticalForumThread.IRequest;
  };
  export type Body = IEconPoliticalForumThread.IRequest;
  export type Response = IPageIEconPoliticalForumThread.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/econPoliticalForum/categories/:categoryId/threads",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econPoliticalForum/categories/${encodeURIComponent(props.categoryId ?? "null")}/threads`;
  export const random = (): IPageIEconPoliticalForumThread.ISummary =>
    typia.random<IPageIEconPoliticalForumThread.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("categoryId")(() => typia.assert(props.categoryId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
