import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumModerator } from "../../../structures/IEconPoliticalForumModerator";
export * as password from "./password/index";

/**
 * Register (join) a new moderator-account-capable registered user record in
 * econ_political_forum_registereduser.
 *
 * Purpose and functionality: This endpoint allows a candidate moderator to
 * register a new platform account. It operates against the registered account
 * table econ_political_forum_registereduser and, where applicable, will enable
 * subsequent linking to the moderator table econ_political_forum_moderator. The
 * operation creates a new registered user record (fields referenced: username,
 * email, password_hash, display_name, created_at) and returns initial
 * authorization tokens.
 *
 * Implementation details and required fields: The request body requires
 * username and email and a password value that will be stored as password_hash
 * by the service. The implementation must validate uniqueness against
 * econ_political_forum_registereduser.username and
 * econ_political_forum_registereduser.email and must set email_verified to
 * false until verification completes. The response includes an authorization
 * payload following the IEconPoliticalForumModerator.IAuthorized pattern.
 *
 * Role-specific integration and business context: Although this operation
 * creates a registered user, moderator privileges are represented in
 * econ_political_forum_moderator (registereduser_id, is_active). The system may
 * either auto-create a moderator record (subject to business rules) or require
 * administrator linking. The description here references
 * econ_political_forum_moderator.registereduser_id and
 * econ_political_forum_moderator.is_active to clarify post-registration flows.
 *
 * Security considerations within schema constraints: Passwords must never be
 * returned; only password_hash is stored (in the database) and must be
 * generated server-side. Email verification should be enforced (email_verified
 * and verified_at fields on econ_political_forum_registereduser). The service
 * must observe failed_login_attempts and locked_until business rules in later
 * auth flows but those fields are not directly written by this endpoint except
 * for initialization.
 *
 * Related operations and workflow integration: This operation is typically
 * followed by email verification (which flips
 * econ_political_forum_registereduser.email_verified and sets verified_at) and
 * by administrator or moderator assignment workflows that create or activate an
 * econ_political_forum_moderator record. See also login and refresh operations
 * for session issuance and session management with
 * econ_political_forum_sessions.
 *
 * @param props.connection
 * @param props.body Registration request for a moderator-capable account. The
 *   request must include username and email; password is required and will be
 *   stored as a hashed value (password_hash) server-side.
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/join
 * @accessor api.functional.auth.moderator.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Registration request for a moderator-capable account. The request
     * must include username and email; password is required and will be
     * stored as a hashed value (password_hash) server-side.
     */
    body: IEconPoliticalForumModerator.ICreate;
  };
  export type Body = IEconPoliticalForumModerator.ICreate;
  export type Response = IEconPoliticalForumModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/join";
  export const random = (): IEconPoliticalForumModerator.IAuthorized =>
    typia.random<IEconPoliticalForumModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate moderator (login) and create a session
 * (econ_political_forum_sessions).
 *
 * Purpose and functionality: This endpoint authenticates a moderator-capable
 * registered user by validating credentials against
 * econ_political_forum_registereduser (username or email, and password). On
 * successful authentication the service issues an access token and a refresh
 * token and records a new session in econ_political_forum_sessions
 * (session_token, refresh_token_hash, created_at, expires_at).
 *
 * Implementation details and required fields: The request body typically
 * includes usernameOrEmail and password. The implementation must consult
 * econ_political_forum_registereduser.password_hash for verification, update
 * last_login_at on success, and reset failed_login_attempts. The session record
 * fields referenced include session_token, refresh_token_hash, ip_address,
 * user_agent, last_active_at, and expires_at.
 *
 * Role-specific integration and business context: Login for a moderator must
 * also check whether a moderator record exists and whether the moderator is
 * active (econ_political_forum_moderator.is_active). The system should deny
 * elevated moderation workflows if the linked econ_political_forum_moderator
 * record is missing or marked inactive; however, login may still succeed for
 * general registeredUser purposes.
 *
 * Security considerations within schema constraints: On failed authentication
 * the implementation must increment
 * econ_political_forum_registereduser.failed_login_attempts and set
 * locked_until if thresholds are reached. Refresh tokens must be stored hashed
 * in econ_political_forum_sessions.refresh_token_hash and rotated on use.
 * Tokens must not expose password_hash or other secrets.
 *
 * Related operations and workflow integration: This operation is commonly
 * followed by refresh (to renew access tokens) and session revocation endpoints
 * that update econ_political_forum_sessions.deleted_at for revoked sessions.
 * See password reset operations if account recovery is needed.
 *
 * @param props.connection
 * @param props.body Login credentials for a moderator-capable registered user
 *   (username/email + password).
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/login
 * @accessor api.functional.auth.moderator.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Login credentials for a moderator-capable registered user
     * (username/email + password).
     */
    body: IEconPoliticalForumModerator.ILogin;
  };
  export type Body = IEconPoliticalForumModerator.ILogin;
  export type Response = IEconPoliticalForumModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/login";
  export const random = (): IEconPoliticalForumModerator.IAuthorized =>
    typia.random<IEconPoliticalForumModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh access token using refresh token and rotate session
 * (econ_political_forum_sessions).
 *
 * Purpose and functionality: This endpoint renews authentication for an
 * existing session by accepting a refresh token and returning a new access
 * token and rotated refresh token. It is tied to econ_political_forum_sessions
 * (refresh_token_hash, expires_at) and econ_political_forum_registereduser for
 * audit linking.
 *
 * Implementation details and required fields: The request must include the
 * refresh token issued earlier. The service validates the refresh token against
 * the stored refresh_token_hash in econ_political_forum_sessions and ensures
 * the session has not expired or been revoked (deleted_at null). On success the
 * service rotates the refresh token, updates refresh_token_hash and expires_at,
 * and returns a new access token.
 *
 * Role-specific integration and business context: Refresh tokens renew access
 * for moderator workflows; when used the operation should verify the underlying
 * registered user account is not banned
 * (econ_political_forum_registereduser.is_banned) and that any moderator
 * linkage remains valid for elevated moderator actions.
 *
 * Security considerations within schema constraints: Refresh token reuse or use
 * after revocation must be treated as suspicious: the implementation should
 * record such anomalies in econ_political_forum_audit_logs and may revoke
 * sessions (set deleted_at on econ_political_forum_sessions) after evidence of
 * compromise. Token rotation events should be auditable and recorded.
 *
 * Related operations and workflow integration: This operation integrates with
 * logout/session-revoke endpoints that mark session records deleted_at and with
 * password reset flows that should invalidate active refresh tokens upon
 * successful password change.
 *
 * @param props.connection
 * @param props.body Refresh request containing the refresh token previously
 *   issued.
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/refresh
 * @accessor api.functional.auth.moderator.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh request containing the refresh token previously issued. */
    body: IEconPoliticalForumModerator.IRefresh;
  };
  export type Body = IEconPoliticalForumModerator.IRefresh;
  export type Response = IEconPoliticalForumModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/refresh";
  export const random = (): IEconPoliticalForumModerator.IAuthorized =>
    typia.random<IEconPoliticalForumModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
