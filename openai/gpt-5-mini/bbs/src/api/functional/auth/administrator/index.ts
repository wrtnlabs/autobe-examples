import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumAdministrator } from "../../../structures/IEconPoliticalForumAdministrator";
export * as password from "./password/index";
export * as email from "./email/index";
export * as sessions from "./sessions/index";

/**
 * Register a new administrator account (creates a row in
 * econ_political_forum_registereduser).
 *
 * Purpose and overview: This endpoint allows a new administrator to register an
 * account. It creates a new row in the econ_political_forum_registereduser
 * table and, on success, issues initial authorization tokens. The operation
 * leverages fields such as password_hash (to store the hashed password when
 * provided), email (for identity and notifications), email_verified and
 * verified_at (for verification state), and created_at/updated_at timestamps
 * for audit.
 *
 * Implementation details and schema references: The request body should include
 * email and password (the server stores a password_hash in
 * econ_political_forum_registereduser). The implementation will persist
 * username/display_name and set created_at and updated_at. If email
 * verification is required by policy, the system will create a password reset /
 * verification flow using econ_political_forum_password_resets
 * (reset_token_hash and expires_at) to deliver a verification token.
 *
 * Role-specific integration and business context: As this operation creates
 * administrator accounts, the join flow MUST include administrative approval or
 * an elevated verification step depending on business policy. The created
 * registered user row may later be linked to econ_political_forum_administrator
 * and econ_political_forum_sessions for session management (session_token,
 * refresh_token_hash, expires_at).
 *
 * Security considerations: Do not store plaintext passwords; persist only
 * password_hash. Protect email and verification tokens
 * (password_resets.reset_token_hash and expires_at). Ensure rate-limiting and
 * anti-abuse controls are applied to prevent automated admin account creation.
 * Record audit entries in econ_political_forum_audit_logs for account creation
 * events.
 *
 * Related operations and workflow integration: Related flows: POST
 * /auth/administrator/login (login), POST /auth/administrator/refresh
 * (refresh), POST /auth/administrator/password/reset (request reset using
 * econ_political_forum_password_resets), and session lifecycle endpoints that
 * create entries in econ_political_forum_sessions. Verification may reuse the
 * password_resets table for single-use tokens.
 *
 * @param props.connection
 * @param props.body Administrator registration payload
 * @setHeader token.access Authorization
 *
 * @path /auth/administrator/join
 * @accessor api.functional.auth.administrator.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Administrator registration payload */
    body: IEconPoliticalForumAdministrator.IJoin;
  };
  export type Body = IEconPoliticalForumAdministrator.IJoin;
  export type Response = IEconPoliticalForumAdministrator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/administrator/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/administrator/join";
  export const random = (): IEconPoliticalForumAdministrator.IAuthorized =>
    typia.random<IEconPoliticalForumAdministrator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate administrator and issue tokens (updates
 * econ_political_forum_sessions).
 *
 * Purpose and overview: Authenticate an administrator and create a session
 * record. This operation validates credentials against the
 * econ_political_forum_registereduser.password_hash, updates last_login_at on
 * success, and creates a new econ_political_forum_sessions entry with
 * session_token, refresh_token_hash, expires_at and created_at for session
 * lifecycle tracking.
 *
 * Implementation details and schema references: On successful authentication,
 * record last_login_at and reset failed_login_attempts. If failed, increment
 * failed_login_attempts and set locked_until per lockout policy. Create a
 * session row in econ_political_forum_sessions with session_token (unique) and
 * refresh_token_hash, and set expires_at to the configured access lifetime for
 * refresh semantics.
 *
 * Role-specific integration and business context: This endpoint is public (no
 * prior bearer required) but specifically used to obtain administrator
 * authorization. The system must ensure that if the registered user already has
 * an associated econ_political_forum_administrator row (link via registereduser
 * -> administrator), the returned authorization grants administrator
 * privileges.
 *
 * Security considerations: Record authentication audit events in
 * econ_political_forum_audit_logs. Prevent disclosure of whether email or
 * password was incorrect. Enforce rate limits and account lockout
 * (failed_login_attempts, locked_until). Use secure refresh token rotation:
 * store only refresh_token_hash in sessions and rotate on use.
 *
 * Related operations and workflow integration: Related to POST
 * /auth/administrator/refresh (to rotate tokens) and session management
 * endpoints to revoke sessions. Uses econ_political_forum_password_resets for
 * recovery flows if account lockout occurs.
 *
 * @param props.connection
 * @param props.body Administrator login credentials
 * @setHeader token.access Authorization
 *
 * @path /auth/administrator/login
 * @accessor api.functional.auth.administrator.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Administrator login credentials */
    body: IEconPoliticalForumAdministrator.ILogin;
  };
  export type Body = IEconPoliticalForumAdministrator.ILogin;
  export type Response = IEconPoliticalForumAdministrator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/administrator/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/administrator/login";
  export const random = (): IEconPoliticalForumAdministrator.IAuthorized =>
    typia.random<IEconPoliticalForumAdministrator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh administrator access token and rotate refresh token (operates on
 * econ_political_forum_sessions).
 *
 * Purpose and overview: Refresh an administrator's access token using a valid
 * refresh token. This operation validates the presented refresh token against
 * stored refresh_token_hash in econ_political_forum_sessions, issues a new
 * access token, rotates the refresh token (update refresh_token_hash and
 * expires_at), and records the rotation in audit logs
 * (econ_political_forum_audit_logs).
 *
 * Implementation details and schema references: The refresh request refers to
 * an existing session row in econ_political_forum_sessions. On success, update
 * that row's refresh_token_hash and expires_at and set last_active_at. If the
 * presented token is invalid or previously revoked (deleted_at set), refuse the
 * refresh and require full re-authentication.
 *
 * Role-specific integration and business context: This endpoint supports
 * long-lived administrator sessions while enforcing rotation and revocation. It
 * ties into session revocation endpoints that may set
 * econ_political_forum_sessions.deleted_at to soft-revoke a session.
 *
 * Security considerations: Record rotation events in
 * econ_political_forum_audit_logs. Detect refresh token reuse or anomalies and
 * escalate accounts for review (increment failed counters or create
 * moderation/audit artifacts as needed). Ensure rotated refresh tokens are
 * unique and previous ones are invalidated.
 *
 * Related operations and workflow integration: Related to POST
 * /auth/administrator/login (initial issuance), POST
 * /auth/administrator/sessions/revoke (revocation), and GET /admin/sessions
 * (listing active sessions).
 *
 * @param props.connection
 * @param props.body Refresh token payload
 * @setHeader token.access Authorization
 *
 * @path /auth/administrator/refresh
 * @accessor api.functional.auth.administrator.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token payload */
    body: IEconPoliticalForumAdministrator.IRefresh;
  };
  export type Body = IEconPoliticalForumAdministrator.IRefresh;
  export type Response = IEconPoliticalForumAdministrator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/administrator/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/administrator/refresh";
  export const random = (): IEconPoliticalForumAdministrator.IAuthorized =>
    typia.random<IEconPoliticalForumAdministrator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
