import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconPoliticalForumAdministrator } from "../../../../../structures/IEconPoliticalForumAdministrator";

/**
 * Verify administrator email (sets email_verified and verified_at on
 * econ_political_forum_registereduser).
 *
 * Purpose and overview: Confirm an administrator's email address using a
 * single-use verification token. On success, set registered user fields
 * email_verified = true and verified_at to the timestamp, stored on
 * econ_political_forum_registereduser.
 *
 * Implementation details and schema references: The operation will validate the
 * provided token (implementation may use econ_political_forum_password_resets
 * or a dedicated verification token table). Upon validation, set email_verified
 * = true and verified_at on the registered user row, update updated_at, and
 * record an audit entry in econ_political_forum_audit_logs.
 *
 * Role-specific integration and business context: Email verification affects
 * posting privileges in categories that require verification
 * (econ_political_forum_categories.requires_verification). Administrators must
 * verify email prior to performing certain high-risk actions depending on
 * policy.
 *
 * Security considerations: Verification tokens must be single-use and
 * time-limited. Limit resends and record verification attempts in audit logs.
 * Do not reveal whether the token maps to a specific user in public error
 * messages.
 *
 * Related operations and workflow integration: Connects to POST
 * /auth/administrator/join (initial issuance) and to category posting rules
 * that require email_verified.
 *
 * @param props.connection
 * @param props.token Verification token
 * @path /auth/administrator/email/verify/:token
 * @accessor api.functional.auth.administrator.email.verify.verifyEmail
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function verifyEmail(
  connection: IConnection,
  props: verifyEmail.Props,
): Promise<verifyEmail.Response> {
  return true === connection.simulate
    ? verifyEmail.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...verifyEmail.METADATA,
          path: verifyEmail.path(props),
          status: null,
        },
      );
}
export namespace verifyEmail {
  export type Props = {
    /** Verification token */
    token: string & tags.Format<"uuid">;
  };
  export type Response = IEconPoliticalForumAdministrator.IVerifyEmailResponse;

  export const METADATA = {
    method: "GET",
    path: "/auth/administrator/email/verify/:token",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/auth/administrator/email/verify/${encodeURIComponent(props.token ?? "null")}`;
  export const random =
    (): IEconPoliticalForumAdministrator.IVerifyEmailResponse =>
      typia.random<IEconPoliticalForumAdministrator.IVerifyEmailResponse>();
  export const simulate = (
    connection: IConnection,
    props: verifyEmail.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: verifyEmail.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("token")(() => typia.assert(props.token));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
