{"operations":[{"specification":"Generate public guest authentication endpoints that allow unauthenticated visitors to obtain temporary guest sessions recorded in the Prisma table community_portal_guests. This operation interfaces with the community_portal_guests Prisma table and will create a guest session record (community_portal_guests) and issue short-lived authorization tokens for use as a guest. The implementation will persist guest session metadata using the table columns: id, user_id, guest_token, created_at, expired_at. It will ensure referential integrity with community_portal_users by populating user_id when binding a guest session to an existing user account.","authorizationType":"join","description":"Purpose and overview:\nThis endpoint creates a temporary guest session and records it in the Prisma table community_portal_guests. The operation will insert a new row populating the required columns (id, user_id, guest_token, created_at, expired_at) according to the business rules. The primary goal is to enable unauthenticated visitors to obtain a short-lived guest token that can be used for read-only session-scoped features, while maintaining an auditable record in community_portal_guests.\n\nSecurity considerations and user permissions:\nBecause the guest_token column on community_portal_guests functions as the issued guest credential, token issuance and storage must follow secure token generation and storage practices. The expired_at column in community_portal_guests must be checked when validating tokens to enforce token lifetime. The user_id column references community_portal_users.id and must be validated when provided: the operation should only accept an explicit user_id value when the caller indicates an existing user binding (for example, binding a guest session to a recently created user), otherwise the server may generate a guest record that references a system-managed placeholder user record if policy allows. The operation must never expose password_hash or other secrets from community_portal_users in its response.\n\nRelationship to underlying database entities:\nThis operation is explicitly associated with the Prisma table community_portal_guests and references community_portal_users via user_id. Implementers should query or insert into community_portal_guests and ensure the guest_token value is unique and recorded together with created_at and expired_at timestamps. Use the id column as the PK for returned session references. Any user_id used must correspond to an existing community_portal_users.id to preserve referential integrity.\n\nValidation rules and business logic:\nRequired validation includes verifying an optional provided user_id exists in community_portal_users, generating a cryptographically secure guest_token, and setting created_at and expired_at according to the platform’s guest session TTL policy. The server SHOULD validate that expired_at is a future timestamp and that guest_token is not already present in the community_portal_guests table. If user_id is provided but does not exist, the request MUST be rejected with a 400/404 as appropriate. The API will return the issued guest_token and associated metadata in the response body (ICommunityPortalGuest.IAuthorized), not exposing internal password_hash values.\n\nRelated operations and workflow integration:\nThis join operation is intended to be used together with the refresh operation (/auth/guest/refresh) to renew guest tokens. Typical flow: client calls POST /auth/guest/join to obtain an initial guest_token and created_at/expired_at; later, when the guest token nears expiration, the client calls POST /auth/guest/refresh providing the current guest_token to obtain a renewed ICommunityPortalGuest.IAuthorized response. The join endpoint is public and requires no prior authentication.","summary":"Create a guest session record in the Prisma table community_portal_guests and issue a temporary guest token (relates to community_portal_guests).","parameters":[],"requestBody":{"description":"Request payload to create a guest session. If binding to an existing account, include user_id with a valid community_portal_users.id.","typeName":"ICommunityPortalGuest.ICreate"},"responseBody":{"description":"Authorized response containing issued guest token, expiry, and session metadata from community_portal_guests.","typeName":"ICommunityPortalGuest.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/guest/join","method":"post"},{"specification":"Generate public guest token refresh endpoint that validates and renews an existing guest session stored in the Prisma table community_portal_guests. It will look up a community_portal_guests row by guest_token, validate expired_at and created_at, and return renewed authorization information in ICommunityPortalGuest.IAuthorized.","authorizationType":"refresh","description":"Purpose and overview:\nThis endpoint validates an existing guest credential (community_portal_guests.guest_token) and issues a renewed authorization response. The operation reads the community_portal_guests table using the provided guest_token and returns a renewed token or extended expiry metadata (id, user_id, guest_token, created_at, expired_at) in the authorized response type ICommunityPortalGuest.IAuthorized.\n\nSecurity considerations and user permissions:\nThe refresh operation must strictly validate the provided guest_token against the community_portal_guests.guest_token column and ensure the token has not already expired by comparing against expired_at. To mitigate token replay and abuse, the implementation should enforce token rotation semantics (issue a new guest_token and update expired_at) and use secure token handling. Because the underlying record references user_id (community_portal_users.id), additional checks may be applied when user_id is present (for example, if the user has been suspended in community_portal_members.is_suspended, refresh should be denied).\n\nRelationship to underlying database entities:\nThis operation is centered on the community_portal_guests Prisma table and its columns: guest_token (lookup key), expired_at (expiry check), created_at (auditable creation), id (PK), and user_id (nullable FK referencing community_portal_users.id). The refresh logic must only reference these existing fields and must not assume additional columns exist. Implementers should ensure updates to guest_token and expired_at are persisted to the community_portal_guests row when rotating tokens.\n\nValidation rules and business logic:\nThe API MUST reject refresh requests for unknown or expired guest_token values with 401 Unauthorized. If the record exists and expired_at indicates the token is still valid (or within a configurable refresh window), the API SHOULD issue a new guest_token, update expired_at according to the platform’s TTL policy, and return the updated ICommunityPortalGuest.IAuthorized response. If the associated user_id is present, additional business gating (e.g., account suspension check using community_portal_members.is_suspended) MAY block refresh and return 403 Forbidden.\n\nRelated operations and workflow integration:\nThis refresh endpoint complements POST /auth/guest/join: after obtaining an initial guest_token via join, clients call POST /auth/guest/refresh to renew that guest session. The refresh operation is a public endpoint but requires a valid guest_token in the request body (ICommunityPortalGuest.IRefresh). It returns the same response shape as join (ICommunityPortalGuest.IAuthorized) to allow uniform handling on the client side.","summary":"Refresh a guest session by validating and renewing a guest_token stored in community_portal_guests.","parameters":[],"requestBody":{"description":"Payload containing the current guest_token to be validated and refreshed.","typeName":"ICommunityPortalGuest.IRefresh"},"responseBody":{"description":"Authorized response containing renewed guest token and session metadata from community_portal_guests.","typeName":"ICommunityPortalGuest.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/guest/refresh","method":"post"},{"specification":"Create (join) member registration operation. This operation handles new member sign-up, creating records in the Prisma tables community_portal_users and community_portal_members. It validates required account fields, persists the new user (community_portal_users) and creates a corresponding membership record (community_portal_members) with is_email_verified=false and member_since timestamp. The operation is associated with the Prisma tables: community_portal_users and community_portal_members. It is a public registration endpoint that issues initial authorization payload (ICommunityPortalMember.IAuthorized) on success.","authorizationType":"join","description":"Purpose and functionality:\nThis endpoint registers a new member account by creating a community_portal_users record (storing username, email and password_hash) and a corresponding community_portal_members record (storing member_since and is_email_verified=false). It uses the schema fields community_portal_users.email, community_portal_users.username, community_portal_users.password_hash, community_portal_users.display_name and community_portal_members.member_since and community_portal_members.is_email_verified to model the account creation and initial membership state.\n\nImplementation details and required fields:\nThe request body MUST supply the email (community_portal_users.email), chosen username (community_portal_users.username), a client-supplied password which the server will transform into password_hash (community_portal_users.password_hash), and optional display_name (community_portal_users.display_name). On success, the server will create a new community_portal_users row and a community_portal_members row linked by user_id, setting member_since to the current timestamp (community_portal_members.member_since).\n\nRole-specific integration and business context:\nThis operation targets end users who will become members in the platform. The returned authorized response (ICommunityPortalMember.IAuthorized) contains the token and minimal public user info including the user id (community_portal_users.id), username, display_name, and initial karma (community_portal_users.karma). The API intentionally sets is_email_verified (community_portal_members.is_email_verified) to false until verification completes.\n\nSecurity considerations within schema constraints:\nPasswords are never stored in plaintext; the schema exposes password_hash (community_portal_users.password_hash) as the persisted column. The implementation MUST hash and salt the provided password and NOT accept a pre-hashed value from clients. The endpoint should validate email uniqueness against community_portal_users.email and username uniqueness against community_portal_users.username and return a 409 Conflict when duplicates are detected.\n\nRelated operations and workflow integration:\nTypical workflow: client calls POST /auth/member/join to create the user, then calls the email verification flow (verifyEmail) once they receive a verification token. The login and refresh operations (login, refresh) consume the issued credentials and tokens to establish and renew sessions. This operation maps directly to the Prisma tables community_portal_users and community_portal_members.","summary":"Register a new member by creating community_portal_users and community_portal_members records and returning initial authorization.","parameters":[],"requestBody":{"description":"Registration payload containing username, email and password. The server will hash the password and create the member record.","typeName":"ICommunityPortalMember.ICreate"},"responseBody":{"description":"Authorized response including access token and minimal user profile (id, username, display_name, karma).","typeName":"ICommunityPortalMember.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/member/join","method":"post"},{"specification":"Login operation for members. Authenticates credentials against community_portal_users (email or username) and issues an authorization response. It references the community_portal_users table for credential validation and community_portal_members.is_email_verified for gating content-creation privileges.","authorizationType":"login","description":"Purpose and functionality:\nThis endpoint authenticates an existing member using credentials that map to community_portal_users (email or username) and verifies membership state via community_portal_members.is_email_verified. On successful authentication it returns an authorization payload (ICommunityPortalMember.IAuthorized) that the client can use for authenticated requests.\n\nImplementation details and required fields:\nThe client provides an identifier (email or username) and a password. The server looks up community_portal_users.email or community_portal_users.username, verifies the provided password against community_portal_users.password_hash, and checks community_portal_members.is_email_verified before granting full member privileges. The response includes user id (community_portal_users.id), username, display_name, and karma.\n\nRole-specific integration and business context:\nLogin is a public endpoint used by members to establish sessions. The operation ties into downstream behavior: gated actions like creating posts or voting should verify that community_portal_members.is_email_verified is true. The server may also include member_since (community_portal_members.member_since) in the response for client UI.\n\nSecurity considerations within schema constraints:\nDo not leak whether the provided identifier exists; on failure return a generic authentication error. Use secure comparisons for password verification against password_hash. Consider rate-limiting failed attempts to protect community_portal_users accounts.\n\nRelated operations and workflow integration:\nAfter successful login, clients use the issued tokens to call member-only endpoints. If a member's community_portal_members.is_suspended flag is set (member table), member actions should be restricted. This operation directly references community_portal_users and community_portal_members.","summary":"Authenticate a member and return authorization tokens and basic profile (id, username, display_name, karma).","parameters":[],"requestBody":{"description":"Login payload with identifier (email or username) and password.","typeName":"ICommunityPortalMember.ILogin"},"responseBody":{"description":"Authorized response including access and refresh tokens and minimal profile (id, username, display_name, karma).","typeName":"ICommunityPortalMember.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/member/login","method":"post"},{"specification":"Token refresh operation for members. Accepts a refresh token and returns a new authorization payload. This operation is tied to the authorization lifecycle for community_portal_users and does not modify persistent profile fields but issues new tokens tied to a user id (community_portal_users.id).","authorizationType":"refresh","description":"Purpose and functionality:\nThis endpoint renews authentication by accepting a valid refresh token and issuing a new access token and optionally a rotated refresh token. The issued tokens are associated with community_portal_users.id and the returned authorized payload follows ICommunityPortalMember.IAuthorized.\n\nImplementation details and required fields:\nClients POST the refresh token in the request body. The server validates the refresh token, ensures the referenced user (community_portal_users.id) still exists and is not suspended, and returns a fresh authorized response. No profile mutation is expected; the operation only issues new tokens for an existing community_portal_users record.\n\nRole-specific integration and business context:\nRefresh is a public endpoint that requires a valid refresh token. It ensures continuity of member sessions without re-supplying credentials. The server should check membership state (e.g., community_portal_members.is_suspended) before issuing tokens.\n\nSecurity considerations within schema constraints:\nRotate refresh tokens on use where feasible and bind tokens to community_portal_users.id for auditability. If the referenced user record no longer exists, return 401 Unauthorized. Avoid revealing internal details about community_portal_users records on failure.\n\nRelated operations and workflow integration:\nThis operation complements login and join flows by enabling long-lived session management. It references community_portal_users for user existence and membership checks but does not alter persisted user or member records.","summary":"Refresh authentication tokens for a member using a valid refresh token and return a new ICommunityPortalMember.IAuthorized payload.","parameters":[],"requestBody":{"description":"Refresh request containing the refresh token issued at login or prior refresh.","typeName":"ICommunityPortalMember.IRefresh"},"responseBody":{"description":"New authorized response including rotated tokens and basic profile (id, username, display_name, karma).","typeName":"ICommunityPortalMember.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/member/refresh","method":"post"},{"specification":"Request password reset operation. Creates a password-reset request for a member based on community_portal_users.email. This operation records no permanent schema change but creates a password reset flow tied to the user's email (community_portal_users.email).","authorizationType":null,"description":"Purpose and functionality:\nThis endpoint initiates a password reset flow for a member by accepting an email address that maps to community_portal_users.email. The server generates a single-use reset artifact (token) and sends it to the provided address. No persistent changes to community_portal_users are made until the reset is completed.\n\nImplementation details and required fields:\nThe client provides the email (community_portal_users.email). The server looks up the user and, if found, issues a time-limited reset token sent to that address. For privacy, the endpoint returns a generic confirmation message regardless of whether the email exists to avoid account enumeration.\n\nRole-specific integration and business context:\nThis is a public endpoint used when members forget credentials. The reset token allows the user to call a subsequent changePassword operation or a token-based password update endpoint. The implementation should reference community_portal_users.email and community_portal_users.id for token binding.\n\nSecurity considerations within schema constraints:\nAlways treat this flow as sensitive: send tokens only to the verified email address (community_portal_users.email) and limit token lifetime. Do not leak whether the email exists in community_portal_users; return a generic response message.\n\nRelated operations and workflow integration:\nThis operation pairs with a password-apply operation (changePassword) that consumes the reset token to update community_portal_users.password_hash. It references the community_portal_users table for lookup and token binding.","summary":"Initiate a password reset flow by email for a member (no direct DB mutation until reset is applied).","parameters":[],"requestBody":{"description":"Password reset request containing the target email address.","typeName":"ICommunityPortalMember.IRequestPasswordReset"},"responseBody":{"description":"Confirmation that a password reset was requested (generic response to avoid account enumeration).","typeName":"ICommunityPortalMember.IPasswordResetRequested"},"authorizationRole":null,"name":"requestPasswordReset","prerequisites":[],"path":"/auth/member/password/request-reset","method":"post"},{"specification":"Apply password reset / change password operation. Allows authenticated members or holders of a valid reset token to set a new password. This updates community_portal_users.password_hash for the given community_portal_users.id when the supplied reset token or authenticated context is valid.","authorizationType":null,"description":"Purpose and functionality:\nThis endpoint sets a new password for a member by updating community_portal_users.password_hash for the targeted user. It accepts either an authenticated member session or a valid reset token issued by the requestPasswordReset flow and updates the stored password hash accordingly.\n\nImplementation details and required fields:\nThe request MUST include either the reset token and desired new password (token flow) or the currentPassword and newPassword when the user is authenticated (session flow). On validation, the server computes a new password hash and updates community_portal_users.password_hash for the corresponding community_portal_users.id.\n\nRole-specific integration and business context:\nChanging a password is a security-sensitive operation that ties directly to the community_portal_users table. If the authenticated (authorizationRole=\"member\") path is used, the server should verify the provided current password against community_portal_users.password_hash before allowing an update. If the reset-token path is used, verify the token is valid and bound to community_portal_users.id.\n\nSecurity considerations within schema constraints:\nNever accept pre-hashed passwords from clients. Use secure hashing and rotate any refresh tokens on password change. Record an audit event tied to community_portal_users.id when the password is changed.\n\nRelated operations and workflow integration:\nThis operation is used after requestPasswordReset or as an authenticated change-password endpoint. It updates community_portal_users.password_hash and may trigger session invalidation for active tokens.","summary":"Set a new password for a member either via reset token or authenticated current-password flow; updates community_portal_users.password_hash.","parameters":[],"requestBody":{"description":"Password change payload: either { resetToken, newPassword } or { currentPassword, newPassword } depending on flow.","typeName":"ICommunityPortalMember.IChangePassword"},"responseBody":{"description":"Result of the password change (success acknowledgement).","typeName":"ICommunityPortalMember.IChangePasswordResult"},"authorizationRole":"member","name":"changePassword","prerequisites":[{"endpoint":{"path":"/auth/member/password/request-reset","method":"post"},"description":"The token-based changePassword flow requires a single-use reset token issued by the password reset initiation. POST /auth/member/password/request-reset creates that reset token (bound to community_portal_users.email and id); the reset token must exist and be valid before calling POST /auth/member/password/change with the token."}],"path":"/auth/member/password/change","method":"post"},{"specification":"Email verification operation for members. Consumes a verification token and flips community_portal_members.is_email_verified to true for the linked user. It references the community_portal_members table and community_portal_users.id for mapping.","authorizationType":null,"description":"Purpose and functionality:\nThis endpoint verifies a member's email by accepting a verification token issued at registration. When the token is validated, the implementation sets community_portal_members.is_email_verified = true for the corresponding membership record and records the verification event (member_since and updated_at may be referenced).\n\nImplementation details and required fields:\nThe request includes a verification token that the server validates and maps to a community_portal_users.id / community_portal_members record. On success the server updates community_portal_members.is_email_verified to true and returns the authorized view of the user or a simple success response.\n\nRole-specific integration and business context:\nEmail verification unlocks member capabilities that gate content creation and voting. The endpoint ties the verification artifact to community_portal_users.email and the membership record (community_portal_members.is_email_verified). The client may subsequently call login to obtain tokens that reflect verified membership privileges.\n\nSecurity considerations within schema constraints:\nTreat verification tokens as single-use and time-limited. Do not expose whether the token maps to which internal id on failure; return a generic invalid/expired response. Ensure the update is auditable and tied to community_portal_users.id.\n\nRelated operations and workflow integration:\nThis operation complements the join flow and allows the member to obtain full privileges (posting, voting) once community_portal_members.is_email_verified is true. It references community_portal_members and community_portal_users in the Prisma schema.","summary":"Verify a member's email by consuming a verification token and setting community_portal_members.is_email_verified to true.","parameters":[],"requestBody":{"description":"Verification request containing the verification token issued at registration.","typeName":"ICommunityPortalMember.IVerifyEmail"},"responseBody":{"description":"Acknowledgement of successful verification and optionally updated authorized profile.","typeName":"ICommunityPortalMember.IVerifyEmailResult"},"authorizationRole":null,"name":"verifyEmail","prerequisites":[],"path":"/auth/member/verify-email","method":"post"},{"specification":"Generate authorization-related API operations for the moderator role. This operation set focuses on JWT-based authentication and security flows for the \"moderator\" role and maps to the Prisma tables community_portal_users and community_portal_members. Each endpoint is designed to support account creation, credential-based authentication, token refresh, email verification, and password management for moderator accounts using fields present in the schema (community_portal_users.email, community_portal_users.password_hash, community_portal_users.username, community_portal_users.display_name, community_portal_users.karma, community_portal_members.is_email_verified, community_portal_members.is_suspended, community_portal_members.member_since).","authorizationType":"join","description":"Purpose and overview:\nThis endpoint creates a new moderator account and issues initial authentication tokens. It maps to the community_portal_users and community_portal_members tables: a new community_portal_users row is created (username, email, password_hash, display_name, avatar_uri optional) and a corresponding community_portal_members row is created to track is_email_verified and member_since. The operation is intended for onboarding moderator candidates or promoting members into moderator status when appropriate.\n\nImplementation details using confirmed schema fields:\nRequest payload SHOULD include username (community_portal_users.username), email (community_portal_users.email), password (which will be stored as community_portal_users.password_hash by the implementation), and optional display_name (community_portal_users.display_name). The server will create community_portal_users and community_portal_members records and set community_portal_members.is_email_verified=false until verification occurs. The response returns the authorized token container and minimal user summary.\n\nRole-specific integration and business context:\nThis join flow is scoped to creation of moderator-capable accounts. The implementation should ensure the created records reflect the moderator candidate's intended privileges while referencing the community_portal_members.member_since timestamp and initial karma (community_portal_users.karma). Any moderator appointment workflow should run after account creation per product policy.\n\nSecurity considerations constrained by schema:\nPasswords must be handled only as a secure hash stored in community_portal_users.password_hash; plaintext passwords MUST never be persisted. The service SHOULD enforce email uniqueness (community_portal_users.email is unique in the schema) and validate email format. The implementation MUST respect community_portal_members.is_suspended if a later moderation action suspends the account.\n\nRelated operations and workflow integration:\nAfter join, the typical flow is to call verifyEmail to confirm community_portal_members.is_email_verified, then use login to obtain fresh tokens, and refresh to renew access tokens. See /auth/moderator/verify, /auth/moderator/login, and /auth/moderator/refresh for complementary operations.","summary":"Register a new moderator account (creates community_portal_users and community_portal_members)","parameters":[],"requestBody":{"description":"Registration payload for a moderator account (username, email, password, optional displayName).","typeName":"ICommunityPortalModerator.ICreate"},"responseBody":{"description":"Authorized response with initial access and refresh tokens and user summary.","typeName":"ICommunityPortalModerator.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/moderator/join","method":"post"},{"specification":"Authenticate a moderator using credentials. This operation authenticates against community_portal_users (email or username) and validates account state in community_portal_members (is_email_verified, is_suspended).","authorizationType":"login","description":"Purpose and overview:\nAuthenticate an existing moderator account and issue short-lived access tokens and longer-lived refresh tokens. This operation reads community_portal_users.password_hash to validate credentials and checks community_portal_members.is_email_verified and community_portal_members.is_suspended to determine eligibility for sign-in.\n\nImplementation details using confirmed schema fields:\nThe request body SHOULD accept credentials (email or username) and password. The operation MUST validate the provided password against community_portal_users.password_hash and confirm the associated community_portal_members.is_email_verified is true before issuing full privileges. If community_portal_members.is_suspended is true, authentication must be denied with an explanatory result.\n\nRole-specific integration and business context:\nSuccessful login produces an ICommunityPortalModerator.IAuthorized response including token material and a minimal user profile (id, username, display_name, karma from community_portal_users.karma, and member_since from community_portal_members.member_since). The UI can use these fields to display moderator context.\n\nSecurity considerations constrained by schema:\nImplementers MUST avoid disclosing whether the email exists in error messages. Failed login attempts should be counted for rate-limiting and anti-abuse while respecting the community_portal_users.deleted_at and community_portal_members.is_suspended fields. Password verification uses the stored community_portal_users.password_hash only.\n\nRelated operations and workflow integration:\nAfter successful login clients may call refresh to rotate tokens. If the account is newly created and community_portal_members.is_email_verified is false, prompt the user to verify via the verifyEmail operation.\n","summary":"Authenticate moderator and return authorized tokens","parameters":[],"requestBody":{"description":"Credentials for moderator sign-in (email or username and password).","typeName":"ICommunityPortalModerator.ILogin"},"responseBody":{"description":"Authorized response containing access and refresh tokens and user summary.","typeName":"ICommunityPortalModerator.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/moderator/login","method":"post"},{"specification":"Refresh moderator access tokens using a refresh token. Associates refreshed tokens to the community_portal_users.id and may consult community_portal_members.is_suspended to decide renewal eligibility.","authorizationType":"refresh","description":"Purpose and overview:\nIssue new access (and, optionally, rotated refresh) tokens for a moderator using a valid refresh token. The operation logically associates the token with community_portal_users.id and verifies account status by consulting community_portal_members.is_suspended so suspended accounts cannot obtain new tokens.\n\nImplementation details using confirmed schema fields:\nRequest payload SHOULD contain a refresh token tied to a specific community_portal_users.id. The server resolves the user record (community_portal_users.id) and confirms the membership state (community_portal_members.is_suspended). If eligible, the endpoint returns a new ICommunityPortalModerator.IAuthorized response with newly issued tokens and lightweight user info (username, id, karma).\n\nRole-specific integration and business context:\nToken refresh is part of the normal moderator session lifecycle; it supports long-lived login experiences without re-entering credentials while ensuring account state checks (is_suspended) remain enforced before reissuing privileges.\n\nSecurity considerations constrained by schema:\nRotate refresh tokens on use when possible and validate refresh token binding to community_portal_users.id. If community_portal_users.deleted_at is set, deny token refresh. Log refresh events tied to the user id for audit.\n\nRelated operations and workflow integration:\nUsed after login and join flows; clients should call refresh when access tokens expire. For security-sensitive actions, require reauthentication via login rather than refresh.\n","summary":"Refresh moderator access tokens","parameters":[],"requestBody":{"description":"Refresh token payload to obtain new access tokens.","typeName":"ICommunityPortalModerator.IRefresh"},"responseBody":{"description":"Authorized response with renewed access (and optionally refresh) tokens.","typeName":"ICommunityPortalModerator.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/moderator/refresh","method":"post"},{"specification":"Verify email addresses for moderator accounts by updating community_portal_members.is_email_verified and returning a status. This operation references community_portal_users.id and community_portal_members.is_email_verified.","authorizationType":null,"description":"Purpose and overview:\nConfirm a moderator's email address and flip community_portal_members.is_email_verified to true for the associated user. This operation accepts a verification token tied to a community_portal_users.id and updates the membership record's is_email_verified and member_since as appropriate.\n\nImplementation details using confirmed schema fields:\nThe request payload SHOULD include a one-time verification token and the target user identifier (or token-bound lookup). Once validated, the implementation MUST set community_portal_members.is_email_verified=true and record the current timestamp in member_since if not already set. The response indicates success and may optionally return a lightweight user summary (id, username).\n\nRole-specific integration and business context:\nEmail verification is required before granting full moderator responsibilities in many workflows; the UI should surface guidance if verification is pending. The existence of community_portal_members.is_suspended should be considered—verification does not override suspension.\n\nSecurity considerations constrained by schema:\nVerification tokens must be single-use and time-limited. Do not expose the community_portal_users.password_hash. If community_portal_users.deleted_at is set, reject verification attempts and advise account recreation.\n\nRelated operations and workflow integration:\nTypical sequence: join -> verify (this operation) -> login -> refresh. After verification the client may call login to obtain tokens.","summary":"Verify moderator email and activate membership record","parameters":[],"requestBody":{"description":"Payload containing the verification token (and optionally user id) to confirm email.","typeName":"ICommunityPortalModerator.IVerifyEmailRequest"},"responseBody":{"description":"Result indicating verification success and optional minimal user summary.","typeName":"ICommunityPortalModerator.IVerifyEmailResponse"},"authorizationRole":null,"name":"verifyEmail","prerequisites":[],"path":"/auth/moderator/verify","method":"post"},{"specification":"Request a password reset for a moderator account. This operation references community_portal_users.email and will trigger a reset flow that ultimately updates community_portal_users.password_hash.","authorizationType":null,"description":"Purpose and overview:\nInitiate a password reset process for a moderator account. The endpoint accepts an email address (community_portal_users.email) and, if a matching account exists, sends a one-time password reset token to that address. The response is a generic acknowledgement to avoid account enumeration.\n\nImplementation details using confirmed schema fields:\nThe request body SHOULD include the email addressing which the reset is requested. The implementation locates the community_portal_users row by email and generates a time-limited token. The token exchange to set a new password is performed in resetPassword. The operation does not return user-specific details in order to preserve privacy.\n\nRole-specific integration and business context:\nThis operation is public-facing and supports moderator account recovery. Because community_portal_users.email is unique per schema, the system can reliably generate and send a reset token when appropriate but must not disclose account presence in responses.\n\nSecurity considerations constrained by schema:\nAlways respond with a neutral acknowledgment regardless of whether an account exists for the supplied email. Ensure the reset token workflow ultimately results in replacing the stored community_portal_users.password_hash and log reset events against the user id when applicable.\n\nRelated operations and workflow integration:\nSequence: requestPasswordReset -> resetPassword. After a successful reset, the user should be able to login and obtain tokens.","summary":"Request password reset email for a moderator account","parameters":[],"requestBody":{"description":"Email payload to request a password reset link or token.","typeName":"ICommunityPortalModerator.IRequestPasswordReset"},"responseBody":{"description":"Acknowledgement that a reset link/token has been issued if an account exists.","typeName":"ICommunityPortalModerator.IRequestPasswordResetResponse"},"authorizationRole":null,"name":"requestPasswordReset","prerequisites":[],"path":"/auth/moderator/password/request-reset","method":"post"},{"specification":"Complete password reset by validating a token and updating community_portal_users.password_hash. This operation updates the user's password_hash field and is associated with community_portal_users.id.","authorizationType":null,"description":"Purpose and overview:\nFinalize a password reset for a moderator by consuming a time-limited token and setting a new password hash in community_portal_users.password_hash. This operation ensures the account can be recovered securely and that the reset is auditable against the user id.\n\nImplementation details using confirmed schema fields:\nRequest payload SHOULD include the reset token and the new password. The server validates the token, locates the community_portal_users row, computes a secure hash for the provided password, and updates community_portal_users.password_hash. The response confirms completion without returning sensitive data.\n\nRole-specific integration and business context:\nThis operation completes the account recovery flow for moderators. After a successful reset, clients should call login to obtain fresh tokens. Implementations should also invalidate existing refresh tokens for the user to prevent token reuse after a password change.\n\nSecurity considerations constrained by schema:\nNever return the password_hash in responses. Ensure token consumption is single-use and that community_portal_users.deleted_at and community_portal_members.is_suspended are considered—deny resets for deleted accounts or log and surface appropriate guidance.\n\nRelated operations and workflow integration:\nPreceded by requestPasswordReset and typically followed by login and refresh operations.","summary":"Complete password reset and update stored password hash","parameters":[],"requestBody":{"description":"Reset token and new password to update the stored password hash.","typeName":"ICommunityPortalModerator.IResetPassword"},"responseBody":{"description":"Acknowledgement of password reset completion.","typeName":"ICommunityPortalModerator.IResetPasswordResponse"},"authorizationRole":null,"name":"resetPassword","prerequisites":[],"path":"/auth/moderator/password/reset","method":"post"},{"specification":"Allow an authenticated moderator to change their password. This operation updates community_portal_users.password_hash for the authenticated community_portal_users.id and verifies current credentials prior to change.","authorizationType":null,"description":"Purpose and overview:\nEnable an authenticated moderator to change their password. The operation targets community_portal_users.password_hash for the calling user and requires current password verification before applying the new hash. This is a security-sensitive user operation scoped to authenticated moderators.\n\nImplementation details using confirmed schema fields:\nRequest payload SHOULD include the current password and the new password. The server validates the current password against community_portal_users.password_hash, computes the new hash, and updates community_portal_users.password_hash. The endpoint should also record an audit event tied to community_portal_users.id.\n\nRole-specific integration and business context:\nThis endpoint is restricted to authenticated moderators (authorizationRole=\"moderator\"). It supports user-initiated credential rotation and should invalidate existing refresh tokens after a successful change to protect sessions.\n\nSecurity considerations constrained by schema:\nDo not expose community_portal_users.password_hash. Require reauthentication or MFA for high-risk changes if platform policy dictates. Log the password change event with user id and timestamp for audit (linked to community_portal_users.id).\n\nRelated operations and workflow integration:\nAfter changePassword completes, clients may need to reauthenticate (login) or use refreshed tokens depending on token invalidation policy.","summary":"Authenticated moderator changes their password","parameters":[],"requestBody":{"description":"Current password and new password for the authenticated moderator.","typeName":"ICommunityPortalModerator.IChangePassword"},"responseBody":{"description":"Acknowledgement of successful password change.","typeName":"ICommunityPortalModerator.IChangePasswordResponse"},"authorizationRole":"moderator","name":"changePassword","prerequisites":[],"path":"/auth/moderator/password/change","method":"post"},{"specification":"Create an admin account and issue initial JWT tokens for admin role. Associated Prisma tables: community_portal_admins (admin metadata) and community_portal_users (authentication/profile).","authorizationType":"join","description":"Purpose and overview: This endpoint creates a new admin account and issues initial authorization tokens. It operates against the community_portal_admins and community_portal_users tables: the admin metadata will be recorded in community_portal_admins (user_id, admin_level, is_active, created_at) and the authentication identity will be created in community_portal_users (email, password_hash, username, display_name, created_at). The operation enables platform administrators to obtain an ICommunityPortalAdmin.IAuthorized response that contains issued access and refresh tokens.\n\nImplementation details and field usage: The request payload maps to the admin creation DTO and must include the desired username and email that will be stored in community_portal_users.username and community_portal_users.email, and a password that will be stored as a secure password_hash in community_portal_users.password_hash. The created admin record in community_portal_admins will reference the new user's id in community_portal_admins.user_id and may set community_portal_admins.admin_level and community_portal_admins.is_active. The response reflects the newly created user's id and token data and references community_portal_admins.created_at for auditing.\n\nRole-specific integration and business context: This endpoint is the join (registration) entry for the admin role. It is used when provisioning elevated accounts that will be represented in community_portal_admins. The API consumer should expect the platform to validate uniqueness against community_portal_users.email and community_portal_users.username before creating records. If community_portal_admins.is_active is set, the system will allow the new admin to perform elevated actions once tokens are issued and standard verification checks are satisfied.\n\nSecurity considerations: The request should only transport the raw password in the request body over TLS; the server MUST persist a secure hash in community_portal_users.password_hash and MUST NOT return password or password_hash in responses. The endpoint should validate that community_portal_members.is_email_verified is true for the underlying user if the platform requires an existing verified member before granting admin privileges (refer to community_portal_members.user_id and community_portal_members.is_email_verified). Protect rate-limits and audit the creation via community_portal_admins.created_at and community_portal_users.created_at fields.\n\nRelated operations and workflow: Typical workflow uses POST /auth/admin/join to create the admin and then POST /auth/admin/login to obtain fresh tokens. Follow-up operations include POST /auth/admin/refresh for token renewal and password management operations (password reset/change) that reference community_portal_users.password_hash and community_portal_users.email.","summary":"Create admin account and issue initial tokens (relates to community_portal_admins and community_portal_users)","parameters":[],"requestBody":{"description":"Admin creation payload containing authentication and admin metadata.","typeName":"ICommunityPortalAdmin.ICreate"},"responseBody":{"description":"Authorized response containing access and refresh tokens and minimal admin profile.","typeName":"ICommunityPortalAdmin.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/admin/join","method":"post"},{"specification":"Authenticate an admin and issue access + refresh tokens. Associated Prisma tables: community_portal_users (authentication) and community_portal_admins (admin metadata/is_active).","authorizationType":"login","description":"Purpose and overview: This endpoint authenticates an admin user by validating credentials against community_portal_users.password_hash and, on success, issues JWT-style access and refresh tokens returning ICommunityPortalAdmin.IAuthorized. It also checks admin metadata in community_portal_admins (community_portal_admins.is_active and community_portal_admins.admin_level) to determine if the account is allowed to receive admin-scoped tokens.\n\nImplementation details and field usage: The request body includes credentials that map to community_portal_users.email (or username) and password; the server validates the password against community_portal_users.password_hash. If an admin record exists (community_portal_admins.user_id referencing the user) the server validates community_portal_admins.is_active before issuing admin-scoped tokens. The response contains token expiry metadata and may reference community_portal_admins.admin_level to indicate privilege level.\n\nRole-specific integration and business context: This is the admin login flow and must integrate with the platform's admin roster represented by community_portal_admins. The login operation is expected to enforce any additional platform checks such as account suspension (community_portal_members.is_suspended) or user deletion status (community_portal_users.deleted_at) before granting tokens.\n\nSecurity considerations: Do not expose community_portal_users.password_hash or any internal audit timestamps in the response. Authentication failure should be generic and must not reveal whether an email or username exists in community_portal_users. Successful logins should be audited using community_portal_admins.user_id and community_portal_users.id, recording the login event timestamp (server-side) and respecting rate-limits and multi-factor policies if applied.\n\nRelated operations and workflow: After successful login, clients should use POST /auth/admin/refresh to renew tokens. Password lifecycle operations (reset and change) that update community_portal_users.password_hash are available as separate endpoints. Administrative account activation state can be observed via community_portal_admins.is_active and adjusted via platform management tools.","summary":"Authenticate admin and return authorized tokens (relates to community_portal_users and community_portal_admins)","parameters":[],"requestBody":{"description":"Admin login credentials (email/username + password).","typeName":"ICommunityPortalAdmin.ILogin"},"responseBody":{"description":"Authorized response containing access and refresh tokens and admin metadata.","typeName":"ICommunityPortalAdmin.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/admin/login","method":"post"},{"specification":"Refresh admin access tokens using a valid refresh token. Associated Prisma tables: community_portal_users (token owner) and community_portal_admins (is_active/admin_level used to validate continued admin privileges).","authorizationType":"refresh","description":"Purpose and overview: This endpoint accepts a refresh token and returns a renewed access token (and optionally a rotated refresh token) for an admin represented in community_portal_users and community_portal_admins. The operation ensures the token owner still maps to an active admin entry (community_portal_admins.is_active) before issuing admin-scoped credentials.\n\nImplementation details and field usage: The request body contains the refresh token and the server resolves the token to a user id that corresponds to community_portal_users.id. The server validates that the resolved user has an associated community_portal_admins entry and that community_portal_admins.is_active is true. The response issues a new ICommunityPortalAdmin.IAuthorized payload with updated token lifetimes.\n\nRole-specific integration and business context: This refresh flow is specifically scoped to admin tokens and must consider admin lifecycle changes: if community_portal_admins.is_active has been toggled to false or the admin record removed, the refresh must be denied. Similarly, if community_portal_users.deleted_at is set (user removed), refresh must be denied.\n\nSecurity considerations: Refresh tokens must be validated securely; refresh rotation and revocation are recommended. The endpoint should log token refresh events with references to community_portal_admins.user_id and community_portal_admins.admin_level for auditability. Failure to validate admin state must return an appropriate unauthorized response.\n\nRelated operations and workflow: Clients obtain initial tokens via POST /auth/admin/login or POST /auth/admin/join and then call this endpoint to renew access. Password resets or admin activation/deactivation (changes to community_portal_admins.is_active) impact refresh behavior and should be checked prior to issuing tokens.","summary":"Refresh admin tokens using refresh token (relates to community_portal_users and community_portal_admins)","parameters":[],"requestBody":{"description":"Refresh request payload containing refresh token.","typeName":"ICommunityPortalAdmin.IRefresh"},"responseBody":{"description":"Authorized response containing renewed access token and optional rotated refresh token.","typeName":"ICommunityPortalAdmin.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/admin/refresh","method":"post"},{"specification":"Initiate a password reset for an admin account by email. Associated Prisma table: community_portal_users (email).","authorizationType":null,"description":"Purpose and overview: This endpoint initiates an admin password reset flow by accepting an email address and, if a matching community_portal_users record exists, creating a one-time reset token and delivering it to community_portal_users.email. The operation references the community_portal_users.email field and the reset flow will ultimately update community_portal_users.password_hash.\n\nImplementation details and field usage: The request contains the admin's email (community_portal_users.email). The server generates a single-use reset token tied to the user id and records the issuance for audit. The email sent to the address references community_portal_users.id indirectly via the secure token; the endpoint does not reveal whether the email exists to callers for privacy.\n\nRole-specific integration and business context: Although this is an unauthenticated request, it targets admin accounts and therefore tooling that processes the reset must respect admin lifecycle fields such as community_portal_admins.is_active (to decide whether to allow reset flows for deactivated admin accounts). The reset confirmation step will update community_portal_users.password_hash.\n\nSecurity considerations: Do not disclose account existence; return a generic success response regardless of whether a matching email exists. Rate-limit requests to this endpoint to protect against enumeration and abuse. Record reset request events with timestamps and the target community_portal_users.id when applicable.\n\nRelated operations and workflow: Follow-up endpoint POST /auth/admin/password/confirm completes the reset by accepting the token and new password and updating community_portal_users.password_hash. After reset, clients typically POST /auth/admin/login to authenticate with new credentials.","summary":"Request admin password reset (relates to community_portal_users.email)","parameters":[],"requestBody":{"description":"Password reset request containing the admin email address.","typeName":"ICommunityPortalAdmin.IResetRequest"},"responseBody":{"description":"Acknowledgement of reset request (generic success to avoid account enumeration).","typeName":"ICommunityPortalAdmin.IResetRequestResponse"},"authorizationRole":null,"name":"requestPasswordReset","prerequisites":[],"path":"/auth/admin/password/reset","method":"post"},{"specification":"Confirm a password reset using a one-time token and set a new password. Associated Prisma table: community_portal_users (password_hash).","authorizationType":null,"description":"Purpose and overview: This endpoint finalizes a password reset by accepting a one-time reset token and a new password, validating the token, and updating community_portal_users.password_hash for the referenced user. It ensures the token maps to a valid community_portal_users.id before performing the update.\n\nImplementation details and field usage: The request payload includes the reset token and the desired new password. The server validates the token, resolves it to community_portal_users.id, and replaces the stored community_portal_users.password_hash with a secure hash of the new password. The operation updates community_portal_users.updated_at for auditability.\n\nRole-specific integration and business context: This operation is typically used when an admin user cannot authenticate and has used POST /auth/admin/password/reset to request assistance. After successfully changing the password, the user may be redirected to POST /auth/admin/login. If the user also has a community_portal_admins record, the system may optionally re-evaluate community_portal_admins.is_active as part of post-reset checks.\n\nSecurity considerations: Validate the reset token for expiry and single-use semantics. After a successful reset, revoke other active refresh tokens for that user to prevent session fixation. Record the password change event for audit referencing community_portal_users.id and the timestamp in community_portal_users.updated_at.\n\nRelated operations and workflow: Token issuance occurs in POST /auth/admin/password/reset; after confirmation clients authenticate via POST /auth/admin/login. For privileged accounts, consider requiring reauthentication or MFA after password reset for sensitive admin actions.","summary":"Confirm admin password reset and set new password (relates to community_portal_users.password_hash)","parameters":[],"requestBody":{"description":"Reset confirm payload containing token and new password.","typeName":"ICommunityPortalAdmin.IResetConfirm"},"responseBody":{"description":"Acknowledgement of password change and guidance to re-authenticate.","typeName":"ICommunityPortalAdmin.IResetConfirmResponse"},"authorizationRole":null,"name":"confirmPasswordReset","prerequisites":[{"endpoint":{"path":"/auth/admin/password/reset","method":"post"},"description":"A password reset token must have been issued for the admin account before confirmation. POST /auth/admin/password/reset creates the one-time reset token tied to community_portal_users.email; if this prerequisite fails, the confirm operation cannot validate a token or resolve the target community_portal_users.id."}],"path":"/auth/admin/password/confirm","method":"post"},{"specification":"Change password for an authenticated admin. Associated Prisma tables: community_portal_users (password_hash) and community_portal_admins (user privileges checked prior to allowing operation).","authorizationType":null,"description":"Purpose and overview: This endpoint allows an authenticated admin (represented by community_portal_users.id and linked community_portal_admins record) to change their password by providing the current password and a new password. The operation updates community_portal_users.password_hash and community_portal_users.updated_at.\n\nImplementation details and field usage: The request body contains currentPassword and newPassword. The server validates the current password against community_portal_users.password_hash and, if valid, stores a secure hash of newPassword in community_portal_users.password_hash. Before performing the change, the server may verify the admin has an active community_portal_admins entry (community_portal_admins.is_active) to ensure only active admins perform this operation.\n\nRole-specific integration and business context: This endpoint requires an authenticated admin context; the controller must verify the bearer token maps to a community_portal_users.id that has an associated community_portal_admins record. The change updates the user's credential record and is auditable via community_portal_users.updated_at.\n\nSecurity considerations: Require the current password to mitigate token theft scenarios. Upon successful change, rotate or revoke refresh tokens and log the event with reference to community_portal_admins.user_id. Enforce password strength rules and prevent reuse of recent passwords if the platform enforces such history.\n\nRelated operations and workflow: This operation complements the reset flows (POST /auth/admin/password/reset and POST /auth/admin/password/confirm). After changing the password, the client should reauthenticate via POST /auth/admin/login if tokens were revoked.","summary":"Change password for authenticated admin (relates to community_portal_users.password_hash and community_portal_admins.is_active)","parameters":[],"requestBody":{"description":"Payload with currentPassword and newPassword for authenticated admin.","typeName":"ICommunityPortalAdmin.IChangePassword"},"responseBody":{"description":"Acknowledgement of password change; tokens may be rotated or revoked.","typeName":"ICommunityPortalAdmin.IChangePasswordResponse"},"authorizationRole":"admin","name":"changePassword","prerequisites":[],"path":"/auth/admin/password","method":"put"},{"specification":"Verify admin's email address using a verification token. Associated Prisma table: community_portal_members (is_email_verified) and community_portal_users (email).","authorizationType":null,"description":"Purpose and overview: This endpoint accepts an email verification token and, when valid, updates community_portal_members.is_email_verified for the linked user record. The operation references community_portal_users.email to locate the account and community_portal_members.user_id/is_email_verified to record verification state.\n\nImplementation details and field usage: The request receives a verification token (usually issued at registration) and resolves it to community_portal_users.id. The server then updates the related community_portal_members.is_email_verified to true and sets community_portal_members.updated_at. The verification event may also be recorded in community_portal_users.updated_at for auditing.\n\nRole-specific integration and business context: Email verification is required by many flows (e.g., allowing token issuance or gating admin privileges). For admin accounts, callers should be aware that community_portal_admins.is_active may be contingent on verification; the platform can choose to enforce community_portal_members.is_email_verified before enabling admin-scoped tokens.\n\nSecurity considerations: Tokens must be single-use and time-limited. The endpoint should not disclose extraneous account data. Successful verification should be auditable and linked to community_portal_users.id and community_portal_members.user_id. If the account is suspended (community_portal_members.is_suspended), verification may be recorded but should not automatically lift suspension.\n\nRelated operations and workflow: Tokens are typically issued during POST /auth/admin/join or during user invitation flows. After verification, the client proceeds to authenticate via POST /auth/admin/login to obtain admin tokens.","summary":"Verify admin email using token (relates to community_portal_members.is_email_verified and community_portal_users.email)","parameters":[],"requestBody":{"description":"Email verification payload containing the verification token.","typeName":"ICommunityPortalAdmin.IVerifyEmail"},"responseBody":{"description":"Acknowledgement of verification and guidance to authenticate.","typeName":"ICommunityPortalAdmin.IVerifyEmailResponse"},"authorizationRole":null,"name":"verifyEmail","prerequisites":[],"path":"/auth/admin/email/verify","method":"post"},{"specification":"This operation retrieves a filtered, paginated list of user accounts from the Prisma model community_portal_users. It is intended to support administrative and discovery UIs that need to search, filter, sort, and page over user profiles. The operation maps directly to the community_portal_users table defined in the Prisma schema and must respect the schema's fields and privacy considerations (for example, password_hash exists in the table but MUST NOT be exposed by this API). Implementation should use the model's indexed fields (username, email, karma, created_at) for efficient filtering and sorting. Sensitive filters (email-based search), bulk export, and inclusion of archived records MUST require appropriate authorization and auditing.","path":"/communityPortal/users","method":"patch","summary":"Search and retrieve a filtered, paginated list of CommunityPortal users","description":"Retrieve a filtered and paginated list of user profiles from the community_portal_users table. This operation supports complex queries such as partial username/display_name matching, karma range filtering, sorting by karma or creation date, and pagination. By default the operation excludes soft-deleted users (community_portal_users.deleted_at IS NULL) and does not expose sensitive fields such as password_hash.\n\nSecurity and permissions: Basic discovery of public profile summaries may be permitted for unauthenticated callers, but any request that requests sensitive fields (email), performs email-based lookup, requests includeArchived=true, or requests bulk export must require authentication and explicit authorization. Audit access to email-based searches is REQUIRED. Returned user summaries include only public profile fields (id, username, display_name, bio, avatar_uri, karma, created_at) unless the caller is authorized to receive more details.\n\nRelationship to DB entity: This operation directly references the community_portal_users Prisma model. The model's fields such as id, username, email, password_hash, display_name, bio, avatar_uri, karma, created_at, updated_at, deleted_at are present in schema. The operation may optionally join to community_portal_members to restrict to verified members (is_email_verified) when requested and authorized.\n\nValidation and error handling: The request body must conform to ICommunityPortalUser.IRequest schema (search filters, pagination). Requests with invalid pagination/sort parameters SHOULD return 400 Bad Request. If the operation is rate-limited, return 429 with retry information. On internal errors return 500. Empty result sets return an empty data array with pagination meta.","parameters":[],"requestBody":{"description":"Search criteria and pagination parameters for user filtering (ICommunityPortalUser.IRequest). Implementations MUST include controls for includeArchived and sensitive filters to enforce authorization.","typeName":"ICommunityPortalUser.IRequest"},"responseBody":{"description":"Paginated list of user summary information matching search criteria (IPageICommunityPortalUser.ISummary). Returned summaries MUST NOT include password_hash or other sensitive secrets.","typeName":"IPageICommunityPortalUser.ISummary"},"authorizationType":null,"authorizationRole":null,"prerequisites":[],"name":"index"},{"specification":"This operation retrieves a single user profile from the Prisma model community_portal_users by its primary key (id). It is intended to power public profile pages and account detail screens. The operation is strictly read-only and must not return sensitive authentication fields such as password_hash. When the Prisma record has deleted_at set (soft-deleted), the API should treat the user as not found for public consumption or return 404 depending on policy. Access to PII (email) or membership flags requires authorization.","path":"/communityPortal/users/{userId}","method":"get","summary":"Retrieve a single CommunityPortal user profile by ID","description":"Return the public profile for a single user from the community_portal_users table identified by the path parameter userId.\n\nPurpose and overview: This endpoint is intended for profile pages and content attribution. It returns public profile fields (id, username, display_name, bio, avatar_uri, karma, created_at, updated_at). It references the Prisma schema comments that document these fields and the soft-delete behavior (deleted_at).\n\nSecurity and user permissions: Public callers may retrieve basic profile data. Any request that attempts to access sensitive details (email, membership flags, internal notes) must require authentication and explicit authorization. The API MUST NOT return password_hash under any circumstance.\n\nRelationship to DB entity and validation: The endpoint maps directly to the community_portal_users model. Validate userId as a UUID and exclude records where deleted_at is set by default. If not found, return 404 with a clear message.\n\nError handling: 400 for invalid UUID format, 404 when user not found or soft-deleted (policy-dependent), 500 for internal errors. 401 when the implementation requires authentication for this resource and the caller is unauthenticated.","parameters":[{"name":"userId","in":"path","description":"Unique identifier of the target user","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"User public profile information (ICommunityPortalUser). Returned fields are public profile attributes; PII is excluded unless the caller is authorized.","typeName":"ICommunityPortalUser"},"authorizationType":null,"authorizationRole":null,"prerequisites":[],"name":"at"},{"specification":"Update operation for the community_portal_users table. This operation updates editable profile attributes for a user account. It maps directly to the Prisma model community_portal_users and is intended for account owners to modify profile-related fields such as display_name, bio, avatar_uri, and to submit a new plaintext password for server-side hashing into password_hash. The implementation MUST validate the path parameter userId (UUID), verify the authenticated caller is the account owner, reject updates to protected fields (username, email, karma, created_at, deleted_at), and treat records with deleted_at != null as not found. The operation should persist the change, update updated_at, and emit an audit record. It must never return password_hash in the response. Transport and logging requirements: endpoint MUST be served over TLS, request bodies containing password MUST NOT be logged, and password strength must be validated. Rate-limiting and abuse protections for password changes are recommended.","path":"/communityPortal/member/users/{userId}","method":"put","summary":"Update an existing user's editable profile fields (community_portal_users)","description":"This endpoint allows an authenticated account owner to update their own editable profile fields stored in community_portal_users. It accepts profile fields and an optional plaintext password to be hashed by the server. The response returns the public view of the updated user and MUST NOT include password_hash or any secret fields.\n\nSecurity and authorization:\nOnly the authenticated account owner may call this endpoint for their userId. The server MUST authenticate the request and verify ownership (authenticated user id must equal path userId). Admin-level overrides, if allowed, must be explicitly modeled in separate admin endpoints.\n\nDatabase relation and behavior:\nMaps to the Prisma model community_portal_users. The presence of deleted_at indicates soft-deletion; updates to soft-deleted accounts are rejected with 404. The server must not cascade-delete related resources; related posts/comments/votes remain and should be handled by separate moderation processes.\n\nValidation and business logic:\n- Path parameter userId (UUID) is required and must reference an existing, non-deleted user.\n- Writable body fields: display_name (string | null), bio (string | null), avatar_uri (string | null), password (string | null) — password triggers server-side hashing and storage in password_hash; plaintext password MUST NOT be returned.\n- Protected fields: username, email, karma, created_at, deleted_at are not writable via this endpoint and must be rejected if present in the request.\n- The server SHOULD validate password strength and apply optimistic concurrency via updated_at where feasible.\n\nErrors and edge cases:\n- 400 Bad Request: invalid payload or attempt to modify protected fields.\n- 401 Unauthorized: caller not authenticated.\n- 403 Forbidden: authenticated caller not the account owner.\n- 404 Not Found: userId does not exist or account already soft-deleted.\n- 429 Too Many Requests: rate limits exceeded for password changes.\n- 500 Internal Server Error: unexpected failures.","parameters":[{"name":"userId","description":"Target user's ID (UUID) to update","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Editable user profile fields. Provide only fields to change. If password is provided, server will hash it; plaintext password is never returned.","typeName":"ICommunityPortalUser.IUpdate"},"responseBody":{"description":"Updated public user representation (excludes password_hash). Includes fields such as id, username, display_name, bio, avatar_uri, karma, created_at, updated_at.","typeName":"ICommunityPortalUser.ISummary"},"authorizationType":null,"authorizationRole":"member","name":"update","prerequisites":[]},{"specification":"Soft-delete operation for the community_portal_users table. Because the Prisma schema includes deleted_at for community_portal_users, this endpoint performs a soft-delete by setting deleted_at to the current timestamp. The intent is to preserve audit trails and related content for moderation and legal purposes. The operation verifies caller authorization (account owner) and records an audit entry. Permanent purge and admin-driven removal are out of scope. Decide platform-wide idempotency for deletes (404 vs 204) and document the chosen behavior.","path":"/communityPortal/member/users/{userId}","method":"delete","summary":"Soft-delete (mark deleted_at) a user account in community_portal_users","description":"This endpoint marks the specified user account as deleted by setting deleted_at on the community_portal_users record. It preserves the row for audit, moderation, and legal traceability and does not cascade-remove related posts/comments/votes.\n\nSecurity and permissions:\nOnly the authenticated account owner may request this soft-delete. The server MUST authenticate and verify ownership. Admin-level permanent deletion or legal holds are outside the scope of this user-facing endpoint.\n\nDatabase relation and behavior:\nMaps to community_portal_users. The operation MUST not cascade-delete related content as a side-effect; content references should remain for audit. If deleted_at is already set, the server SHOULD return 404 Not Found or 204 No Content according to platform-wide idempotency policy (recommend documenting one behavior and applying it consistently).\n\nBusiness rules and validation:\n- Path parameter userId (UUID) is required and must reference an existing user.\n- If the record's deleted_at is already set, return 404 Not Found (or 204 if idempotent semantics are chosen).\n- The server MUST create an auditable entry recording actor id, timestamp, and optional reason.\n\nErrors and edge cases:\n- 401 Unauthorized when the caller is not authenticated.\n- 403 Forbidden when authenticated but not the account owner.\n- 404 Not Found when userId not found or already deleted (if 404 semantics chosen).\n- 500 Internal Server Error for unexpected failures.","parameters":[{"name":"userId","description":"Target user's ID (UUID) to delete","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationType":null,"authorizationRole":"member","name":"erase","prerequisites":[]},{"specification":"Retrieves a paginated, filterable list of communities from the community_portal_communities table in the Prisma schema. This operation is designed to support discovery, search, and listing workflows for communityPortal and maps directly to the community_portal_communities model. It leverages community attributes such as id, creator_user_id, name, slug, description, is_private, visibility, created_at, updated_at and deleted_at (the latter used to exclude archived records from results). The operation returns community summary data suitable for list views and supports pagination, sorting, and basic filtering (by name, slug, visibility, and creator) via the request DTO.\n\nThis specification references the Prisma model comments for community_portal_communities: the creator_user_id is nullable to avoid cascade deletion; slug is a URL-friendly unique identifier; deleted_at indicates archived records and should be excluded from standard listings. Implementers should honor the visibility and is_private attributes: unauthenticated callers must only receive public communities, while an authenticated user may receive additional results (their private communities or communities they have membership/subscription for) depending on authorization checks.\n\nBusiness-level validation rules: name and slug matching should be case-insensitive (slug canonicalized on write). Requests that ask for specific slug or creator filters should validate formats (slug pattern) and apply canonicalization before lookup. Pagination parameters must be validated (limit must be positive, offset >= 0). Sorting accepts a mode and direction; when sorting by relevance or text search, use indexed trigram search as indicated in the Prisma indexes. The Prisma schema's indexes (created_at, visibility, name GIN trigram) are provided as guidance for backend implementation and do not alter the request/response contract.\n\nRelated operations: GET /communities/{communityId} returns a single community detail (useful for detail pages). Error handling: invalid request payloads return 400; if authenticated-only filters are requested by an unauthenticated caller, return 401; server errors return 500. The response payload is a paginated summary (IPageICommunityPortalCommunity.ISummary) containing community summary records and pagination metadata.","path":"/communityPortal/communities","method":"patch","summary":"Search and retrieve a filtered, paginated list of communities","description":"Retrieve a filtered and paginated list of communities from the system. This operation supports name/slug search, visibility filtering, pagination, and sorting. It returns community summary information optimized for list displays (slug, name, short description, is_private, visibility, creator reference and timestamps).\n\nSecurity considerations and permissions: public communities are visible to unauthenticated callers; private communities are only included when the requesting user is authorized to view them (membership, subscription, or explicit access). The endpoint returns only communities with deleted_at set to null (archived records are omitted). When clients request extra detail (e.g., includeModeratorSummary), results may be restricted to authorized callers.\n\nRelationship to the Prisma schema: maps to the community_portal_communities model. The slug field is unique and suitable for canonical lookups; creator_user_id is nullable per schema comments and must be handled accordingly in result shaping. Use the provided DB indexes (created_at, visibility, name trigram) to implement performant listing and search.\n\nValidation and business logic: validate pagination params (limit, offset), enforce maximum allowed page size, validate sort mode values, and canonicalize slug filters. If a caller supplies an invalid visibility filter or unsupported sort value, return 400 with validation details.\n\nRelated API operations: GET /communities/{communityId} for detail retrieval. Error behavior: 400 for invalid inputs, 401 when requesting private data without authentication, 500 for server errors.","parameters":[],"requestBody":{"description":"Search criteria and pagination parameters for community filtering","typeName":"ICommunityPortalCommunity.IRequest"},"responseBody":{"description":"Paginated list of community summary information matching search criteria","typeName":"IPageICommunityPortalCommunity.ISummary"},"authorizationRoles":[],"name":"index","authorizationRole":null,"authorizationType":null,"prerequisites":[]},{"specification":"Retrieves a single community record by its primary identifier from the community_portal_communities table in the Prisma schema. This operation returns the community's full business representation (ICommunityPortalCommunity) including id, creator_user_id, name, slug, description, is_private, visibility, created_at, updated_at. The operation respects the model comment that creator_user_id is nullable and the presence of deleted_at (archived records) — archived/ deleted communities must not be returned to callers unless the caller has explicit elevated privileges and a business reason.\n\nThis specification references the Prisma model comments for community_portal_communities: slug is a URL-friendly unique identifier; soft-archive timestamp (deleted_at) indicates records that are not active and should be excluded from normal retrievals; creator_user_id may be null, so API responses must handle missing creator information gracefully. Implementers should ensure that for private communities the endpoint enforces membership or subscription-based visibility and returns 403 or 401 when the caller lacks access.\n\nValidation rules and expected behavior: validate that communityId is a UUID and that the target community exists and is active (deleted_at null) unless the caller is authorized to retrieve archived records. If the community is private and the caller is unauthenticated or not a member, the API should return 401/403 per platform policy. Related operations: PATCH /communities for search/list. Error handling: 400 for malformed communityId, 404 when community not found or not visible to the caller, 401 for unauthenticated access to private content, 500 for internal errors.","path":"/communityPortal/communities/{communityId}","method":"get","summary":"Retrieve community details by ID","description":"Fetch detailed information for a single community identified by its UUID. The response includes canonical fields: id, name, slug, description, is_private, visibility, creator reference (if present), and timestamps. The API handles nullable creator_user_id per schema guidance and returns a normalized representation suitable for community detail pages.\n\nSecurity considerations and user permissions: Public communities are viewable by any caller. Private communities are visible only to authorized members or subscribers; unauthenticated callers will receive a 401 or a 403 according to policy. The endpoint excludes archived records (deleted_at not null) from normal results; attempts to access archived communities without elevated privileges should yield 404 to avoid information leakage.\n\nRelationship to underlying DB entity: maps directly to community_portal_communities in the Prisma schema. The slug field is suitable for alternate lookups (frontend-friendly); however, this endpoint is specifically by UUID. Validation rules: communityId must be a UUID; return 400 for invalid format.\n\nValidation and error handling: 400 for invalid UUID format, 404 when community does not exist or is not visible to caller, 401 for unauthenticated requests to private communities, and 500 for server errors. Related API operations: PATCH /communities for searching and listing communities.\n","parameters":[{"name":"communityId","description":"Unique identifier of the target community","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed community information","typeName":"ICommunityPortalCommunity"},"authorizationRoles":[],"name":"at","authorizationRole":null,"authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"The community resource must exist before it can be retrieved. POST /communityPortal/member/communities creates a community record (community_portal_communities) and returns its generated id; creating this resource ensures the {communityId} used by GET /communityPortal/communities/{communityId} references a valid, active community. If the creation fails or the community is archived (deleted_at set), the GET will not succeed (404 or access error)."}]},{"specification":"Operation for creating a CommunityPortal community (maps to Prisma model: community_portal_communities). This POST /communityPortal/member/communities operation creates a new community record in the community_portal_communities table. It validates required business properties derived from the Prisma model (name, slug, is_private, visibility) and records creator relationship server-side using the authenticated user id. The operation implements application-level uniqueness validation for slug/name (Prisma model enforces @@unique([slug])) and enforces allowed value constraints for visibility at the application layer. The operation persists created_at and updated_at timestamps and returns the canonical community representation. This operation must align with the community_portal_communities model: id (UUID), creator_user_id (nullable UUID), name, slug, description (nullable), is_private (boolean), visibility (string), created_at (timestamp), updated_at (timestamp), deleted_at (nullable timestamp). Clients MUST NOT supply id or timestamps; creator_user_id is derived from authentication.","path":"/communityPortal/member/communities","method":"post","summary":"Create a new community (community_portal_communities)","description":"Create a new community (community_portal_communities) in the CommunityPortal service.\n\nPurpose and overview:\nThis operation allows an authenticated user to create a new community record that corresponds directly to the Prisma model community_portal_communities. The request accepts the community's human-readable name, an optional canonical slug (server may derive from name), optional description, and visibility flags. The server derives the creator_user_id from the authenticated caller and ignores client-supplied id/timestamps.\n\nSecurity and permissions:\nOnly authenticated users (role: \"member\") may create communities. The API expects a bearer token; server maps token to user and sets creator_user_id. Inputs must be validated for reserved names and allowed visibility values.\n\nValidation rules and expected behavior:\n- Required: name and either provided slug or server will canonicalize slug from name.\n- description is optional and may be null.\n- is_private is required boolean indicating invite-only communities.\n- visibility is required and validated by application logic.\n- If slug already exists, return 409 Conflict.\n\nError handling:\n- 400 Bad Request: missing required fields or invalid formats.\n- 401 Unauthorized: unauthenticated request.\n- 409 Conflict: slug already in use.\n- 422 Unprocessable Entity: business validation errors.","parameters":[],"requestBody":{"description":"Community creation payload. Client-supplied fields: name (required), slug (optional), description (optional), is_private (required), visibility (required). Server-derived: creator_user_id, id, created_at, updated_at, deleted_at (excluded).","typeName":"ICommunityPortalCommunity.ICreate"},"responseBody":{"description":"Created community representation (server-managed fields returned: id, creator_user_id, name, slug, description, is_private, visibility, created_at, updated_at, deleted_at).","typeName":"ICommunityPortalCommunity"},"authorizationType":null,"authorizationRole":"member","name":"create","prerequisites":[]},{"specification":"Operation for updating a CommunityPortal community (maps to Prisma model: community_portal_communities). This PUT /communityPortal/member/communities/{communityId} operation updates mutable fields of an existing community record. It operates against the Prisma model community_portal_communities and may update fields including name, slug, description, is_private, and visibility. The operation validates communityId as UUID and enforces slug uniqueness if changed. Server enforces authorization: caller must be community creator OR an active moderator for the community OR an admin. Soft-deleted communities (deleted_at != null) are treated as not found.","path":"/communityPortal/member/communities/{communityId}","method":"put","summary":"Update an existing community (community_portal_communities) by ID","description":"Update an existing community (community_portal_communities) by its ID.\n\nPurpose and overview:\nThis operation updates mutable attributes of a community stored in the Prisma model. Typical updates include name, slug, description, is_private, and visibility. The operation requires communityId path parameter and authentication. Server must verify caller's rights (creator, assigned moderator, or admin) before applying changes. Server-managed fields (created_at, deleted_at) cannot be modified via this API.\n\nSecurity and permissions:\nAuthenticated users (role: \"member\") may call this endpoint, but the server MUST enforce that only the community creator, an active moderator assigned to the community, or an admin may perform the update. Requests from other members must return 403 Forbidden.\n\nValidation and behavior:\n- Path parameter communityId must be a valid UUID matching an existing non-deleted community.\n- Request body properties are optional and only provided fields are applied.\n- If slug is provided and changed, validate uniqueness and allowed characters; return 409 on conflict.\n- Server must not allow updates to created_at or deleted_at via this endpoint.\n\nErrors:\n- 400 Bad Request: invalid input.\n- 401 Unauthorized: unauthenticated request.\n- 403 Forbidden: caller lacks owner/moderator/admin rights.\n- 404 Not Found: communityId does not exist or is soft-deleted.\n- 409 Conflict: slug already in use.\n","parameters":[{"name":"communityId","description":"Unique identifier (UUID) of the target community","schema":{"type":"string","format":"uuid"},"in":"path","required":true}],"requestBody":{"description":"Community update payload (partial) - only provided fields will be updated. Allowed client-updatable fields: name, slug, description, is_private, visibility.","typeName":"ICommunityPortalCommunity.IUpdate"},"responseBody":{"description":"Updated community representation","typeName":"ICommunityPortalCommunity"},"authorizationType":null,"authorizationRole":"member","name":"update","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"The community resource must exist before it can be updated. This prerequisite creates (or ensures existence of) a community_portal_communities record and provides a valid communityId used by the PUT operation. If this creation fails or does not return a valid id, the update cannot proceed; the POST response supplies the community representation required by the update flow."}]},{"specification":"Operation targets Prisma model community_portal_communities. Performs a soft-delete by setting deleted_at. Verifies actor authorization: only platform admins, the community creator, or an active assigned moderator (as recorded in community_portal_moderators) may perform this action. Validates communityId is a UUID and that the community currently has deleted_at == null. The operation records an application-level audit entry (implementation detail) and triggers downstream business workflows (notify subscribers, reassign moderators) outside of the DB mutation. Associated Prisma fields referenced: id, creator_user_id, name, slug, description, created_at, deleted_at. No fields outside schema are referenced.","path":"/communityPortal/member/communities/{communityId}","method":"delete","summary":"Soft-delete a community by setting deleted_at (community_portal_communities)","description":"Purpose and overview:\nThis endpoint performs a controlled soft-delete of a Community (Prisma model: community_portal_communities) by setting its deleted_at timestamp. The intent is to hide the community from public listings while preserving rows and related records (posts, subscriptions, reports, moderators) for audit and appeal.\n\nSecurity and permissions:\nOnly authorized actors may perform this action. The service MUST enforce that the caller is either:\n- a platform-level admin (operation-level authorization), OR\n- the community.creator_user_id (ownership check), OR\n- an active assigned moderator for the community with removal privileges (checked via community_portal_moderators where is_active==true).\nIf the caller is not authorized, return 403 Forbidden. If the community does not exist or deleted_at is already set, return 404 Not Found.\n\nValidation and business rules:\n- Validate communityId is a UUID and that the community exists with deleted_at == null before making changes.\n- The operation MUST be idempotent: repeated requests do not produce duplicate side effects.\n- The DB mutation sets deleted_at to current UTC timestamp; child records are preserved.\n- Audit logging and downstream notifications are implementation-level responsibilities and must not be exposed as writeable API parameters.\n\nErrors and expected responses:\n- 400 Bad Request for malformed UUID\n- 401 Unauthorized for unauthenticated calls\n- 403 Forbidden for unauthorized callers\n- 404 Not Found if community not found or already deleted\n- 500 Internal Server Error for unexpected failures","parameters":[{"name":"communityId","in":"path","description":"Target community's unique identifier (UUID)","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationType":null,"authorizationRole":"admin","name":"erase","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"The community must exist and be active (deleted_at == null) before performing a soft-delete. This prerequisite creates (or ensures existence of) the community_portal_communities record and yields a valid communityId; without a valid existing community the erase operation will return Not Found or fail validation. This ensures the delete operation has a concrete target with initial persisted state."}]},{"specification":"Operation targets Prisma model community_portal_subscriptions. Returns a paginated list of subscription summaries filtered and sorted according to request parameters. By default returns only active subscriptions (deleted_at is null) for the authenticated caller. If a requester supplies a userId different from the authenticated caller, the service MUST deny the request with 403 unless the caller has admin privileges. Supported filters: userId (UUID), communityId (UUID), activeOnly (boolean). Sorting: created_at asc/desc. Pagination: limit, offset. References Prisma fields: id, user_id, community_id, created_at, deleted_at.","path":"/communityPortal/member/subscriptions","method":"patch","summary":"List subscriptions with filters, sorting, and pagination (community_portal_subscriptions)","description":"Purpose and overview:\nReturn a paginated, filterable list of community subscriptions (Prisma model: community_portal_subscriptions). Intended primarily for \"My subscriptions\" UI but supports admin-scoped queries with appropriate authorization.\n\nSecurity and privacy:\n- The endpoint requires authentication. By default it returns subscriptions for the authenticated user only.\n- If the request includes a userId filter that differs from the authenticated user's id, the server MUST return 403 Forbidden unless the caller has admin privileges.\n- The operation must never leak other users' subscription lists to unauthorized callers.\n\nFiltering, sorting, and pagination:\n- Filters supported: userId (UUID), communityId (UUID), activeOnly (boolean to exclude soft-deleted rows).\n- Sorting: created_at asc/desc.\n- Pagination: limit (positive integer), offset (non-negative integer).\n- Implementers may optimize the common case (authenticated user's subscriptions) using indexes on user_id and community_id.\n\nValidation and errors:\n- 400 Bad Request: invalid UUIDs, negative offset, non-positive limit\n- 401 Unauthorized: unauthenticated request\n- 403 Forbidden: requesting another user's subscriptions without admin privileges\n- 500 Internal Server Error: unexpected failures\n\nResponse behavior:\nReturn a paginated container: { total: number, limit: number, offset: number, data: [ { id, user_id, community_id, created_at } ] }","parameters":[],"requestBody":{"description":"Search and pagination parameters for subscription listing (filters: userId, communityId, activeOnly; pagination: limit, offset; sort: created_at asc/desc)","typeName":"ICommunityPortalSubscription.IRequest"},"responseBody":{"description":"Paginated list of subscription summary items","typeName":"IPageICommunityPortalSubscription.ISummary"},"authorizationType":null,"authorizationRole":"member","name":"index","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"The target community must exist before listing or filtering subscriptions by communityId. Creating the community (POST /communityPortal/member/communities) ensures the supplied communityId is valid; if this prerequisite fails, requests that filter by that communityId should return 404 Not Found or be rejected as invalid."}]},{"specification":"Retrieve a single subscription record from the community_portal_subscriptions Prisma model. This operation reads the subscription by its primary key (id) and returns the subscription business object. It maps directly to the Prisma model community_portal_subscriptions and exposes its primary attributes (id, user_id, community_id, created_at, updated_at, deleted_at). The operation treats deleted_at as soft-delete flag and surfaces deleted_at for owner audit. Server implementation MUST verify the authenticated user is the subscription owner (subscription.user_id) before returning the resource.","path":"/communityPortal/member/subscriptions/{subscriptionId}","method":"get","summary":"Retrieve a subscription by ID","description":"Purpose and overview: Return a subscription entry from the community_portal_subscriptions table by its UUID identifier. The response includes the subscription's id, user_id, community_id, created_at, updated_at, and deleted_at so the authenticated owner can determine active vs revoked status.\n\nSecurity and permissions: Requires an authenticated member. The service MUST verify the requesting member is the owner of the subscription (match on user_id) before returning the resource to avoid exposing other users' subscriptions. If not authorized, return 403 Forbidden or 404 per policy.\n\nRelationship to DB entities: Operates on the Prisma model community_portal_subscriptions. The response DTO corresponds to ICommunityPortalSubscription and reflects the model attributes.\n\nValidation and business rules: Path parameter subscriptionId must be a UUID. If the subscription does not exist return 404 Not Found. If the subscription exists but is soft-deleted, this endpoint returns the record including deleted_at for the owner to allow audit; product policy may choose to hide revoked subscriptions (in which case return 404) — be explicit in implementation.","parameters":[{"name":"subscriptionId","description":"Unique identifier of the target subscription (UUID)","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Subscription information for the given id","typeName":"ICommunityPortalSubscription"},"authorizationType":null,"authorizationRole":"member","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"Ensure the parent community exists because subscriptions reference a community_id. Creating the community provides a valid communityId that subscriptions can reference; without it subscription creation may fail."},{"endpoint":{"path":"/communityPortal/member/communities/{communityId}/subscriptions","method":"post"},"description":"A subscription record must be created before it can be retrieved by subscriptionId. This POST operation creates a community_portal_subscriptions record and returns its id; if this prerequisite is not executed successfully the retrieval will return 404 Not Found."}],"name":"at"},{"specification":"Revoke (soft-delete) a subscription in the community_portal_subscriptions Prisma model by setting deleted_at to current timestamp. Because the model includes deleted_at, this operation marks the record as revoked rather than hard-deleting the row. Implementations MUST handle re-subscribe semantics (either reactivate existing soft-deleted row or use a partial unique index) to avoid unique constraint violations on (user_id, community_id). Only the subscribing authenticated member may revoke their own subscription; server MUST verify ownership before performing the update. The operation preserves the record for audit and emits events for downstream feed/cache invalidation.","path":"/communityPortal/member/subscriptions/{subscriptionId}","method":"delete","summary":"Revoke (soft-delete) a subscription","description":"Purpose and overview: Mark a subscription as revoked by updating its deleted_at timestamp. This preserves the subscription record in the community_portal_subscriptions table for auditing and potential recovery.\n\nSecurity and permissions: Requires an authenticated member. The service MUST verify the requesting member is the owner of the subscription (user_id) before revoking it. This endpoint is for self-service revocation.\n\nBehavior and business rules: Path parameter subscriptionId must be a UUID. If the subscription is already soft-deleted (deleted_at non-null) the endpoint should be idempotent and return 204 No Content. If the subscription is not found, return 404 Not Found. On successful revoke, return 204 No Content. IMPORTANT: because the model enforces @@unique([user_id, community_id]), re-subscribe behavior must be defined: either reactivate the existing row (clear deleted_at) or implement a partial unique index WHERE deleted_at IS NULL to allow new inserts.\n\nError handling: 400 for invalid UUID, 401 if unauthenticated, 403 if the authenticated user is not the subscription owner, 404 if not found. This operation returns no response body on success.","parameters":[{"name":"subscriptionId","description":"Unique identifier of the target subscription (UUID)","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationType":null,"authorizationRole":"member","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"Create the parent community (community_portal_communities). A subscription references a community_id, so the community must exist before a subscription can be created. If this step fails, the subscription cannot be established and the subscriptionId required by the revoke operation will not exist."},{"endpoint":{"path":"/communityPortal/member/communities/{communityId}/subscriptions","method":"post"},"description":"Create the subscription record (community_portal_subscriptions). The revoke (soft-delete) operation requires an existing subscriptionId. This POST creates the subscription (user_id derived from authenticated context and community_id provided) that must exist before it can be revoked."}],"name":"erase"},{"specification":"Retrieve a paginated list of subscription summaries for a specific user. This operation reads from the Prisma model community_portal_subscriptions and returns active (non-soft-deleted) subscription records linked to the specified community_portal_users.id. The response includes minimal related community summary data (community id, slug, name, visibility) from community_portal_communities for UI rendering. Business rules: by default only subscriptions with community_portal_subscriptions.deleted_at IS NULL are returned; inclusion of archived (soft-deleted) subscriptions is controlled by the optional includeArchived query flag and caller authorization (enforced in service/business logic). The operation validates the userId path parameter as a UUID and respects community visibility rules for private communities.","path":"/communityPortal/member/users/{userId}/subscriptions","method":"get","summary":"List subscriptions for a user (paginated)","description":"Return a paginated list of the specified user's community subscriptions.\n\nThis operation retrieves subscription summaries sourced from the community_portal_subscriptions Prisma model and includes minimal related community fields (id, slug, name, visibility) to aid UI presentation. By default only active subscriptions (community_portal_subscriptions.deleted_at IS NULL) are returned; archived/revoked subscriptions may be included only when the caller is authorized and supplies the includeArchived query flag.\n\nSecurity and permissions: Requires an authenticated member context. By default a user may retrieve only their own subscriptions; platform policy may allow moderators/admins to fetch other users' subscriptions (authorization enforced in the service layer). The implementation must enforce community visibility rules so that private communities appear only when the requester has access.\n\nValidation and errors: Path parameter userId MUST be a UUID corresponding to an existing community_portal_users.id. Query-based pagination parameters (limit, offset) and optional includeArchived are supported by the service (documented as query params), but only the path parameter is required at the API surface. Return 401 for unauthenticated requests, 403 if the caller is not authorized to view the target user's subscriptions, 404 if the user does not exist or no visible subscriptions are found for the caller, and 400 for malformed parameters.","parameters":[{"name":"userId","description":"UUID of the user whose subscriptions are requested","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Paginated subscription summary list including community summary fields","typeName":"IPageICommunityPortalSubscription.ISummary"},"authorizationRoles":["member"],"name":"index","authorizationRole":"member","authorizationType":null,"prerequisites":[]},{"specification":"Create (subscribe) a new subscription record linking the authenticated caller to the specified community. This operation writes to the Prisma model community_portal_subscriptions and creates a record with user_id derived from the authenticated member context and community_id provided in the path. The model supports soft-delete (deleted_at) so service logic may reactivate an existing soft-deleted subscription instead of inserting a duplicate, depending on platform policy.","path":"/communityPortal/member/communities/{communityId}/subscriptions","method":"post","summary":"Subscribe the authenticated member to a community","description":"Create a subscription that links the authenticated member to the target community.\n\nThis operation creates a community_portal_subscriptions record with created_at/updated_at timestamps and deleted_at = NULL. If a soft-deleted subscription exists for the same (user_id, community_id) the service MAY reactivate it (clear deleted_at) rather than inserting a duplicate, according to platform policy. The service MUST validate the target community exists and enforce community visibility and membership rules (e.g., private community invitations or approval workflows).\n\nSecurity and permissions: Requires an authenticated member. The service verifies the caller is permitted to subscribe to the community; for private communities additional checks apply. On success the created subscription (or reactivated subscription) is returned with minimal related community data for UI consumption.\n\nValidation and errors: Path parameter communityId MUST be a UUID referencing an existing community_portal_communities.id. Return 401 Unauthorized when the caller is unauthenticated, 403 Forbidden when the caller is not permitted to subscribe, 404 Not Found when the communityId does not exist, 409 Conflict when an active subscription already exists and duplicates are disallowed, and 400 Bad Request for invalid inputs.","parameters":[{"name":"communityId","description":"UUID of the community to subscribe to","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Subscription creation request. Minimal payload because the authenticated user's id is derived from the auth context. Use this to provide optional client preferences (e.g., notification preferences).","typeName":"ICommunityPortalSubscription.ICreate"},"responseBody":{"description":"The created or reactivated subscription resource with minimal community summary fields","typeName":"ICommunityPortalSubscription"},"authorizationRoles":["member"],"name":"create","authorizationRole":"member","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"The target community must exist before a member can subscribe. POST /communityPortal/member/communities creates the community_portal_communities record and returns its id (community_id); without this resource the subscription creation will fail (404) or violate FK constraints."}]},{"specification":"Retrieves a filtered, searchable, and paginated list of posts from the Prisma model `community_portal_posts`. This operation is implemented against the \"community_portal_posts\" table in the Prisma schema. It supports multi-field search (title/body), filtering by post_type, community_id, author_user_id, and status, plus pagination and sorting by modes (hot, new, top, controversial). Implementation MUST exclude soft-deleted records by default (the model includes a `deleted_at` timestamp) and MUST respect community visibility (the related `community_portal_communities.visibility` field) when returning posts to unauthenticated or guest users.\n\nBusiness purpose: Provide clients with a single, flexible endpoint to power community feeds, community pages, and search results. The endpoint is designed to support complex queries from the frontend (search box, filters, pagination, and sort) while returning compact summary objects appropriate for list displays.\n\nDatabase relationship note: Each post references `community_portal_communities` via `community_id` and `community_portal_users` via `author_user_id`. The Prisma schema documents the primary entity as \"Primary entity for community posts\" and notes fields such as `post_type`, `title`, `body`, `link_url`, `image_url`, `status`, `created_at`, `updated_at`, and `deleted_at`. Implementations should use these fields for filtering, searching, and deriving list summaries.\n\nValidation and business rules: The request supports filter parameters for `community_id`, `author_user_id`, `post_type`, `status`, free-text `q` (search against `title` and `body`), and date ranges on `created_at`. Because `deleted_at` exists on the model, this operation MUST exclude records where `deleted_at` is non-null unless an explicit \"includeDeleted\" flag is provided (and allowed) by privileged tooling. Sorting modes (`hot`, `new`, `top`, `controversial`) are accepted as a parameter, but the exact algorithms for `hot` / `controversial` are implementation-defined and must be provided by the engineering team; the API accepts the parameter and orders results accordingly.\n\nSecurity and visibility: This endpoint is public by default (no authentication required) for public community feeds. For community-scoped private content (community.visibility != 'public' or community.is_private = true), the implementation MUST apply access control and only return posts to authorized users. The endpoint returns summary DTOs optimized for list rendering and omits heavy fields not needed for the list unless explicitly requested (e.g., by an \"includeBody\" flag).\n\nErrors and edge cases: If filter values are invalid (malformed UUIDs, unknown post_type or status), the API returns 400. If pagination parameters are out of range, the API returns 400. Partial or transient errors should surface 500 with explanatory message. The operation must return consistent pagination metadata (total count if available, limit, offset) and stable ordering for paginated queries.","path":"/communityPortal/posts","method":"patch","summary":"Search and retrieve a filtered, paginated list of community posts","description":"Retrieve a filtered and paginated list of community posts from the system.\n\nThis operation provides advanced search and filtering for the Prisma model `community_portal_posts` (the schema describes this as the \"Primary entity for community posts\" and documents fields such as `post_type`, `title`, `body`, `link_url`, `image_url`, `status`, `created_at`, `updated_at`, and `deleted_at`). The endpoint accepts complex request criteria (filter by community, author, type, and status; full-text search across `title` and `body`; time-range filters) and returns a paginated collection of summary objects optimized for feed displays.\n\nSecurity and visibility considerations: By default, results exclude rows with a non-null `deleted_at` (the model includes a `deleted_at` column). The response also respects community visibility: posts belonging to communities whose `visibility` is not public must not be returned to unauthenticated guests; authenticated callers may receive additional posts according to their access rights. Sorting modes include `hot`, `new`, `top`, and `controversial` — note that the Prisma model stores the canonical fields used for ranking (timestamps and status) but does not prescribe ranking formulas; the hot/controversial algorithms are to be defined by implementers.\n\nRelationship notes: Each returned post summary will normally include the post's `id`, `community_id`, `author_user_id`, `post_type`, `title`, `status`, and `created_at` and may include derived fields such as `score` or `preview` produced by aggregation or materialized views. The operation should not attempt to mutate system-generated aggregates directly; any ranking/score values should be read from authoritative aggregates or computed via the agreed algorithm.\n\nValidation and error handling: The request body is validated against allowed filter keys and pagination ranges. Invalid UUIDs or unsupported enum values result in a 400 Bad Request. If an internal error occurs, respond with 500. For large result sets, the operation supports `limit` and `offset` and SHOULD encourage use of cursor-based pagination for very large feeds.","parameters":[],"requestBody":{"description":"Search criteria and pagination parameters for post filtering (filters: communityId, authorUserId, postType, status, q, createdAt range; sorting: sort=hot|new|top|controversial; pagination: limit, offset).","typeName":"ICommunityPortalPost.IRequest"},"responseBody":{"description":"Paginated list of post summary information matching search criteria. Each summary references the community_portal_posts model fields (id, community_id, author_user_id, post_type, title, status, created_at) and may include aggregated fields such as score. Implementation returns IPageICommunityPortalPost.ISummary.","typeName":"IPageICommunityPortalPost.ISummary"},"authorizationType":null,"authorizationRole":null,"name":"index","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"Filtering by community_id requires the referenced community to exist. POST /communityPortal/member/communities creates the community_portal_communities record whose id (community_id) is used when listing or searching posts; ensure the community exists to avoid invalid filters or 404-like behaviors."}]},{"specification":"Retrieves a single post by its ID from the Prisma model `community_portal_posts`. This operation targets the `community_portal_posts` table (described in the Prisma schema as \"Primary entity for community posts\") and returns the full post representation including field-level details: `id`, `community_id`, `author_user_id`, `post_type`, `title`, `body`, `link_url`, `image_url`, `status`, `created_at`, `updated_at`. Implementations SHOULD also populate related info (author summary and community slug/name) when feasible for richer client rendering.\n\nBusiness purpose: Provide a canonical detail view used on post pages and permalinks. The POST detail operation must respect the `deleted_at` soft-delete column on the model: if `deleted_at` is set for the requested row, the API should return 404 Not Found unless the caller has privileged access for audit/investigation.\n\nRelationships and data rules: The Prisma model links each post to `community_portal_communities` via `community_id` and to `community_portal_users` via `author_user_id`. The schema comment recommends nullable `author_user_id` to preserve posts when users are removed; the implementation must therefore handle null authors gracefully (present an anonymous/removed-author placeholder). The model also contains `post_type` and optional `link_url`/`image_url` fields — callers SHOULD verify `post_type` and present appropriate UI for text, link, or image posts.\n\nValidation and error handling: If the `postId` path parameter is not a valid UUID, return 400. If no active (non-deleted) post exists with the given ID, return 404. If the post exists but belongs to a private community and the caller lacks access, return 403 Forbidden. Normal successful response is 200 with the `ICommunityPortalPost` response schema.","path":"/communityPortal/posts/{postId}","method":"get","summary":"Retrieve a single community post by ID","description":"Retrieve detailed information for a single community post by its ID.\n\nPurpose and overview: This operation returns the canonical post record from the Prisma model `community_portal_posts` (the schema describes it as the primary entity for community posts). It includes all detail fields suitable for a post detail page: `title`, `body` (for text posts), `link_url` (for link posts), `image_url` (for image posts), `post_type`, `status`, timestamps, and relational references to author and community.\n\nSecurity and permissions: Because `community_portal_posts` records have a `deleted_at` field, this endpoint by default hides soft-deleted posts and returns 404 for such records. Additionally, community visibility rules (stored on `community_portal_communities.visibility` and `is_private`) must be enforced: posts in non-public communities are returned only to authorized callers. If the post's `author_user_id` is null (user deleted), the endpoint SHOULD surface a safe placeholder for author information.\n\nRelationship to underlying DB entities: The operation maps directly to the `community_portal_posts` Prisma model and must not reference non-existent columns. The Prisma schema documents how posts relate to comments, votes and reports; the endpoint SHOULD not attempt to return exhaustive comment or vote lists inline unless the client requests them via explicit query parameters (e.g., includeComments=true) — keep the default payload focused on the post record and essential relational summaries.\n\nValidation rules and error handling: Validate `postId` as UUID. Return 400 on malformed IDs, 404 if post not found or soft-deleted (unless privileged), and 403 if access is denied due to community privacy. Unexpected server errors result in 500.","parameters":[{"name":"postId","description":"Unique identifier (UUID) of the target post","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed post information mapped from the `community_portal_posts` Prisma model, represented by `ICommunityPortalPost`.","typeName":"ICommunityPortalPost"},"authorizationType":null,"authorizationRole":null,"name":"at","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"The post belongs to a community; ensure the parent community exists first. POST /communityPortal/member/communities creates the community_portal_communities record (id/slug) that posts reference. If this prerequisite fails, posts referencing that community cannot be created or may be invalid, causing retrieval to fail or return 404/403."},{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"The specific post must have been created before it can be retrieved. POST /communityPortal/member/posts creates the community_portal_posts record and returns its generated id (postId). If this prerequisite is not executed successfully, attempting to GET the postId will result in 404 Not Found."}]},{"specification":"Operation to create a new post record in the community_portal_posts table (Prisma model community_portal_posts). This endpoint enables an authenticated member to create a post of type 'text', 'link', or 'image' in a target community. The operation maps directly to the Prisma model fields and enforces the business rules implied by the schema: community_id is required and must reference an existing community; post_type must be one of the allowed types and determines which content field is required (body for text, link_url for link, image_url for image); title is required; author_user_id is set by the server from the authenticated session; created_at/updated_at are set by the server; deleted_at must not be set by the client. The server should validate and sanitize inputs, enforce community visibility and membership rules, and place posts into moderation queues when community or system policy requires pre-approval.","path":"/communityPortal/member/posts","method":"post","summary":"Create a post in a community (community_portal_posts)","description":"Create a new post in a specified community. This endpoint persists a community_portal_posts record and supports three post types (text, link, image) as defined by the Prisma model.\n\nOnly authenticated, verified members may create posts. The server MUST verify the caller's identity and membership/verification state and set author_user_id to the authenticated user's id. The payload MUST include community_id (target community), post_type (\"text\" | \"link\" | \"image\"), and title. Depending on post_type, include the appropriate content field: for \"text\" include body; for \"link\" include link_url (valid http/https URL); for \"image\" include image_url or use a media upload pipeline. The server MUST sanitize and validate all inputs (title, body, link_url, image_url) and enforce configured size/format limits for media.\n\nBusiness behavior: If the target community requires moderator pre-approval, the server SHOULD create the post with status \"pending\" and notify moderators. created_at and updated_at are recorded by the server. The client MUST NOT provide deleted_at. On success the created post representation is returned.","parameters":[],"requestBody":{"description":"Post creation payload. Required fields: community_id (uuid), post_type ('text'|'link'|'image'), title (string). Include body for text posts, link_url for link posts, or image_url for image posts.","typeName":"ICommunityPortalPost.ICreate"},"responseBody":{"description":"Representation of the created post record. Contains canonical fields mapped from community_portal_posts (id, community_id, author_user_id, post_type, title, body/link_url/image_url, status, created_at, updated_at).","typeName":"ICommunityPortalPost"},"authorizationType":null,"authorizationRole":"member","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"A post requires a target community (community_id) that must exist. POST /communityPortal/member/communities creates the community_portal_communities record that provides a valid community_id. If the community does not exist, creating a post will fail with 404/validation error."},{"endpoint":{"path":"/communityPortal/member/communities/{communityId}/subscriptions","method":"post"},"description":"Posting may require the author to be subscribed/ a member of the community (especially for private communities). POST /communityPortal/member/communities/{communityId}/subscriptions creates or reactivates a subscription (community_portal_subscriptions) linking the authenticated user to the community. If subscription/membership is required and this prerequisite is not satisfied, POST /communityPortal/member/posts may return 403 Forbidden."}],"name":"create"},{"specification":"Operation to update an existing post record in the community_portal_posts table. This endpoint allows an authorized actor (typically the post author or other authorized user per platform policy) to modify mutable post attributes. It maps to the Prisma model community_portal_posts and must preserve created_at while updating updated_at. The operation enforces model constraints and business rules: the target post must exist and not be soft-deleted (deleted_at null); post_type changes require validating the matching content field for the new type; status transitions may trigger moderation-side effects.","path":"/communityPortal/member/posts/{postId}","method":"put","summary":"Update an existing post (community_portal_posts)","description":"Update fields of an existing post record. This operation permits editing mutable fields such as title, body, link_url, image_url, and status for the post identified by postId.\n\nAuthentication and authorization: Caller must be authenticated and authorized to update the specified post (commonly the original author or a permitted moderator/role as defined by platform policy). The server MUST verify the post exists and is not soft-deleted (deleted_at is null) before applying updates. created_at MUST be preserved by the server; updated_at MUST be set to the current timestamp on successful update.\n\nValidation: If post_type is changed, the server MUST validate presence of appropriate content for the new type. Status transitions (for example, 'pending'→'published' or marking 'removed') may trigger audit records, notifications, or moderation actions. The server MUST return 404 if postId does not exist or is deleted, 403 if caller is not authorized, 400 for validation errors, and 409 for business-rule conflicts.","parameters":[{"name":"postId","in":"path","description":"Target post's ID","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Post update payload. Include only fields to be changed (title, body, link_url, image_url, status). Do not include created_at or deleted_at.","typeName":"ICommunityPortalPost.IUpdate"},"responseBody":{"description":"Updated post resource reflecting applied changes, with canonical fields from community_portal_posts (id, community_id, author_user_id, post_type, title, body/link_url/image_url, status, created_at, updated_at).","typeName":"ICommunityPortalPost"},"authorizationType":null,"authorizationRole":"member","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"A community must exist before a post can be created in it. POST /communityPortal/member/communities creates the required community_portal_communities record and returns its id (community_id) which is needed when creating a post. If this prerequisite fails, a post cannot be created because the post's community_id would reference a non-existent community."},{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"The target post must exist before it can be updated. POST /communityPortal/member/posts creates a community_portal_posts record and returns the generated postId. If this prerequisite fails, the update operation will receive 404 (post not found) or be unable to reference the required post resource."}],"name":"update"},{"specification":"Operation to remove a post record from the community_portal_posts table in the Prisma schema. This operation targets the community_portal_posts model and implements the platform's soft-delete behavior because the Prisma model defines a nullable deleted_at timestamp. The endpoint supports owner-authorized deletion of a single post identified by postId. Business rules: the operation must verify the caller's authorization (ownership of the post or moderator-level permission) before setting deleted_at; it must not physically remove the row because deleted_at exists and must be populated to preserve audit trails and relations (comments, votes, reports). The operation must validate that the target post exists and is not already soft-deleted, return 404 if not found, and return 409 if deletion cannot be performed due to conflicting business rules (for example, locked/archived state expressed by status). This operation integrates with other moderation flows (reports) — if reports reference the post, they remain intact and the report records should preserve references per Prisma schema comments. Implementers should ensure audit logging of the actor and reason (application-level) when performing the soft-delete.","path":"/communityPortal/member/posts/{postId}","method":"delete","summary":"Soft-delete a post (community_portal_posts) by ID","description":"This endpoint marks a post as deleted by setting the community_portal_posts.deleted_at timestamp. It operates on the community_portal_posts model and preserves the post record for audit, moderation, and historical integrity. The caller must be authenticated and authorized: the author (owner) may delete their own post, and community-scoped moderators or platform admins may delete posts within their scope. The server implementation MUST enforce ownership checks and moderator scope before setting deleted_at.\n\nValidation: Validate path parameter postId as a UUID. If the post does not exist or deleted_at is already set, return 404. If the post's status or business rules prevent deletion, return 409 Conflict. On success set deleted_at to current UTC timestamp, persist audit entry (actor id, reason) at application level, and return 204 No Content.\n\nSecurity: Do not expose password_hash or other secrets. Ensure authorization check enforces owner-or-scope-moderator/admin policy. Log the action for audit.","parameters":[{"name":"postId","in":"path","description":"Target post's ID (community_portal_posts.id)","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationType":null,"authorizationRole":"member","name":"erase","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"A community must exist before a post can be created in it. POST /communityPortal/member/communities creates the required community_portal_communities record and returns its id (community_id) which is typically referenced by posts. If this prerequisite fails, posts cannot be created for that community and subsequent delete operations referencing such posts would fail with not-found."},{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"The post to be deleted must exist and not be soft-deleted. POST /communityPortal/member/posts creates the post (community_portal_posts) and returns its id; this ensures the delete target (postId) exists. If this prerequisite fails, the delete operation will return 404 or cannot perform the soft-delete."}]},{"specification":"Operation to retrieve a paginated list of posts for a specific community from the community_portal_posts table. This operation is associated with the community_portal_posts model in the Prisma schema and returns published posts for a given community (community_id). It supports sorting modes used by UIs (hot, new, top, controversial) and pagination parameters (limit/offset). The sorting algorithms for 'hot' and 'controversial' are intentionally left unspecified by this API design and must be implemented and documented by the backend team according to business rules.\n\nThis endpoint returns feed-oriented summary data and filters out soft-deleted posts by default (deleted_at IS NULL). For private communities, the implementation MUST enforce membership/subscription checks. The response should not include internal lifecycle fields such as deleted_at for public consumers; include such fields only in moderator/admin views.","path":"/communityPortal/communities/{communityId}/posts","method":"get","summary":"List posts in a community with sorting and pagination","description":"Retrieve a paginated list of posts belonging to a given community. By default the endpoint returns visible posts (status = 'published', deleted_at IS NULL). The endpoint supports query parameters limit, offset and sort (hot|new|top|controversial). Implementers MUST enforce community visibility: public communities are viewable by unauthenticated callers; private communities require membership/subscription.\n\nValidation: Validate communityId as UUID and ensure the community exists and is visible to the caller. Validate limit (1..100) and offset (>=0) and sort value. Return 400 for invalid parameters, 403 if access is denied for private communities, 404 if community not found. Response: paginated metadata and an array of post summary objects including id, title, post_type, author_user_id, created_at, updated_at, status, and a small preview (body or link/image summary). Do NOT include deleted_at in public summaries.","parameters":[{"name":"communityId","in":"path","description":"Target community's ID (community_portal_communities.id)","schema":{"type":"string","format":"uuid"}},{"name":"sort","in":"query","description":"Sort mode for the list. 'hot' and 'controversial' algorithms are unspecified and must be implemented by the backend; API accepts the parameter to request ordering.","schema":{"type":"string","enum":["hot","new","top","controversial"]}},{"name":"limit","in":"query","description":"Maximum number of items to return (pagination). Recommended max 100.","schema":{"type":"integer","minimum":1,"maximum":100}},{"name":"offset","in":"query","description":"Pagination offset (zero-based).","schema":{"type":"integer","minimum":0}}],"requestBody":null,"responseBody":{"description":"Paginated list of community posts matching the query parameters","typeName":"IPageICommunityPortalPost"},"authorizationType":null,"authorizationRole":null,"name":"index","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"The community must exist before listing its posts. POST /communityPortal/member/communities creates the community_portal_communities record and returns the community id; if this prerequisite is not satisfied, the list operation may return 404 Not Found."},{"endpoint":{"path":"/communityPortal/member/communities/{communityId}/subscriptions","method":"post"},"description":"For private or invite-only communities, the caller must be a member/subscribed to view posts. POST /communityPortal/member/communities/{communityId}/subscriptions creates or reactivates a subscription linking the authenticated user to the community; without this (when the community is private) the list operation will return 403 Forbidden."}]},{"specification":"Retrieve a paginated, filterable list of posts belonging to a specific community. This operation is implemented against the Prisma model community_portal_posts and returns posts that belong to the specified community_id. It supports pagination, sorting (sort modes: hot|new|top|controversial), optional search on title/body, and filters for post_type and moderation status. The operation excludes records where community_portal_posts.deleted_at is set (i.e., hidden/deleted records) and obeys community visibility rules defined on community_portal_communities (the implementation MUST enforce that public communities are readable by unauthenticated callers while private communities require authenticated membership). Validation rules: communityId must be a UUID and correspond to an existing community; requested page/limit must be within allowed bounds. This specification references the Prisma table community_portal_posts, its columns (id, community_id, author_user_id, post_type, title, body, link_url, image_url, status, created_at, updated_at, deleted_at) and the relationship to community_portal_communities to enforce visibility and membership constraints.","path":"/communityPortal/communities/{communityId}/posts","method":"patch","summary":"List posts in a community with pagination, filtering and sorting (community_portal_posts)","description":"Purpose and overview:\n\nRetrieve a filtered, sorted, and paginated list of posts within a single community. This operation queries the community_portal_posts table (Prisma model community_portal_posts) for records whose community_id matches the provided communityId, excluding records where deleted_at is set. It returns a page container of post summary items suitable for list displays.\n\nSecurity considerations and permissions:\n\nPublic access is allowed for posts in communities whose visibility is 'public'. For communities with private visibility, the service MUST require authentication and verify the requesting user is permitted to view that community (membership or explicit access). The implementation MUST not expose content for private communities to unauthenticated callers; when access is denied the service returns 403 Forbidden.\n\nRelationship to database entities:\n\nThis operation is directly associated with the community_portal_posts Prisma model. Returned summaries should include core properties (id, title, post_type, created_at, status, author_user_id, image_url/link_url where applicable) and must not expose sensitive fields such as internal moderation metadata beyond the documented response schema.\n\nValidation rules and business logic:\n\n- communityId path parameter MUST be a UUID identifying the target community. The service MUST verify the community exists.  \n- Deleted posts (deleted_at IS NOT NULL) MUST be excluded from results.  \n- Results MUST support pagination (limit, offset or page/size) and return total counts in the paginated response metadata.  \n- Sorting accepts sort values 'hot', 'new', 'top', 'controversial'. The exact ranking algorithms for 'hot' and 'controversial' are stakeholder-defined and are not implemented here; the API accepts the parameter and returns posts ordered accordingly by the backend implementation.\n\nRelated operations:\n\n- Creating or updating posts is handled by POST/PUT endpoints on /communityPortal/communities/{communityId}/posts (not part of this operation).  \n- To view comments for a specific post use GET/PATCH on /communityPortal/posts/{postId}/comments.\n\nError handling and edge cases:\n\n- If the communityId does not exist, the service SHALL return 404 Not Found.  \n- If the community is private and the caller is unauthenticated or unauthorized, the service SHALL return 403 Forbidden.  \n- If pagination parameters are invalid (e.g., limit too large), the service SHALL return 400 Bad Request with an explanatory message.","parameters":[{"name":"communityId","description":"UUID of the target community (community_portal_communities.id)","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Search, filter and pagination parameters for community posts","typeName":"ICommunityPortalPost.IRequest"},"responseBody":{"description":"Paginated list of community post summaries","typeName":"IPageICommunityPortalPost.ISummary"},"authorizationType":null,"authorizationRole":null,"name":"index","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"The community must exist before listing/filtering posts. POST /communityPortal/member/communities creates the community_portal_communities record and yields the community id required by this operation; absence of the community leads to 404 Not Found."},{"endpoint":{"path":"/communityPortal/member/communities/{communityId}/subscriptions","method":"post"},"description":"When the target community is private, the requester must be subscribed or otherwise granted membership. POST /communityPortal/member/communities/{communityId}/subscriptions creates or reactivates the member's subscription; if membership is required and missing, the operation will return 403 Forbidden."}]},{"specification":"Retrieve a paginated, filterable list of comments for a specific post. This operation targets the Prisma model community_portal_comments and returns comments whose post_id matches the provided postId. It supports pagination, optional parent_comment_id filtering to retrieve a thread or top-level comments, sorting (chronological/newest-first or other modes), and search on the comment body. The operation excludes records where community_portal_comments.deleted_at is set. Validation rules: postId must be a UUID and refer to an existing post; if parentCommentId is provided it must exist and belong to the same post. The response contains comment summaries and threading metadata suitable for UI rendering.","path":"/communityPortal/posts/{postId}/comments","method":"patch","summary":"List comments for a post with pagination and optional parent-thread filtering (community_portal_comments)","description":"Purpose and overview:\n\nReturn a paginated list of comments associated with a single post. This operation queries the community_portal_comments Prisma model for comments with the given post_id, excluding comments whose deleted_at is set. It supports retrieving top-level comments or replies by accepting an optional parentCommentId filter in the request body.\n\nSecurity considerations and permissions:\n\nComments for posts in public communities are readable by unauthenticated callers. For posts in private communities, the service MUST verify the requesting user's access and return 403 Forbidden for unauthorized requests. The operation must respect post status (e.g., hidden/removed) and not return comments for posts that are not visible to the caller.\n\nRelationship to database entities:\n\nThis operation is directly associated with community_portal_comments. Returned summaries should include id, author_user_id (nullable if user was deleted), parent_comment_id, body (truncated for summaries where applicable), created_at, and any UI-friendly metadata like reply_count.\n\nValidation rules and business logic:\n\n- postId path parameter MUST be a UUID and refer to an existing community_portal_posts record.  \n- parentCommentId, if supplied in the request, MUST reference a comment that belongs to the same post; otherwise return 400 Bad Request.  \n- Deleted comments (deleted_at IS NOT NULL) MUST be excluded from results.  \n- Pagination and sorting parameters MUST be supported in the request body (limit, offset, sort).  \n\nRelated operations:\n\n- To list posts for the parent community use PATCH /communityPortal/communities/{communityId}/posts.  \n- To cast votes on comments use POST/PUT on /communityPortal/comments/{commentId}/votes or the votes endpoints defined elsewhere.\n\nError handling and edge cases:\n\n- If the postId does not exist, return 404 Not Found.  \n- If parentCommentId does not belong to the specified post, return 400 Bad Request.  \n- If the post is not visible to the caller due to privacy or moderation state, return 403 Forbidden.","parameters":[{"name":"postId","description":"UUID of the target post (community_portal_posts.id)","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Search, filter and pagination parameters for post comments","typeName":"ICommunityPortalComment.IRequest"},"responseBody":{"description":"Paginated list of comment summaries for the post","typeName":"IPageICommunityPortalComment.ISummary"},"authorizationType":null,"authorizationRole":null,"name":"index","prerequisites":[{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"The target post must exist before listing its comments. POST /communityPortal/member/posts creates a new community post and returns its generated postId; without an existing post the comment listing cannot be validated and will return 404 Not Found."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/comments","method":"post"},"description":"If a parentCommentId filter is provided, that parent comment must exist and belong to the specified post. POST /communityPortal/member/posts/{postId}/comments creates a comment under the post and returns its commentId; this ensures the parentCommentId used for thread filtering is valid. If this prerequisite fails, the parentCommentId filter would be invalid and the operation should return 400 Bad Request."}]},{"specification":"Retrieve a single comment record from the Prisma model community_portal_comments. This operation returns the canonical comment record for display in a post thread. It validates identifiers, enforces community visibility and membership rules, and returns only non-deleted comments (soft-deleted comments with deleted_at != null are treated as not found). The operation maps model fields to API response properties and must avoid exposing sensitive user fields when including author profile information.","path":"/communityPortal/posts/{postId}/comments/{commentId}","method":"get","summary":"Retrieve a specific comment for a post (community_portal_comments)","description":"Purpose and overview:\nRetrieve a single comment that belongs to a specific post. This endpoint returns the canonical comment record from the community_portal_comments Prisma model. The response includes the comment fields: id, post_id, parent_comment_id (nullable), author_user_id (nullable), body, created_at, updated_at, and deleted_at (nullable).\n\nImportant behavior and visibility:\nOnly active (non-deleted) comments are returned. Although deleted_at is part of the model and present in the response schema, this endpoint will only return comments where deleted_at == null. If a comment has deleted_at != null the endpoint MUST respond with 404 Not Found to avoid exposing deleted content.\n\nSecurity and permissions:\nThis is a read operation that may be publicly accessible for public communities. For private communities, the caller must be an authorized member/subscriber or otherwise granted access; otherwise return 403 Forbidden. If the implementation enriches the response with author profile details, include only non-sensitive author fields (for example: display_name, avatar_uri). Do NOT include password_hash, email, or other sensitive data.\n\nValidation and relationship checks:\n- Validate postId and commentId are valid UUIDs; return 400 Bad Request for malformed UUIDs.\n- Confirm the comment exists and comment.post_id equals the supplied postId; if not, return 404 Not Found.\n- If the containing community is private and caller lacks access, return 403 Forbidden.\n\nResponses and error handling:\n- 200 OK: comment payload when found and visible.\n- 400 Bad Request: invalid UUID format for path parameters.\n- 403 Forbidden: caller lacks access to the containing community/post (private community).\n- 404 Not Found: comment not found, does not belong to the specified post, or has been soft-deleted (deleted_at != null).","parameters":[{"name":"postId","in":"path","description":"Target post's unique identifier (UUID). The comment must belong to this post.","schema":{"type":"string","format":"uuid"}},{"name":"commentId","in":"path","description":"Target comment's unique identifier (UUID).","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed comment information as defined by the community_portal_comments model. Note: deleted_at is nullable; returned comments will have deleted_at == null.","typeName":"ICommunityPortalComment"},"authorizationType":null,"authorizationRole":null,"name":"at","prerequisites":[{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"The parent post must exist before retrieving a comment. POST /communityPortal/member/posts creates the post resource and produces the postId that the comment references; without the post existing the comment lookup is invalid and should return 404 Not Found."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/comments","method":"post"},"description":"The target comment must exist before it can be retrieved. POST /communityPortal/member/posts/{postId}/comments creates a comment under the given post and returns its commentId; this ensures the specified commentId is present and associated with the post. If this prerequisite fails, the get operation must return 404 Not Found."}]},{"specification":"Create a new comment under a specific post in the Prisma model community_portal_comments. Persists a new comment record with optional parent reference, server-assigned author reference (authenticated user), body text, timestamps, and deleted_at initialized to null. The server enforces validation (post existence, parent comment consistency, nesting depth) and membership/visibility rules.","path":"/communityPortal/member/posts/{postId}/comments","method":"post","summary":"Create a new comment for a post (community_portal_comments)","description":"Purpose and overview:\nCreate a comment attached to a post. The request creates a new row in the community_portal_comments model. Input fields allowed from clients are: parent_comment_id (optional) and body (required). The server MUST populate author_user_id from the authenticated session and set created_at/updated_at timestamps. deleted_at must be null on create.\n\nSecurity considerations and permissions:\nOnly authenticated, verified members may create comments. The endpoint requires membership/visibility checks for the target post's community (private communities enforce access). Clients MUST NOT supply author_user_id. If author_user_id is present in the payload, the server SHOULD reject the request with 400 Bad Request and an explanatory message to prevent spoofing.\n\nValidation and business logic:\n- Validate postId is a valid UUID and references an existing post; if not found, return 404 Not Found.\n- Require a non-empty body string; if missing or empty, return 400 Bad Request.\n- If parent_comment_id is provided, validate it is a UUID and that the parent comment exists and its post_id matches postId; otherwise return 400 Bad Request.\n- Enforce maximum comment length and nesting depth per platform policy; if violated, return 400 Bad Request with an explanatory message.\n\nResponses and error handling:\n- 201 Created: returns the created comment payload. Recommend including a Location header pointing to GET /communityPortal/posts/{postId}/comments/{commentId}.\n- 400 Bad Request: validation errors (missing body, invalid parent_comment_id, nesting depth exceeded, body too long), or if author_user_id is supplied by client.\n- 401 Unauthorized: when authentication is missing or invalid.\n- 403 Forbidden: user lacks access to the target community/post (private community).\n- 404 Not Found: referenced postId or parent_comment_id does not exist.","parameters":[{"name":"postId","in":"path","description":"Target post's unique identifier (UUID) under which the comment will be created.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Comment creation payload. Allowed client fields: parent_comment_id (optional, UUID) and body (string, required). Clients MUST NOT supply author_user_id.","typeName":"ICommunityPortalComment.ICreate"},"responseBody":{"description":"Created comment representation reflecting the community_portal_comments model. Server-assigned fields include id, post_id, author_user_id, created_at, updated_at (deleted_at will be null).","typeName":"ICommunityPortalComment"},"authorizationType":null,"authorizationRole":"member","name":"create","prerequisites":[{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"The target post identified by postId must exist before creating a comment. Creating a post via POST /communityPortal/member/posts produces the postId referenced by the comment; if the post does not exist the comment creation will fail with 404 Not Found."}]},{"specification":"This operation updates the mutable fields of a comment in the community_portal_comments table. It is tied directly to the Prisma model community_portal_comments. Business rules: validate that the comment exists and belongs to the specified post (postId), that comment.deleted_at is null (not deleted), and that the caller is authorized (the comment author OR an active community moderator for the comment's community OR an active admin). The operation updates only allowed mutable fields (body and updated_at) and returns the updated comment. Server-side enforcement of ownership/moderator/admin checks and audit logging of the mutation are required.","path":"/communityPortal/member/posts/{postId}/comments/{commentId}","method":"put","summary":"Update a comment on a post (community_portal_comments)","description":"Update the text body of an existing comment attached to a specific post.\n\nPurpose and overview: This endpoint updates a single comment record in the community_portal_comments table. The path parameters identify the post (postId) and the comment (commentId). The request body supplies fields to update (primarily the comment body). The operation validates that the comment exists and belongs to the specified post, that the comment is not deleted (deleted_at null), and that the caller is authorized to edit (author OR community moderator OR admin). The updated comment, including updated_at, is returned.\n\nSecurity and permissions: Requires an authenticated member (authorizationRole = \"member\"). Implementation MUST verify that the caller is the comment's author or an authorized moderator/admin. If the caller is unauthenticated, return 401. If authenticated but not authorized, return 403. All successful edits MUST be recorded in audit logs (actorId, action, targetId, timestamp).\n\nRelationship to DB entities: Directly tied to the community_portal_comments Prisma model. Use postId to validate comment.post_id relation before performing updates. This operation updates only mutable comment fields (body and updated_at) and must not change post_id, parent_comment_id, created_at, or deleted_at in this edit flow.\n\nValidation and business logic:\n- Request MUST include a non-empty body string for the comment text.\n- Body must respect configured length limits (example default: max 10,000 characters).\n- If comment.deleted_at is set, return 404 Not Found.\n- If postId does not match comment.post_id, return 404 Not Found.\n- Edits should be idempotent: applying the same update repeatedly yields the same stored comment state.\n\nErrors and edge cases:\n- 400 Bad Request: missing/empty body or body exceeding allowed length.\n- 401 Unauthorized: request unauthenticated.\n- 403 Forbidden: authenticated but not authorized to edit.\n- 404 Not Found: post or comment not found, or comment already deleted.","parameters":[{"name":"postId","in":"path","schema":{"type":"string","format":"uuid"},"description":"Target post identifier (community_portal_posts.id)."},{"name":"commentId","in":"path","schema":{"type":"string","format":"uuid"},"description":"Target comment identifier (community_portal_comments.id)."}],"requestBody":{"description":"Fields to update on the comment. Expected shape: { body: string } (ICommunityPortalComment.IUpdate).","typeName":"ICommunityPortalComment.IUpdate"},"responseBody":{"description":"Updated comment representation (ICommunityPortalComment). Author sub-object, if included, MUST only expose safe public fields (id, username, display_name).","typeName":"ICommunityPortalComment"},"authorizationType":null,"authorizationRole":"member","name":"update","prerequisites":[{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"The parent post (postId) must exist prior to updating a comment. Ensure the post is created so that the comment's post_id relationship is valid; otherwise the update may return 404 Not Found."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/comments","method":"post"},"description":"The comment to be updated (commentId) must exist. Create the comment first using POST /communityPortal/member/posts/{postId}/comments to obtain the commentId; if the comment does not exist the update will fail with 404 Not Found."}]},{"specification":"Soft-delete the specified comment in community_portal_comments by setting deleted_at to the current server timestamp. Tied to the Prisma model community_portal_comments. Validate existence and linkage (comment.post_id equals provided postId), verify caller authorization (comment author OR community moderator OR admin), and preserve related audit data (votes, reports). Because the Prisma model includes deleted_at, soft-delete semantics are supported and used here. Implementation must not cascade-delete related entities; related aggregates are implementation concerns.","path":"/communityPortal/member/posts/{postId}/comments/{commentId}","method":"delete","summary":"Delete (soft-delete) a comment on a post (community_portal_comments)","description":"Soft-delete a comment so it is no longer visible in public comment listings while preserving the record for audit.\n\nPurpose and overview: This endpoint marks a comment as deleted by setting the deleted_at timestamp on the community_portal_comments row identified by postId and commentId. It ensures the comment belongs to the specified post and that the caller is authorized to delete it (author OR community moderator OR admin). Because the underlying model includes deleted_at, a soft-delete approach is used to retain audit and moderation trails.\n\nSecurity and permissions: Requires an authenticated member (authorizationRole = \"member\"). Implementation MUST verify ownership or moderator/admin privilege. If unauthenticated return 401. If authenticated but not authorized return 403. If the comment is already deleted (deleted_at non-null), return 404 Not Found.\n\nRelationship to DB entities: Operates on community_portal_comments and must not cascade-delete related entities. Votes, reports, and other related records should remain for auditing. Implementation may trigger asynchronous updates (e.g., decrement aggregated comment counts) but such side effects are out of scope for this API contract.\n\nValidation and business logic:\n- Verify the comment exists and comment.post_id equals provided postId.\n- If comment.deleted_at is not null, return 404 Not Found.\n- Apply a soft-delete by setting deleted_at to server current timestamp.\n\nErrors and edge cases:\n- 401 Unauthorized: request unauthenticated.\n- 403 Forbidden: authenticated but not authorized to delete.\n- 404 Not Found: post or comment missing or comment already deleted.\n- 500 Internal Server Error: unexpected server-side failure while applying deleted_at.\n\nResponse: Prefer 204 No Content on successful soft-delete to indicate no response body is returned.","parameters":[{"name":"postId","in":"path","schema":{"type":"string","format":"uuid"},"description":"Target post identifier (community_portal_posts.id)."},{"name":"commentId","in":"path","schema":{"type":"string","format":"uuid"},"description":"Target comment identifier (community_portal_comments.id)."}],"requestBody":null,"responseBody":null,"authorizationType":null,"authorizationRole":"member","name":"erase","prerequisites":[{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"The target post must exist before any comments can be referenced or modified. POST /communityPortal/member/posts creates the community_portal_posts record and returns its id (postId). If the post does not exist, attempts to operate on comments for that post will fail with 404/not-found."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/comments","method":"post"},"description":"The comment to be soft-deleted must exist. POST /communityPortal/member/posts/{postId}/comments creates a community_portal_comments record and returns its id (commentId). If the comment does not exist, the delete operation should return 404. Creating the comment is required so the delete can reference a valid commentId and verify comment.post_id == postId."}]},{"specification":"Create a vote record for a post (community_portal_votes). This operation creates a new vote targeting a post and persists it to the community_portal_votes table in the Prisma schema. It is intended to be used when an authenticated member casts an upvote or downvote on a post. The operation enforces XOR target semantics (post_id XOR comment_id) and application-level uniqueness (one active vote per user,target). The API requires the server to validate the caller is an active member (community_portal_members.is_email_verified==true and is_suspended==false) and to associate the authenticated user's id as user_id on the created record. The post_id must reference an existing community_portal_posts.id and comment_id MUST be null for this endpoint. The operation respects soft-delete semantics: community_portal_votes.deleted_at exists in the schema so soft-delete patterns are supported by the data model; API behavior for deleted votes is implementation-defined (recommended: treat soft-deleted votes as not found for update flows).","path":"/communityPortal/member/posts/{postId}/votes","method":"post","summary":"Cast an upvote or downvote on a post (create community_portal_votes record)","description":"Cast a vote on a post and create a community_portal_votes record.\n\nPurpose and overview:\nThis operation allows an authenticated member to cast a vote (+1 for upvote, -1 for downvote) on a post identified by {postId}. It records a community_portal_votes entry linked to post_id and the authenticated user. The created vote record contains only the fields defined on the vote model (id, user_id, post_id, comment_id (null), value, created_at, updated_at, deleted_at).\n\nSecurity and permissions:\nOnly authenticated, active members may call this endpoint. The server MUST verify the caller's membership status using community_portal_members (is_email_verified and is_suspended) and MUST NOT accept client-supplied user_id values. Ownership is derived from the authentication context.\n\nRelationship to DB and validation rules:\n- Maps directly to the community_portal_votes model.\n- Enforce XOR target semantics: set post_id and leave comment_id null.\n- Validate that {postId} exists and is visible to the caller (return 404 or 403 as appropriate).\n- Validate request value is exactly +1 or -1; return 400 for invalid values.\n- Enforce one active vote per (user,post) via DB constraints and/or application logic. Document whether POST returns 409 on duplicates or performs upsert semantics.\n- Respect soft-delete semantics: treat soft-deleted vote records as not-found for update flows unless policy allows reactivation.\n\nExpected responses and errors:\n- 201 Created: returns created vote resource (ICommunityPortalVote) with fields present on the vote model.\n- 400 Bad Request: invalid payload or vote value.\n- 401 Unauthorized: unauthenticated caller.\n- 403 Forbidden: caller not permitted to vote (suspended/unverified or community-restricted).\n- 404 Not Found: post not found or not visible.\n- 409 Conflict: duplicate vote exists and server policy rejects duplicates on create.\n\nImplementation notes:\nKeep response limited to vote-model fields. If updated post aggregates are required in the response, return a documented wrapper type that includes a post summary DTO (e.g., ICommunityPortalPostSummary) and declare that explicitly in the responseBody typeName.","parameters":[{"name":"postId","in":"path","schema":{"type":"string","format":"uuid"},"description":"Target post's ID (community_portal_posts.id)"}],"requestBody":{"description":"Vote creation payload. Body must provide the vote value (+1 or -1). The server will associate the authenticated user as voter and set comment_id to null for post votes.","typeName":"ICommunityPortalVote.ICreate"},"responseBody":{"description":"Created vote record (fields as defined on community_portal_votes model).","typeName":"ICommunityPortalVote"},"authorizationType":null,"authorizationRole":"member","prerequisites":[{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"The post being voted on must exist. POST /communityPortal/member/posts creates the community_portal_posts record and returns its id (postId). If the post does not exist or is not visible to the caller, casting a vote will fail (404/403)."}],"name":"create"},{"specification":"Update an existing vote record for a post (community_portal_votes). This operation updates mutable fields of an existing vote targeting a post. It requires the authenticated user to be the vote owner. The endpoint verifies that the vote identified by {voteId} exists, that it targets the post identified by {postId} (vote.post_id == postId), and that the vote is not soft-deleted (deleted_at null) before applying allowed updates (commonly value). Concurrency conflicts should be handled (e.g., 409).","path":"/communityPortal/member/posts/{postId}/votes/{voteId}","method":"put","summary":"Update an existing vote on a post (modify community_portal_votes record)","description":"Modify an existing vote record for a post.\n\nPurpose and overview:\nAllows the authenticated owner of a vote to change its value (e.g., +1 -> -1) for the vote identified by {voteId} and scoped to post {postId}. The endpoint is scoped to post-targeted votes; comment-targeted votes must use a comment-specific endpoint.\n\nSecurity and permissions:\nOnly the vote owner (authenticated user whose id == vote.user_id) or an authorized system account may update the vote. The server MUST verify ownership and membership status before applying changes. Moderator/admin overrides are out of scope for this endpoint.\n\nValidation and business logic:\n- Validate path parameters postId and voteId are valid UUIDs.\n- Confirm vote exists and its post_id matches postId; otherwise return 400 or 404.\n- Ensure vote is not soft-deleted (deleted_at is null); if soft-deleted treat as 404.\n- Allowed updates should be limited (value); validate new value is exactly +1 or -1.\n- Define canonical removal flow: prefer DELETE /communityPortal/member/posts/{postId}/votes/{voteId} for vote removal (documented separately). If platform uses a sentinel value (e.g., 0) for removal, document that explicitly.\n- Consider optimistic concurrency (ETag/If-Match) to avoid lost updates; return 409 on conflict.\n\nExpected responses and errors:\n- 200 OK: returns updated vote resource (ICommunityPortalVote).\n- 400 Bad Request: invalid payload or vote-post mismatch.\n- 401 Unauthorized: unauthenticated caller.\n- 403 Forbidden: caller not owner or not permitted.\n- 404 Not Found: vote or post not found, or vote soft-deleted.\n- 409 Conflict: concurrent modification detected (optional concurrency control).\n\nImplementation notes:\nKeep returned fields consistent with the vote model. Use DELETE for removal flows and document the platform's canonical behavior for removal and re-voting.","parameters":[{"name":"postId","in":"path","schema":{"type":"string","format":"uuid"},"description":"Target post's ID (community_portal_posts.id)"},{"name":"voteId","in":"path","schema":{"type":"string","format":"uuid"},"description":"Vote record ID to modify (community_portal_votes.id)"}],"requestBody":{"description":"Vote update payload. Typically includes the new vote value (e.g., +1 or -1). The server will enforce ownership and validate the value.","typeName":"ICommunityPortalVote.IUpdate"},"responseBody":{"description":"Updated vote record representation (fields as defined on community_portal_votes model).","typeName":"ICommunityPortalVote"},"authorizationType":null,"authorizationRole":"member","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"A community must exist before a post can be created within it. Creating a community (community_portal_communities) ensures there is a valid community_id that posts reference; if this prerequisite fails, subsequent post creation (and therefore votes tied to posts) cannot be performed."},{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"The target post must exist before any votes referencing it can be created or updated. This POST creates the community_portal_posts record (producing postId). If this fails, votes for the post cannot be created or updated."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/votes","method":"post"},"description":"The vote record must exist before it can be updated. This POST creates a community_portal_votes record scoped to the given postId; if creating the vote fails then there is no vote resource to update and the update operation will fail (404/400)."}],"name":"update"},{"specification":"This operation creates a vote record in the community_portal_votes table targeting a comment. It operates on the community_portal_votes Prisma model. The endpoint enforces XOR semantics (a vote must target exactly one of post_id or comment_id); for this operation comment_id is populated and post_id must be null. The server MUST derive the voter identity from the authenticated session (do NOT accept user_id from client), validate that the comment exists and belongs to the specified post, validate the vote value is +1 or -1, ensure one active vote per (user,comment) (backend policy: upsert/update existing vote recommended), persist created_at/updated_at, and return the created/updated vote representation. If included, returned aggregates (e.g., comment score) are best-effort and may be eventually consistent.","path":"/communityPortal/member/posts/{postId}/comments/{commentId}/votes","method":"post","summary":"Create a vote on a comment","description":"Create a vote on a comment within a post.\n\nPurpose and overview:\nThis endpoint enables an authenticated member to cast a vote (+1 or -1) on a comment identified by {commentId} within the post identified by {postId}. The API persists a community_portal_votes record with comment_id set (post_id must be null for comment-targeted votes), stores the integer vote value, and returns the authoritative vote representation. The backend MUST validate that the post exists and is active, the comment exists and belongs to that post, and the requester is eligible to vote (e.g., verified and not suspended).\n\nSecurity and permissions:\nOnly authenticated members may call this endpoint. The server MUST derive the voter identity from the authenticated session and must ignore any client-supplied user_id to prevent tampering. The backend SHOULD verify membership status (community_portal_members.is_email_verified and is_suspended) prior to creating the vote.\n\nRelationship to DB entities and business rules:\nThis operation maps to the community_portal_votes model in the Prisma schema. Business rules to enforce:\n- A vote must target exactly one entity (post OR comment). For this endpoint, comment_id is populated and post_id must be null.\n- Accept only integer vote values +1 or -1.\n- Enforce one active vote per (user, comment) pair; the backend SHOULD perform an upsert/update existing vote behavior unless policy dictates otherwise.\n- Persist created_at and updated_at timestamps and support soft-delete via deleted_at on the vote record.\n\nValidation and error responses:\n- 400 Bad Request: invalid vote value, mismatched post/comment relation, or malformed UUIDs.\n- 401 Unauthorized: missing or invalid authentication credentials, or member not verified/suspended.\n- 404 Not Found: post or comment not found or soft-deleted.\n- 409 Conflict: duplicate vote attempts if backend policy rejects duplicates.","parameters":[{"name":"postId","in":"path","description":"UUID of the parent post that contains the comment","schema":{"type":"string","format":"uuid"}},{"name":"commentId","in":"path","description":"UUID of the comment to vote on","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Vote creation payload. The authenticated user is the voter; request body only needs the vote value (+1 or -1).","typeName":"ICommunityPortalVote.ICreate"},"responseBody":{"description":"Created vote object reflecting authoritative stored fields (id, comment_id, value, created_at, updated_at). Response may include updated aggregate score for the comment when available (best-effort).","typeName":"ICommunityPortalVote"},"authorizationType":null,"authorizationRole":"member","name":"create","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"A community must exist so a post may be created within it. Comment resources are scoped to posts which in turn are scoped to a community; if the community does not exist the post/comment/vote workflow cannot proceed."},{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"The parent post must exist before a comment can be created. This POST produces the postId that the comment and its votes will reference; without it the comment and comment-vote operations will fail."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/comments","method":"post"},"description":"The comment must exist before a vote can reference it. This POST creates the community_portal_comments record (producing commentId) under the given postId; if comment creation fails the comment-vote operation cannot proceed."}]},{"specification":"Soft-delete (mark deleted_at) a vote record in the community_portal_votes table that targets a post. This operation relies on the community_portal_votes Prisma model which includes a deleted_at timestamp; therefore deletion is implemented as a soft-delete. The endpoint verifies ownership (or elevated permission), verifies the vote belongs to the specified post_id, sets deleted_at, emits domain events or triggers aggregate reconciliation (post score, author karma), and returns 204 No Content on success.","path":"/communityPortal/member/posts/{postId}/votes/{voteId}","method":"delete","summary":"Soft-delete a vote on a post","description":"Remove (soft-delete) a vote on a post.\n\nPurpose and overview:\nThis endpoint allows an authenticated member to remove their previously cast vote on a post identified by {postId}. The specific vote record to remove is identified by {voteId}. The backend MUST verify the vote exists, is active (deleted_at is null), that it is associated with the given post_id, and that the authenticated requester is authorized to remove it (typically the vote owner). On success the service marks deleted_at on the vote record and returns 204 No Content.\n\nSecurity and permissions:\nOnly authenticated members may call this endpoint. The server MUST verify the requester owns the vote (vote.user_id == authenticated user) or has explicit elevated rights per platform policy. If the requester lacks permission, return 403 Forbidden.\n\nRelationship to DB entities and business rules:\nThis operation updates the community_portal_votes record's deleted_at field to preserve auditability. Downstream effects include updating aggregates (post score, author karma). The backend should emit events or perform aggregate reconciliation so system state remains consistent.\n\nValidation and error responses:\n- 401 Unauthorized: missing or invalid authentication credentials.\n- 403 Forbidden: authenticated user is not the owner of the vote and lacks elevated rights.\n- 404 Not Found: post or vote not found or already soft-deleted.\n- 409 Conflict: concurrent modification prevented deletion.","parameters":[{"name":"postId","in":"path","description":"UUID of the post that the vote targets","schema":{"type":"string","format":"uuid"}},{"name":"voteId","in":"path","description":"UUID of the vote to remove","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationType":null,"authorizationRole":"member","name":"erase","prerequisites":[{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"A community post must exist before any votes can reference it. Create the post to obtain a valid postId; if the post does not exist the vote cannot be created or deleted."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/votes","method":"post"},"description":"The vote record must exist before it can be soft-deleted. Create a vote for the given postId to obtain voteId and ensure the vote is active (deleted_at is null). If this prerequisite fails the delete operation cannot locate the vote."}]},{"specification":"Update an existing vote (community_portal_votes). This operation targets the community_portal_votes Prisma model and updates mutable fields for a single vote identified by voteId. It is intended to change the stored vote value (for example, switch +1 to -1) or other allowed mutable metadata while preserving audit timestamps. The operation must validate that the vote exists and is active (deleted_at is null), that the authenticated caller is the vote owner, and that the vote's target reference (post_id or comment_id) matches the path parameters. The implementation must not change the vote target (post_id/comment_id) or user_id via this operation. The request body uses ICommunityPortalVote.IUpdate and the response returns the updated ICommunityPortalVote entity.","description":"Update a user's vote record for a specific post or comment.\n\nPurpose and overview:\nThis endpoint updates the vote value and other permitted mutable attributes of a vote record in the community_portal_votes model. A vote targets either a post or a comment (XOR). The endpoint verifies that the vote exists and is active, that the path parameters correspond to the vote's target, and that the caller is authorized (the vote owner). The response returns the updated vote, including id, user reference, target reference, value, created_at, and updated_at.\n\nSecurity and authorization:\nOnly the authenticated vote owner (member) may update their vote. The service must verify the caller's identity matches vote.user_id and enforce business gating (e.g., suspended members may be prevented from changing votes). All modifications should update updated_at and be auditable.\n\nRelationship to DB entity:\nMaps to the Prisma model community_portal_votes (fields: id, user_id, post_id, comment_id, value, created_at, updated_at, deleted_at). Do not assume additional fields beyond the model.\n\nValidation and business rules:\n- The vote record must exist and be active (deleted_at is null).\n- The path parameters postId and commentId must match the vote's target reference (post_id or comment_id) depending on which target the vote has.\n- The request must not change the vote's target or user_id; only 'value' and permitted metadata may be updated.\n\nError handling:\nReturn 400 for malformed input, 401 if unauthenticated, 403 if the caller is not the vote owner, 404 if the vote/post/comment is not found or inactive, and 409 for conflicting state (e.g., attempting to change the vote target).","summary":"Update a user's vote for a post or comment","path":"/communityPortal/member/posts/{postId}/comments/{commentId}/votes/{voteId}","method":"put","parameters":[{"name":"postId","in":"path","description":"Identifier of the parent post (community_portal_posts.id) - must match the vote's post_id if the vote targets a post","schema":{"type":"string","format":"uuid"}},{"name":"commentId","in":"path","description":"Identifier of the parent comment (community_portal_comments.id) - must match the vote's comment_id if the vote targets a comment","schema":{"type":"string","format":"uuid"}},{"name":"voteId","in":"path","description":"Identifier of the vote record to update (community_portal_votes.id)","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Updatable fields for a vote record (e.g., value). Must not include post_id, comment_id, or user_id.","typeName":"ICommunityPortalVote.IUpdate"},"responseBody":{"description":"Updated vote record reflecting the new value and timestamps.","typeName":"ICommunityPortalVote"},"authorizationRoles":["member"],"name":"update","authorizationRole":"member","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"The parent post must exist before creating comments within it. Creating the post provides the postId required by subsequent comment and vote operations."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/comments","method":"post"},"description":"The comment must exist under the target post before a vote on that comment can be created or updated. Create the comment to obtain commentId and validate it belongs to the specified postId."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/comments/{commentId}/votes","method":"post"},"description":"The comment-targeted vote must exist before it can be updated. Create a vote on the specified comment to obtain voteId (ensure XOR semantics: comment_id populated and post_id null). If this prerequisite fails the update cannot proceed."}]},{"specification":"Soft-delete (erase) a vote record (community_portal_votes). This operation sets the deleted_at timestamp on the specified vote, preserving the row for audit and excluding it from active aggregations. It verifies the vote exists and is active, that the authenticated caller is the vote owner, and that the path parameters correspond to the vote's target. Because the model includes deleted_at, deletion is implemented as a soft-delete rather than a physical removal.","description":"Delete (soft-delete) a user's vote for a specific post or comment.\n\nPurpose and overview:\nThis endpoint marks a vote record as deleted by setting deleted_at on the community_portal_votes record. The vote remains in storage for audit and reconciliation but is no longer treated as active for ranking and aggregates. The operation must verify the vote exists, is active (deleted_at is null), and that the caller is authorized to delete it (the vote owner).\n\nSecurity and authorization:\nOnly the authenticated vote owner (member) may delete their vote. The service must verify caller identity matches vote.user_id and enforce any additional business gating.\n\nRelationship to DB entity:\nActs on the community_portal_votes model (id, user_id, post_id, comment_id, value, created_at, updated_at, deleted_at). Use soft-delete semantics as deleted_at exists.\n\nValidation and business rules:\n- Confirm the vote exists and is active.\n- Ensure postId/commentId path parameters match the vote's target references.\n- If the vote is already deleted, return 409 Conflict or 200 if idempotent deletion is chosen by policy.\n\nError handling:\nReturn 401 if unauthenticated, 403 if the caller is not the vote owner, 404 if the vote/post/comment is not found, and 409 if the vote is already deleted (unless idempotent semantics are used).","summary":"Delete (soft-delete) a user's vote for a post or comment","path":"/communityPortal/member/posts/{postId}/comments/{commentId}/votes/{voteId}","method":"delete","parameters":[{"name":"postId","in":"path","description":"Identifier of the parent post (community_portal_posts.id) - must match the vote's post_id if the vote targets a post","schema":{"type":"string","format":"uuid"}},{"name":"commentId","in":"path","description":"Identifier of the parent comment (community_portal_comments.id) - must match the vote's comment_id if the vote targets a comment","schema":{"type":"string","format":"uuid"}},{"name":"voteId","in":"path","description":"Identifier of the vote record to delete (community_portal_votes.id)","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["member"],"name":"erase","authorizationRole":"member","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"The target post must exist before creating comments or votes under it. Creating a post ensures the {postId} references a valid community_portal_posts record; if this prerequisite fails, the vote cannot be validated or deleted."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/comments","method":"post"},"description":"The target comment must exist before a vote that references it can exist. Creating the comment ensures the {commentId} references a valid community_portal_comments record belonging to the specified post; if this fails, the vote deletion request cannot be performed."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/comments/{commentId}/votes","method":"post"},"description":"A vote record must exist before it can be soft-deleted. Creating a vote tied to the specified post/comment provides a valid {voteId} to act upon; if this prerequisite fails, there is no vote to delete."}]},{"specification":"Search and list operation for vote events (community_portal_votes). This operation implements a paginated, filterable search over the community_portal_votes Prisma model. It is intended to support user-facing vote history pages, self-service account activity, and authorized audit queries. The operation explicitly uses the model fields defined in the Prisma schema: id, user_id, post_id, comment_id, value, created_at, updated_at, deleted_at. The specification follows the business constraints described in the Prisma model: a vote targets either a post OR a comment (XOR semantics) and vote values are integers (+1 or -1). The API enforces validation of UUID formats for userId/postId/commentId and ISO-8601 for date ranges. By default, records with deleted_at != null are excluded unless the client sets includeDeleted=true.\n\nThis operation is associated with the community_portal_votes table in the Prisma schema. Business rules and validation logic referenced from the schema: ensure at most one of postId or commentId is provided as a filter (to respect XOR constraint), return vote.value exactly as stored (+1 or -1), and support pagination and sorting (created_at or value). The API surface returns vote summaries suitable for list displays and respects privacy: user-scoped queries (filter by userId) must only return records allowed by authorization (caller typically the same member). Cross-user queries require elevated authorization in implementation logic.","path":"/communityPortal/member/votes","method":"patch","summary":"Search and retrieve a paginated list of vote events (community_portal_votes)","description":"Retrieve a filtered, sorted, and paginated list of vote events from the community_portal_votes table.\n\nPurpose and overview: This operation enables clients to search vote events by voter (user_id), by target (post_id or comment_id), by date ranges, and to page and sort results. Typical use cases include a user reviewing their own vote history on their profile and authorized audit/analytics views. Returned items include id, userId, postId (nullable), commentId (nullable), value (+1 or -1), createdAt, and updatedAt.\n\nSecurity considerations and permissions: This endpoint requires an authenticated member context. The server MUST ensure that user-scoped queries (for example filtering by userId) return only records the caller is permitted to view (commonly the caller's own votes). Aggregated or cross-user queries require additional authorization checks implemented server-side. The operation excludes soft-deleted votes by default (deleted_at not null) unless includeDeleted=true is explicitly requested.\n\nRelationship to underlying DB entity: Maps directly to the community_portal_votes Prisma model and uses the model fields and semantics described in the schema. The API enforces XOR semantics at request validation time by rejecting requests that provide both postId and commentId filters simultaneously. Pagination and sorting operate over created_at and value fields. Error handling: malformed UUIDs/date formats return 400; unauthenticated calls return 401; attempts to query other users' votes without authorization return 403.","parameters":[],"requestBody":{"description":"Search criteria and pagination parameters for votes listing. Filters: userId (uuid), postId (uuid), commentId (uuid), value (+1/-1), date range (createdFrom, createdTo), sort (createdAt|value), limit, offset. Note: provide either postId or commentId, not both (XOR).","typeName":"ICommunityPortalVote.IRequest"},"responseBody":{"description":"Paginated list of vote summary records. Each item: id, userId, postId, commentId, value, createdAt, updatedAt.","typeName":"IPageICommunityPortalVote.ISummary"},"authorizationType":null,"authorizationRole":"member","name":"index","prerequisites":[{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"When filtering the vote index by postId, the referenced post must exist. Creating a post ensures the {postId} used as a filter maps to an actual community_portal_posts record for query validation."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/comments","method":"post"},"description":"When filtering the vote index by commentId, the referenced comment must exist under the specified post. Creating the comment ensures the {commentId} used as a filter maps to an actual community_portal_comments record for query validation."}]},{"specification":"Search and list operation for moderation reports (community_portal_reports). This operation implements a paginated, filterable search over the community_portal_reports Prisma model and returns report metadata suitable for inbox, status pages, and moderation queues. It uses only the model fields provided in the Prisma schema: id, reporter_user_id, community_id, post_id, comment_id, assigned_moderator_id, closed_by_moderator_id, reason_code, reason_text, status, is_urgent, severity, reporter_contact_email, created_at, reviewed_at, closed_at, and resolution_notes. The API supports filtering by reporter, community, target post/comment, status, urgency, severity, and date ranges.\n\nThis operation is explicitly linked to the community_portal_reports table as defined in the Prisma schema. Business rules from the schema are respected: report targets may be nullable (anonymous reports), resolution_notes may be present but should only be revealed to authorized callers, and status values follow the application-level vocabulary (OPEN, IN_REVIEW, REQUIRES_ACTION, DISMISSED, CLOSED). The endpoint defaults to excluding sensitive fields (e.g., resolution_notes) from unauthorized callers and requires server-side authorization checks when returning moderator-facing details.","path":"/communityPortal/member/reports","method":"patch","summary":"Search and retrieve a paginated list of moderation reports (community_portal_reports)","description":"Retrieve a filtered, sorted, and paginated list of moderation report records from the community_portal_reports table.\n\nPurpose and overview: This operation provides listing capabilities for report records that capture user-submitted complaints about posts, comments, or community issues. Responses contain report metadata used for inbox displays and status tracking: id, reporterUserId (nullable), communityId (nullable), postId (nullable), commentId (nullable), reasonCode, reasonText, status, isUrgent, severity, createdAt, reviewedAt, closedAt. Sensitive fields such as resolutionNotes may be returned only to authorized moderator/admin clients.\n\nSecurity and authorization: Authenticated members may list reports they submitted (reporter_user_id). Moderators/admins require appropriate authorization to list community-scoped or assigned queues; the API accepts the filters but server-side enforcement MUST restrict access. When a caller lacks permission to view private moderator fields, those fields MUST be omitted from the response.\n\nValidation and business logic: The API must validate UUID filters and restrict status filter values to the known application vocabulary (OPEN, IN_REVIEW, REQUIRES_ACTION, DISMISSED, CLOSED). Requests with malformed IDs or invalid status values return 400. Unauthorized attempts to query others' reports return 403. Empty result sets return an empty page with pagination metadata.","parameters":[],"requestBody":{"description":"Search criteria and pagination parameters for report listing. Filters: reporterUserId (uuid), communityId (uuid), postId (uuid), commentId (uuid), status (enum), isUrgent (boolean), severity (string), createdFrom/createdTo (ISO datetime), sort (createdAt|severity), limit, offset. Note: member-scoped callers may only query their own reporterUserId; moderator/admin callers can use broader filters and receive moderator-only fields.","typeName":"ICommunityPortalReport.IRequest"},"responseBody":{"description":"Paginated list of report summary records matching search criteria. Moderator-only fields (resolutionNotes, assignedModeratorId, closedByModeratorId) are returned only to authorized moderator/admin callers.","typeName":"IPageICommunityPortalReport.ISummary"},"authorizationType":null,"authorizationRole":"member","name":"index","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"Community must exist before filtering or listing reports by communityId; creating a community returns the community_id required by report filters. If this prerequisite fails, community-scoped report queries will return 404 for that communityId."},{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"Post must exist before filtering or listing reports by postId; creating a post provides the postId used in report filters. This also depends on a community existing (parent resource) and will fail if the parent community is missing."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/comments","method":"post"},"description":"Comment must exist before filtering or listing reports by commentId; creating a comment yields the commentId used in report filters. This prerequisite requires the parent post to exist and will fail if the post is missing."}]},{"specification":"Retrieve a single moderation report from the community_portal_reports Prisma model. Returns the canonical report representation (fields as defined in the Prisma model). Intended for authorized viewers (the reporting user, the assigned moderator for the report or the community, and authorized platform staff). Implementation MUST validate the reportId path parameter (UUID), enforce authorization, and handle nullable foreign keys by returning null for missing referenced entities (deleted user/community/post/comment).","path":"/communityPortal/member/reports/{reportId}","method":"get","summary":"Retrieve a moderation report by ID (community_portal_reports)","description":"Retrieve a single moderation report and its metadata from the community_portal_reports table.\n\nPurpose and overview: Returns one report record identified by the path parameter `reportId`. The response includes business attributes captured in the Prisma model: reporter_user_id (nullable for anonymous reports), community_id, post_id, comment_id, assigned_moderator_id, closed_by_moderator_id, reason_code, reason_text, status, is_urgent, severity, reporter_contact_email, created_at, reviewed_at, closed_at, and resolution_notes. When related references are null (e.g., referenced user or content deleted), the corresponding fields MUST be null in the response.\n\nSecurity and permissions: Requires an authenticated member context. Authorization rules (enforced by the service) MUST be implemented as follows: the reporting user may view their own report; assigned moderators or moderators of the referenced community may view reports for triage; platform staff/admins may view any report. Field-level visibility: `reporter_contact_email` and `resolution_notes` are sensitive and MUST only be returned to authorized viewers (author, assigned moderator, admin) — the service MUST enforce this.\n\nValidation rules and business logic: Validate `reportId` is a UUID; if malformed return 400. If report not found return 404. If the caller is not authenticated return 401; if authenticated but not authorized to view this report return 403. Server errors return 500. Do not expose internal/moderator-only fields to unauthorized callers.","parameters":[{"name":"reportId","in":"path","description":"UUID of the target report (community_portal_reports.id)","schema":{"type":"string","format":"uuid"},"required":true}],"requestBody":null,"responseBody":{"description":"Report record including lifecycle, references, and resolution notes (authorized view may vary)","typeName":"ICommunityPortalReport"},"authorizationType":null,"authorizationRole":"member","name":"at","prerequisites":[{"endpoint":{"path":"/communityPortal/member/reports","method":"post"},"description":"A report record must be created before it can be retrieved by reportId. Creating a report (via POST /communityPortal/member/reports) produces the reportId required by this GET; if report creation fails, retrieval will return 404."}]},{"specification":"Create a new moderation report in the community_portal_reports Prisma model. The endpoint accepts client-fillable report fields and returns the created canonical report. Server will set server-managed fields (created_at, status, reviewed_at, closed_at, assigned_moderator_id, resolution_notes) and must derive reporter_user_id from the authenticated principal when the caller is authenticated. Anonymous reports may be accepted (reporter_user_id = null) subject to anti-abuse controls.","path":"/communityPortal/member/reports","method":"post","summary":"Create a new moderation report (community_portal_reports)","description":"Create a new report record in the community_portal_reports table.\n\nPurpose and overview: Allows a caller to file a report about a community, post, or comment. Client-provided fields MUST be limited to: one or more target references (community_id, post_id, comment_id — at least one required), reason_code (controlled vocabulary), optional reason_text, optional is_urgent flag, optional severity, and optional reporter_contact_email. The server MUST validate targets exist and must set `created_at` and initial `status` (e.g., 'OPEN'). The server MUST NOT accept or honor client-supplied server-managed fields such as `created_at`, `reviewed_at`, `closed_at`, `status`, `assigned_moderator_id`, or `resolution_notes`.\n\nSecurity and permissions: Requires an authenticated member context for authenticated reports. If anonymous reports are supported, the server SHOULD expose a separate public endpoint or accept null reporter_user_id but MUST enforce stricter anti-abuse controls (rate-limiting, CAPTCHA). For authenticated callers, the service MUST set `reporter_user_id` to the authenticated principal and ignore any client-supplied `reporter_user_id` to preserve audit integrity.\n\nValidation rules and business logic: The server MUST validate that at least one of community_id, post_id, or comment_id is present and that any provided reference exists (404 if a referenced target does not exist). Validate `reason_code` against the allowed taxonomy. On success, server returns 201 Created with the created report record (including server-managed fields). On validation error return 400 with field-level messages; on authentication failure return 401.","parameters":[],"requestBody":{"description":"Report creation payload. Allowed client fields: community_id (nullable), post_id (nullable), comment_id (nullable) — at least one required; reason_code (string, required); reason_text (string, optional); is_urgent (boolean, optional); severity (string, optional); reporter_contact_email (string, optional). The server will derive reporter_user_id from authenticated caller (if present) and set server-managed fields.","typeName":"ICommunityPortalReport.ICreate"},"responseBody":{"description":"Created report record (community_portal_reports) with server-managed fields populated","typeName":"ICommunityPortalReport"},"authorizationType":null,"authorizationRole":"member","name":"create","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"A community must exist when the report targets a community (community_id) or when posts/comments referenced by the report belong to a community. Creating a community (POST /communityPortal/member/communities) ensures the referenced community_id is valid; if this prerequisite fails, reports referencing that community would be invalid (404)."},{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"A post must exist when the report targets a post (post_id) or when reporting a comment that belongs to a post. Creating a post (POST /communityPortal/member/posts) ensures the referenced post_id is valid; if this prerequisite fails, reports referencing that post would be invalid (404)."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/comments","method":"post"},"description":"A comment must exist when the report targets a comment (comment_id). Creating a comment (POST /communityPortal/member/posts/{postId}/comments) ensures the referenced comment_id (and its post relationship) is valid; if this prerequisite fails, reports referencing that comment would be invalid (404)."}]},{"specification":"Updates mutable fields of the community_portal_reports table in the Prisma schema. This operation targets the community_portal_reports model and allows authorized moderators to update report lifecycle properties such as status, assigned_moderator_id, closed_by_moderator_id, reviewed_at, closed_at, resolution_notes, severity, is_urgent, and reporter_contact_email. It maps directly to the Prisma model community_portal_reports and must validate foreign-key references (assigned_moderator_id, closed_by_moderator_id, community_id, post_id, comment_id) against existing records in related tables. The operation preserves auditability: implementations MUST record the acting moderator's identity and reason in platform audit logs when assignment or closure changes occur. Business validation includes allowed status transitions and controlled reason_code vocabulary enforcement at the application layer.","description":"Update an existing moderation report in the community_portal_reports table.\n\nThis operation updates only mutable fields on an existing report. It accepts any subset of the updatable properties defined by the Prisma model (for example: status, assigned_moderator_id, closed_by_moderator_id, resolution_notes, reviewed_at, closed_at, is_urgent, severity, reporter_contact_email). The endpoint does not allow changing immutable audit fields such as id or created_at. Implementations MUST validate that supplied UUIDs exist in their corresponding tables and that state transitions are permitted by workflow rules.\n\nSecurity and permissions:\nOnly authenticated moderators may call this endpoint. The application MUST perform authorization checks (for example, moderator scoped to the relevant community or elevated global moderator privileges) and return 403 Forbidden for unauthorized attempts. All assignment and closure changes MUST be recorded with actor identity in audit logs.\n\nValidation and business logic:\n- Allowed status values and reason_code vocabulary are enforced by application logic; invalid values must result in 400 Bad Request.\n- Status transitions should follow configured workflow rules (e.g., OPEN -> IN_REVIEW -> REQUIRES_ACTION -> CLOSED); invalid transitions must be rejected.\n- Timestamps (reviewed_at, closed_at) must be ISO 8601 UTC and validated server-side.\n- Any provided moderator IDs must refer to active moderator assignments; otherwise return 400.\n\nRelated operations:\n- GET /reports/{reportId} to fetch report details.\n- DELETE /reports/{reportId} to remove a report (hard delete).","summary":"Update an existing moderation report (community_portal_reports)","path":"/communityPortal/moderator/reports/{reportId}","method":"put","parameters":[{"name":"reportId","in":"path","description":"Target report's ID","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Partial report update payload. Only fields defined on the community_portal_reports model are accepted. Example updatable fields: status, assigned_moderator_id, closed_by_moderator_id, resolution_notes, reviewed_at, closed_at, is_urgent, severity, reporter_contact_email.","typeName":"ICommunityPortalReport.IUpdate"},"responseBody":{"description":"Updated report record as stored in the community_portal_reports table","typeName":"ICommunityPortalReport"},"authorizationRoles":["moderator"],"name":"update","authorizationRole":"moderator","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPortal/member/reports","method":"post"},"description":"The report resource must exist before it can be updated. Creating the report (POST /communityPortal/member/reports) ensures the {reportId} refers to an existing report record; if this prerequisite fails, update attempts will result in 404 Not Found."}]},{"specification":"Hard-delete operation for the community_portal_reports table. Because the Prisma model for community_portal_reports does not include a deleted_at soft-delete column, this operation performs a permanent removal of the report row. The operation must verify existence, enforce strict authorization (admins only in typical deployments), check for legal holds or retention policies, record a deletion audit entry with actor identity and reason, and then remove the record from the database.","description":"Permanently remove the specified moderation report from the community_portal_reports table.\n\nThis operation performs a hard delete because the Prisma model lacks a soft-delete column for reports. Before deletion the application SHOULD verify that deletion is permitted (no legal hold, retention policy constraints, or required archival). The operation MUST record an audit entry capturing the deletion actor, timestamp, and justification.\n\nSecurity and permissions:\nOnly authorized admins may call this endpoint. The application MUST enforce strict authorization and return 403 Forbidden for unauthorized attempts. Deletion is irreversible and MUST be guarded by policy checks in application logic.\n\nValidation and business logic:\n- Verify the report exists; if not, return 404 Not Found.\n- If retention or legal hold blocks deletion, return 409 Conflict.\n- Record an audit entry with actor identity and provided justification (application-level requirement) before performing the hard delete.\n\nRelated operations:\n- PUT /reports/{reportId} to update report state instead of deleting when preservation is desired.","summary":"Permanently remove a moderation report (hard delete)","path":"/communityPortal/admin/reports/{reportId}","method":"delete","parameters":[{"name":"reportId","in":"path","description":"Target report's ID","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["admin"],"name":"erase","authorizationRole":"admin","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/communityPortal/member/reports","method":"post"},"description":"The target report must exist before it can be permanently removed. POST /communityPortal/member/reports creates a moderation report and returns its id; ensuring a report record exists prevents the delete from returning 404 and provides the audit trail referenced by the deletion logic. If this prerequisite fails, the hard-delete cannot proceed."}]},{"specification":"Create a moderation report for a target post in the community_portal_reports table. This operation persists an auditable report record with required reason_code and optional reason_text, is_urgent, severity, and reporter_contact_email. It references the target post via post_id and may also populate community_id for routing. The operation uses the Prisma model community_portal_reports and validates that the referenced post exists (community_portal_posts.id).","path":"/communityPortal/member/posts/{postId}/reports","method":"post","summary":"Create a report for a post (community_portal_reports)","description":"Create a moderation report for a post and persist it to community_portal_reports.\n\nPurpose and overview:\nThis endpoint allows an authenticated member to report a post. The API inserts a record into community_portal_reports linking to the target post via post_id. Reports are intended to be auditable evidence and should remain even if the referenced post or users are later removed.\n\nSecurity and permissions:\nCaller must be authenticated as a member. The server sets reporter_user_id from the authenticated context. The implementation must not expose sensitive fields (password_hash, secrets) in the response. Access control ensures the reporter has visibility to the target post.\n\nValidation and behavior:\n- Validate path parameter postId is a UUID and that the post exists; otherwise respond 404.\n- Request body MUST include reason_code (controlled vocabulary enforced at application level). Optional fields: reason_text, is_urgent (boolean), severity, reporter_contact_email (email format validated if provided).\n- On success return HTTP 201 Created with the created report resource.\n\nErrors: 400 Bad Request (validation), 401 Unauthorized (not authenticated), 404 Not Found (post not found), 409 Conflict (duplicate-report policy if implemented).","parameters":[{"name":"postId","in":"path","description":"Target post's ID (community_portal_posts.id)","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Report creation payload: required: reason_code. Optional: reason_text, is_urgent (boolean), severity, reporter_contact_email. The server sets reporter_user_id from the authenticated member.","typeName":"ICommunityPortalReport.ICreate"},"responseBody":{"description":"Created report record persisted to community_portal_reports. Includes id, reporter_user_id, post_id, community_id (if resolved), reason_code, reason_text, is_urgent, severity, reporter_contact_email, status, created_at and audit fields.","typeName":"ICommunityPortalReport"},"authorizationType":null,"authorizationRole":"member","name":"create","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"The post's parent community must exist before creating a post. POST /communityPortal/member/communities creates the community (community_portal_communities) and returns a community_id required when creating posts. If the community does not exist, post creation will fail and subsequent report creation referencing that postId will be invalid."},{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"The reported post must exist prior to filing a report against it. POST /communityPortal/member/posts creates a post and returns its id (postId). The report operation requires a valid post_id referencing an existing community_portal_posts row; if this prerequisite fails the report creation will return 404/validation error."}]},{"specification":"Create a moderation report for a target comment in the community_portal_reports table. This operation persists an auditable report record with required reason_code and optional reason_text, is_urgent, severity, and reporter_contact_email. It references the target comment via comment_id and may populate post_id and community_id for routing. The operation uses the Prisma model community_portal_reports and validates that the referenced comment exists (community_portal_comments.id).","path":"/communityPortal/member/comments/{commentId}/reports","method":"post","summary":"Create a report for a comment (community_portal_reports)","description":"Create a moderation report for a comment and persist it to community_portal_reports.\n\nPurpose and overview:\nThis endpoint allows an authenticated member to report a comment. The API inserts a record into community_portal_reports linking to the target comment via comment_id. Reports are intended to be auditable evidence and should remain even if the referenced comment or users are later removed.\n\nSecurity and permissions:\nCaller must be authenticated as a member. The server sets reporter_user_id from the authenticated context. The implementation must not expose sensitive fields (password_hash, secrets) in the response. Access control ensures the reporter has visibility to the target comment.\n\nValidation and behavior:\n- Validate path parameter commentId is a UUID and that the comment exists; otherwise respond 404.\n- Request body MUST include reason_code (controlled vocabulary enforced at application level). Optional fields: reason_text, is_urgent (boolean), severity, reporter_contact_email (email format validated if provided).\n- On success return HTTP 201 Created with the created report resource.\n\nErrors: 400 Bad Request (validation), 401 Unauthorized (not authenticated), 404 Not Found (comment not found), 409 Conflict (duplicate-report policy if implemented).","parameters":[{"name":"commentId","in":"path","description":"Target comment's ID (community_portal_comments.id)","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Report creation payload: required: reason_code. Optional: reason_text, is_urgent (boolean), severity, reporter_contact_email. The server sets reporter_user_id from the authenticated member.","typeName":"ICommunityPortalReport.ICreate"},"responseBody":{"description":"Created report record persisted to community_portal_reports. Includes id, reporter_user_id, comment_id, post_id (if resolved), community_id (if resolved), reason_code, reason_text, is_urgent, severity, status, created_at and audit fields.","typeName":"ICommunityPortalReport"},"authorizationType":null,"authorizationRole":"member","name":"create","prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"A community must exist before creating a post that the comment belongs to. Posts require a valid community_id; if the community does not exist the subsequent post creation (and thus comment creation) will fail. Creating the community ensures the parent scope for the post/comment exists."},{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"A post must exist before a comment can be created against it. This operation creates a community_portal_posts record (returns post id) which is required to attach a comment. If post creation fails or the post id is not available, creating the comment will fail with 404/validation errors."},{"endpoint":{"path":"/communityPortal/member/posts/{postId}/comments","method":"post"},"description":"The comment resource itself must be created before it can be reported. This POST creates the community_portal_comments record and returns its generated comment id (commentId) which the report endpoint validates. If this prerequisite fails the report endpoint will return 404 Not Found for the commentId."}]},{"specification":"Retrieves a paginated, filterable list of posts authored by a specific user. This operation is associated with the Prisma model community_portal_posts and uses fields defined on that model (id, community_id, author_user_id, post_type, title, body, link_url, image_url, status, created_at, updated_at, deleted_at). The operation supports filtering by post_type and status, sorting (mode: new/top/hot/controversial), and pagination. By default the operation excludes posts with a non-null deleted_at (soft-deleted posts) unless an explicit includeDeleted flag is provided in the request. When includeDeleted=true the operation will only return soft-deleted records to authorized callers (community moderators or admins) — unauthenticated or unauthorized callers MUST receive 403 Forbidden. The response returns a paginated summary view suitable for user profile pages and feeds.","path":"/communityPortal/users/{userId}/posts","method":"patch","summary":"Search and retrieve a paginated list of posts authored by a given user (profile posts)","description":"Purpose and overview:\nRetrieve a filtered, sorted, and paginated list of posts created by the specified user. This operation is intended for user profile pages and for building user-centric feeds that show a user's public contributions. It operates on the community_portal_posts table as defined in the Prisma schema.\n\nSecurity considerations and user permissions:\nThis is a read operation and is public by default for published content. Visibility of specific posts is subject to the post.status and community visibility rules. By default, posts with deleted_at set (soft-deleted) are excluded. If includeDeleted is requested, the implementation MUST validate the requesting user's permissions: only community moderators and admins shall be permitted to view soft-deleted records; unauthorized callers must receive 403 Forbidden.\n\nRelationship to underlying database entities:\nThis operation maps directly to the community_portal_posts model. Relevant columns include: id, community_id, author_user_id, post_type, title, body, link_url, image_url, status, created_at, updated_at, deleted_at. The operation may join or reference community metadata where needed for display (e.g., community.slug/name) but must not assume additional columns beyond those defined in the Prisma model.\n\nValidation rules and business logic:\n- userId path parameter must be a UUID corresponding to community_portal_users.id.\n- Request body may include pagination (limit, offset), sort mode (hot|new|top|controversial), post_type filter (text|link|image), status filter (published|pending|removed), and includeDeleted boolean. By default (includeDeleted=false) records where deleted_at IS NOT NULL MUST be omitted.\n- If includeDeleted=true, the server MUST check caller authorization and only return deleted records to authorized roles (moderator/admin). Sorting modes \"hot\" and \"controversial\" are accepted as parameters but their algorithmic definitions are implementation details.\n\nRelated API operations:\n- GET /communities/{communityId}/posts (list posts by community)\n- GET /posts/{postId} (retrieve single post detail)\n\nExpected behavior and error handling:\n- Returns a paginated result set with post summaries. If userId does not exist, return 404 Not Found. If request validation fails (invalid pagination or filter values), return 400 Bad Request with field-level errors. If includeDeleted is true and the caller lacks permission to view deleted records, return 403 Forbidden.\n","parameters":[{"name":"userId","description":"Unique identifier (UUID) of the target user whose posts are being requested","schema":{"type":"string","format":"uuid"},"in":"path"}],"requestBody":{"description":"Search, filter, sort and pagination parameters for retrieving a user's posts","typeName":"ICommunityPortalPost.IRequest"},"responseBody":{"description":"Paginated list of post summary information authored by the specified user","typeName":"IPageICommunityPortalPost.ISummary"},"authorizationType":null,"authorizationRole":null,"prerequisites":[{"endpoint":{"path":"/communityPortal/member/communities","method":"post"},"description":"Community existence may be required when filtering posts by communityId. Creating the community ensures the communityId referenced in requests exists; if the community does not exist the listing may return 404 or empty results when filtering by communityId."},{"endpoint":{"path":"/communityPortal/member/posts","method":"post"},"description":"At least one post must exist for the target user for the listing to return results. This POST creates community_portal_posts records (author_user_id is set from the authenticated session) and seeds data that the patched index operation will retrieve. If no posts exist authored by the user, the result will be an empty page."}],"name":"index"},{"specification":"Retrieves a paginated, filterable list of comments authored by a specific user. This operation is associated with the Prisma model community_portal_comments and uses fields defined on that model (id, post_id, parent_comment_id, author_user_id, body, created_at, updated_at, deleted_at). The operation supports filtering by post_id, parent_comment_id presence (top-level vs replies), and pagination. By default soft-deleted comments (deleted_at not null) are excluded unless includeDeleted is explicitly requested. When includeDeleted=true the operation will only return soft-deleted comments to authorized callers (community moderators or admins) — unauthorized callers MUST receive 403 Forbidden.","path":"/communityPortal/users/{userId}/comments","method":"patch","summary":"Search and retrieve a paginated list of comments authored by a given user (profile comments)","description":"Purpose and overview:\nReturn a filtered and paginated list of comments created by the specified user for profile views and moderation summaries. This operation is centered on the community_portal_comments Prisma model.\n\nSecurity considerations and user permissions:\nThis read operation is public by default for non-deleted comments but must respect comment visibility and the deleted_at soft-delete marker. By default, comments with deleted_at set are omitted. If includeDeleted=true is provided, the implementation MUST check permissions and only return deleted comments to authorized callers (moderators/admins); unauthenticated or unauthorized includeDeleted requests must be rejected with 403 Forbidden.\n\nRelationship to underlying database entities:\nThis operation directly references fields on community_portal_comments: id, post_id, parent_comment_id, author_user_id, body, created_at, updated_at, deleted_at. It may include contextual post identifiers (post_id) and, where helpful, the community context via post->community_id joins, but must not assume fields outside the defined Prisma models.\n\nValidation rules and business logic:\n- userId path parameter must be a UUID referring to community_portal_users.id.\n- Request body may include pagination parameters (limit, offset), optional postId filter to narrow comments to a specific post, a flag to request only top-level comments (parent_comment_id IS NULL) or only replies, and includeDeleted boolean. By default includeDeleted=false and deleted comments MUST be excluded.\n\nRelated API operations:\n- GET /posts/{postId}/comments (comments by post)\n- GET /comments/{commentId} (single comment detail)\n\nExpected behavior and error handling:\n- Returns a paginated list of comment summaries. If the userId does not exist, return 404 Not Found. If request parameters are invalid, return 400 Bad Request. If includeDeleted is requested without adequate permission, return 403 Forbidden.\n","parameters":[{"name":"userId","description":"Unique identifier (UUID) of the target user whose comments are being requested","schema":{"type":"string","format":"uuid"},"in":"path"}],"requestBody":{"description":"Search, filter and pagination parameters for retrieving a user's comments","typeName":"ICommunityPortalComment.IRequest"},"responseBody":{"description":"Paginated list of comment summary information authored by the specified user","typeName":"IPageICommunityPortalComment.ISummary"},"authorizationType":null,"authorizationRole":null,"prerequisites":[{"endpoint":{"path":"/communityPortal/member/posts/{postId}/comments","method":"post"},"description":"If the request filters by parentCommentId, the referenced parent comment must already exist. Create the parent comment using POST /communityPortal/member/posts/{postId}/comments to obtain a valid parent_comment_id; without this the filter will reference a non-existent comment and the operation may return 404 or produce no results."}],"name":"index"}],"components":{"authorization":[{"name":"guest","description":"Unauthenticated visitor with read-only access to public communities and content discovery features. Can browse communities and view posts and comments but cannot create content, vote, comment, or subscribe.","kind":"guest"},{"name":"member","description":"Authenticated user who can create and manage their own account, create posts (text/link/image), comment, vote, subscribe to communities, report content, and view/edit their profile. Eligible to gain karma through community interactions.","kind":"member"},{"name":"moderator","description":"Authenticated community-level manager appointed to one or more specific communities. Can review and act on reports within those communities, remove or approve posts/comments in their communities, pin or lock posts, and manage community-specific rules and settings. Moderator actions are scoped to assigned communities.","kind":"member"},{"name":"admin","description":"Authenticated global administrator with elevated privileges across the entire platform. Can manage users, resolve escalated reports, enforce bans, configure system-wide policies, and perform platform-level moderation and maintenance.","kind":"admin"}],"schemas":{"IPage.IPagination":{"type":"object","properties":{"current":{"type":"integer","minimum":0,"description":"Current page number."},"limit":{"type":"integer","minimum":0,"description":"Limitation of records per a page."},"records":{"type":"integer","minimum":0,"description":"Total records in the database."},"pages":{"type":"integer","minimum":0,"description":"Total pages.\n\nEqual to {@link records} / {@link limit} with ceiling."}},"required":["current","limit","records","pages"],"description":"Page information."},"IAuthorizationToken":{"type":"object","properties":{"access":{"type":"string","description":"JWT access token for authenticated requests.\n\nThis token should be included in the Authorization header for subsequent\nauthenticated API requests as `Bearer {token}`."},"refresh":{"type":"string","description":"Refresh token for obtaining new access tokens.\n\nThis token can be used to request new access tokens when the current access\ntoken expires, extending the user's session."},"expired_at":{"type":"string","format":"date-time","description":"Access token expiration timestamp.\n\nISO 8601 date-time string indicating when the access token will expire and\ncan no longer be used for authentication."},"refreshable_until":{"type":"string","format":"date-time","description":"Refresh token expiration timestamp.\n\nISO 8601 date-time string indicating the latest time until which the\nrefresh token can be used to obtain new access tokens."}},"required":["access","refresh","expired_at","refreshable_until"],"description":"Authorization token response structure.\n\nThis interface defines the structure of the authorization token response\nreturned after successful user authentication. It contains both access and\nrefresh tokens along with their expiration information.\n\nThis token structure is automatically included in API schemas when the system\ndetects authorization roles in the requirements analysis phase. It provides a\nstandard format for JWT-based authentication across the generated backend\napplications."},"IPageICommunityPortalUser.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPortalUser.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageICommunityPortalCommunity.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPortalCommunity.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageICommunityPortalSubscription.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPortalSubscription.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageICommunityPortalPost.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPortalPost.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageICommunityPortalPost":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPortalPost"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageICommunityPortalComment.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPortalComment.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageICommunityPortalVote.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPortalVote.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageICommunityPortalReport.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPortalReport.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"ICommunityPortalGuest.ICreate":{"type":"object","x-autobe-prisma-schema":"community_portal_guests","properties":{},"required":[],"description":"Request DTO for creating a guest session recorded in the community_portal_guests Prisma table.\n\nThis object intentionally contains no client-supplied actor or system-managed fields. The server MUST generate the guest session record server-side and populate id, guest_token, created_at, and expired_at. Association to an existing user (if applicable) must be performed server-side based on authenticated context or explicit server-side binding flows; clients MUST NOT supply user_id, author_id, or other actor identifiers in this Create DTO.\n\nNotes:\n- Do not include password or any sensitive user credential in this payload.\n- The server is responsible for generating the guest_token, id, created_at and expired_at fields."},"ICommunityPortalGuest.IAuthorized":{"type":"object","x-autobe-prisma-schema":"community_portal_guests","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the guest session record in community_portal_guests. This is a server-assigned UUID identifying the created guest session."},"user_id":{"type":"string","format":"uuid","description":"Reference to the associated community_portal_users.id. This field reflects the user association recorded on the guest session. If the guest session was created bound to a user, this contains that user's UUID."},"guest_token":{"type":"string","description":"Cryptographically-secure token issued for the guest session. This token is the credential the client will present for guest-authenticated requests and MUST be treated as sensitive by clients (store in memory or short-lived storage)."},"created_at":{"type":"string","format":"date-time","description":"Timestamp (UTC) when the guest session record was created in the database (community_portal_guests.created_at)."},"expired_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Expiration timestamp for the issued guest_token (community_portal_guests.expired_at). This field may be null if the server represents non-expiring sessions (rare); clients SHOULD treat null as indefinite or consult server policies. Typically this contains an ISO 8601 date-time in UTC after which the token must be considered invalid."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","user_id","guest_token","created_at","token"],"description":"Authorized response returned after successful guest-join or guest-refresh operations.\n\nThis object reflects the persisted community_portal_guests record and includes the server-generated id, the bound user_id (if any), the issued guest_token, and timestamps for creation and expiry. The server MUST NOT return sensitive user authentication data such as password_hash. Clients use guest_token as a bearer credential for guest-scoped access until expired_at.\n\nBehavioral notes:\n- guest_token MUST be treated as a secret by clients and stored according to security best-practices for short-lived credentials.\n- The server is responsible for token rotation on refresh and must update expired_at accordingly.\n- When x-autobe-prisma-schema is present, every property in this schema corresponds to an actual column in the Prisma model community_portal_guests."},"ICommunityPortalGuest.IRefresh":{"type":"object","x-autobe-prisma-schema":"community_portal_guests","properties":{"guest_token":{"type":"string","description":"Guest session token issued by POST /auth/guest/join and stored in community_portal_guests.guest_token.\n\nThis token is a cryptographically-secure opaque string that the server validates against the community_portal_guests table. Clients MUST present this token when calling the guest refresh operation. The server MUST reject requests with unknown or expired tokens."}},"required":["guest_token"],"description":"Payload to refresh a guest session.\n\nThis object represents the request body for the guest token refresh endpoint. It contains the single required property guest_token which maps to community_portal_guests.guest_token in the Prisma schema. The server will validate the token, ensure the corresponding record's expired_at has not lapsed, and (where applicable) rotate the token and update expired_at.\n\nOnly the guest_token is required for this request. No passwords or other PII are accepted in this payload."},"ICommunityPortalMember.ICreate":{"type":"object","properties":{"username":{"type":"string","description":"Unique login handle for the new account. Maps to community_portal_users.username in the Prisma schema.\n\nThe value should be a user-visible identifier (3-30 characters recommended) and will be validated for uniqueness by the server. Do not include whitespace-only values. The server enforces username uniqueness and will return 409 Conflict on duplicates."},"email":{"type":"string","format":"email","description":"Primary email address for the account. Maps to community_portal_users.email.\n\nThis address is used for verification and account recovery. The server will validate format and uniqueness. For privacy and security the API will not return whether an email exists in verbose error messages; on registration conflicts the server returns 409 Conflict."},"password":{"type":"string","description":"Plain-text password supplied by the client. The server MUST hash and salt this value and persist the result into community_portal_users.password_hash. Clients MUST NOT send pre-hashed passwords. Password strength requirements are enforced server-side (example: minimum length and complexity)."},"display_name":{"type":"string","description":"Optional human-friendly display name. Maps to community_portal_users.display_name.\n\nThis value is shown in UI contexts and is not required to be unique. If omitted, the server may derive a display name from the username."}},"required":["username","email","password"],"description":"Request payload to register a new member.\n\nThis DTO is used by POST /auth/member/join to create a new community_portal_users row and the corresponding community_portal_members record. Required properties: username, email, and password. Optional property: display_name. The server will create the user record and a membership record (community_portal_members) with is_email_verified=false and member_since set to the current timestamp. Passwords are never stored in plaintext; the server is responsible for hashing and storing the password in community_portal_users.password_hash.\n\nValidation rules (business-level): the server will enforce uniqueness for username and email and apply password-strength checks. Returns 409 on uniqueness conflicts and 400 for invalid formats."},"ICommunityPortalMember.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the authenticated user. This property corresponds to the `id` column on the Prisma model `community_portal_users` and is the primary key used across the platform to reference the user.\n\nThis value is generated by the system at account creation and MUST be returned to clients to identify the authenticated principal in subsequent calls."},"username":{"type":"string","description":"Canonical login handle of the authenticated user as stored in `community_portal_users.username`.\n\nThis value is the public short identifier displayed in UI attribution and used for sign-in (or an alternative identifier such as email, depending on frontend flows)."},"display_name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Human-friendly display name stored in `community_portal_users.display_name`.\n\nThis field may be null when a user has not configured a display name. When present, it is intended for UI display and may contain spaces and punctuation."},"karma":{"type":"integer","description":"Aggregated reputation score persisted on the Prisma model as `community_portal_users.karma`.\n\nKarma is an integer used for reputation and gating. The exact calculation of karma is a platform business rule and is derived from vote events and other actions; this schema property provides the current stored value for client display."},"avatar_uri":{"oneOf":[{"type":"string","format":"uri"},{"type":"null"}],"description":"Optional avatar image URI mapped from `community_portal_users.avatar_uri`.\n\nMay be null when the user has not set an avatar. When present, this URI should be treated as a pointer to a media resource and must not contain secrets."},"created_at":{"type":"string","format":"date-time","description":"Account creation timestamp mapped from `community_portal_users.created_at` in the Prisma schema.\n\nThis is returned for informational purposes (for example, \"joined on\" displays) and is represented in ISO 8601 UTC date-time format."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","token"],"description":"Authorization response returned after successful member authentication or registration.\n\nThis schema represents a safe, public-facing view of the authenticated user combined with issued token information. It intentionally excludes sensitive storage fields such as `password_hash` and `email` (these exist on the `community_portal_users` Prisma model but are never exposed).\n\nThe `token` property reuses the central `IAuthorizationToken` component to standardize token format across authentication responses."},"ICommunityPortalMember.ILogin":{"type":"object","properties":{"identifier":{"type":"string","description":"Identifier for authentication. Accepts either the user's username or their verified email address. The server will resolve this value against `community_portal_users.username` and `community_portal_users.email` to locate the account.\n\nClients SHOULD normalize the identifier (trim whitespace) prior to submission."},"password":{"type":"string","description":"Plain-text password supplied by the user for authentication. The server MUST validate the provided password against the stored `community_portal_users.password_hash` and MUST NOT accept a pre-hashed value from clients.\n\nPasswords are transmitted only over secure channels (TLS) and MUST meet platform-defined strength requirements enforced server-side."},"remember":{"type":"boolean","description":"Optional flag indicating whether the client requests a long-lived session (refresh token issuance/extended session). This field is advisory and the server may ignore it based on policy."}},"required":["identifier","password"],"description":"Login request payload for member authentication.\n\n`identifier` may be either username or email; `password` is the plain-text credential. The server will perform credential verification against the `community_portal_users` model and validate membership state via `community_portal_members.is_email_verified` as appropriate. This DTO is intentionally minimal and does not include tokens or server-managed fields."},"ICommunityPortalMember.IRefresh":{"type":"object","properties":{"refreshToken":{"type":"string","description":"Refresh token string previously issued by the authentication service.\n\nThis token is a time-limited credential that the client presents to obtain a new access token without re-supplying primary credentials. The token value MUST be treated as sensitive and transported only over TLS. The server validates the token against its authorization store and may rotate it on successful refresh."}},"required":["refreshToken"],"description":"Request body to refresh member authentication tokens.\n\nClients call this endpoint to exchange a valid refresh token for a new access token (and optionally a rotated refresh token). The request contains only the opaque refreshToken value; the server is responsible for validating the token, ensuring the referenced community_portal_users record still exists and is eligible (not suspended), and returning a new authorization payload.\n\nThis DTO intentionally contains only the refresh token to minimize sensitive payload surface area and to keep token handling server-driven. Do not include credentials, user-identifying fields, or other sensitive material in this request object."},"ICommunityPortalMember.IRequestPasswordReset":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Email address associated with the member's account in community_portal_users.email.\n\nThis address is used to locate the account and to deliver a single-use password reset artifact (token or link). For privacy, the API that accepts this DTO SHOULD respond generically (for example, always returning a success acknowledgement) so as not to reveal whether the email is present in the system. The server MUST validate the syntax of the email and enforce anti-abuse protections (rate limits, CAPTCHA) before issuing a reset token."}},"required":["email"],"description":"Request to initiate a password-reset flow for a member.\n\nThe request contains the target email address for which a password reset should be initiated. The implementation will look up the corresponding community_portal_users record, generate a single-use, time-limited reset token, and deliver it to the supplied email address. This DTO intentionally carries only the email field to minimize information exposure and to align with privacy-preserving practices."},"ICommunityPortalMember.IPasswordResetRequested":{"type":"object","properties":{"message":{"type":"string","description":"User-facing confirmation message indicating that a password reset request was received.\n\nThis message is intentionally generic to avoid account enumeration. It does not confirm the existence of an account for the supplied email and provides guidance about next steps (for example, checking the inbox for a reset link). Use this message to inform the user that the reset flow was initiated."},"request_id":{"type":"string","description":"Optional opaque identifier for the password reset request created by the system.\n\nThis identifier may be used for internal tracing or support follow-up. It MUST NOT contain secrets or the reset token. Implementations may omit this property in the response; when present it provides an audit reference for support and diagnostics."}},"required":["message"],"description":"Acknowledgement returned after initiating a password reset request.\n\nThis response confirms that the system has processed the password reset request. For privacy and security, the message is deliberately non-committal about whether an account exists for the supplied email address. The payload may include an optional internal request identifier for support and tracing but MUST NOT include any secrets (reset tokens) or user-sensitive fields.\n\nUse this DTO to display a consistent confirmation to users after they request a password reset."},"ICommunityPortalMember.IChangePassword":{"oneOf":[{"$ref":"#/components/schemas/ICommunityPortalMember.IChangePassword.ITokenFlow"},{"$ref":"#/components/schemas/ICommunityPortalMember.IChangePassword.ICurrentPasswordFlow"}],"description":"Request body for setting a new password. Accepts exactly one of the supported flows:\n\n1) Token flow: the client supplies a single-use reset token and the new password. Used when the user follows a password-reset link delivered via email.\n\n2) Current-password flow: the authenticated user supplies their current password together with the desired new password. Used when a logged-in user changes their password.\n\nThe API validates which flow is being used by the presence of the respective required properties. Implementations MUST NOT accept both flows in the same request. Passwords are provided in plaintext in the request and MUST be hashed server-side before persisting; the API MUST never return password hashes in responses."},"ICommunityPortalMember.IChangePassword.ITokenFlow":{"type":"object","properties":{"resetToken":{"type":"string","description":"Single-use password reset token issued by the password-reset initiation flow. The token MUST be validated server-side for expiry and binding to a user account. Tokens are time-limited and single-use; treat them as secrets."},"newPassword":{"type":"string","minLength":8,"description":"The new plaintext password the user wishes to set.\n\nPassword strength requirements: recommended minimum 8 characters including at least one letter and one number. Server-side policies may enforce additional checks (special character requirements, breached-password checks, reuse prevention). The client MUST submit the raw password; the server is responsible for hashing and securely storing the derived password_hash."}},"required":["resetToken","newPassword"],"description":"Change-password payload using a reset token.\n\nUse this shape when the caller has a valid reset token issued by the password-reset request flow. The server will validate the token, locate the bound user, and replace the stored password_hash with a securely hashed representation of newPassword. The response to this operation is an acknowledgement and must not contain password or password_hash values."},"ICommunityPortalMember.IChangePassword.ICurrentPasswordFlow":{"type":"object","properties":{"currentPassword":{"type":"string","minLength":8,"description":"The user's current plaintext password. The server MUST validate this value against the stored password_hash prior to applying the new password."},"newPassword":{"type":"string","minLength":8,"description":"The new plaintext password the user wishes to set. See server-side password strength/rotation policy; the server will hash and store the derived password_hash and must not return it in responses."}},"required":["currentPassword","newPassword"],"description":"Change-password payload for authenticated users using their current password. The server MUST verify currentPassword, apply password strength validation to newPassword, hash it securely, update the stored password_hash for the authenticated user, and revoke or rotate active refresh tokens as policy dictates."},"ICommunityPortalMember.IChangePasswordResult":{"type":"object","properties":{"success":{"type":"boolean","description":"Indicates whether the password change operation completed successfully.\n\nTrue when the server accepted and applied the new password hash for the authenticated user; false when the operation failed due to validation, authorization, or other server-side errors."},"message":{"type":"string","description":"Human-readable message describing the outcome of the password change operation.\n\nThis message is intended for display in the client UI and should be non-sensitive. Examples: \"Password changed successfully.\" or \"Current password is incorrect.\" Do not include raw password data or internal error traces in this message."}},"required":["success","message"],"description":"Result returned after a change-password operation.\n\nThis DTO represents the business-level outcome of updating the caller's credential (the server-side update of community_portal_users.password_hash). It intentionally contains no sensitive fields (e.g., password_hash) and provides a simple success flag and a user-facing message. Use this response to acknowledge completion or surface expected next steps (for example, prompting re-login if the implementation invalidates active sessions)."},"ICommunityPortalMember.IVerifyEmail":{"type":"object","properties":{"success":{"type":"boolean","description":"Indicates whether the email verification succeeded.\n\nTrue when the verification token was valid and the membership record was updated (community_portal_members.is_email_verified set to true). False when the token was invalid, expired, or the account cannot be verified for business reasons."},"userId":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"The UUID of the user whose email was verified.\n\nThis field mirrors the primary key of the corresponding community_portal_users record when the verification is successful and the server elects to return it. It may be null in cases where the server chooses not to return identifying information (for privacy) or when verification failed."},"message":{"type":"string","description":"A descriptive, non-sensitive message intended for client display.\n\nOn success this typically reads: \"Email verified successfully.\" On failure provide a clear, actionable message such as: \"Verification token expired. Request a new verification email.\" Avoid returning internal diagnostics or security-sensitive details."}},"required":["success","message"],"description":"Response returned after consuming an email verification token.\n\nThis DTO communicates whether the verification completed and provides optional linkage to the verified user's id. It is designed to be safe for client consumption: no authentication secrets or internal hashes are included. The implementation may optionally include userId when appropriate for the client workflow, but it MUST omit any sensitive fields such as password_hash."},"ICommunityPortalMember.IVerifyEmailResult":{"type":"object","properties":{"success":{"type":"boolean","description":"Indicates whether the email verification operation completed successfully.\n\nTrue when the verification token was accepted and the membership record (community_portal_members.is_email_verified) was updated. False when the token was invalid, expired, or verification could not be completed."},"message":{"type":"string","description":"Human-friendly message describing the verification result suitable for direct display in client UI. Avoid returning internal diagnostics or sensitive data."},"user":{"$ref":"#/components/schemas/ICommunityPortalUser.ISummary","description":"Optional public-safe summary of the user record after verification. This object MUST follow the ICommunityPortalUser.ISummary schema and therefore MUST NOT expose sensitive fields such as password_hash, password_hash variants, salts, refresh tokens, or internal system flags. It is included only when the server chooses to surface minimal profile information to the client."}},"required":["success"],"description":"Result of an email verification operation for a member.\n\nThis DTO is returned after consuming a verification token. The 'success' flag is REQUIRED and MUST be true when verification succeeded. The optional 'user' property references a public-safe user summary (ICommunityPortalUser.ISummary) to avoid leaking sensitive authentication fields.\n\nSecurity note: Under no circumstances shall this response include password hashes, salts, tokens, or other secrets. Any schema referenced by 'user' MUST be validated to ensure it contains only public-facing fields."},"ICommunityPortalUser":{"type":"object","x-autobe-prisma-schema":"community_portal_users","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the user. Corresponds to community_portal_users.id in the Prisma schema.\n\nThis property is a UUID assigned by the system at user creation and is used to reference the user across related records such as posts, comments, subscriptions, and reports. It is immutable once created."},"username":{"type":"string","description":"Unique login handle for the account. Corresponds to community_portal_users.username in the Prisma schema.\n\nThis value is used for public attribution of content and for authentication login identifiers. It must be unique across the system and is canonicalized/case rules are enforced by the backend."},"display_name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional human-friendly display name shown in UI. Maps to community_portal_users.display_name in the Prisma schema.\n\nThis value is intended for presentation and may differ from the unique username. It can be null when a user has not set a display name. Keep this field concise to fit profile layouts."},"bio":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional profile biography text for the user (community_portal_users.bio in Prisma).\n\nUse this free-text field to present a short biography. The platform may index this field for fuzzy search (GIN trigram index at the DB level), so avoid extremely large blobs. Can be null if not provided."},"avatar_uri":{"oneOf":[{"type":"string","format":"uri"},{"type":"null"}],"description":"Optional avatar image URI (community_portal_users.avatar_uri in the Prisma schema).\n\nThis is a client-displayable URI referencing the user's avatar image. The backend should validate and sanitize stored URIs. The property may be null if the user has no avatar."},"karma":{"type":"integer","description":"Aggregated integer karma score for the user as stored in community_portal_users.karma.\n\nThis value represents the persisted reputation metric and is used for display and gating decisions. It is updated by backend processes in response to vote events and moderation actions."},"created_at":{"type":"string","format":"date-time","description":"Record creation timestamp in UTC corresponding to community_portal_users.created_at.\n\nThis timestamp is assigned at account creation and is useful for sorting, auditing, and calculating account age-based rules."},"updated_at":{"type":"string","format":"date-time","description":"Last modification timestamp in UTC corresponding to community_portal_users.updated_at.\n\nReflects the most recent profile or account metadata change and is useful for optimistic concurrency and audit displays."}},"required":["id","username","karma","created_at","updated_at"],"description":"Public representation of a CommunityPortal user.\n\nThis schema maps to the Prisma model community_portal_users and intentionally exposes only non-sensitive, public-facing fields. Sensitive authentication fields such as password_hash are deliberately excluded from this representation.\n\nProperties included here exist in the Prisma model and are documented with references to the corresponding columns."},"ICommunityPortalModerator.ICreate":{"type":"object","x-autobe-prisma-schema":"community_portal_users","properties":{"username":{"type":"string","description":"Desired unique username for the moderator account. The server will validate uniqueness against existing users."},"email":{"type":"string","format":"email","description":"Email address for the moderator account. Used for verification and notifications."},"password":{"type":"string","description":"Plain-text password supplied by the client. The server MUST hash and salt this value before persisting to the database (do NOT store this value as-is)."},"display_name":{"type":"string","description":"Optional human-friendly display name for the moderator profile."},"avatar_uri":{"oneOf":[{"type":"string","format":"uri"},{"type":"null"}],"description":"Optional avatar image URI. If provided the server will validate and store a reference."}},"required":["username","email","password"],"description":"Payload for creating a new moderator account. This DTO is a request shape and represents client-supplied fields used to create underlying records (community_portal_users and community_portal_members). The server is responsible for mapping and persisting these values to the Prisma models, hashing the password into password_hash, creating the membership record (is_email_verified=false), and performing any moderator-appointment workflow.\n\nSecurity notes:\n- The 'password' field is required in this request schema as plaintext; the implementation MUST NOT accept a pre-hashed password from clients.\n- This request schema intentionally does NOT include server-managed fields (id, created_at, updated_at) or internal-only columns (password_hash)."},"ICommunityPortalModerator.IAuthorized":{"type":"object","x-autobe-prisma-schema":"community_portal_users","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the moderator (maps to community_portal_users.id).\n\nThis is the canonical UUID assigned to the user account. It is used by clients to reference the authenticated moderator in subsequent requests and must match the value stored in the database."},"username":{"type":"string","description":"Public username/handle for the moderator (maps to community_portal_users.username).\n\nThis value is unique across the platform and is intended for display and attribution purposes."},"display_name":{"type":"string","description":"Human-friendly display name for the moderator (maps to community_portal_users.display_name).\n\nThis field is optional in the database but included here when present for UI display. It may be null in some profiles."},"karma":{"type":"integer","description":"Aggregated karma score for the moderator (maps to community_portal_users.karma).\n\nThis integer reflects reputation derived from community activity. Calculation details are governed by business rules and may be computed from vote events."},"avatar_uri":{"type":"string","description":"Optional URL for the moderator's avatar image (maps to community_portal_users.avatar_uri).\n\nThis is provided when available to help client UIs render a profile picture. The server may normalize or proxy images; clients should treat this as a display-only URI."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","username","token"],"description":"Authorization response for a moderator account.\n\nThis object is returned after successful moderator authentication flows (login, join for moderator accounts, or token refresh). It contains the minimal public profile information derived from the community_portal_users Prisma model and an authorization token container under the property `token`.\n\nThe shape intentionally exposes only public, non-sensitive fields from the user record (id, username, display_name, avatar_uri, karma). Sensitive authentication artifacts such as password_hash are never included. When this schema is used, the server guarantees that every property annotated as coming from the Prisma model actually exists on the referenced model or is a safe relation-derived value."},"ICommunityPortalModerator.ILogin":{"type":"object","properties":{"identifier":{"type":"string","description":"User identifier used to authenticate. This may be either the moderator's email address or username. The server will resolve the identifier to the corresponding community_portal_users record."},"password":{"type":"string","description":"Plain-text password provided by the user for authentication. The server MUST hash and compare this value against the stored password_hash. Clients MUST transmit this value only over secure channels (TLS) and SHOULD not store it locally."}},"required":["identifier","password"],"description":"Login request payload for moderator authentication.\n\nClients submit this object to authenticate a moderator using credentials that map to the community_portal_users table. The server resolves the `identifier` to a user record (by email or username), verifies the `password` against the stored password hash, and returns an ICommunityPortalModerator.IAuthorized response on success. This request schema intentionally avoids exposing or accepting fields that would mutate server-side accounts (for example, user id or password_hash)."},"ICommunityPortalModerator.IRefresh":{"type":"object","properties":{"refresh_token":{"type":"string","description":"Refresh token previously issued by the authentication service. This token MUST be presented exactly as issued (do not modify or trim). Typical tokens are opaque strings or JWTs. The server will validate token integrity, expiry, and binding to the user account before issuing new access credentials.","minLength":10},"device_id":{"type":"string","format":"uuid","description":"Optional identifier of the device or client instance requesting token renewal. When present, the server MAY validate that the refresh token is bound to this device and may use the value for auditing and token-rotation policies. This field is optional and may be omitted by clients that do not track device identifiers."}},"required":["refresh_token"],"description":"Request payload for renewing moderator authentication tokens.\n\nThis object represents the minimal client request to obtain a fresh access token (and optionally a rotated refresh token) for a moderator account. The `refresh_token` property is mandatory and must contain the previously issued refresh credential. The optional `device_id` value (UUID) may be provided when the client tracks device-scoped sessions and wishes the server to enforce device-bound token semantics.\n\nSecurity note: Do not include sensitive secrets other than the refresh token. The server will perform membership and suspension checks against the moderator's account before returning renewed tokens."},"ICommunityPortalModerator.IVerifyEmailRequest":{"type":"object","properties":{"verification_token":{"type":"string","minLength":8,"description":"Single-use verification token issued by the system during moderator account registration. This token is time-limited and MUST be submitted exactly as delivered in the verification email or out-of-band message. Tokens are single-use and will be invalidated after successful consumption or expiry."}},"required":["verification_token"],"description":"Payload to verify a moderator's email address.\n\nProvide the single-use `verification_token` issued at registration. The server will resolve the token to the corresponding user account and perform the verification; clients MUST NOT supply or attempt to override the actor identity (for example, by submitting a `user_id`). Actor identity is derived server-side from the token mapping and must never be accepted from clients.\n\nSecurity note: Tokens are single-use and time-limited; on successful verification the server will set the moderator membership record's email-verified flag. If the token is invalid or expired, the server MUST return an appropriate error (e.g., 400/401) without leaking internal account identifiers."},"ICommunityPortalUser.ISummary":{"type":"object","x-autobe-prisma-schema":"community_portal_users","properties":{"id":{"type":"string","format":"uuid","description":"Primary identifier of the user as stored in the Prisma model community_portal_users.id.\n\nThis value is the canonical UUID used across the platform to reference the user. It is generated by the system and never supplied by clients when creating resources."},"username":{"type":"string","description":"Unique login handle for the user (community_portal_users.username).\n\nThis is the primary display handle used in list views and attribution. It must be unique across the system and is suitable for use in URLs and mentions."},"display_name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional human-friendly display name (community_portal_users.display_name).\n\nThis value is shown in UIs where a more readable name than the username is preferred. It may be null if the user did not provide a display name."},"bio":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional profile biography text (community_portal_users.bio).\n\nThis short free-text field may be indexed for fuzzy search (as indicated by the Prisma trigram index) and can be null when the user has not provided a biography."},"avatar_uri":{"oneOf":[{"type":"string","format":"uri"},{"type":"null"}],"description":"Optional avatar image URI for the user's profile (community_portal_users.avatar_uri).\n\nWhen present, this should be a publicly accessible URI suitable for displaying the user's avatar. It may be null when no avatar is set."},"karma":{"type":"integer","description":"Aggregated reputation score for the user (community_portal_users.karma).\n\nThis integer reflects the user's reputation as stored in the Prisma model. The authoritative calculation may be driven by vote events, but this field holds the persisted aggregate used for display and gating."},"created_at":{"type":"string","format":"date-time","description":"Record creation timestamp in UTC (community_portal_users.created_at).\n\nUsed to show join date and for sorting/filtering in admin or analytics views."},"updated_at":{"type":"string","format":"date-time","description":"Last modification timestamp in UTC (community_portal_users.updated_at).\n\nIndicates when the user record was last changed (profile edit, karma update, etc.)."}},"required":["id","username","karma","created_at","updated_at"],"description":"Public summary view of a user (ICommunityPortalUser.ISummary).\n\nThis DTO represents the safe, public-facing subset of the community_portal_users Prisma model suitable for list and profile summary displays. It intentionally omits sensitive fields such as email and password_hash. The schema maps directly to the Prisma model fields and is intended for use wherever a compact user representation is required (author attribution, lists, leaderboards).\n\nProperty notes:\n- id and username are required to uniquely identify a user in lists.\n- karma is included for reputation display and gating checks in the UI.\n- Optional fields (display_name, bio, avatar_uri) may be null when absent."},"ICommunityPortalModerator.IVerifyEmailResponse":{"type":"object","properties":{"success":{"type":"boolean","description":"Indicates whether the email verification succeeded.\n\nWhen true, the membership record (community_portal_members.is_email_verified) has been set to true for the linked user."},"message":{"type":"string","description":"Human-readable message describing the result of the verification operation.\n\nClients can display this message to inform the user of the verification outcome or next steps."},"user":{"oneOf":[{"$ref":"#/components/schemas/ICommunityPortalUser.ISummary"},{"type":"null"}],"description":"Optional minimal user summary reflecting the verified account or null when the implementation chooses not to return user details. When present, this object contains safe public fields from the community_portal_users model (id, username, display_name, avatar_uri, karma, created_at, updated_at). This property is nullable to reflect cases where privacy or minimal responses are required."}},"required":["success","message"],"description":"Response returned after consuming an email verification token for a moderator candidate.\n\nThis response indicates whether the verification token was accepted and the membership record was updated (community_portal_members.is_email_verified = true). It MAY include a minimal user summary (ICommunityPortalUser.ISummary) when the implementation chooses to return the updated user view to the caller.\n\nThe response never contains sensitive authentication data (for example, password_hash) and is safe to display in client UIs."},"ICommunityPortalModerator.IRequestPasswordReset":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"The email address associated with the moderator account (community_portal_users.email).\n\nThis value must be a valid email address. For privacy, the server will respond with a generic acknowledgement regardless of whether an account exists for the supplied address."}},"required":["email"],"description":"Request payload to initiate a password reset for a moderator account.\n\nThe server uses the supplied email to locate the corresponding community_portal_users record and, if present, issue a time-limited reset token delivered to that email. To avoid account enumeration attacks the API returns a generic confirmation message to callers regardless of whether the email exists."},"ICommunityPortalModerator.IRequestPasswordResetResponse":{"type":"object","properties":{"message":{"type":"string","description":"Human-readable confirmation message indicating that a password reset request was received and that a reset artifact (e.g., email with a reset link) will be sent if an account exists. This message is intentionally generic to avoid account enumeration. Example: \"If an account exists for that email, a password reset link has been sent.\""},"next_steps":{"type":"string","description":"Optional guidance for the client on next steps the user should take (e.g., check email, allow up to X minutes). This field is optional and may be omitted by the server if no additional guidance is required."},"case_id":{"type":"string","description":"Optional support or case identifier provided when the system wishes to surface a reference for the user's request. This field SHOULD NOT reveal account existence and is optional for correlating support tickets."}},"required":["message"],"description":"Acknowledgement returned after a password reset request.\n\nThis response intentionally provides a generic confirmation that a password reset request was processed. It MUST NOT reveal whether the supplied email address corresponds to an existing account. The primary property is `message`, which contains user-facing text. Optional properties such as `next_steps` and `case_id` may be provided by the server for UX or support workflows.\n\nUse cases:\n- Returned by endpoints that initiate password-reset flows to inform the caller a reset was requested without exposing account existence.\n\nSecurity note:\n- Do not include any sensitive account information (for example, do NOT include email, user id, or password_hash).","title":"ICommunityPortalModerator.IRequestPasswordResetResponse"},"ICommunityPortalModerator.IResetPassword":{"type":"object","properties":{"resetToken":{"type":"string","description":"Single-use password reset token issued by the system (opaque string). The token is time-limited and MUST be consumed by this endpoint to authorize the password change. The server validates the token and maps it to the target user account."},"newPassword":{"type":"string","description":"The user's desired new password in plaintext. The server will hash and salt this value before persisting; the raw value MUST NOT be stored. Password strength requirements SHOULD be enforced by the server (e.g., minimum length, complexity). Example: a recommended minimum length is 8 characters.","minLength":8},"rotateSessions":{"type":"boolean","description":"Optional flag indicating whether existing sessions/refresh tokens should be rotated/revoked after the password change. When true, the server SHOULD revoke or rotate active refresh tokens for the affected account to prevent session fixation. If omitted, the server applies the default session-handling policy.","default":true}},"required":["resetToken","newPassword"],"description":"Payload to complete a password reset using a reset token.\n\nThis object is submitted to the reset-confirmation endpoint to finalize a password reset. Required fields:\n- `resetToken`: the single-use token previously issued by the request-reset operation.\n- `newPassword`: the new plaintext password which the server will securely hash.\n\nOptional field `rotateSessions` allows the client to indicate whether existing sessions should be invalidated; servers SHOULD revoke existing refresh tokens by default for security.\n\nSecurity guidance:\n- The server MUST validate token expiry and single-use semantics.\n- The server MUST NOT echo the new password in any response and MUST apply secure hashing before storing.","title":"ICommunityPortalModerator.IResetPassword"},"ICommunityPortalModerator.IResetPasswordResponse":{"type":"object","properties":{"success":{"type":"boolean","description":"Indicates whether the password reset operation was completed successfully.\n\nThis boolean is true when the reset token was valid and the new password was accepted and persisted. It is false when the operation failed due to an invalid or expired token, a violation of password policy, or other validation errors."},"message":{"type":"string","description":"Human-readable, client-facing message describing the result of the password reset attempt.\n\nMessages should be non-technical and actionable (for example: \"Password has been reset successfully. Please sign in with your new password.\"). For security and privacy reasons, responses SHOULD NOT disclose whether a specific email exists during request flows that initiate resets; this property is intended for the final confirmation after a valid reset token has been consumed."}},"required":["success","message"],"description":"Response returned after completing a password reset flow for a moderator account.\n\nThis object is returned when a password reset token is consumed and the server has attempted to update the moderator account's credential (community_portal_users.password_hash). The response provides a simple success indicator and a user-facing message summarizing the outcome.\n\nThe response intentionally avoids returning sensitive data (such as password hashes or tokens) and is suitable for direct display in client UIs or for driving subsequent client workflows (for example, redirecting the user to the login screen)."},"ICommunityPortalModerator.IChangePassword":{"type":"object","properties":{"currentPassword":{"type":"string","minLength":8,"description":"The moderator's current plain-text password.\n\nThis field must contain the current password for the authenticated moderator and will be verified by the server against community_portal_users.password_hash. The server MUST use a secure, constant-time comparison and reject the request if verification fails. Plain-text is required here because the server is responsible for hashing and salting when updating the stored password hash."},"newPassword":{"type":"string","minLength":8,"description":"The new plain-text password that the moderator wishes to set.\n\nThe server MUST validate this value against the platform password policy (minimum strength, banned passwords list, and any other configured requirements) before hashing and persisting it in community_portal_users.password_hash. The server MUST NOT accept a pre-hashed password value from the client. For security, callers SHOULD transmit this property only over TLS and clients SHOULD avoid logging it."}},"required":["currentPassword","newPassword"],"description":"Request payload to change an authenticated moderator's password.\n\nThis DTO is used when an authenticated moderator wants to replace their existing password. The server verifies the currentPassword against the stored community_portal_users.password_hash and, if valid and the newPassword satisfies password policy, replaces the stored hash with a secure hash of newPassword. The server should also rotate or revoke long-lived refresh tokens according to platform policy and record an auditable event tied to the moderator's user id."},"ICommunityPortalModerator.IChangePasswordResponse":{"type":"object","properties":{"success":{"type":"boolean","description":"Indicates whether the password change operation completed successfully."},"message":{"type":"string","description":"Human-readable message describing the result of the password change operation. Intended for client display and may contain guidance or next steps."},"userId":{"type":"string","format":"uuid","description":"The unique identifier of the user whose password was changed. This corresponds to community_portal_users.id in the Prisma schema. This field is optional and may be omitted by implementations that prefer not to echo identifiers in responses."},"changedAt":{"type":"string","format":"date-time","description":"Timestamp (ISO 8601) when the password change was applied on the server. Provided for auditing and client synchronization; if omitted the client may assume the operation was applied immediately."}},"required":["success","message"],"description":"Response returned after a successful or failed moderator password-change operation.\n\nThis response acknowledges the outcome of a change-password request initiated by an authenticated moderator. It intentionally omits any sensitive credential data (for example, the password or password_hash) and contains only non-sensitive audit metadata and a user-facing message.\n\nProperties:\n- success: Boolean flag required to indicate success/failure.\n- message: Human-readable description of the result suitable for direct display to the user.\n- userId: Optional UUID of the affected user (maps to community_portal_users.id) included for client-side correlation and audit. Implementations MAY omit this for privacy.\n- changedAt: Optional server timestamp in RFC3339/ISO-8601 format recording when the change was applied.\n\nSecurity note: This response MUST never include password contents or any secret material. Use HTTPS and authenticated channels for transport."},"ICommunityPortalAdmin.ICreate":{"type":"object","properties":{"username":{"type":"string","description":"Chosen unique login handle for the admin account. This maps to community_portal_users.username in the Prisma schema and must be unique across users."},"email":{"type":"string","format":"email","description":"Primary email address for the admin account. This maps to community_portal_users.email in the Prisma schema and is used for verification and notifications. Implementations SHOULD validate uniqueness and syntactic correctness."},"password":{"type":"string","description":"Plain-text password supplied by the client. The server MUST hash and salt this value before persisting into community_portal_users.password_hash. The plaintext password MUST NOT be stored or echoed back in responses."},"displayName":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional human-friendly display name shown in UIs. Corresponds to community_portal_users.display_name. May be null if the admin prefers not to set a display name."},"adminLevel":{"type":"string","description":"Optional admin role or level string such as 'super' or 'moderator_coordinator'. This maps conceptually to community_portal_admins.admin_level in the Prisma schema. The server should validate allowed values per platform policy."},"isActive":{"type":"boolean","description":"Optional flag indicating whether the admin account should be active immediately. If omitted, the server applies platform default (typically true for provisioning flows controlled by administrators). This maps to community_portal_admins.is_active semantics."}},"required":["username","email","password"],"description":"Payload to create a new admin account.\n\nThis DTO is used by the administrative onboarding flow to create the authentication identity (community_portal_users) and the corresponding admin metadata (community_portal_admins). Client-supplied fields include the user identity and credential (username, email, password) plus optional profile and admin-scoped attributes.\n\nImportant rules and notes:\n- The server MUST hash and salt the plaintext password and persist only the derived password_hash into the community_portal_users table. The plaintext password MUST NOT be stored or echoed back.\n- Required fields: username, email, password. Optional fields may be provided to set display name, initial admin level, and activation flag.\n- This DTO intentionally does not include server-managed fields such as id, user_id, created_at, updated_at, or deleted_at; those are assigned by the server upon creation.\n\nSecurity guidance: Transmit this payload only over TLS. The server MUST enforce uniqueness constraints for username and email and return 409 Conflict for duplicates. Audit creation actions in moderation/admin logs."},"ICommunityPortalAdmin.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the authenticated admin user. This value corresponds to the user's primary id and is used to correlate the authorization token with the admin identity."},"admin":{"$ref":"#/components/schemas/ICommunityPortalAdmin.ISummary","description":"Summary information for the admin account.\n\nThis object contains stable, non-sensitive admin metadata drawn from the platform's admin record. It is intended to provide the client with the minimal admin context required for UI rendering and audit tracing."},"user":{"$ref":"#/components/schemas/ICommunityPortalUser.ISummary","description":"Public user profile associated with the admin account.\n\nIncludes safe, public-facing user attributes (username, display name, avatar, karma) that frontends can display alongside admin actions without exposing authentication secrets."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","admin","user","token"],"description":"Authorization response for an admin account.\n\nThis DTO is returned after successful admin authentication or token refresh. It bundles a lightweight admin summary and the public user profile for convenience, together with the authorization token payload required for authenticated API calls. The structure intentionally avoids exposing any secrets (for example, password_hash) and provides only public, display-safe fields.\n\nThe admin and user sub-objects map to the underlying Prisma models (see their respective schemas). This DTO itself is a transport container and does not directly map every property to a single Prisma model."},"ICommunityPortalAdmin.ILogin":{"type":"object","properties":{"identifier":{"type":"string","description":"Login identifier used to authenticate the admin account.\n\nAccepts either the account email address or the username. The server will resolve the identifier to a community_portal_users record during authentication. Clients should prefer email for clarity, but username is supported for convenience."},"password":{"type":"string","description":"Plain-text password supplied by the user for authentication.\n\nThe server WILL hash and verify this password against the stored password_hash; clients MUST transmit this value only over TLS. This field is required for credential-based authentication and MUST never be returned in responses."}},"required":["identifier","password"],"description":"Login request payload for admin authentication.\n\nClients submit this object to POST /auth/admin/login to obtain an ICommunityPortalAdmin.IAuthorized response on success. The payload intentionally contains only the credential fields required for authentication and excludes any server-managed or derived properties."},"ICommunityPortalAdmin.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the user (community_portal_users.id).\n\nThis is the canonical UUID used across the platform to identify the account."},"username":{"type":"string","description":"The unique login handle for the user (community_portal_users.username).\n\nVisible on profile pages and used for attribution of posts and actions."},"display_name":{"type":"string","description":"Optional human-friendly display name (community_portal_users.display_name).\n\nMay be null or omitted by the client when not set; used for presentation rather than identity."},"karma":{"type":"integer","description":"Aggregated reputation score for the user (community_portal_users.karma).\n\nThis integer summarizes user reputation; the exact calculation method is determined by platform policy."},"member_since":{"type":"string","format":"date-time","description":"Timestamp when the user became a verified member (community_portal_members.member_since).\n\nThis property is useful for display on profile and for eligibility checks. It may be omitted if membership metadata is not returned by the server."}},"required":["id","username","karma"],"description":"A compact, public-facing summary of an admin-capable user.\n\nThis type is intentionally limited to non-sensitive fields suitable for client presentation. It does not include authentication secrets or internal-only metadata."},"ICommunityPortalAdmin.IRefresh":{"type":"object","properties":{"refresh_token":{"type":"string","description":"Refresh token previously issued to the admin during authentication. This token is an opaque string (for example, a JWT or other long-lived token) that the server validates and rotates when issuing a new access token. The server MUST validate that the token is bound to an existing community_portal_users.id and that any associated admin privileges (community_portal_admins.is_active) remain valid before issuing new credentials."}},"required":["refresh_token"],"description":"Payload for refreshing admin authentication tokens.\n\nThis object contains the refresh token issued to an administrator at login. The server validates the token, checks admin account state (active/admin record), and returns a renewed authorization response when permitted.\n\nDo not include sensitive server-side fields (password_hash) in the response. The refresh token presented here must be treated as confidential in transit and storage."},"ICommunityPortalAdmin.IResetRequest":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Email address of the admin account that requests a password reset. This corresponds to community_portal_users.email in the database schema. The server SHOULD validate format and, for privacy, return a generic acknowledgement regardless of whether the email exists."}},"required":["email"],"description":"Request payload to initiate an admin password reset.\n\nProvide the administrator's email address. The server will create a time-limited, single-use reset token bound to the corresponding community_portal_users.id (if an account exists) and deliver it to this email address. For privacy and anti-enumeration, the endpoint's response should not reveal whether a matching account was found."},"ICommunityPortalAdmin.IResetRequestResponse":{"type":"object","properties":{"message":{"type":"string","description":"Human-readable acknowledgement message confirming that a password reset request has been received and that, if an account exists for the supplied email, a reset token has been delivered to that address.\n\nThis message MUST be generic to avoid account enumeration and therefore MUST NOT indicate whether the target email is present in the community_portal_users table. Implementers should ensure the text does not leak any PII or internal state."}},"required":["message"],"description":"Acknowledgement response returned after initiating an admin password reset request.\n\nThis DTO is returned by the POST /auth/admin/password/reset operation. It provides a user-facing, privacy-preserving confirmation that the reset request workflow has been triggered. The response intentionally avoids returning user identifiers or sensitive information.\n\nBusiness notes: The underlying Prisma model referenced by the request flow is community_portal_users (email). This response does not and SHOULD NOT expose community_portal_users.password_hash or any other sensitive database fields."},"ICommunityPortalAdmin.IResetConfirm":{"type":"object","properties":{"success":{"type":"boolean","description":"Indicates whether the password reset token was validated and the password change was applied successfully.\n\nA value of true means the password has been updated on the associated community_portal_users record. A value of false indicates the reset token was invalid, expired, or some other validation failed."},"message":{"type":"string","description":"A concise, user-facing message describing the result of the reset confirmation attempt.\n\nWhen success=true the message SHOULD instruct the user to sign in with the new credentials. When success=false the message SHOULD provide non-sensitive guidance (for example: 'Invalid or expired token. Request a new password reset.') and must not reveal internal state."}},"required":["success","message"],"description":"Response returned by the admin password reset confirmation endpoint that consumes a one-time token and sets a new password.\n\nThis DTO corresponds to the completion step of the reset flow (POST /auth/admin/password/confirm). It confirms whether the reset operation succeeded and returns guidance for next steps. The implementation updates community_portal_users.password_hash as part of the operation; for security, this response MUST NOT include any sensitive data such as password_hash, tokens, or internal identifiers.\n\nAudit note: Successful password resets SHOULD produce an audit entry referencing the affected community_portal_users.id; however, audit details are recorded server-side and are not included in this DTO."},"ICommunityPortalAdmin.IResetConfirmResponse":{"type":"object","properties":{"success":{"type":"boolean","description":"Indicates whether the password reset operation completed successfully.\n\nThis boolean is true when the reset token was valid and the user's password_hash was updated. It is false when the token was invalid, expired, or the operation failed for other reasons."},"message":{"type":"string","description":"Human-readable acknowledgement message describing the outcome of the reset operation.\n\nThis message is suitable for direct display to the admin user in the UI. It explains next steps (for example, instructing the user to re-authenticate) and may include non-sensitive informational guidance. Avoid including internal error codes or sensitive details."},"user_id":{"oneOf":[{"type":"string","format":"uuid","description":"Identifier (UUID) of the affected user account when available.\n\nThis field is provided for audit and client-side correlation. It may be null in cases where the token could not be resolved to a concrete user (for example, expired or invalid token). Do not expose other PII in this response."},{"type":"null"}],"description":"Identifier (UUID) of the affected user account when available.\n\nThis field is provided for audit and client-side correlation. It may be null in cases where the token could not be resolved to a concrete user (for example, expired or invalid token). Do not expose other PII in this response."},"reauthenticate":{"type":"boolean","description":"Flag indicating whether the client should prompt the user to re-authenticate.\n\nA value of true indicates the platform recommends or requires the user to log in again (for example because tokens were rotated or invalidated after the password change). A value of false means no immediate reauthentication is necessary."}},"required":["success","message"],"description":"Response returned after completing a password reset confirmation for an admin account.\n\nThis DTO acknowledges the outcome of a reset-confirm operation and provides guidance to the client about next steps (for instance whether the user must re-authenticate). It intentionally contains no sensitive credential material and only includes minimal audit-friendly identifiers when available.\n\nUse cases: returned by endpoints that consume a reset token and apply a new password hash to the stored account record."},"ICommunityPortalAdmin.IChangePassword":{"type":"object","properties":{"currentPassword":{"type":"string","description":"The current password for the authenticated admin account, provided in plain text.\n\nThis value MUST be verified server-side against the stored password hash (community_portal_users.password_hash). It is required for confidential operations to guard against session theft. Do not transmit this value in logs or store it in plaintext."},"newPassword":{"type":"string","description":"The new desired password provided in plain text.\n\nThe server MUST validate this value against the platform's password policy (length, complexity, breached-password checks) and then compute and store a secure hash in community_portal_users.password_hash. The plaintext newPassword MUST never be returned in any API response or persisted in logs."}},"required":["currentPassword","newPassword"],"description":"Request payload for an authenticated admin to change their account password.\n\nThis DTO carries the current credential and the desired new credential. The server is responsible for verifying the current password, enforcing password strength and reuse policies, hashing the new password securely, and invalidating or rotating session/refresh tokens as required by platform policy.\n\nSecurity notes: Clients must transmit this payload only over TLS. The API should rate-limit this operation and require additional verification (MFA) for privileged accounts if platform policy mandates."},"ICommunityPortalAdmin.IChangePasswordResponse":{"type":"object","properties":{"success":{"type":"boolean","description":"True when the password change operation completed successfully. Clients SHOULD interpret a value of true as confirmation that the server has stored a new password hash and performed any associated session/refresh-token invalidation actions required by policy."},"message":{"type":"string","description":"Human-readable, localized-ready message describing the outcome of the password-change operation. This message is intended for display in the client UI and may contain guidance such as whether reauthentication is required or next steps."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp (ISO 8601, UTC) when the password_hash field was updated on the server for the affected account. Provided as an audit-friendly hint; presence of this field indicates when the credential change was applied."},"requires_reauthentication":{"type":"boolean","description":"When true, the client SHOULD prompt the user to reauthenticate (for example, perform a fresh login) because active sessions and refresh tokens may have been revoked as part of the security policy."}},"required":["success","message"],"description":"Acknowledgement response returned after a successful or failed password change operation for an admin account.\n\nThis response object confirms whether the requested password change has been applied. It intentionally omits sensitive data (for example, password_hash) and instead provides audit-friendly metadata such as updated_at and a user-facing message. The client should treat a successful response as authoritative and follow any guidance provided in the message (for example, prompting for reauthentication if requires_reauthentication is true).\n\nThe schema is intended for UI consumption and integration with session-management flows. It provides multiple pieces of information: a boolean success flag for programmatic checks, a localized message for end-user display, an optional updated_at timestamp for audit display, and an optional requires_reauthentication flag to instruct client behavior."},"ICommunityPortalAdmin.IVerifyEmail":{"type":"object","properties":{"token":{"type":"string","description":"One-time email verification token issued during account creation or invitation flows. Tokens are time-limited and single-use. The server validates this token and, on success, marks the related membership record (community_portal_members.is_email_verified) as true."},"user_id":{"type":"string","format":"uuid","description":"Optional UUID of the user associated with the verification token. When provided, the server MAY use this as an additional lookup hint. Clients SHOULD prefer supplying only the token; inclusion of user_id is optional and only used when the verification flow requires explicit user identification."}},"required":["token"],"description":"Request payload for email verification of an admin account.\n\nClients MUST provide the single-use verification token received by email. The token is validated by the server and maps to a community_portal_users / community_portal_members record; upon successful validation the server sets is_email_verified = true for the membership record. The optional user_id may be supplied when the verification workflow includes explicit user identification, but it is not required and should not be relied upon as the sole verification mechanism.\n\nThis type is intentionally compact and excludes any sensitive or internal-only fields. All tokens are expected to be treated as confidential and transmitted over TLS only."},"ICommunityPortalAdmin.IVerifyEmailResponse":{"type":"object","properties":{"success":{"type":"boolean","description":"Indicates whether the email verification operation succeeded.\n\nTrue when the supplied verification token was valid and the membership record was updated accordingly; false when the token was invalid or expired."},"message":{"type":"string","description":"Human-friendly message describing the outcome of the verification operation.\n\nThis text is intended for UI display (confirmation or error guidance). It SHOULD be concise and non-technical."},"user":{"$ref":"#/components/schemas/ICommunityPortalAdmin.ISummary","description":"Optional lightweight summary of the affected admin user record.\n\nIncluded when the implementation chooses to return a compact representation of the verified account to the client (for example, after a successful verification). The summary contains safe, public-facing properties only."}},"required":["success"],"description":"Response returned after attempting to verify an administrator's email address.\n\nThis response conveys whether verification succeeded and may include a brief, user-facing explanation and an optional minimal user summary useful for client UI updates."},"ICommunityPortalUser.IRequest":{"type":"object","properties":{"page":{"type":"integer","description":"Page number for paginated results.\n\nThis value is 1-based in typical UI flows. Use it together with `limit` to page through results."},"limit":{"type":"integer","description":"Maximum number of items to return in the page.\n\nImplementations SHOULD enforce a sensible maximum (for example, 100) for performance and abuse protection."},"q":{"type":"string","description":"Free-text search query applied to searchable profile fields such as username, display_name, and bio.\n\nWhen provided, the backend performs fuzzy/partial matching based on configured search indices."},"username":{"type":"string","description":"Exact or partial username filter.\n\nUse this field to restrict results to accounts whose username matches the supplied value (case-insensitive depending on implementation)."},"display_name":{"type":"string","description":"Exact or partial display name filter.\n\nUseful for searching human-facing names separate from the canonical username."},"min_karma":{"type":"integer","description":"Minimum karma filter.\n\nWhen supplied, only users with karma greater than or equal to this value are returned."},"max_karma":{"type":"integer","description":"Maximum karma filter.\n\nWhen supplied, only users with karma less than or equal to this value are returned."},"created_from":{"type":"string","format":"date-time","description":"Start of creation date range (inclusive) in ISO 8601 format.\n\nWhen provided, only users created at or after this timestamp are returned."},"created_to":{"type":"string","format":"date-time","description":"End of creation date range (inclusive) in ISO 8601 format.\n\nWhen provided, only users created at or before this timestamp are returned."},"includeArchived":{"type":"boolean","description":"When true, include soft-deleted/archived user records (community_portal_users.deleted_at IS NOT NULL) in the results.\n\nAccess to archived records is typically restricted and requires elevated authorization; unauthenticated callers should not set this flag."},"sort_by":{"type":"string","description":"Field to sort results by. Typical supported values: 'username', 'created_at', 'karma'.\n\nThe backend should document the allowed values; if an unsupported value is supplied a 400 Bad Request is appropriate."},"order":{"type":"string","description":"Sort direction. Allowed values: 'asc' or 'desc'.\n\nWhen omitted, implementations typically default to 'desc' for dates and 'asc' for alphabetical sorts."},"includeUnverified":{"type":"boolean","description":"When true, include users who are not email-verified (community_portal_members.is_email_verified == false).\n\nAccess to unverified-user filtering may be restricted to authorized callers depending on privacy policy."}},"required":[],"description":"Query and pagination parameters used to search and list user profiles.\n\nThis request DTO supports free-text search, exact or partial field filters, karma and date-range filtering, sorting, and control over whether archived or unverified accounts are included. Fields that reference sensitive data (for example `includeArchived` or `includeUnverified`) require appropriate authorization on the server side."},"ICommunityPortalUser.IUpdate":{"type":"object","x-autobe-prisma-schema":"community_portal_users","properties":{"display_name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional new display name for the user (writes to community_portal_users.display_name).\n\nWhen provided, the server updates the stored display_name. Null indicates clearing the field. The backend enforces allowed length and character rules."},"bio":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional biography text to update (writes to community_portal_users.bio).\n\nClients may submit a shorter or longer bio; backend enforces configured length limits. Use explicit null to clear the bio."},"avatar_uri":{"oneOf":[{"type":"string","format":"uri"},{"type":"null"}],"description":"Optional avatar URI to update (writes to community_portal_users.avatar_uri).\n\nProvide a validated, safe URI or null to clear the existing avatar. The server validates formats and may reject unsupported schemes."}},"required":[],"description":"Update DTO for CommunityPortal user profile (ICommunityPortalUser.IUpdate).\n\nAll fields are optional and intended for account owners to update editable profile attributes. This DTO maps to the writable subset of the Prisma model community_portal_users and deliberately excludes protected fields such as username, email, karma, created_at, deleted_at, and password_hash. Use explicit null to clear optional fields."},"ICommunityPortalCommunity.IRequest":{"type":"object","properties":{"q":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional full-text search query applied to community name and description.\n\nWhen provided, servers SHOULD apply case-insensitive/trigram-fuzzy matching (the Prisma model includes GIN trigram indexes on name and description) to improve discovery. Null indicates no free-text filter."},"slug":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional canonical slug filter for exact community lookup (community_portal_communities.slug).\n\nProvide the community slug to restrict results to the matching community. The slug is typically canonicalized to lowercase on write; callers should pass the canonical form where possible."},"name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional name filter (case-insensitive). Use for matching community titles or performing name-based discovery.\n\nService implementations may apply normalized matching (lowercasing/trigram) when evaluating this field."},"visibility":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional visibility filter for communities (e.g., 'public' or 'private' as stored in community_portal_communities.visibility).\n\nThe Prisma model stores visibility as a string; allowed values are controlled by application policy. When supplied, the server SHOULD validate the value against supported visibility modes."},"is_private":{"oneOf":[{"type":"boolean"},{"type":"null"}],"description":"Optional boolean filter to include only private (true) or non-private (false) communities.\n\nThis maps to the community_portal_communities.is_private boolean column. Null indicates no filter."},"page":{"oneOf":[{"type":"integer","minimum":1},{"type":"null"}],"description":"Optional 1-based page number for pagination. If omitted or null, server defaults apply (e.g., page 1)."},"limit":{"oneOf":[{"type":"integer","minimum":1},{"type":"null"}],"description":"Optional page size limit for pagination. Servers SHOULD enforce a maximum allowed limit to protect performance. Null allows server default."},"offset":{"oneOf":[{"type":"integer","minimum":0},{"type":"null"}],"description":"Optional zero-based offset for pagination alternatives to page/limit. Use only one pagination strategy per request. Null indicates not provided."},"sort_by":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional sort key for results (for example: 'created_at' or 'name').\n\nNote: ranking modes such as 'hot' or 'top' are typically used for posts; community listing sort keys are implementation-defined. When provided, the server validates the key and applies the requested ordering."}},"required":[],"description":"Request DTO for listing and searching communities (ICommunityPortalCommunity.IRequest).\n\nThis request type is used by community listing/search endpoints and contains pagination, filtering, and sort options. It is not directly linked to a single Prisma model as an x-autobe-prisma-schema because it represents query parameters rather than a persisted record.\n\nGuidance:\n- Servers SHOULD ignore null properties and apply defaults when necessary.\n- Provide either page/limit or offset for pagination (both may be accepted but prefer one strategy per client request).\n- The server MUST validate UUID formats for creator_user_id and return 400 for malformed values."},"ICommunityPortalCommunity":{"type":"object","x-autobe-prisma-schema":"community_portal_communities","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the community record as defined in the Prisma model. This is the canonical UUID used to reference the community across the platform.\n\nThis value is generated by the system and is immutable once created. Use this identifier for linking posts, subscriptions, moderators, and reports."},"creator_user_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Reference to the creating user's community_portal_users.id. Per the Prisma schema this field is nullable to avoid cascade-delete when a user is removed.\n\nWhen present it identifies the user who created the community. When null, the community has no current creator assignment (for example, if the original creator account was removed or ownership was reassigned)."},"name":{"type":"string","description":"Human-readable community title used for display. This corresponds to the community_portal_communities.name column in the Prisma schema.\n\nBusiness guidance: This is the primary display name shown to users in lists and headers and should be treated as plain text (validation rules, length and allowed characters are enforced by application logic)."},"slug":{"type":"string","description":"URL-friendly unique identifier for the community (slug). The Prisma model enforces uniqueness on slug (@@unique([slug])).\n\nThe slug is typically canonicalized on write (lowercased, sanitized) and is suitable for use in URLs and client routing. Clients may provide a suggested slug or allow the server to derive one from the name."},"description":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional short community description or purpose statement mapped to community_portal_communities.description.\n\nThis field is intended for a succinct summary shown in community listings and discovery views. It may be null when no description is provided."},"is_private":{"type":"boolean","description":"Whether the community is private (invite-only) as represented by community_portal_communities.is_private in the Prisma schema.\n\nTrue indicates membership is restricted; false indicates public membership. The application enforces membership gating and visibility for private communities."},"visibility":{"type":"string","description":"Visibility policy for the community (stored in community_portal_communities.visibility).\n\nThe Prisma schema stores this as a string; application-level code may restrict allowed values (for example 'public' or 'private'). Clients should treat this as an opaque string and rely on server-side documentation for permitted values."},"created_at":{"type":"string","format":"date-time","description":"Record creation timestamp (UTC) as stored in community_portal_communities.created_at. This timestamp is system-managed and indicates when the community record was created."},"updated_at":{"type":"string","format":"date-time","description":"Last update timestamp (UTC) as stored in community_portal_communities.updated_at. This is managed by the system and updated whenever the community record is modified."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Soft-delete timestamp (nullable) corresponding to community_portal_communities.deleted_at in the Prisma schema.\n\nWhen null the community is active; when set the community is considered archived/removed from normal listings. This is system-managed and should not be modified directly by clients."}},"required":["id","name","slug","is_private","visibility","created_at","updated_at"],"description":"Full community representation returned by read endpoints for a single community.\n\nThis schema maps directly to the Prisma model `community_portal_communities`. All properties in this schema correspond to columns in that model. The representation includes public-facing attributes (name, slug, description), visibility and privacy flags, the optional creator reference, and system-managed timestamps. Deleted communities set `deleted_at` and should be treated as archived by clients.\n\nDesign notes:\n- All object properties are named and typed to match the Prisma model.\n- Nullable fields are represented using oneOf to explicitly allow null.\n- This type deliberately does not include relation objects (e.g., nested arrays of posts or moderators). Relations are returned as separate referenced resources where needed.\n"},"ICommunityPortalCommunity.ICreate":{"type":"object","x-autobe-prisma-schema":"community_portal_communities","properties":{"name":{"type":"string","description":"Human-readable community title. Required when creating a community. The server may apply additional validation (length, disallowed characters) and may canonicalize casing."},"slug":{"type":"string","description":"Optional URL-friendly slug proposing the canonical identifier for the community. If omitted the server will derive a slug from `name` and ensure uniqueness (Prisma model enforces unique slug). Clients may provide a preferred slug but must accept server-side canonicalization."},"description":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional short description or purpose statement for the community. May be null if no description is provided."},"is_private":{"type":"boolean","description":"Indicates whether the community is private (invite-only). Required for creation and stored as community_portal_communities.is_private. The server enforces membership gating for private communities."},"visibility":{"type":"string","description":"Visibility policy for the community. This string maps to community_portal_communities.visibility. Valid values are defined by the application (for example 'public' or 'private'); clients should supply the desired visibility value per platform documentation."}},"required":["name","is_private","visibility"],"description":"Create DTO for community_portal_communities. Used as the request body when creating a new community via POST endpoints.\n\nRules and constraints:\n- Do NOT include system-managed fields such as id, creator_user_id, created_at, updated_at or deleted_at in this payload. Those are set by the server.\n- `name`, `is_private`, and `visibility` are required to satisfy the Prisma model non-nullable columns. `slug` is optional because the server may derive it; if provided it must be unique and valid per platform rules.\n- `description` is optional and may be omitted or set to null explicitly.\n\nSecurity note: Creator is derived from the authenticated session; clients must not attempt to set creator_user_id in create payloads."},"ICommunityPortalCommunity.IUpdate":{"type":"object","x-autobe-prisma-schema":"community_portal_communities","properties":{"name":{"type":"string","description":"Human-readable community title corresponding to community_portal_communities.name.\n\nProvide a concise, display-friendly community title. When supplied the server will validate allowed characters and apply uniqueness/normalization rules as required by the platform."},"slug":{"type":"string","description":"URL-friendly canonical identifier for the community that maps to community_portal_communities.slug.\n\nThe slug should be lowercase and URL-safe. If omitted, the server may derive a slug from the provided name. When provided, the server validates uniqueness and accepted characters."},"description":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional short community description mapping to community_portal_communities.description.\n\nSet this to a brief statement of the community's purpose. To clear the description explicitly set this property to null."},"is_private":{"type":"boolean","description":"Boolean flag that indicates whether the community is invite-only (maps to community_portal_communities.is_private).\n\nChanging this flag may affect membership and visibility rules for the community."},"visibility":{"type":"string","description":"Visibility policy string for the community (maps to community_portal_communities.visibility).\n\nTypical values are platform-defined (for example: 'public' or 'private'). The server enforces allowed values."}},"required":[],"description":"DTO used to update a community (ICommunityPortalCommunity.IUpdate).\n\nThis object contains only the mutable fields that clients may supply when updating a community. Each property directly maps to a column on the Prisma model community_portal_communities. All fields are optional; include only the fields you intend to change. To clear the description explicitly set it to null. Server-managed fields (id, creator_user_id, created_at, updated_at, deleted_at) must NOT be supplied by clients."},"ICommunityPortalSubscription.IRequest":{"type":"object","properties":{"communityId":{"type":"string","format":"uuid","description":"Filter by community id (UUID). Returns subscriptions for the specified community. Server MUST canonicalize and validate the UUID; unauthorized access to other users' subscriptions is not allowed."},"myItems":{"type":"boolean","description":"When true return only subscriptions belonging to the authenticated caller. This avoids sending direct user IDs from the client and enforces that the server derive the user identity from the authentication context."},"activeOnly":{"type":"boolean","description":"When true return only active (non-soft-deleted) subscriptions. When false or omitted, results may include revoked subscriptions if the caller is authorized to view them."},"limit":{"type":"integer","minimum":1,"maximum":100,"description":"Maximum number of subscription records to return. A reasonable upper bound protects the endpoint from large responses."},"offset":{"type":"integer","minimum":0,"description":"Zero-based pagination offset."},"sort":{"oneOf":[{"const":"created_at.asc","description":"Sort order for subscription results by created_at ascending."},{"const":"created_at.desc","description":"Sort order for subscription results by created_at descending."}],"description":"Sort order for subscription results by created_at. Use exact enum values: 'created_at.asc' or 'created_at.desc'."}},"required":[],"description":"Request DTO for listing subscriptions (ICommunityPortalSubscription.IRequest).\n\nProvides filtering, pagination, and simple sorting for subscription listing endpoints. Direct user_id filters are forbidden in request DTOs; use the boolean flag myItems to request the authenticated user's subscriptions. When communityId differs from the authenticated user's communities, the server must enforce authorization and may return 403 if the caller lacks privileges."},"ICommunityPortalSubscription":{"type":"object","x-autobe-prisma-schema":"community_portal_subscriptions","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the subscription record as stored in the community_portal_subscriptions table.\n\nThis value is the canonical identifier for the subscription and matches the Prisma model's `id` column (type: UUID). It is used to reference the subscription in subsequent API calls and audit records."},"user_id":{"type":"string","format":"uuid","description":"Identifier of the subscribing user (references community_portal_users.id).\n\nThis property maps to the `user_id` FK column in the Prisma model. In API responses it identifies the account that owns the subscription. For security, mutation APIs typically derive this value from the authenticated session rather than accepting it from clients."},"community_id":{"type":"string","format":"uuid","description":"Identifier of the subscribed community (references community_portal_communities.id).\n\nThis property corresponds to the `community_id` column in the Prisma model and indicates which community the user has subscribed to. The value is required for identifying the subscription target in both UI and backend logic."},"created_at":{"type":"string","format":"date-time","description":"Timestamp (UTC) when the subscription record was created.\n\nThis property maps to the Prisma `created_at` column. It is provided in responses for auditing and sorting subscriptions by creation time."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp (UTC) of the last update to the subscription record.\n\nThis maps to the Prisma `updated_at` column and is useful for synchronization and optimistic concurrency checks."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Soft-delete timestamp (UTC) for the subscription record.\n\nThis property maps to the Prisma `deleted_at` column. When null the subscription is active; when set it indicates the record was revoked/soft-deleted and preserved for audit purposes."}},"required":["id","user_id","community_id","created_at","updated_at"],"description":"Subscription entity representing a user's subscription to a community.\n\nThis schema corresponds directly to the Prisma model `community_portal_subscriptions`. It contains the canonical persisted attributes used by the API to represent subscriptions. Fields that are managed by the server (id, created_at, updated_at) are included in the response but MUST NOT be supplied by clients when creating subscriptions. The presence of `x-autobe-prisma-schema` enforces that every listed property exists in the referenced Prisma model."},"ICommunityPortalSubscription.ICreate":{"type":"object","x-autobe-prisma-schema":"community_portal_subscriptions","properties":{"community_id":{"type":"string","format":"uuid","description":"Target community identifier to subscribe to (maps to community_portal_subscriptions.community_id).\n\nWhen creating a subscription the client supplies the community_id of the community to join. The server will derive the subscribing user (user_id) from the authenticated session and will set server-managed fields such as id, created_at, updated_at. Do not include user_id in the request body."}},"required":["community_id"],"description":"Create DTO for a subscription record.\n\nThis schema is the request body used to create a new subscription and maps to the Prisma model `community_portal_subscriptions`. The only required client-supplied property is `community_id`. The server-side logic derives the authenticated `user_id` and populates id/timestamps. Because this type references the Prisma model via `x-autobe-prisma-schema`, all properties included here must exist on that model; additional client-only properties are intentionally omitted to maintain DB-interface consistency."},"ICommunityPortalPost":{"type":"object","x-autobe-prisma-schema":"community_portal_posts","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the post.\n\nThis corresponds to the primary key column `id` in the Prisma model `community_portal_posts`. It is a UUID used to reference the post across the API and database."},"community_id":{"type":"string","format":"uuid","description":"Identifier of the community that owns this post.\n\nThis maps to `community_id` in the Prisma model and MUST reference an existing community_portal_communities.id."},"author_user_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Author user id (nullable).\n\nMaps to `author_user_id` in Prisma. Nullable to preserve posts when the author account is removed. When present it references community_portal_users.id."},"post_type":{"type":"string","description":"Post type indicator such as 'text', 'link', or 'image'.\n\nThis field maps to `post_type` in the Prisma model and determines which content field (body/link_url/image_url) is expected to be populated."},"title":{"type":"string","description":"User-facing title of the post.\n\nMaps to `title` in Prisma. Recommended max length enforced at application level (e.g., 300 characters)."},"body":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Text body for text posts. Nullable for link/image posts.\n\nCorresponds to `body` in the Prisma model."},"link_url":{"oneOf":[{"type":"string","format":"uri"},{"type":"null"}],"description":"External link URL for link-type posts.\n\nCorresponds to `link_url` in the Prisma model. When present the value MUST be a valid http/https URI."},"image_url":{"oneOf":[{"type":"string","format":"uri"},{"type":"null"}],"description":"Representative image URL for image-type posts.\n\nCorresponds to `image_url` in the Prisma model. For multi-image posts use a dedicated media table (not modeled here)."},"status":{"type":"string","description":"Moderation state of the post (for example 'published', 'pending', 'removed').\n\nThis maps to the `status` column in Prisma and is enforced at application level."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp in ISO 8601 format (UTC).\n\nThis maps to `created_at` in Prisma and is set by the server upon insert."},"updated_at":{"type":"string","format":"date-time","description":"Last update timestamp in ISO 8601 format (UTC).\n\nThis maps to `updated_at` in Prisma and is updated by the server when the post changes."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Soft-delete timestamp (nullable).\n\nWhen set, the post is archived/hidden. This maps to `deleted_at` in the Prisma model."}},"required":["id","community_id","post_type","title","status","created_at","updated_at"],"description":"Canonical representation of a CommunityPortal post.\n\nThis schema mirrors the Prisma model `community_portal_posts` and includes all public-facing fields that exist in the model. Sensitive data is intentionally omitted. All properties are validated against the database model; no phantom properties were added.\n\nUse this schema for single-item GET responses (detailed views)."},"ICommunityPortalPost.IRequest":{"type":"object","properties":{"communityId":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Filter by community id (UUID). Nullable to explicitly indicate no community filter."},"postType":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Filter by post type (for example 'text','link','image'). Nullable means no type filter."},"status":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Filter by moderation status (for example 'published','pending','removed'). Nullable indicates no status filter."},"q":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Full-text search query applied to title and body. Nullable to indicate no search term."},"createdFrom":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Filter: include posts with created_at >= this ISO 8601 datetime. Nullable for no lower bound."},"createdTo":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Filter: include posts with created_at <= this ISO 8601 datetime. Nullable for no upper bound."},"sort":{"$ref":"#/components/schemas/IEPostSortMode","description":"Requested sort mode. Backend implements ordering; 'hot' and 'controversial' algorithms are implementation-defined."},"limit":{"type":"integer","format":"int32","minimum":1,"maximum":100,"description":"Maximum number of items to return. Server enforces an upper bound (recommended max 100)."},"offset":{"type":"integer","format":"int32","minimum":0,"description":"Zero-based offset for pagination."},"includeDeleted":{"type":"boolean","description":"When true, include soft-deleted posts (deleted_at not null) if the caller is authorized. Default false."}},"required":[],"description":"Request DTO for searching and listing posts. Contains filter, sort and pagination parameters. All properties are optional; nullable-capable fields allow explicit null values."},"IEPostSortMode":{"oneOf":[{"const":"hot","description":"Sorting modes for post listing endpoints. Allowed values: 'hot', 'new', 'top', 'controversial'.\n\nNote: The precise ranking algorithms for 'hot' and 'controversial' are implementation-defined and must be provided by the backend team."},{"const":"new","description":"Sorting modes for post listing endpoints. Allowed values: 'hot', 'new', 'top', 'controversial'.\n\nNote: The precise ranking algorithms for 'hot' and 'controversial' are implementation-defined and must be provided by the backend team."},{"const":"top","description":"Sorting modes for post listing endpoints. Allowed values: 'hot', 'new', 'top', 'controversial'.\n\nNote: The precise ranking algorithms for 'hot' and 'controversial' are implementation-defined and must be provided by the backend team."},{"const":"controversial","description":"Sorting modes for post listing endpoints. Allowed values: 'hot', 'new', 'top', 'controversial'.\n\nNote: The precise ranking algorithms for 'hot' and 'controversial' are implementation-defined and must be provided by the backend team."}],"description":"Sorting modes for post listing endpoints. Allowed values: 'hot', 'new', 'top', 'controversial'.\n\nNote: The precise ranking algorithms for 'hot' and 'controversial' are implementation-defined and must be provided by the backend team."},"ICommunityPortalPost.IEPostType":{"oneOf":[{"const":"text","description":"Post type discriminator for community_portal_posts. Allowed values: 'text' (text post), 'link' (external link post), 'image' (image post)."},{"const":"link","description":"Post type discriminator for community_portal_posts. Allowed values: 'text' (text post), 'link' (external link post), 'image' (image post)."},{"const":"image","description":"Post type discriminator for community_portal_posts. Allowed values: 'text' (text post), 'link' (external link post), 'image' (image post)."}],"description":"Post type discriminator for community_portal_posts. Allowed values: 'text' (text post), 'link' (external link post), 'image' (image post)."},"ICommunityPortalPost.ICreate.IText":{"type":"object","properties":{"community_id":{"type":"string","format":"uuid","description":"Target community UUID (community_portal_communities.id)."},"post_type":{"type":"string","const":"text","description":"Discriminator for text post variant; must be 'text'."},"title":{"type":"string","maxLength":300,"description":"Post title. Required."},"body":{"type":"string","maxLength":40000,"description":"Text body for text posts. Required for 'text' post_type."}},"required":["community_id","post_type","title","body"],"description":"Create DTO for a text post mapped to the community_portal_posts Prisma model. Server MUST set id, author_user_id, created_at, updated_at and ignore client-supplied server-managed fields.","x-autobe-prisma-schema":"community_portal_posts"},"ICommunityPortalPost.ICreate.ILink":{"type":"object","properties":{"community_id":{"type":"string","format":"uuid","description":"Target community UUID (community_portal_communities.id)."},"post_type":{"type":"string","const":"link","description":"Discriminator for link post variant; must be 'link'."},"title":{"type":"string","maxLength":300,"description":"Post title. Required."},"link_url":{"type":"string","format":"uri","maxLength":80000,"description":"External link URL for link posts. Required for 'link' post_type."},"body":{"type":"string","maxLength":40000,"description":"Optional body/summary for link posts."}},"required":["community_id","post_type","title","link_url"],"description":"Create DTO for a link post mapped to the community_portal_posts Prisma model. Server MUST set id, author_user_id, created_at, updated_at and ignore client-supplied server-managed fields.","x-autobe-prisma-schema":"community_portal_posts"},"ICommunityPortalPost.ICreate.IImage":{"type":"object","properties":{"community_id":{"type":"string","format":"uuid","description":"Target community UUID (community_portal_communities.id)."},"post_type":{"type":"string","const":"image","description":"Discriminator for image post variant; must be 'image'."},"title":{"type":"string","maxLength":300,"description":"Post title. Required."},"image_url":{"type":"string","format":"uri","maxLength":80000,"description":"Representative image URL for image posts. Required for single-image flow."},"body":{"type":"string","maxLength":40000,"description":"Optional caption or description for the image post."}},"required":["community_id","post_type","title","image_url"],"description":"Create DTO for an image post mapped to the community_portal_posts Prisma model. For multi-image posts use media upload APIs (outside this schema). Server MUST set id, author_user_id, created_at, updated_at and ignore client-supplied server-managed fields.","x-autobe-prisma-schema":"community_portal_posts"},"ICommunityPortalPost.ICreate":{"oneOf":[{"$ref":"#/components/schemas/ICommunityPortalPost.ICreate.IText"},{"$ref":"#/components/schemas/ICommunityPortalPost.ICreate.ILink"},{"$ref":"#/components/schemas/ICommunityPortalPost.ICreate.IImage"}],"description":"Polymorphic create DTO for community_portal_posts. The payload MUST match exactly one variant depending on post_type ('text'|'link'|'image'). Each variant contains a const 'post_type' discriminator. Server will set author_user_id and timestamps and must ignore client-supplied server-managed fields.","x-autobe-prisma-schema":"community_portal_posts"},"ICommunityPortalPost.IUpdate":{"type":"object","properties":{"title":{"type":"string","maxLength":300,"description":"Editable post title. Optional in updates."},"body":{"type":"string","maxLength":40000,"description":"Editable text body. Optional; may be used to replace or clear existing body."},"link_url":{"type":"string","format":"uri","maxLength":80000,"description":"Editable link URL for link posts."},"image_url":{"type":"string","format":"uri","maxLength":80000,"description":"Editable representative image URL for image posts."},"status":{"type":"string","description":"Moderation state (e.g., 'published','pending','removed'). Allowed values enforced by application logic."},"post_type":{"$ref":"#/components/schemas/ICommunityPortalPost.IEPostType","description":"Post type. Changing post_type requires appropriate content fields for the new type and may be restricted by server policy."}},"required":[],"description":"Update DTO for community_portal_posts. All fields optional. Immutable and server-managed fields such as id, author_user_id, created_at, updated_at and deleted_at are excluded from this DTO.","x-autobe-prisma-schema":"community_portal_posts"},"ICommunityPortalComment.IRequest":{"type":"object","properties":{"limit":{"type":"integer","description":"Maximum number of comment items to return in the page.\n\nThis parameter controls the page size for comment listings. Use sensible limits to avoid large payloads. Implementations may enforce a server-side maximum. Example: 20.","minimum":1,"default":20},"offset":{"type":"integer","description":"Zero-based offset for pagination.\n\nUse offset to page through results. For large result sets consider switching to cursor-based pagination. Example: 0 for first page.","minimum":0,"default":0},"parentCommentId":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional parent comment UUID to filter replies of a specific parent comment.\n\nWhen provided, the API returns comments whose parent_comment_id equals this UUID. If null, no parent-based filtering is applied. The value must be a valid UUID when supplied."},"includeDeleted":{"type":"boolean","description":"When true, include soft-deleted comments (deleted_at IS NOT NULL) in results if the caller is authorized.\n\nDefault behavior is to exclude deleted comments. Only privileged callers (moderators/admins) should be allowed to set this to true; otherwise the server must ignore or reject the flag."},"sort":{"oneOf":[{"const":"new","description":"Sorting mode for comment listings.\n\nCommon values: 'new' (newest first), 'old' (oldest first). Other modes are backend-defined. The server accepts the parameter but the precise ordering semantics for non-standard modes are implementation-defined."},{"const":"old","description":"Sorting mode for comment listings.\n\nCommon values: 'new' (newest first), 'old' (oldest first). Other modes are backend-defined. The server accepts the parameter but the precise ordering semantics for non-standard modes are implementation-defined."}],"description":"Sorting mode for comment listings.\n\nCommon values: 'new' (newest first), 'old' (oldest first). Other modes are backend-defined. The server accepts the parameter but the precise ordering semantics for non-standard modes are implementation-defined."},"q":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional full-text search query to match against comment body.\n\nWhen provided the backend may perform fuzzy or trigram search against the body field and return matching comments. Use with care for performance; the server may restrict its use."}},"description":"Request parameters for listing comments.\n\nThis request object is used to filter, sort, and page comment lists. It maps to the business-level listing requirements for the community_portal_comments entity and only contains query/query-body parameters (pagination, filtering, and optional search).","required":[]},"ICommunityPortalComment":{"type":"object","x-autobe-prisma-schema":"community_portal_comments","properties":{"id":{"type":"string","format":"uuid","description":"Primary identifier of the comment.\n\nCorresponds to community_portal_comments.id in the Prisma schema. This UUID uniquely identifies the comment record and is stable across reads."},"post_id":{"type":"string","format":"uuid","description":"Reference to the parent post's id.\n\nMaps to community_portal_comments.post_id. Every comment belongs to a post; this field is required and used to scope comment threads and enforce visibility rules."},"parent_comment_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional parent comment identifier for nested replies.\n\nMaps to community_portal_comments.parent_comment_id. Null indicates a top-level comment. When present, it references another comment.id in the same post and enables nested threading."},"author_user_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional author user id referencing the comment's author.\n\nMaps to community_portal_comments.author_user_id. This field is nullable to preserve comment audit trails when user accounts are removed; a null value indicates the author record is no longer available."},"body":{"type":"string","description":"The text body of the comment.\n\nMaps to community_portal_comments.body. This is the primary content field for the comment and is required for a valid comment. Implementations should enforce configured max lengths and apply sanitization before returning this field."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the comment was created (UTC).\n\nCorresponds to community_portal_comments.created_at in the Prisma schema. Timestamps are expressed in ISO 8601 / RFC 3339 format in UTC."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp when the comment was last updated (UTC).\n\nCorresponds to community_portal_comments.updated_at. Use this field for optimistic concurrency checks and client-side caching."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Soft-delete timestamp; when set the comment is considered deleted/archived.\n\nMaps to community_portal_comments.deleted_at. Public APIs normally exclude records with deleted_at != null; this field is included for audit and moderator views."}},"required":["id","post_id","body","created_at","updated_at"],"description":"Canonical representation of a comment.\n\nThis schema maps directly to the Prisma model community_portal_comments and includes all persistent fields that are safe to expose in API responses. Property descriptions reference the underlying Prisma columns and provide business context for each field. Nullable fields are represented using oneOf with a null alternative to align with JSON Schema nullable handling."},"ICommunityPortalComment.ICreate":{"type":"object","x-autobe-prisma-schema":"community_portal_comments","properties":{"post_id":{"type":"string","format":"uuid","description":"Identifier of the parent post to which this comment will belong. This corresponds to community_portal_comments.post_id and must reference an existing community_portal_posts.id. The server uses this value to attach the comment to the correct post. Provide a valid UUID."},"parent_comment_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional identifier of the parent comment for nested replies. Corresponds to community_portal_comments.parent_comment_id. Use a UUID to attach this comment as a reply to an existing comment, or null if creating a top-level comment."},"body":{"type":"string","description":"The text body of the comment. This maps to the community_portal_comments.body column in the Prisma model. Provide the full comment text; empty bodies are not valid for creation.","minLength":1}},"required":["post_id","body"],"description":"DTO for creating a new comment.\n\nThis request object is used when a member creates a comment on a post or replies to another comment. It maps directly to the writable fields of the community_portal_comments Prisma model while intentionally excluding server-managed or sensitive fields (id, author_user_id, created_at, updated_at, deleted_at). The server is expected to derive author_user_id from the authenticated session and to set timestamps.\n\nBusiness notes:\n- post_id is required and must point to an existing post; the server validates existence and permissions.\n- parent_comment_id is optional; include it to create a nested reply. Use null for top-level comments.\n- body is required and must contain the comment text. The server enforces length and nesting-depth rules according to platform policy."},"ICommunityPortalComment.IUpdate":{"type":"object","x-autobe-prisma-schema":"community_portal_comments","properties":{"body":{"type":"string","description":"Updated text body for the comment.\n\nBusiness rules: This is the only mutable field allowed via the general comment update endpoint. The server enforces max length and sanitization. This field is optional in the update DTO to follow the Partial<T> pattern; if omitted, no change is applied."}},"required":[],"description":"DTO for updating a comment (partial). All fields are optional. This request maps to mutable properties of the Prisma model community_portal_comments while intentionally excluding system-managed and immutable fields (id, post_id, parent_comment_id, author_user_id, created_at, updated_at, deleted_at). The server MUST derive author identity from authentication and must not accept author_user_id in this DTO."},"ICommunityPortalVote.ICreate":{"oneOf":[{"required":["post_id"],"properties":{"post_id":{"oneOf":[{"type":"string","format":"uuid"}]},"comment_id":{"type":"null"}}},{"required":["comment_id"],"properties":{"comment_id":{"oneOf":[{"type":"string","format":"uuid"}]},"post_id":{"type":"null"}}}],"description":"Request DTO for creating a vote on either a post or a comment. Exactly one target MUST be specified: either `post_id` OR `comment_id` (XOR). The `value` property is required and must be 1 or -1. The voter (user_id) is derived from the authenticated session and MUST NOT be provided by the client. The server is responsible for enforcing eligibility (e.g., community_portal_members.is_email_verified, not suspended) and for enforcing one active vote per (user,target) via DB constraints or application logic.","x-autobe-prisma-schema":"community_portal_votes"},"ICommunityPortalVote":{"type":"object","x-autobe-prisma-schema":"community_portal_votes","properties":{"id":{"type":"string","format":"uuid","description":"Primary key (UUID) of the vote record as stored in community_portal_votes.id. This value uniquely identifies the vote."},"user_id":{"type":"string","format":"uuid","description":"UUID of the voting user (community_portal_users.id). This field is populated by the server based on the authenticated principal and is required for auditability."},"post_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Nullable UUID reference to the post (community_portal_posts.id) targeted by the vote. Null when the vote targets a comment. Use nullable representation to reflect the underlying Prisma column semantics."},"comment_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Nullable UUID reference to the comment (community_portal_comments.id) targeted by the vote. Null when the vote targets a post."},"value":{"oneOf":[{"const":1,"description":"Vote value stored as integer. Allowed values are exactly +1 for an upvote and -1 for a downvote. This field is authoritative for scoring and karma calculations."},{"const":-1,"description":"Vote value stored as integer. Allowed values are exactly +1 for an upvote and -1 for a downvote. This field is authoritative for scoring and karma calculations."}],"description":"Vote value stored as integer. Allowed values are exactly +1 for an upvote and -1 for a downvote. This field is authoritative for scoring and karma calculations."},"created_at":{"type":"string","format":"date-time","description":"Timestamp (ISO 8601) when the vote was first created. Stored in UTC in the database (community_portal_votes.created_at)."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp (ISO 8601) of the last update to the vote record (community_portal_votes.updated_at)."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Nullable soft-delete timestamp. When non-null the vote is considered removed/archived for active aggregates but retained for audit (community_portal_votes.deleted_at)."}},"required":["id","user_id","value","created_at","updated_at"],"description":"Main Vote DTO (ICommunityPortalVote) representing the persisted vote record mapped to the Prisma model community_portal_votes.\n\nThis object is the canonical representation returned by read operations and contains identifiers, the vote value, and audit timestamps. The `post_id` and `comment_id` properties are nullable to reflect the XOR relationship in the database: a vote targets either a post or a comment. The `deleted_at` property is nullable and used to indicate soft-deletion; active votes have deleted_at == null.\n\nAll properties in this schema correspond directly to columns on the community_portal_votes model and must not reference fields that do not exist in the Prisma schema."},"ICommunityPortalVote.IUpdate":{"type":"object","x-autobe-prisma-schema":"community_portal_votes","properties":{"value":{"oneOf":[{"const":1,"description":"Vote value to apply to the target vote record.\n\nThis property maps to community_portal_votes.value in the Prisma schema and must be either 1 (upvote) or -1 (downvote). Use exactly the numeric values 1 or -1. Do not attempt to change vote target (post_id/comment_id) or actor (user_id) through this DTO. This DTO is intended for updating an existing vote's value (for example switching +1 to -1)."},{"const":-1,"description":"Vote value to apply to the target vote record.\n\nThis property maps to community_portal_votes.value in the Prisma schema and must be either 1 (upvote) or -1 (downvote). Use exactly the numeric values 1 or -1. Do not attempt to change vote target (post_id/comment_id) or actor (user_id) through this DTO. This DTO is intended for updating an existing vote's value (for example switching +1 to -1)."}],"description":"Vote value to apply to the target vote record.\n\nThis property maps to community_portal_votes.value in the Prisma schema and must be either 1 (upvote) or -1 (downvote). Use exactly the numeric values 1 or -1. Do not attempt to change vote target (post_id/comment_id) or actor (user_id) through this DTO. This DTO is intended for updating an existing vote's value (for example switching +1 to -1)."}},"required":[],"description":"Update DTO for a vote record.\n\nThis schema represents the allowable request body when updating an existing community_portal_votes record. Only mutable, client-editable properties are present. The server MUST derive the actor (user_id) from the authenticated session and MUST validate ownership before applying changes. The schema is intentionally minimal: changing the vote target or user is not permitted via this DTO.\n\nSecurity note: The API SHOULD verify that the authenticated caller is the vote owner (vote.user_id) and that the member is eligible to vote (e.g., verified and not suspended) before applying updates.\n"},"ICommunityPortalVote.IRequest":{"type":"object","properties":{"postId":{"type":"string","format":"uuid","description":"Filter votes by the target post id (community_portal_posts.id). Provide either postId or commentId to scope results to a single target type. The API enforces XOR semantics: do not supply both postId and commentId simultaneously."},"commentId":{"type":"string","format":"uuid","description":"Filter votes by the target comment id (community_portal_comments.id). Provide either commentId or postId, not both. The service validates that the referenced comment exists and belongs to the expected post when applicable."},"myItems":{"type":"boolean","description":"When true, restrict results to votes cast by the authenticated caller (the server derives the user id from the auth context). Use this instead of providing a direct user id in the request to avoid exposing or allowing arbitrary user_id filters."},"value":{"oneOf":[{"const":1,"description":"Filter by vote value. Allowed values are 1 (upvote) and -1 (downvote)."},{"const":-1,"description":"Filter by vote value. Allowed values are 1 (upvote) and -1 (downvote)."}],"description":"Filter by vote value. Allowed values are 1 (upvote) and -1 (downvote)."},"createdFrom":{"type":"string","format":"date-time","description":"Inclusive lower bound (ISO 8601) for vote.created_at. Use this to filter votes created on or after the given timestamp."},"createdTo":{"type":"string","format":"date-time","description":"Inclusive upper bound (ISO 8601) for vote.created_at. Use this to filter votes created on or before the given timestamp."},"sort":{"oneOf":[{"const":"createdAt","description":"Sort key for results. Supported values: 'createdAt' (chronological) or 'value' (group by vote value). The API accepts this parameter and orders results accordingly; direction (asc/desc) can be handled via convention or a separate parameter (not defined here)."},{"const":"value","description":"Sort key for results. Supported values: 'createdAt' (chronological) or 'value' (group by vote value). The API accepts this parameter and orders results accordingly; direction (asc/desc) can be handled via convention or a separate parameter (not defined here)."}],"description":"Sort key for results. Supported values: 'createdAt' (chronological) or 'value' (group by vote value). The API accepts this parameter and orders results accordingly; direction (asc/desc) can be handled via convention or a separate parameter (not defined here)."},"limit":{"type":"integer","minimum":1,"maximum":100,"description":"Pagination limit — maximum number of records to return. Recommended maximum is 100 to protect backend resources."},"offset":{"type":"integer","minimum":0,"description":"Pagination offset (zero-based). Use in combination with limit for page navigation."},"includeDeleted":{"type":"boolean","description":"When true and the caller is authorized, include soft-deleted vote records (community_portal_votes.deleted_at is not null). By default this is false and deleted votes are excluded from results."}},"required":[],"description":"Request DTO for searching and listing vote events.\n\nThis schema is intended for list/filter endpoints over community_portal_votes. All properties are optional filters and pagination controls. The server MUST enforce XOR semantics between postId and commentId (only one of them may be provided) and must validate UUID and date-time formats. By default the server excludes soft-deleted records unless includeDeleted=true and the caller has the required authorization.\n\nNotes on authorization and visibility:\n- Use myItems=true to request the authenticated caller's votes; do not allow arbitrary user id filtering in request DTOs.\n- The API must not expose sensitive fields (such as password_hash) through joined user objects; only minimal public profile fields may be returned when enriching results."},"ICommunityPortalReport":{"type":"object","x-autobe-prisma-schema":"community_portal_reports","properties":{"id":{"type":"string","format":"uuid","description":"Primary identifier of the report.\n\nThis value corresponds to the Prisma model community_portal_reports.id and is the canonical UUID for the report record."},"reporterUserId":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Identifier of the reporting user, if the report was filed by an authenticated member.\n\nMaps to community_portal_reports.reporter_user_id in the Prisma schema and may be null for anonymous reports. When present this value MUST reference an existing user id."},"communityId":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Community identifier related to the report, if applicable.\n\nThis maps to community_portal_reports.community_id in Prisma and is nullable because some reports may target cross-community items or be filed without a specific community reference."},"postId":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Post identifier targeted by this report when the report concerns a post.\n\nCorresponds to community_portal_reports.post_id in the Prisma model. Nullable when the report targets a comment or community-level issue."},"commentId":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Comment identifier targeted by this report when the report concerns a comment.\n\nCorresponds to community_portal_reports.comment_id in the Prisma model. Nullable when the report targets a post or community-level issue."},"assignedModeratorId":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Moderator-assignment identifier indicating which moderator is assigned to triage this report.\n\nMaps to community_portal_reports.assigned_moderator_id in Prisma. Nullable until assignment occurs."},"closedByModeratorId":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Moderator identifier who closed or resolved the report.\n\nCorresponds to community_portal_reports.closed_by_moderator_id in Prisma and is nullable until the report is closed."},"reasonCode":{"type":"string","description":"Controlled reason code describing why the report was filed (for example: 'spam', 'harassment', 'hate', 'illegal', 'other').\n\nThis maps to community_portal_reports.reason_code and should be selected from the platform's controlled taxonomy. The application enforces allowed values; the schema stores the canonical code."},"reasonText":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional free-text details provided by the reporter to explain the report.\n\nMaps to community_portal_reports.reason_text in Prisma. Useful for moderator context and search; nullable when the reporter supplies no extra detail."},"status":{"type":"string","description":"Lifecycle state of the report (application-level vocabulary such as 'OPEN', 'IN_REVIEW', 'REQUIRES_ACTION', 'DISMISSED', 'CLOSED').\n\nThis field maps to community_portal_reports.status in Prisma and indicates current processing state of the report. Allowed values are controlled by the application workflow."},"isUrgent":{"type":"boolean","description":"Flag indicating whether the reporter marked this report as urgent and requiring prioritized handling.\n\nCorresponds to community_portal_reports.is_urgent in the Prisma model."},"severity":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional severity level for triage (for example: 'low', 'medium', 'high').\n\nMaps to community_portal_reports.severity in Prisma and may be used alongside isUrgent to prioritize handling."},"reporterContactEmail":{"oneOf":[{"type":"string","format":"email"},{"type":"null"}],"description":"Optional contact email provided by the reporter for follow-up. Must be a valid email address when supplied.\n\nThis maps to community_portal_reports.reporter_contact_email in the Prisma model and is nullable when not provided."},"createdAt":{"type":"string","format":"date-time","description":"Timestamp when the report was created (UTC).\n\nCorresponds to community_portal_reports.created_at in Prisma and is recorded by the system when the report is filed."},"reviewedAt":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when a moderator first reviewed the report.\n\nMaps to community_portal_reports.reviewed_at in Prisma and is nullable until review occurs."},"closedAt":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when the report was resolved or closed.\n\nCorresponds to community_portal_reports.closed_at in the Prisma model and is nullable until closure."},"resolutionNotes":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional moderator notes describing the resolution or actions taken for the report.\n\nMaps to community_portal_reports.resolution_notes in Prisma. Because this field may contain moderator-only information, callers must be authorized to view it."}},"required":["id","reasonCode","status","isUrgent","createdAt"],"description":"Complete representation of a moderation report.\n\nThis schema is the authoritative API representation of the Prisma model community_portal_reports. It contains all public-facing fields mapped from the database model and includes nullable references for preserved auditability. Sensitive or moderator-only fields (for example resolutionNotes or reporterContactEmail) should be returned only to authorized callers per application rules.\n\nThe descriptions reference the corresponding Prisma model columns and explain nullability and business meaning. Use this type for detailed report responses returned by report retrieval endpoints."},"ICommunityPortalReport.IRequest":{"type":"object","properties":{"communityId":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Filter by community UUID. Matches community_portal_reports.community_id. Nullable to allow omission."},"postId":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Filter by post UUID (community_portal_reports.post_id). Nullable to allow omission."},"commentId":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Filter by comment UUID (community_portal_reports.comment_id). Nullable to allow omission."},"status":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Filter by report lifecycle status (e.g., 'OPEN','IN_REVIEW','REQUIRES_ACTION','DISMISSED','CLOSED')."},"isUrgent":{"oneOf":[{"type":"boolean"},{"type":"null"}],"description":"Filter by urgency flag. When true, return urgent reports."},"severity":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Filter by severity (e.g., 'low','medium','high')."},"createdFrom":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Filter reports created at or after this ISO-8601 timestamp."},"createdTo":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Filter reports created at or before this ISO-8601 timestamp."},"sort":{"oneOf":[{"const":"createdAt","description":"Sort key for results. Backend may support direction via a separate parameter. Allowed sample keys: 'createdAt', 'severity', 'isUrgent'."},{"const":"severity","description":"Sort key for results. Backend may support direction via a separate parameter. Allowed sample keys: 'createdAt', 'severity', 'isUrgent'."},{"const":"isUrgent","description":"Sort key for results. Backend may support direction via a separate parameter. Allowed sample keys: 'createdAt', 'severity', 'isUrgent'."}],"description":"Sort key for results. Backend may support direction via a separate parameter. Allowed sample keys: 'createdAt', 'severity', 'isUrgent'."},"limit":{"type":"integer","format":"int32","minimum":1,"description":"Maximum number of records to return (pagination)."},"offset":{"type":"integer","format":"int32","minimum":0,"description":"Record offset for pagination (zero-based)."},"includeDeleted":{"oneOf":[{"type":"boolean"},{"type":"null"}],"description":"When true and caller is authorized, include soft-deleted reports (records with deleted_at set). Default: false."}},"description":"Request DTO for listing moderation reports. All fields are optional filters. This DTO is NOT permitted to include direct user_id filters in public request types; admin-scoped request DTOs must be defined separately with stricter authorization.","required":[]},"ICommunityPortalReport.ICreate":{"oneOf":[{"required":["community_id"]},{"required":["post_id"]},{"required":["comment_id"]}],"description":"Client-writable report creation DTO mapping to the community_portal_reports Prisma model. Server-managed fields (id, reporter_user_id for authenticated callers, status, created_at, reviewed_at, closed_at, assigned_moderator_id, closed_by_moderator_id, resolution_notes) are not accepted from clients and will be ignored if provided. At least one target identifier (community_id OR post_id OR comment_id) must be provided.","x-autobe-prisma-schema":"community_portal_reports"},"ICommunityPortalReport.IUpdate":{"type":"object","x-autobe-prisma-schema":"community_portal_reports","properties":{"status":{"oneOf":[{"const":"OPEN","description":"Report lifecycle state. Allowed application-level values: 'OPEN', 'IN_REVIEW', 'REQUIRES_ACTION', 'DISMISSED', 'CLOSED'. Use exact enum values enforced by the application."},{"const":"IN_REVIEW","description":"Report lifecycle state. Allowed application-level values: 'OPEN', 'IN_REVIEW', 'REQUIRES_ACTION', 'DISMISSED', 'CLOSED'. Use exact enum values enforced by the application."},{"const":"REQUIRES_ACTION","description":"Report lifecycle state. Allowed application-level values: 'OPEN', 'IN_REVIEW', 'REQUIRES_ACTION', 'DISMISSED', 'CLOSED'. Use exact enum values enforced by the application."},{"const":"DISMISSED","description":"Report lifecycle state. Allowed application-level values: 'OPEN', 'IN_REVIEW', 'REQUIRES_ACTION', 'DISMISSED', 'CLOSED'. Use exact enum values enforced by the application."},{"const":"CLOSED","description":"Report lifecycle state. Allowed application-level values: 'OPEN', 'IN_REVIEW', 'REQUIRES_ACTION', 'DISMISSED', 'CLOSED'. Use exact enum values enforced by the application."}],"description":"Report lifecycle state. Allowed application-level values: 'OPEN', 'IN_REVIEW', 'REQUIRES_ACTION', 'DISMISSED', 'CLOSED'. Use exact enum values enforced by the application."},"assigned_moderator_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional moderator assignment. Nullable: clear assignment by sending null. Maps to assigned_moderator_id in the Prisma model and must reference a community_portal_moderators.id when provided."},"closed_by_moderator_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Moderator who closed/resolved the report. Nullable. Maps to closed_by_moderator_id in the Prisma model."},"resolution_notes":{"type":"string","description":"Optional moderator notes describing the resolution or actions taken. Maps to resolution_notes in the Prisma model. Returned only to authorized moderator/admin callers when reading."},"reviewed_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when a moderator first reviewed the report. Use ISO 8601 date-time format in UTC. Maps to reviewed_at in the Prisma model."},"closed_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when the report was resolved/closed. Use ISO 8601 date-time format in UTC. Maps to closed_at in the Prisma model."},"is_urgent":{"type":"boolean","description":"Flag indicating whether the report requires prioritized handling. Maps to is_urgent in the Prisma model."},"severity":{"type":"string","description":"Optional severity level used for triage. Maps to severity in the Prisma model."},"reporter_contact_email":{"oneOf":[{"type":"string","format":"email"},{"type":"null"}],"description":"Optional contact email captured at report submission for follow-up. Nullable to allow redaction. Maps to reporter_contact_email in the Prisma model."}},"required":[],"description":"Report update DTO for communityPortal.\n\nThis object represents fields that authorized moderators may update on an existing moderation report. It maps to mutable columns on the community_portal_reports Prisma model. Fields are optional to support partial updates (PATCH/PUT semantics) and any field set by the client will be validated against the model's expectations (UUID formats, allowed status values, ISO 8601 timestamps).\n\nAudit and workflow notes:\n- The application MUST record the acting moderator's identity and an audit entry when assignment, status, or closure fields change.\n- Status transitions should follow configured workflow rules; invalid transitions are rejected by the server with 400 Bad Request.\n- assigned_moderator_id and closed_by_moderator_id accept null to clear those relationships; when provided they must reference existing moderator assignments."},"ICommunityPortalCommunity.ISummary":{"type":"object","x-autobe-prisma-schema":"community_portal_communities","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the community (Prisma: community_portal_communities.id). This is the canonical identifier used to reference the community in API operations and relationships."},"name":{"type":"string","description":"Human-readable community title (Prisma: community_portal_communities.name). Used as the primary display value in lists and search results. This field is intentionally concise for list views."},"slug":{"type":"string","description":"URL-friendly canonical slug for the community (Prisma: community_portal_communities.slug). Slug values are canonicalized on write and used for client-friendly routing and lookup."},"description":{"type":"string","description":"Short community description or purpose statement (Prisma: community_portal_communities.description). In summary views this may be truncated by the UI to keep list payloads compact."},"is_private":{"type":"boolean","description":"Indicates whether the community is private/invite-only (Prisma: community_portal_communities.is_private). Clients should use this flag to control discoverability and membership UX."},"visibility":{"type":"string","description":"Visibility policy for the community (Prisma: community_portal_communities.visibility). Expected values are managed by application logic; the summary exposes the value for client routing and filtering."},"created_at":{"type":"string","format":"date-time","description":"Record creation timestamp in UTC (Prisma: community_portal_communities.created_at). Provided for sorting and display; included only because the Prisma model defines this column."},"updated_at":{"type":"string","format":"date-time","description":"Last update timestamp in UTC (Prisma: community_portal_communities.updated_at). Provided for UI freshness indicators; only included because the Prisma model defines this column."}},"required":["id","name","slug"],"description":"Community summary view mapped to the Prisma model community_portal_communities.\n\nThis summary is optimized for list displays and discovery endpoints. It intentionally includes only the public, non-sensitive fields that exist on the underlying Prisma model and omits internal or sensitive fields (for example, deleted_at is omitted from summary to avoid exposing internal soft-delete flags in list views).\n\nThe schema includes x-autobe-prisma-schema to indicate direct correspondence to the Prisma model and to enable automated verification that all included properties exist in the database model. All properties included here are present in the referenced Prisma model."},"ICommunityPortalSubscription.ISummary":{"type":"object","x-autobe-prisma-schema":"community_portal_subscriptions","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the subscription record (Prisma: community_portal_subscriptions.id)."},"user_id":{"type":"string","format":"uuid","description":"Subscriber's user id (Prisma: community_portal_subscriptions.user_id). Present to identify the owner of the subscription in administrative or self-service views."},"community_id":{"type":"string","format":"uuid","description":"Identifier of the subscribed community (Prisma: community_portal_subscriptions.community_id)."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the subscription was created (Prisma: community_portal_subscriptions.created_at). Provided for ordering and display in subscription lists."}},"required":["id","community_id","created_at"],"description":"Subscription summary view mapped to the Prisma model community_portal_subscriptions.\n\nThis summary is intended for list displays (for example: a user's subscriptions) and includes only non-sensitive fields that exist in the Prisma model. The record preserves the link to the owning user (user_id) for administrative and self-service scenarios. The schema intentionally omits deleted_at from the public summary to avoid exposing internal revocation flags in default list responses.\n\nx-autobe-prisma-schema is provided to assert the direct mapping to the Prisma model and to ensure that downstream generation tools validate property existence against the database model."},"ICommunityPortalPost.ISummary":{"type":"object","x-autobe-prisma-schema":"community_portal_posts","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the post (UUID)."},"title":{"type":"string","description":"Post title used as primary display field in lists."},"post_type":{"type":"string","description":"Post type: 'text' | 'link' | 'image'."},"community_id":{"type":"string","format":"uuid","description":"Identifier of the community that owns this post."},"author_user_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Author's user id (nullable). Presented as an id only in summary views."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp of the post in ISO 8601 UTC."}},"required":["id","title","post_type","community_id","created_at"],"description":"Summary representation of a CommunityPortal post optimized for list views.\n\nThis summary omits large content fields (body, link_url, image_url) and internal fields. It maps to the Prisma model `community_portal_posts` and includes only fields that exist in the model."},"ICommunityPortalComment.ISummary":{"type":"object","x-autobe-prisma-schema":"community_portal_comments","properties":{"id":{"type":"string","format":"uuid","description":"Primary identifier of the comment (community_portal_comments.id)."},"post_id":{"type":"string","format":"uuid","description":"Identifier of the parent post (community_portal_comments.post_id)."},"parent_comment_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional parent comment id for nested replies (community_portal_comments.parent_comment_id). Null denotes a top-level comment."},"author_user_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional author user id (community_portal_comments.author_user_id). Nullable to preserve audit trails when the author account is removed."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp in ISO 8601 format (UTC). Maps to community_portal_comments.created_at."}},"required":["id","post_id","created_at"],"description":"Compact summary representation of a comment for list views. This schema omits large text bodies to keep payloads lightweight. It maps directly to fields present in the Prisma model community_portal_comments and is safe to expose in public list endpoints."},"ICommunityPortalVote.ISummary":{"type":"object","x-autobe-prisma-schema":"community_portal_votes","properties":{"id":{"type":"string","format":"uuid","description":"Primary identifier of the vote record.\n\nThis is the unique UUID assigned to the vote when it was created in the database (maps to community_portal_votes.id). It is used to reference the vote in updates or deletion operations and must be treated as an immutable identifier for the life of the vote."},"user_id":{"type":"string","format":"uuid","description":"Identifier of the user who cast the vote.\n\nThis references community_portal_users.id. In the persisted model this field is required and identifies the actor who performed the vote. For public-facing summaries this field is included to enable UI attribution or linking to the voter's public profile (subject to privacy rules)."},"post_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"If the vote targets a post, the UUID of that post.\n\nThis property references community_portal_posts.id when the vote targets a post. It is nullable because a vote may instead target a comment (in which case comment_id will be set). Use oneOf to represent the nullable relationship explicitly."},"comment_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"If the vote targets a comment, the UUID of that comment.\n\nThis property references community_portal_comments.id when the vote targets a comment. It is nullable because a vote may instead target a post (in which case post_id will be set). Exactly one of post_id or comment_id is expected to be non-null at the data model level; the API representation preserves that distinction."},"value":{"type":"integer","description":"Vote value. Integer representing the user's vote.\n\nAllowed values are +1 for an upvote and -1 for a downvote as defined by the data model. The backend enforces these semantics; clients should only submit or expect +1/-1 values."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp of the vote in ISO 8601 format (UTC).\n\nThis field maps to community_portal_votes.created_at and indicates when the vote was recorded. Timestamps are expressed in date-time format and should be treated as authoritative for ordering and auditing purposes."},"updated_at":{"type":"string","format":"date-time","description":"Last-modified timestamp for the vote record in ISO 8601 format (UTC).\n\nMaps to community_portal_votes.updated_at and is updated on vote changes (for example, when a user changes +1 to -1). Use this field for concurrency checks or UI freshness indicators."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Soft-delete timestamp (nullable).\n\nWhen set, this vote has been soft-deleted and should be excluded from active tallies and feeds. This maps to community_portal_votes.deleted_at and is null for active votes. Use oneOf to represent the nullable timestamp explicitly."}},"required":["id","user_id","value","created_at","updated_at"],"description":"Summary view of a vote record.\n\nThis compact representation of a community vote is intended for list and summary responses where full vote audit details are not required. It maps directly to the Prisma model community_portal_votes and includes the core identifying and relational fields (id, user_id, post_id, comment_id), the vote value, and timestamps for creation and last update. Nullable relations (post_id/comment_id, deleted_at) are represented using oneOf to allow explicit null values.\n\nDo not include sensitive authentication fields in this schema. When used in public responses, consider access-control requirements for exposing user_id and related attribution fields."},"ICommunityPortalReport.ISummary":{"type":"object","x-autobe-prisma-schema":"community_portal_reports","properties":{"id":{"type":"string","format":"uuid","description":"Primary identifier of the report record.\n\nThis UUID uniquely identifies the moderation report (maps to community_portal_reports.id). It is used to fetch, update, or reference the report in moderation workflows."},"reporter_user_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"UUID of the reporting user, if authenticated, otherwise null.\n\nThis field maps to community_portal_reports.reporter_user_id and is nullable to allow anonymous reports. When present it references community_portal_users.id and provides attribution for the report; when null the report was submitted anonymously."},"community_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"UUID of the related community, if applicable.\n\nMaps to community_portal_reports.community_id. Nullable because some reports target cross-community items or references that do not map to a single community."},"post_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"UUID of the reported post when the report targets a post.\n\nThis references community_portal_posts.id and is nullable when the report targets a comment or a community-level issue. Use oneOf to explicitly represent null when there is no post target."},"comment_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"UUID of the reported comment when the report targets a comment.\n\nThis references community_portal_comments.id and is nullable when the report targets a post or community-level issue. Exactly one of post_id or comment_id is typically set for content-level reports."},"assigned_moderator_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Moderator assignment identifier (nullable).\n\nMaps to community_portal_reports.assigned_moderator_id. This field is null until a moderator is assigned for triage. When populated it references community_portal_moderators.id and indicates the moderator responsible for the initial review."},"closed_by_moderator_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Moderator identifier who closed/resolved the report (nullable).\n\nThis maps to community_portal_reports.closed_by_moderator_id and is null until the report is resolved. When present it references community_portal_moderators.id and provides an auditable reference to the actor who closed the report."},"reason_code":{"type":"string","description":"Controlled reason code for the report (for example: 'spam', 'harassment', 'hate', 'illegal', 'other').\n\nThis field maps to community_portal_reports.reason_code and is expected to be one value from the platform's controlled vocabulary. The application layer enforces allowed values; the schema type is string to allow the service to document and validate the allowed set."},"reason_text":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional free-text details provided by the reporter.\n\nMaps to community_portal_reports.reason_text. This field offers contextual information to moderators and may be indexed for fuzzy search; it is nullable and should be provided only when the reporter includes additional details."},"status":{"type":"string","description":"Lifecycle state of the report (for example: 'OPEN', 'IN_REVIEW', 'REQUIRES_ACTION', 'DISMISSED', 'CLOSED').\n\nThis maps to community_portal_reports.status. The application enforces the allowed values and transitions; clients should treat this as an opaque string with documented possible states at the API level."},"is_urgent":{"type":"boolean","description":"Flag indicating whether the reporter marked this report as urgent.\n\nMaps to community_portal_reports.is_urgent and is used to prioritize triage queues. True indicates prioritized handling."},"severity":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional severity level for triage (for example: 'low', 'medium', 'high').\n\nThis maps to community_portal_reports.severity and is nullable. Use the platform's controlled vocabulary for severity when provided."},"reporter_contact_email":{"oneOf":[{"type":"string","format":"email"},{"type":"null"}],"description":"Optional contact email provided by the reporter for follow-up.\n\nMaps to community_portal_reports.reporter_contact_email. When present it should be a valid email address and treated as PII: return it only to authorized moderation viewers and protect it in transit and at rest."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the report was created (ISO 8601, UTC).\n\nMaps to community_portal_reports.created_at and serves as the authoritative creation time for audit and queue ordering."},"reviewed_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when a moderator first reviewed the report (nullable).\n\nMaps to community_portal_reports.reviewed_at. Null indicates the report has not yet been reviewed."},"closed_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when the report was resolved/closed (nullable).\n\nMaps to community_portal_reports.closed_at and is null for open/in-review reports."},"resolution_notes":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional moderator notes describing the resolution or actions taken (nullable).\n\nMaps to community_portal_reports.resolution_notes. This is an auditable text field and may contain sensitive moderation context. Only authorized moderator or admin clients should receive this field in responses."}},"required":["id","reason_code","status","is_urgent","created_at"],"description":"Summary view of a moderation report.\n\nThis schema represents the concise, API-facing summary of a moderation report as stored in the Prisma model community_portal_reports. It includes identifiers for the report and optional references to the reporter, community, post, and comment targets, as well as lifecycle and triage metadata (status, is_urgent, severity, timestamps). Nullable relation fields are represented using oneOf with explicit null to preserve JSON Schema correctness and client clarity.\n\nField-level privacy notes: contact data (reporter_contact_email) and resolution_notes are sensitive and should be exposed only to authorized moderation or admin clients according to platform policies. The schema intentionally includes these fields because they exist on the Prisma model; service implementations MUST enforce field-level authorization when producing responses."}}}}