import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postCommunityPortalMemberCommunities } from "../../../../providers/postCommunityPortalMemberCommunities";
import { MemberAuth } from "../../../../decorators/MemberAuth";
import { MemberPayload } from "../../../../decorators/payload/MemberPayload";
import { putCommunityPortalMemberCommunitiesCommunityId } from "../../../../providers/putCommunityPortalMemberCommunitiesCommunityId";
import { deleteCommunityPortalMemberCommunitiesCommunityId } from "../../../../providers/deleteCommunityPortalMemberCommunitiesCommunityId";
import { AdminAuth } from "../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../decorators/payload/AdminPayload";

import { ICommunityPortalCommunity } from "../../../../api/structures/ICommunityPortalCommunity";

@Controller("/communityPortal/member/communities")
export class CommunityportalMemberCommunitiesController {
  /**
   * Create a new community (community_portal_communities) in the
   * CommunityPortal service.
   *
   * Purpose and overview: This operation allows an authenticated user to create
   * a new community record that corresponds directly to the Prisma model
   * community_portal_communities. The request accepts the community's
   * human-readable name, an optional canonical slug (server may derive from
   * name), optional description, and visibility flags. The server derives the
   * creator_user_id from the authenticated caller and ignores client-supplied
   * id/timestamps.
   *
   * Security and permissions: Only authenticated users (role: "member") may
   * create communities. The API expects a bearer token; server maps token to
   * user and sets creator_user_id. Inputs must be validated for reserved names
   * and allowed visibility values.
   *
   * Validation rules and expected behavior:
   *
   * - Required: name and either provided slug or server will canonicalize slug
   *   from name.
   * - Description is optional and may be null.
   * - Is_private is required boolean indicating invite-only communities.
   * - Visibility is required and validated by application logic.
   * - If slug already exists, return 409 Conflict.
   *
   * Error handling:
   *
   * - 400 Bad Request: missing required fields or invalid formats.
   * - 401 Unauthorized: unauthenticated request.
   * - 409 Conflict: slug already in use.
   * - 422 Unprocessable Entity: business validation errors.
   *
   * @param connection
   * @param body Community creation payload. Client-supplied fields: name
   *   (required), slug (optional), description (optional), is_private
   *   (required), visibility (required). Server-derived: creator_user_id, id,
   *   created_at, updated_at, deleted_at (excluded).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @MemberAuth()
    member: MemberPayload,
    @TypedBody()
    body: ICommunityPortalCommunity.ICreate,
  ): Promise<ICommunityPortalCommunity> {
    try {
      return await postCommunityPortalMemberCommunities({
        member,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing community (community_portal_communities) by ID.
   *
   * Update an existing community (community_portal_communities) by its ID.
   *
   * Purpose and overview: This operation updates mutable attributes of a
   * community stored in the Prisma model. Typical updates include name, slug,
   * description, is_private, and visibility. The operation requires communityId
   * path parameter and authentication. Server must verify caller's rights
   * (creator, assigned moderator, or admin) before applying changes.
   * Server-managed fields (created_at, deleted_at) cannot be modified via this
   * API.
   *
   * Security and permissions: Authenticated users (role: "member") may call
   * this endpoint, but the server MUST enforce that only the community creator,
   * an active moderator assigned to the community, or an admin may perform the
   * update. Requests from other members must return 403 Forbidden.
   *
   * Validation and behavior:
   *
   * - Path parameter communityId must be a valid UUID matching an existing
   *   non-deleted community.
   * - Request body properties are optional and only provided fields are applied.
   * - If slug is provided and changed, validate uniqueness and allowed
   *   characters; return 409 on conflict.
   * - Server must not allow updates to created_at or deleted_at via this
   *   endpoint.
   *
   * Errors:
   *
   * - 400 Bad Request: invalid input.
   * - 401 Unauthorized: unauthenticated request.
   * - 403 Forbidden: caller lacks owner/moderator/admin rights.
   * - 404 Not Found: communityId does not exist or is soft-deleted.
   * - 409 Conflict: slug already in use.
   *
   * @param connection
   * @param communityId Unique identifier (UUID) of the target community
   * @param body Community update payload (partial) - only provided fields will
   *   be updated. Allowed client-updatable fields: name, slug, description,
   *   is_private, visibility.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":communityId")
  public async update(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPortalCommunity.IUpdate,
  ): Promise<ICommunityPortalCommunity> {
    try {
      return await putCommunityPortalMemberCommunitiesCommunityId({
        member,
        communityId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft-delete a community by setting deleted_at
   * (community_portal_communities).
   *
   * Purpose and overview: This endpoint performs a controlled soft-delete of a
   * Community (Prisma model: community_portal_communities) by setting its
   * deleted_at timestamp. The intent is to hide the community from public
   * listings while preserving rows and related records (posts, subscriptions,
   * reports, moderators) for audit and appeal.
   *
   * Security and permissions: Only authorized actors may perform this action.
   * The service MUST enforce that the caller is either:
   *
   * - A platform-level admin (operation-level authorization), OR
   * - The community.creator_user_id (ownership check), OR
   * - An active assigned moderator for the community with removal privileges
   *   (checked via community_portal_moderators where is_active==true). If the
   *   caller is not authorized, return 403 Forbidden. If the community does not
   *   exist or deleted_at is already set, return 404 Not Found.
   *
   * Validation and business rules:
   *
   * - Validate communityId is a UUID and that the community exists with
   *   deleted_at == null before making changes.
   * - The operation MUST be idempotent: repeated requests do not produce
   *   duplicate side effects.
   * - The DB mutation sets deleted_at to current UTC timestamp; child records are
   *   preserved.
   * - Audit logging and downstream notifications are implementation-level
   *   responsibilities and must not be exposed as writeable API parameters.
   *
   * Errors and expected responses:
   *
   * - 400 Bad Request for malformed UUID
   * - 401 Unauthorized for unauthenticated calls
   * - 403 Forbidden for unauthorized callers
   * - 404 Not Found if community not found or already deleted
   * - 500 Internal Server Error for unexpected failures
   *
   * @param connection
   * @param communityId Target community's unique identifier (UUID)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":communityId")
  public async erase(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteCommunityPortalMemberCommunitiesCommunityId({
        admin,
        communityId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
