import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postCommunityPortalMemberPostsPostIdCommentsCommentIdVotes } from "../../../../../../providers/postCommunityPortalMemberPostsPostIdCommentsCommentIdVotes";
import { MemberAuth } from "../../../../../../decorators/MemberAuth";
import { MemberPayload } from "../../../../../../decorators/payload/MemberPayload";
import { putCommunityPortalMemberPostsPostIdCommentsCommentIdVotesVoteId } from "../../../../../../providers/putCommunityPortalMemberPostsPostIdCommentsCommentIdVotesVoteId";
import { deleteCommunityPortalMemberPostsPostIdCommentsCommentIdVotesVoteId } from "../../../../../../providers/deleteCommunityPortalMemberPostsPostIdCommentsCommentIdVotesVoteId";

import { ICommunityPortalVote } from "../../../../../../api/structures/ICommunityPortalVote";

@Controller("/communityPortal/member/posts/:postId/comments/:commentId/votes")
export class CommunityportalMemberPostsCommentsVotesController {
  /**
   * Create a vote on a comment within a post.
   *
   * Purpose and overview: This endpoint enables an authenticated member to cast
   * a vote (+1 or -1) on a comment identified by {commentId} within the post
   * identified by {postId}. The API persists a community_portal_votes record
   * with comment_id set (post_id must be null for comment-targeted votes),
   * stores the integer vote value, and returns the authoritative vote
   * representation. The backend MUST validate that the post exists and is
   * active, the comment exists and belongs to that post, and the requester is
   * eligible to vote (e.g., verified and not suspended).
   *
   * Security and permissions: Only authenticated members may call this
   * endpoint. The server MUST derive the voter identity from the authenticated
   * session and must ignore any client-supplied user_id to prevent tampering.
   * The backend SHOULD verify membership status
   * (community_portal_members.is_email_verified and is_suspended) prior to
   * creating the vote.
   *
   * Relationship to DB entities and business rules: This operation maps to the
   * community_portal_votes model in the Prisma schema. Business rules to
   * enforce:
   *
   * - A vote must target exactly one entity (post OR comment). For this endpoint,
   *   comment_id is populated and post_id must be null.
   * - Accept only integer vote values +1 or -1.
   * - Enforce one active vote per (user, comment) pair; the backend SHOULD
   *   perform an upsert/update existing vote behavior unless policy dictates
   *   otherwise.
   * - Persist created_at and updated_at timestamps and support soft-delete via
   *   deleted_at on the vote record.
   *
   * Validation and error responses:
   *
   * - 400 Bad Request: invalid vote value, mismatched post/comment relation, or
   *   malformed UUIDs.
   * - 401 Unauthorized: missing or invalid authentication credentials, or member
   *   not verified/suspended.
   * - 404 Not Found: post or comment not found or soft-deleted.
   * - 409 Conflict: duplicate vote attempts if backend policy rejects duplicates.
   *
   * @param connection
   * @param postId UUID of the parent post that contains the comment
   * @param commentId UUID of the comment to vote on
   * @param body Vote creation payload. The authenticated user is the voter;
   *   request body only needs the vote value (+1 or -1).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPortalVote.ICreate,
  ): Promise<ICommunityPortalVote> {
    try {
      return await postCommunityPortalMemberPostsPostIdCommentsCommentIdVotes({
        member,
        postId,
        commentId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a user's vote for a post or comment.
   *
   * Update a user's vote record for a specific post or comment.
   *
   * Purpose and overview: This endpoint updates the vote value and other
   * permitted mutable attributes of a vote record in the community_portal_votes
   * model. A vote targets either a post or a comment (XOR). The endpoint
   * verifies that the vote exists and is active, that the path parameters
   * correspond to the vote's target, and that the caller is authorized (the
   * vote owner). The response returns the updated vote, including id, user
   * reference, target reference, value, created_at, and updated_at.
   *
   * Security and authorization: Only the authenticated vote owner (member) may
   * update their vote. The service must verify the caller's identity matches
   * vote.user_id and enforce business gating (e.g., suspended members may be
   * prevented from changing votes). All modifications should update updated_at
   * and be auditable.
   *
   * Relationship to DB entity: Maps to the Prisma model community_portal_votes
   * (fields: id, user_id, post_id, comment_id, value, created_at, updated_at,
   * deleted_at). Do not assume additional fields beyond the model.
   *
   * Validation and business rules:
   *
   * - The vote record must exist and be active (deleted_at is null).
   * - The path parameters postId and commentId must match the vote's target
   *   reference (post_id or comment_id) depending on which target the vote
   *   has.
   * - The request must not change the vote's target or user_id; only 'value' and
   *   permitted metadata may be updated.
   *
   * Error handling: Return 400 for malformed input, 401 if unauthenticated, 403
   * if the caller is not the vote owner, 404 if the vote/post/comment is not
   * found or inactive, and 409 for conflicting state (e.g., attempting to
   * change the vote target).
   *
   * @param connection
   * @param postId Identifier of the parent post (community_portal_posts.id) -
   *   must match the vote's post_id if the vote targets a post
   * @param commentId Identifier of the parent comment
   *   (community_portal_comments.id) - must match the vote's comment_id if the
   *   vote targets a comment
   * @param voteId Identifier of the vote record to update
   *   (community_portal_votes.id)
   * @param body Updatable fields for a vote record (e.g., value). Must not
   *   include post_id, comment_id, or user_id.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":voteId")
  public async update(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
    @TypedParam("voteId")
    voteId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPortalVote.IUpdate,
  ): Promise<ICommunityPortalVote> {
    try {
      return await putCommunityPortalMemberPostsPostIdCommentsCommentIdVotesVoteId(
        {
          member,
          postId,
          commentId,
          voteId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Delete (soft-delete) a user's vote for a post or comment.
   *
   * Delete (soft-delete) a user's vote for a specific post or comment.
   *
   * Purpose and overview: This endpoint marks a vote record as deleted by
   * setting deleted_at on the community_portal_votes record. The vote remains
   * in storage for audit and reconciliation but is no longer treated as active
   * for ranking and aggregates. The operation must verify the vote exists, is
   * active (deleted_at is null), and that the caller is authorized to delete it
   * (the vote owner).
   *
   * Security and authorization: Only the authenticated vote owner (member) may
   * delete their vote. The service must verify caller identity matches
   * vote.user_id and enforce any additional business gating.
   *
   * Relationship to DB entity: Acts on the community_portal_votes model (id,
   * user_id, post_id, comment_id, value, created_at, updated_at, deleted_at).
   * Use soft-delete semantics as deleted_at exists.
   *
   * Validation and business rules:
   *
   * - Confirm the vote exists and is active.
   * - Ensure postId/commentId path parameters match the vote's target references.
   * - If the vote is already deleted, return 409 Conflict or 200 if idempotent
   *   deletion is chosen by policy.
   *
   * Error handling: Return 401 if unauthenticated, 403 if the caller is not the
   * vote owner, 404 if the vote/post/comment is not found, and 409 if the vote
   * is already deleted (unless idempotent semantics are used).
   *
   * @param connection
   * @param postId Identifier of the parent post (community_portal_posts.id) -
   *   must match the vote's post_id if the vote targets a post
   * @param commentId Identifier of the parent comment
   *   (community_portal_comments.id) - must match the vote's comment_id if the
   *   vote targets a comment
   * @param voteId Identifier of the vote record to delete
   *   (community_portal_votes.id)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":voteId")
  public async erase(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
    @TypedParam("voteId")
    voteId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteCommunityPortalMemberPostsPostIdCommentsCommentIdVotesVoteId(
        {
          member,
          postId,
          commentId,
          voteId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
