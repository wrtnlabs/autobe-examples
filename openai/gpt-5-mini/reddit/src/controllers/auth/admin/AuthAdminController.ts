import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthAdminJoin } from "../../../providers/postAuthAdminJoin";
import { postAuthAdminLogin } from "../../../providers/postAuthAdminLogin";
import { postAuthAdminRefresh } from "../../../providers/postAuthAdminRefresh";

import { ICommunityPortalAdmin } from "../../../api/structures/ICommunityPortalAdmin";

@Controller("/auth/admin")
export class AuthAdminController {
  /**
   * Create admin account and issue initial tokens (relates to
   * community_portal_admins and community_portal_users).
   *
   * Purpose and overview: This endpoint creates a new admin account and issues
   * initial authorization tokens. It operates against the
   * community_portal_admins and community_portal_users tables: the admin
   * metadata will be recorded in community_portal_admins (user_id, admin_level,
   * is_active, created_at) and the authentication identity will be created in
   * community_portal_users (email, password_hash, username, display_name,
   * created_at). The operation enables platform administrators to obtain an
   * ICommunityPortalAdmin.IAuthorized response that contains issued access and
   * refresh tokens.
   *
   * Implementation details and field usage: The request payload maps to the
   * admin creation DTO and must include the desired username and email that
   * will be stored in community_portal_users.username and
   * community_portal_users.email, and a password that will be stored as a
   * secure password_hash in community_portal_users.password_hash. The created
   * admin record in community_portal_admins will reference the new user's id in
   * community_portal_admins.user_id and may set
   * community_portal_admins.admin_level and community_portal_admins.is_active.
   * The response reflects the newly created user's id and token data and
   * references community_portal_admins.created_at for auditing.
   *
   * Role-specific integration and business context: This endpoint is the join
   * (registration) entry for the admin role. It is used when provisioning
   * elevated accounts that will be represented in community_portal_admins. The
   * API consumer should expect the platform to validate uniqueness against
   * community_portal_users.email and community_portal_users.username before
   * creating records. If community_portal_admins.is_active is set, the system
   * will allow the new admin to perform elevated actions once tokens are issued
   * and standard verification checks are satisfied.
   *
   * Security considerations: The request should only transport the raw password
   * in the request body over TLS; the server MUST persist a secure hash in
   * community_portal_users.password_hash and MUST NOT return password or
   * password_hash in responses. The endpoint should validate that
   * community_portal_members.is_email_verified is true for the underlying user
   * if the platform requires an existing verified member before granting admin
   * privileges (refer to community_portal_members.user_id and
   * community_portal_members.is_email_verified). Protect rate-limits and audit
   * the creation via community_portal_admins.created_at and
   * community_portal_users.created_at fields.
   *
   * Related operations and workflow: Typical workflow uses POST
   * /auth/admin/join to create the admin and then POST /auth/admin/login to
   * obtain fresh tokens. Follow-up operations include POST /auth/admin/refresh
   * for token renewal and password management operations (password
   * reset/change) that reference community_portal_users.password_hash and
   * community_portal_users.email.
   *
   * @param connection
   * @param body Admin creation payload containing authentication and admin
   *   metadata.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ICommunityPortalAdmin.ICreate,
  ): Promise<ICommunityPortalAdmin.IAuthorized> {
    try {
      return await postAuthAdminJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate admin and return authorized tokens (relates to
   * community_portal_users and community_portal_admins).
   *
   * Purpose and overview: This endpoint authenticates an admin user by
   * validating credentials against community_portal_users.password_hash and, on
   * success, issues JWT-style access and refresh tokens returning
   * ICommunityPortalAdmin.IAuthorized. It also checks admin metadata in
   * community_portal_admins (community_portal_admins.is_active and
   * community_portal_admins.admin_level) to determine if the account is allowed
   * to receive admin-scoped tokens.
   *
   * Implementation details and field usage: The request body includes
   * credentials that map to community_portal_users.email (or username) and
   * password; the server validates the password against
   * community_portal_users.password_hash. If an admin record exists
   * (community_portal_admins.user_id referencing the user) the server validates
   * community_portal_admins.is_active before issuing admin-scoped tokens. The
   * response contains token expiry metadata and may reference
   * community_portal_admins.admin_level to indicate privilege level.
   *
   * Role-specific integration and business context: This is the admin login
   * flow and must integrate with the platform's admin roster represented by
   * community_portal_admins. The login operation is expected to enforce any
   * additional platform checks such as account suspension
   * (community_portal_members.is_suspended) or user deletion status
   * (community_portal_users.deleted_at) before granting tokens.
   *
   * Security considerations: Do not expose community_portal_users.password_hash
   * or any internal audit timestamps in the response. Authentication failure
   * should be generic and must not reveal whether an email or username exists
   * in community_portal_users. Successful logins should be audited using
   * community_portal_admins.user_id and community_portal_users.id, recording
   * the login event timestamp (server-side) and respecting rate-limits and
   * multi-factor policies if applied.
   *
   * Related operations and workflow: After successful login, clients should use
   * POST /auth/admin/refresh to renew tokens. Password lifecycle operations
   * (reset and change) that update community_portal_users.password_hash are
   * available as separate endpoints. Administrative account activation state
   * can be observed via community_portal_admins.is_active and adjusted via
   * platform management tools.
   *
   * @param connection
   * @param body Admin login credentials (email/username + password).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ICommunityPortalAdmin.ILogin,
  ): Promise<ICommunityPortalAdmin.IAuthorized> {
    try {
      return await postAuthAdminLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh admin tokens using refresh token (relates to community_portal_users
   * and community_portal_admins).
   *
   * Purpose and overview: This endpoint accepts a refresh token and returns a
   * renewed access token (and optionally a rotated refresh token) for an admin
   * represented in community_portal_users and community_portal_admins. The
   * operation ensures the token owner still maps to an active admin entry
   * (community_portal_admins.is_active) before issuing admin-scoped
   * credentials.
   *
   * Implementation details and field usage: The request body contains the
   * refresh token and the server resolves the token to a user id that
   * corresponds to community_portal_users.id. The server validates that the
   * resolved user has an associated community_portal_admins entry and that
   * community_portal_admins.is_active is true. The response issues a new
   * ICommunityPortalAdmin.IAuthorized payload with updated token lifetimes.
   *
   * Role-specific integration and business context: This refresh flow is
   * specifically scoped to admin tokens and must consider admin lifecycle
   * changes: if community_portal_admins.is_active has been toggled to false or
   * the admin record removed, the refresh must be denied. Similarly, if
   * community_portal_users.deleted_at is set (user removed), refresh must be
   * denied.
   *
   * Security considerations: Refresh tokens must be validated securely; refresh
   * rotation and revocation are recommended. The endpoint should log token
   * refresh events with references to community_portal_admins.user_id and
   * community_portal_admins.admin_level for auditability. Failure to validate
   * admin state must return an appropriate unauthorized response.
   *
   * Related operations and workflow: Clients obtain initial tokens via POST
   * /auth/admin/login or POST /auth/admin/join and then call this endpoint to
   * renew access. Password resets or admin activation/deactivation (changes to
   * community_portal_admins.is_active) impact refresh behavior and should be
   * checked prior to issuing tokens.
   *
   * @param connection
   * @param body Refresh request payload containing refresh token.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ICommunityPortalAdmin.IRefresh,
  ): Promise<ICommunityPortalAdmin.IAuthorized> {
    try {
      return await postAuthAdminRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
