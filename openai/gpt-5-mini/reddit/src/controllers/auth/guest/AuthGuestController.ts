import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthGuestJoin } from "../../../providers/postAuthGuestJoin";
import { postAuthGuestRefresh } from "../../../providers/postAuthGuestRefresh";

import { ICommunityPortalGuest } from "../../../api/structures/ICommunityPortalGuest";

@Controller("/auth/guest")
export class AuthGuestController {
  /**
   * Create a guest session record in the Prisma table community_portal_guests
   * and issue a temporary guest token (relates to community_portal_guests).
   *
   * Purpose and overview: This endpoint creates a temporary guest session and
   * records it in the Prisma table community_portal_guests. The operation will
   * insert a new row populating the required columns (id, user_id, guest_token,
   * created_at, expired_at) according to the business rules. The primary goal
   * is to enable unauthenticated visitors to obtain a short-lived guest token
   * that can be used for read-only session-scoped features, while maintaining
   * an auditable record in community_portal_guests.
   *
   * Security considerations and user permissions: Because the guest_token
   * column on community_portal_guests functions as the issued guest credential,
   * token issuance and storage must follow secure token generation and storage
   * practices. The expired_at column in community_portal_guests must be checked
   * when validating tokens to enforce token lifetime. The user_id column
   * references community_portal_users.id and must be validated when provided:
   * the operation should only accept an explicit user_id value when the caller
   * indicates an existing user binding (for example, binding a guest session to
   * a recently created user), otherwise the server may generate a guest record
   * that references a system-managed placeholder user record if policy allows.
   * The operation must never expose password_hash or other secrets from
   * community_portal_users in its response.
   *
   * Relationship to underlying database entities: This operation is explicitly
   * associated with the Prisma table community_portal_guests and references
   * community_portal_users via user_id. Implementers should query or insert
   * into community_portal_guests and ensure the guest_token value is unique and
   * recorded together with created_at and expired_at timestamps. Use the id
   * column as the PK for returned session references. Any user_id used must
   * correspond to an existing community_portal_users.id to preserve referential
   * integrity.
   *
   * Validation rules and business logic: Required validation includes verifying
   * an optional provided user_id exists in community_portal_users, generating a
   * cryptographically secure guest_token, and setting created_at and expired_at
   * according to the platform’s guest session TTL policy. The server SHOULD
   * validate that expired_at is a future timestamp and that guest_token is not
   * already present in the community_portal_guests table. If user_id is
   * provided but does not exist, the request MUST be rejected with a 400/404 as
   * appropriate. The API will return the issued guest_token and associated
   * metadata in the response body (ICommunityPortalGuest.IAuthorized), not
   * exposing internal password_hash values.
   *
   * Related operations and workflow integration: This join operation is
   * intended to be used together with the refresh operation
   * (/auth/guest/refresh) to renew guest tokens. Typical flow: client calls
   * POST /auth/guest/join to obtain an initial guest_token and
   * created_at/expired_at; later, when the guest token nears expiration, the
   * client calls POST /auth/guest/refresh providing the current guest_token to
   * obtain a renewed ICommunityPortalGuest.IAuthorized response. The join
   * endpoint is public and requires no prior authentication.
   *
   * @param connection
   * @param body Request payload to create a guest session. If binding to an
   *   existing account, include user_id with a valid
   *   community_portal_users.id.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ICommunityPortalGuest.ICreate,
  ): Promise<ICommunityPortalGuest.IAuthorized> {
    try {
      return await postAuthGuestJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh a guest session by validating and renewing a guest_token stored in
   * community_portal_guests.
   *
   * Purpose and overview: This endpoint validates an existing guest credential
   * (community_portal_guests.guest_token) and issues a renewed authorization
   * response. The operation reads the community_portal_guests table using the
   * provided guest_token and returns a renewed token or extended expiry
   * metadata (id, user_id, guest_token, created_at, expired_at) in the
   * authorized response type ICommunityPortalGuest.IAuthorized.
   *
   * Security considerations and user permissions: The refresh operation must
   * strictly validate the provided guest_token against the
   * community_portal_guests.guest_token column and ensure the token has not
   * already expired by comparing against expired_at. To mitigate token replay
   * and abuse, the implementation should enforce token rotation semantics
   * (issue a new guest_token and update expired_at) and use secure token
   * handling. Because the underlying record references user_id
   * (community_portal_users.id), additional checks may be applied when user_id
   * is present (for example, if the user has been suspended in
   * community_portal_members.is_suspended, refresh should be denied).
   *
   * Relationship to underlying database entities: This operation is centered on
   * the community_portal_guests Prisma table and its columns: guest_token
   * (lookup key), expired_at (expiry check), created_at (auditable creation),
   * id (PK), and user_id (nullable FK referencing community_portal_users.id).
   * The refresh logic must only reference these existing fields and must not
   * assume additional columns exist. Implementers should ensure updates to
   * guest_token and expired_at are persisted to the community_portal_guests row
   * when rotating tokens.
   *
   * Validation rules and business logic: The API MUST reject refresh requests
   * for unknown or expired guest_token values with 401 Unauthorized. If the
   * record exists and expired_at indicates the token is still valid (or within
   * a configurable refresh window), the API SHOULD issue a new guest_token,
   * update expired_at according to the platform’s TTL policy, and return the
   * updated ICommunityPortalGuest.IAuthorized response. If the associated
   * user_id is present, additional business gating (e.g., account suspension
   * check using community_portal_members.is_suspended) MAY block refresh and
   * return 403 Forbidden.
   *
   * Related operations and workflow integration: This refresh endpoint
   * complements POST /auth/guest/join: after obtaining an initial guest_token
   * via join, clients call POST /auth/guest/refresh to renew that guest
   * session. The refresh operation is a public endpoint but requires a valid
   * guest_token in the request body (ICommunityPortalGuest.IRefresh). It
   * returns the same response shape as join (ICommunityPortalGuest.IAuthorized)
   * to allow uniform handling on the client side.
   *
   * @param connection
   * @param body Payload containing the current guest_token to be validated and
   *   refreshed.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ICommunityPortalGuest.IRefresh,
  ): Promise<ICommunityPortalGuest.IAuthorized> {
    try {
      return await postAuthGuestRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
