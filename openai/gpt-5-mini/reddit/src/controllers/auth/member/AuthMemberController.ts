import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthMemberJoin } from "../../../providers/postAuthMemberJoin";
import { postAuthMemberLogin } from "../../../providers/postAuthMemberLogin";
import { postAuthMemberRefresh } from "../../../providers/postAuthMemberRefresh";

import { ICommunityPortalMember } from "../../../api/structures/ICommunityPortalMember";

@Controller("/auth/member")
export class AuthMemberController {
  /**
   * Register a new member by creating community_portal_users and
   * community_portal_members records and returning initial authorization.
   *
   * Purpose and functionality: This endpoint registers a new member account by
   * creating a community_portal_users record (storing username, email and
   * password_hash) and a corresponding community_portal_members record (storing
   * member_since and is_email_verified=false). It uses the schema fields
   * community_portal_users.email, community_portal_users.username,
   * community_portal_users.password_hash, community_portal_users.display_name
   * and community_portal_members.member_since and
   * community_portal_members.is_email_verified to model the account creation
   * and initial membership state.
   *
   * Implementation details and required fields: The request body MUST supply
   * the email (community_portal_users.email), chosen username
   * (community_portal_users.username), a client-supplied password which the
   * server will transform into password_hash
   * (community_portal_users.password_hash), and optional display_name
   * (community_portal_users.display_name). On success, the server will create a
   * new community_portal_users row and a community_portal_members row linked by
   * user_id, setting member_since to the current timestamp
   * (community_portal_members.member_since).
   *
   * Role-specific integration and business context: This operation targets end
   * users who will become members in the platform. The returned authorized
   * response (ICommunityPortalMember.IAuthorized) contains the token and
   * minimal public user info including the user id (community_portal_users.id),
   * username, display_name, and initial karma (community_portal_users.karma).
   * The API intentionally sets is_email_verified
   * (community_portal_members.is_email_verified) to false until verification
   * completes.
   *
   * Security considerations within schema constraints: Passwords are never
   * stored in plaintext; the schema exposes password_hash
   * (community_portal_users.password_hash) as the persisted column. The
   * implementation MUST hash and salt the provided password and NOT accept a
   * pre-hashed value from clients. The endpoint should validate email
   * uniqueness against community_portal_users.email and username uniqueness
   * against community_portal_users.username and return a 409 Conflict when
   * duplicates are detected.
   *
   * Related operations and workflow integration: Typical workflow: client calls
   * POST /auth/member/join to create the user, then calls the email
   * verification flow (verifyEmail) once they receive a verification token. The
   * login and refresh operations (login, refresh) consume the issued
   * credentials and tokens to establish and renew sessions. This operation maps
   * directly to the Prisma tables community_portal_users and
   * community_portal_members.
   *
   * @param connection
   * @param body Registration payload containing username, email and password.
   *   The server will hash the password and create the member record.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ICommunityPortalMember.ICreate,
  ): Promise<ICommunityPortalMember.IAuthorized> {
    try {
      return await postAuthMemberJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate a member and return authorization tokens and basic profile
   * (id, username, display_name, karma).
   *
   * Purpose and functionality: This endpoint authenticates an existing member
   * using credentials that map to community_portal_users (email or username)
   * and verifies membership state via
   * community_portal_members.is_email_verified. On successful authentication it
   * returns an authorization payload (ICommunityPortalMember.IAuthorized) that
   * the client can use for authenticated requests.
   *
   * Implementation details and required fields: The client provides an
   * identifier (email or username) and a password. The server looks up
   * community_portal_users.email or community_portal_users.username, verifies
   * the provided password against community_portal_users.password_hash, and
   * checks community_portal_members.is_email_verified before granting full
   * member privileges. The response includes user id
   * (community_portal_users.id), username, display_name, and karma.
   *
   * Role-specific integration and business context: Login is a public endpoint
   * used by members to establish sessions. The operation ties into downstream
   * behavior: gated actions like creating posts or voting should verify that
   * community_portal_members.is_email_verified is true. The server may also
   * include member_since (community_portal_members.member_since) in the
   * response for client UI.
   *
   * Security considerations within schema constraints: Do not leak whether the
   * provided identifier exists; on failure return a generic authentication
   * error. Use secure comparisons for password verification against
   * password_hash. Consider rate-limiting failed attempts to protect
   * community_portal_users accounts.
   *
   * Related operations and workflow integration: After successful login,
   * clients use the issued tokens to call member-only endpoints. If a member's
   * community_portal_members.is_suspended flag is set (member table), member
   * actions should be restricted. This operation directly references
   * community_portal_users and community_portal_members.
   *
   * @param connection
   * @param body Login payload with identifier (email or username) and password.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ICommunityPortalMember.ILogin,
  ): Promise<ICommunityPortalMember.IAuthorized> {
    try {
      return await postAuthMemberLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh authentication tokens for a member using a valid refresh token and
   * return a new ICommunityPortalMember.IAuthorized payload.
   *
   * Purpose and functionality: This endpoint renews authentication by accepting
   * a valid refresh token and issuing a new access token and optionally a
   * rotated refresh token. The issued tokens are associated with
   * community_portal_users.id and the returned authorized payload follows
   * ICommunityPortalMember.IAuthorized.
   *
   * Implementation details and required fields: Clients POST the refresh token
   * in the request body. The server validates the refresh token, ensures the
   * referenced user (community_portal_users.id) still exists and is not
   * suspended, and returns a fresh authorized response. No profile mutation is
   * expected; the operation only issues new tokens for an existing
   * community_portal_users record.
   *
   * Role-specific integration and business context: Refresh is a public
   * endpoint that requires a valid refresh token. It ensures continuity of
   * member sessions without re-supplying credentials. The server should check
   * membership state (e.g., community_portal_members.is_suspended) before
   * issuing tokens.
   *
   * Security considerations within schema constraints: Rotate refresh tokens on
   * use where feasible and bind tokens to community_portal_users.id for
   * auditability. If the referenced user record no longer exists, return 401
   * Unauthorized. Avoid revealing internal details about community_portal_users
   * records on failure.
   *
   * Related operations and workflow integration: This operation complements
   * login and join flows by enabling long-lived session management. It
   * references community_portal_users for user existence and membership checks
   * but does not alter persisted user or member records.
   *
   * @param connection
   * @param body Refresh request containing the refresh token issued at login or
   *   prior refresh.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ICommunityPortalMember.IRefresh,
  ): Promise<ICommunityPortalMember.IAuthorized> {
    try {
      return await postAuthMemberRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
