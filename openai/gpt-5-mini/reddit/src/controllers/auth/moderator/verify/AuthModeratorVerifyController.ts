import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthModeratorVerify } from "../../../../providers/postAuthModeratorVerify";

import { ICommunityPortalModerator } from "../../../../api/structures/ICommunityPortalModerator";

@Controller("/auth/moderator/verify")
export class AuthModeratorVerifyController {
  /**
   * Verify moderator email and activate membership record.
   *
   * Purpose and overview: Confirm a moderator's email address and flip
   * community_portal_members.is_email_verified to true for the associated user.
   * This operation accepts a verification token tied to a
   * community_portal_users.id and updates the membership record's
   * is_email_verified and member_since as appropriate.
   *
   * Implementation details using confirmed schema fields: The request payload
   * SHOULD include a one-time verification token and the target user identifier
   * (or token-bound lookup). Once validated, the implementation MUST set
   * community_portal_members.is_email_verified=true and record the current
   * timestamp in member_since if not already set. The response indicates
   * success and may optionally return a lightweight user summary (id,
   * username).
   *
   * Role-specific integration and business context: Email verification is
   * required before granting full moderator responsibilities in many workflows;
   * the UI should surface guidance if verification is pending. The existence of
   * community_portal_members.is_suspended should be consideredâ€”verification
   * does not override suspension.
   *
   * Security considerations constrained by schema: Verification tokens must be
   * single-use and time-limited. Do not expose the
   * community_portal_users.password_hash. If community_portal_users.deleted_at
   * is set, reject verification attempts and advise account recreation.
   *
   * Related operations and workflow integration: Typical sequence: join ->
   * verify (this operation) -> login -> refresh. After verification the client
   * may call login to obtain tokens.
   *
   * @param connection
   * @param body Payload containing the verification token (and optionally user
   *   id) to confirm email.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async verifyEmail(
    @TypedBody()
    body: ICommunityPortalModerator.IVerifyEmailRequest,
  ): Promise<ICommunityPortalModerator.IVerifyEmailResponse> {
    try {
      return await postAuthModeratorVerify({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
