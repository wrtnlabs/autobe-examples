import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthModeratorJoin } from "../../../providers/postAuthModeratorJoin";
import { postAuthModeratorLogin } from "../../../providers/postAuthModeratorLogin";
import { postAuthModeratorRefresh } from "../../../providers/postAuthModeratorRefresh";

import { ICommunityPortalModerator } from "../../../api/structures/ICommunityPortalModerator";

@Controller("/auth/moderator")
export class AuthModeratorController {
  /**
   * Register a new moderator account (creates community_portal_users and
   * community_portal_members).
   *
   * Purpose and overview: This endpoint creates a new moderator account and
   * issues initial authentication tokens. It maps to the community_portal_users
   * and community_portal_members tables: a new community_portal_users row is
   * created (username, email, password_hash, display_name, avatar_uri optional)
   * and a corresponding community_portal_members row is created to track
   * is_email_verified and member_since. The operation is intended for
   * onboarding moderator candidates or promoting members into moderator status
   * when appropriate.
   *
   * Implementation details using confirmed schema fields: Request payload
   * SHOULD include username (community_portal_users.username), email
   * (community_portal_users.email), password (which will be stored as
   * community_portal_users.password_hash by the implementation), and optional
   * display_name (community_portal_users.display_name). The server will create
   * community_portal_users and community_portal_members records and set
   * community_portal_members.is_email_verified=false until verification occurs.
   * The response returns the authorized token container and minimal user
   * summary.
   *
   * Role-specific integration and business context: This join flow is scoped to
   * creation of moderator-capable accounts. The implementation should ensure
   * the created records reflect the moderator candidate's intended privileges
   * while referencing the community_portal_members.member_since timestamp and
   * initial karma (community_portal_users.karma). Any moderator appointment
   * workflow should run after account creation per product policy.
   *
   * Security considerations constrained by schema: Passwords must be handled
   * only as a secure hash stored in community_portal_users.password_hash;
   * plaintext passwords MUST never be persisted. The service SHOULD enforce
   * email uniqueness (community_portal_users.email is unique in the schema) and
   * validate email format. The implementation MUST respect
   * community_portal_members.is_suspended if a later moderation action suspends
   * the account.
   *
   * Related operations and workflow integration: After join, the typical flow
   * is to call verifyEmail to confirm
   * community_portal_members.is_email_verified, then use login to obtain fresh
   * tokens, and refresh to renew access tokens. See /auth/moderator/verify,
   * /auth/moderator/login, and /auth/moderator/refresh for complementary
   * operations.
   *
   * @param connection
   * @param body Registration payload for a moderator account (username, email,
   *   password, optional displayName).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ICommunityPortalModerator.ICreate,
  ): Promise<ICommunityPortalModerator.IAuthorized> {
    try {
      return await postAuthModeratorJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate moderator and return authorized tokens.
   *
   * Purpose and overview: Authenticate an existing moderator account and issue
   * short-lived access tokens and longer-lived refresh tokens. This operation
   * reads community_portal_users.password_hash to validate credentials and
   * checks community_portal_members.is_email_verified and
   * community_portal_members.is_suspended to determine eligibility for
   * sign-in.
   *
   * Implementation details using confirmed schema fields: The request body
   * SHOULD accept credentials (email or username) and password. The operation
   * MUST validate the provided password against
   * community_portal_users.password_hash and confirm the associated
   * community_portal_members.is_email_verified is true before issuing full
   * privileges. If community_portal_members.is_suspended is true,
   * authentication must be denied with an explanatory result.
   *
   * Role-specific integration and business context: Successful login produces
   * an ICommunityPortalModerator.IAuthorized response including token material
   * and a minimal user profile (id, username, display_name, karma from
   * community_portal_users.karma, and member_since from
   * community_portal_members.member_since). The UI can use these fields to
   * display moderator context.
   *
   * Security considerations constrained by schema: Implementers MUST avoid
   * disclosing whether the email exists in error messages. Failed login
   * attempts should be counted for rate-limiting and anti-abuse while
   * respecting the community_portal_users.deleted_at and
   * community_portal_members.is_suspended fields. Password verification uses
   * the stored community_portal_users.password_hash only.
   *
   * Related operations and workflow integration: After successful login clients
   * may call refresh to rotate tokens. If the account is newly created and
   * community_portal_members.is_email_verified is false, prompt the user to
   * verify via the verifyEmail operation.
   *
   * @param connection
   * @param body Credentials for moderator sign-in (email or username and
   *   password).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ICommunityPortalModerator.ILogin,
  ): Promise<ICommunityPortalModerator.IAuthorized> {
    try {
      return await postAuthModeratorLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh moderator access tokens.
   *
   * Purpose and overview: Issue new access (and, optionally, rotated refresh)
   * tokens for a moderator using a valid refresh token. The operation logically
   * associates the token with community_portal_users.id and verifies account
   * status by consulting community_portal_members.is_suspended so suspended
   * accounts cannot obtain new tokens.
   *
   * Implementation details using confirmed schema fields: Request payload
   * SHOULD contain a refresh token tied to a specific
   * community_portal_users.id. The server resolves the user record
   * (community_portal_users.id) and confirms the membership state
   * (community_portal_members.is_suspended). If eligible, the endpoint returns
   * a new ICommunityPortalModerator.IAuthorized response with newly issued
   * tokens and lightweight user info (username, id, karma).
   *
   * Role-specific integration and business context: Token refresh is part of
   * the normal moderator session lifecycle; it supports long-lived login
   * experiences without re-entering credentials while ensuring account state
   * checks (is_suspended) remain enforced before reissuing privileges.
   *
   * Security considerations constrained by schema: Rotate refresh tokens on use
   * when possible and validate refresh token binding to
   * community_portal_users.id. If community_portal_users.deleted_at is set,
   * deny token refresh. Log refresh events tied to the user id for audit.
   *
   * Related operations and workflow integration: Used after login and join
   * flows; clients should call refresh when access tokens expire. For
   * security-sensitive actions, require reauthentication via login rather than
   * refresh.
   *
   * @param connection
   * @param body Refresh token payload to obtain new access tokens.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ICommunityPortalModerator.IRefresh,
  ): Promise<ICommunityPortalModerator.IAuthorized> {
    try {
      return await postAuthModeratorRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
