import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthModeratorPasswordChange } from "../../../../../providers/postAuthModeratorPasswordChange";
import { ModeratorAuth } from "../../../../../decorators/ModeratorAuth";
import { ModeratorPayload } from "../../../../../decorators/payload/ModeratorPayload";

import { ICommunityPortalModerator } from "../../../../../api/structures/ICommunityPortalModerator";

@Controller("/auth/moderator/password/change")
export class AuthModeratorPasswordChangeController {
  /**
   * Authenticated moderator changes their password.
   *
   * Purpose and overview: Enable an authenticated moderator to change their
   * password. The operation targets community_portal_users.password_hash for
   * the calling user and requires current password verification before applying
   * the new hash. This is a security-sensitive user operation scoped to
   * authenticated moderators.
   *
   * Implementation details using confirmed schema fields: Request payload
   * SHOULD include the current password and the new password. The server
   * validates the current password against
   * community_portal_users.password_hash, computes the new hash, and updates
   * community_portal_users.password_hash. The endpoint should also record an
   * audit event tied to community_portal_users.id.
   *
   * Role-specific integration and business context: This endpoint is restricted
   * to authenticated moderators (authorizationRole="moderator"). It supports
   * user-initiated credential rotation and should invalidate existing refresh
   * tokens after a successful change to protect sessions.
   *
   * Security considerations constrained by schema: Do not expose
   * community_portal_users.password_hash. Require reauthentication or MFA for
   * high-risk changes if platform policy dictates. Log the password change
   * event with user id and timestamp for audit (linked to
   * community_portal_users.id).
   *
   * Related operations and workflow integration: After changePassword
   * completes, clients may need to reauthenticate (login) or use refreshed
   * tokens depending on token invalidation policy.
   *
   * @param connection
   * @param body Current password and new password for the authenticated
   *   moderator.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async changePassword(
    @ModeratorAuth()
    moderator: ModeratorPayload,
    @TypedBody()
    body: ICommunityPortalModerator.IChangePassword,
  ): Promise<ICommunityPortalModerator.IChangePasswordResponse> {
    try {
      return await postAuthModeratorPasswordChange({
        moderator,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
