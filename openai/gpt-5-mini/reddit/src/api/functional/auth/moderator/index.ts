import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalModerator } from "../../../structures/ICommunityPortalModerator";
export * as verify from "./verify/index";
export * as password from "./password/index";

/**
 * Register a new moderator account (creates community_portal_users and
 * community_portal_members).
 *
 * Purpose and overview: This endpoint creates a new moderator account and
 * issues initial authentication tokens. It maps to the community_portal_users
 * and community_portal_members tables: a new community_portal_users row is
 * created (username, email, password_hash, display_name, avatar_uri optional)
 * and a corresponding community_portal_members row is created to track
 * is_email_verified and member_since. The operation is intended for onboarding
 * moderator candidates or promoting members into moderator status when
 * appropriate.
 *
 * Implementation details using confirmed schema fields: Request payload SHOULD
 * include username (community_portal_users.username), email
 * (community_portal_users.email), password (which will be stored as
 * community_portal_users.password_hash by the implementation), and optional
 * display_name (community_portal_users.display_name). The server will create
 * community_portal_users and community_portal_members records and set
 * community_portal_members.is_email_verified=false until verification occurs.
 * The response returns the authorized token container and minimal user
 * summary.
 *
 * Role-specific integration and business context: This join flow is scoped to
 * creation of moderator-capable accounts. The implementation should ensure the
 * created records reflect the moderator candidate's intended privileges while
 * referencing the community_portal_members.member_since timestamp and initial
 * karma (community_portal_users.karma). Any moderator appointment workflow
 * should run after account creation per product policy.
 *
 * Security considerations constrained by schema: Passwords must be handled only
 * as a secure hash stored in community_portal_users.password_hash; plaintext
 * passwords MUST never be persisted. The service SHOULD enforce email
 * uniqueness (community_portal_users.email is unique in the schema) and
 * validate email format. The implementation MUST respect
 * community_portal_members.is_suspended if a later moderation action suspends
 * the account.
 *
 * Related operations and workflow integration: After join, the typical flow is
 * to call verifyEmail to confirm community_portal_members.is_email_verified,
 * then use login to obtain fresh tokens, and refresh to renew access tokens.
 * See /auth/moderator/verify, /auth/moderator/login, and
 * /auth/moderator/refresh for complementary operations.
 *
 * @param props.connection
 * @param props.body Registration payload for a moderator account (username,
 *   email, password, optional displayName).
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/join
 * @accessor api.functional.auth.moderator.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Registration payload for a moderator account (username, email,
     * password, optional displayName).
     */
    body: ICommunityPortalModerator.ICreate;
  };
  export type Body = ICommunityPortalModerator.ICreate;
  export type Response = ICommunityPortalModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/join";
  export const random = (): ICommunityPortalModerator.IAuthorized =>
    typia.random<ICommunityPortalModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate moderator and return authorized tokens.
 *
 * Purpose and overview: Authenticate an existing moderator account and issue
 * short-lived access tokens and longer-lived refresh tokens. This operation
 * reads community_portal_users.password_hash to validate credentials and checks
 * community_portal_members.is_email_verified and
 * community_portal_members.is_suspended to determine eligibility for sign-in.
 *
 * Implementation details using confirmed schema fields: The request body SHOULD
 * accept credentials (email or username) and password. The operation MUST
 * validate the provided password against community_portal_users.password_hash
 * and confirm the associated community_portal_members.is_email_verified is true
 * before issuing full privileges. If community_portal_members.is_suspended is
 * true, authentication must be denied with an explanatory result.
 *
 * Role-specific integration and business context: Successful login produces an
 * ICommunityPortalModerator.IAuthorized response including token material and a
 * minimal user profile (id, username, display_name, karma from
 * community_portal_users.karma, and member_since from
 * community_portal_members.member_since). The UI can use these fields to
 * display moderator context.
 *
 * Security considerations constrained by schema: Implementers MUST avoid
 * disclosing whether the email exists in error messages. Failed login attempts
 * should be counted for rate-limiting and anti-abuse while respecting the
 * community_portal_users.deleted_at and community_portal_members.is_suspended
 * fields. Password verification uses the stored
 * community_portal_users.password_hash only.
 *
 * Related operations and workflow integration: After successful login clients
 * may call refresh to rotate tokens. If the account is newly created and
 * community_portal_members.is_email_verified is false, prompt the user to
 * verify via the verifyEmail operation.
 *
 * @param props.connection
 * @param props.body Credentials for moderator sign-in (email or username and
 *   password).
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/login
 * @accessor api.functional.auth.moderator.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Credentials for moderator sign-in (email or username and password). */
    body: ICommunityPortalModerator.ILogin;
  };
  export type Body = ICommunityPortalModerator.ILogin;
  export type Response = ICommunityPortalModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/login";
  export const random = (): ICommunityPortalModerator.IAuthorized =>
    typia.random<ICommunityPortalModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh moderator access tokens.
 *
 * Purpose and overview: Issue new access (and, optionally, rotated refresh)
 * tokens for a moderator using a valid refresh token. The operation logically
 * associates the token with community_portal_users.id and verifies account
 * status by consulting community_portal_members.is_suspended so suspended
 * accounts cannot obtain new tokens.
 *
 * Implementation details using confirmed schema fields: Request payload SHOULD
 * contain a refresh token tied to a specific community_portal_users.id. The
 * server resolves the user record (community_portal_users.id) and confirms the
 * membership state (community_portal_members.is_suspended). If eligible, the
 * endpoint returns a new ICommunityPortalModerator.IAuthorized response with
 * newly issued tokens and lightweight user info (username, id, karma).
 *
 * Role-specific integration and business context: Token refresh is part of the
 * normal moderator session lifecycle; it supports long-lived login experiences
 * without re-entering credentials while ensuring account state checks
 * (is_suspended) remain enforced before reissuing privileges.
 *
 * Security considerations constrained by schema: Rotate refresh tokens on use
 * when possible and validate refresh token binding to
 * community_portal_users.id. If community_portal_users.deleted_at is set, deny
 * token refresh. Log refresh events tied to the user id for audit.
 *
 * Related operations and workflow integration: Used after login and join flows;
 * clients should call refresh when access tokens expire. For security-sensitive
 * actions, require reauthentication via login rather than refresh.
 *
 * @param props.connection
 * @param props.body Refresh token payload to obtain new access tokens.
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/refresh
 * @accessor api.functional.auth.moderator.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token payload to obtain new access tokens. */
    body: ICommunityPortalModerator.IRefresh;
  };
  export type Body = ICommunityPortalModerator.IRefresh;
  export type Response = ICommunityPortalModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/refresh";
  export const random = (): ICommunityPortalModerator.IAuthorized =>
    typia.random<ICommunityPortalModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
