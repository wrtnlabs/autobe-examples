import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalMember } from "../../../structures/ICommunityPortalMember";
export * as password from "./password/index";
export * as verify_email from "./verify_email/index";

/**
 * Register a new member by creating community_portal_users and
 * community_portal_members records and returning initial authorization.
 *
 * Purpose and functionality: This endpoint registers a new member account by
 * creating a community_portal_users record (storing username, email and
 * password_hash) and a corresponding community_portal_members record (storing
 * member_since and is_email_verified=false). It uses the schema fields
 * community_portal_users.email, community_portal_users.username,
 * community_portal_users.password_hash, community_portal_users.display_name and
 * community_portal_members.member_since and
 * community_portal_members.is_email_verified to model the account creation and
 * initial membership state.
 *
 * Implementation details and required fields: The request body MUST supply the
 * email (community_portal_users.email), chosen username
 * (community_portal_users.username), a client-supplied password which the
 * server will transform into password_hash
 * (community_portal_users.password_hash), and optional display_name
 * (community_portal_users.display_name). On success, the server will create a
 * new community_portal_users row and a community_portal_members row linked by
 * user_id, setting member_since to the current timestamp
 * (community_portal_members.member_since).
 *
 * Role-specific integration and business context: This operation targets end
 * users who will become members in the platform. The returned authorized
 * response (ICommunityPortalMember.IAuthorized) contains the token and minimal
 * public user info including the user id (community_portal_users.id), username,
 * display_name, and initial karma (community_portal_users.karma). The API
 * intentionally sets is_email_verified
 * (community_portal_members.is_email_verified) to false until verification
 * completes.
 *
 * Security considerations within schema constraints: Passwords are never stored
 * in plaintext; the schema exposes password_hash
 * (community_portal_users.password_hash) as the persisted column. The
 * implementation MUST hash and salt the provided password and NOT accept a
 * pre-hashed value from clients. The endpoint should validate email uniqueness
 * against community_portal_users.email and username uniqueness against
 * community_portal_users.username and return a 409 Conflict when duplicates are
 * detected.
 *
 * Related operations and workflow integration: Typical workflow: client calls
 * POST /auth/member/join to create the user, then calls the email verification
 * flow (verifyEmail) once they receive a verification token. The login and
 * refresh operations (login, refresh) consume the issued credentials and tokens
 * to establish and renew sessions. This operation maps directly to the Prisma
 * tables community_portal_users and community_portal_members.
 *
 * @param props.connection
 * @param props.body Registration payload containing username, email and
 *   password. The server will hash the password and create the member record.
 * @setHeader token.access Authorization
 *
 * @path /auth/member/join
 * @accessor api.functional.auth.member.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Registration payload containing username, email and password. The
     * server will hash the password and create the member record.
     */
    body: ICommunityPortalMember.ICreate;
  };
  export type Body = ICommunityPortalMember.ICreate;
  export type Response = ICommunityPortalMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/join";
  export const random = (): ICommunityPortalMember.IAuthorized =>
    typia.random<ICommunityPortalMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate a member and return authorization tokens and basic profile (id,
 * username, display_name, karma).
 *
 * Purpose and functionality: This endpoint authenticates an existing member
 * using credentials that map to community_portal_users (email or username) and
 * verifies membership state via community_portal_members.is_email_verified. On
 * successful authentication it returns an authorization payload
 * (ICommunityPortalMember.IAuthorized) that the client can use for
 * authenticated requests.
 *
 * Implementation details and required fields: The client provides an identifier
 * (email or username) and a password. The server looks up
 * community_portal_users.email or community_portal_users.username, verifies the
 * provided password against community_portal_users.password_hash, and checks
 * community_portal_members.is_email_verified before granting full member
 * privileges. The response includes user id (community_portal_users.id),
 * username, display_name, and karma.
 *
 * Role-specific integration and business context: Login is a public endpoint
 * used by members to establish sessions. The operation ties into downstream
 * behavior: gated actions like creating posts or voting should verify that
 * community_portal_members.is_email_verified is true. The server may also
 * include member_since (community_portal_members.member_since) in the response
 * for client UI.
 *
 * Security considerations within schema constraints: Do not leak whether the
 * provided identifier exists; on failure return a generic authentication error.
 * Use secure comparisons for password verification against password_hash.
 * Consider rate-limiting failed attempts to protect community_portal_users
 * accounts.
 *
 * Related operations and workflow integration: After successful login, clients
 * use the issued tokens to call member-only endpoints. If a member's
 * community_portal_members.is_suspended flag is set (member table), member
 * actions should be restricted. This operation directly references
 * community_portal_users and community_portal_members.
 *
 * @param props.connection
 * @param props.body Login payload with identifier (email or username) and
 *   password.
 * @setHeader token.access Authorization
 *
 * @path /auth/member/login
 * @accessor api.functional.auth.member.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Login payload with identifier (email or username) and password. */
    body: ICommunityPortalMember.ILogin;
  };
  export type Body = ICommunityPortalMember.ILogin;
  export type Response = ICommunityPortalMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/login";
  export const random = (): ICommunityPortalMember.IAuthorized =>
    typia.random<ICommunityPortalMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh authentication tokens for a member using a valid refresh token and
 * return a new ICommunityPortalMember.IAuthorized payload.
 *
 * Purpose and functionality: This endpoint renews authentication by accepting a
 * valid refresh token and issuing a new access token and optionally a rotated
 * refresh token. The issued tokens are associated with
 * community_portal_users.id and the returned authorized payload follows
 * ICommunityPortalMember.IAuthorized.
 *
 * Implementation details and required fields: Clients POST the refresh token in
 * the request body. The server validates the refresh token, ensures the
 * referenced user (community_portal_users.id) still exists and is not
 * suspended, and returns a fresh authorized response. No profile mutation is
 * expected; the operation only issues new tokens for an existing
 * community_portal_users record.
 *
 * Role-specific integration and business context: Refresh is a public endpoint
 * that requires a valid refresh token. It ensures continuity of member sessions
 * without re-supplying credentials. The server should check membership state
 * (e.g., community_portal_members.is_suspended) before issuing tokens.
 *
 * Security considerations within schema constraints: Rotate refresh tokens on
 * use where feasible and bind tokens to community_portal_users.id for
 * auditability. If the referenced user record no longer exists, return 401
 * Unauthorized. Avoid revealing internal details about community_portal_users
 * records on failure.
 *
 * Related operations and workflow integration: This operation complements login
 * and join flows by enabling long-lived session management. It references
 * community_portal_users for user existence and membership checks but does not
 * alter persisted user or member records.
 *
 * @param props.connection
 * @param props.body Refresh request containing the refresh token issued at
 *   login or prior refresh.
 * @setHeader token.access Authorization
 *
 * @path /auth/member/refresh
 * @accessor api.functional.auth.member.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh request containing the refresh token issued at login or prior
     * refresh.
     */
    body: ICommunityPortalMember.IRefresh;
  };
  export type Body = ICommunityPortalMember.IRefresh;
  export type Response = ICommunityPortalMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/refresh";
  export const random = (): ICommunityPortalMember.IAuthorized =>
    typia.random<ICommunityPortalMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
