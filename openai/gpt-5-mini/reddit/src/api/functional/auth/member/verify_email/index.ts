import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalMember } from "../../../../structures/ICommunityPortalMember";

/**
 * Verify a member's email by consuming a verification token and setting
 * community_portal_members.is_email_verified to true.
 *
 * Purpose and functionality: This endpoint verifies a member's email by
 * accepting a verification token issued at registration. When the token is
 * validated, the implementation sets community_portal_members.is_email_verified
 * = true for the corresponding membership record and records the verification
 * event (member_since and updated_at may be referenced).
 *
 * Implementation details and required fields: The request includes a
 * verification token that the server validates and maps to a
 * community_portal_users.id / community_portal_members record. On success the
 * server updates community_portal_members.is_email_verified to true and returns
 * the authorized view of the user or a simple success response.
 *
 * Role-specific integration and business context: Email verification unlocks
 * member capabilities that gate content creation and voting. The endpoint ties
 * the verification artifact to community_portal_users.email and the membership
 * record (community_portal_members.is_email_verified). The client may
 * subsequently call login to obtain tokens that reflect verified membership
 * privileges.
 *
 * Security considerations within schema constraints: Treat verification tokens
 * as single-use and time-limited. Do not expose whether the token maps to which
 * internal id on failure; return a generic invalid/expired response. Ensure the
 * update is auditable and tied to community_portal_users.id.
 *
 * Related operations and workflow integration: This operation complements the
 * join flow and allows the member to obtain full privileges (posting, voting)
 * once community_portal_members.is_email_verified is true. It references
 * community_portal_members and community_portal_users in the Prisma schema.
 *
 * @param props.connection
 * @param props.body Verification request containing the verification token
 *   issued at registration.
 * @path /auth/member/verify-email
 * @accessor api.functional.auth.member.verify_email.verifyEmail
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function verifyEmail(
  connection: IConnection,
  props: verifyEmail.Props,
): Promise<verifyEmail.Response> {
  return true === connection.simulate
    ? verifyEmail.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...verifyEmail.METADATA,
          path: verifyEmail.path(),
          status: null,
        },
        props.body,
      );
}
export namespace verifyEmail {
  export type Props = {
    /**
     * Verification request containing the verification token issued at
     * registration.
     */
    body: ICommunityPortalMember.IVerifyEmail;
  };
  export type Body = ICommunityPortalMember.IVerifyEmail;
  export type Response = ICommunityPortalMember.IVerifyEmailResult;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/verify-email",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/verify-email";
  export const random = (): ICommunityPortalMember.IVerifyEmailResult =>
    typia.random<ICommunityPortalMember.IVerifyEmailResult>();
  export const simulate = (
    connection: IConnection,
    props: verifyEmail.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: verifyEmail.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
