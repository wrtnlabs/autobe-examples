import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalAdmin } from "../../../structures/ICommunityPortalAdmin";
export * as password from "./password/index";
export * as email from "./email/index";

/**
 * Create admin account and issue initial tokens (relates to
 * community_portal_admins and community_portal_users).
 *
 * Purpose and overview: This endpoint creates a new admin account and issues
 * initial authorization tokens. It operates against the community_portal_admins
 * and community_portal_users tables: the admin metadata will be recorded in
 * community_portal_admins (user_id, admin_level, is_active, created_at) and the
 * authentication identity will be created in community_portal_users (email,
 * password_hash, username, display_name, created_at). The operation enables
 * platform administrators to obtain an ICommunityPortalAdmin.IAuthorized
 * response that contains issued access and refresh tokens.
 *
 * Implementation details and field usage: The request payload maps to the admin
 * creation DTO and must include the desired username and email that will be
 * stored in community_portal_users.username and community_portal_users.email,
 * and a password that will be stored as a secure password_hash in
 * community_portal_users.password_hash. The created admin record in
 * community_portal_admins will reference the new user's id in
 * community_portal_admins.user_id and may set
 * community_portal_admins.admin_level and community_portal_admins.is_active.
 * The response reflects the newly created user's id and token data and
 * references community_portal_admins.created_at for auditing.
 *
 * Role-specific integration and business context: This endpoint is the join
 * (registration) entry for the admin role. It is used when provisioning
 * elevated accounts that will be represented in community_portal_admins. The
 * API consumer should expect the platform to validate uniqueness against
 * community_portal_users.email and community_portal_users.username before
 * creating records. If community_portal_admins.is_active is set, the system
 * will allow the new admin to perform elevated actions once tokens are issued
 * and standard verification checks are satisfied.
 *
 * Security considerations: The request should only transport the raw password
 * in the request body over TLS; the server MUST persist a secure hash in
 * community_portal_users.password_hash and MUST NOT return password or
 * password_hash in responses. The endpoint should validate that
 * community_portal_members.is_email_verified is true for the underlying user if
 * the platform requires an existing verified member before granting admin
 * privileges (refer to community_portal_members.user_id and
 * community_portal_members.is_email_verified). Protect rate-limits and audit
 * the creation via community_portal_admins.created_at and
 * community_portal_users.created_at fields.
 *
 * Related operations and workflow: Typical workflow uses POST /auth/admin/join
 * to create the admin and then POST /auth/admin/login to obtain fresh tokens.
 * Follow-up operations include POST /auth/admin/refresh for token renewal and
 * password management operations (password reset/change) that reference
 * community_portal_users.password_hash and community_portal_users.email.
 *
 * @param props.connection
 * @param props.body Admin creation payload containing authentication and admin
 *   metadata.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/join
 * @accessor api.functional.auth.admin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Admin creation payload containing authentication and admin metadata. */
    body: ICommunityPortalAdmin.ICreate;
  };
  export type Body = ICommunityPortalAdmin.ICreate;
  export type Response = ICommunityPortalAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/join";
  export const random = (): ICommunityPortalAdmin.IAuthorized =>
    typia.random<ICommunityPortalAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate admin and return authorized tokens (relates to
 * community_portal_users and community_portal_admins).
 *
 * Purpose and overview: This endpoint authenticates an admin user by validating
 * credentials against community_portal_users.password_hash and, on success,
 * issues JWT-style access and refresh tokens returning
 * ICommunityPortalAdmin.IAuthorized. It also checks admin metadata in
 * community_portal_admins (community_portal_admins.is_active and
 * community_portal_admins.admin_level) to determine if the account is allowed
 * to receive admin-scoped tokens.
 *
 * Implementation details and field usage: The request body includes credentials
 * that map to community_portal_users.email (or username) and password; the
 * server validates the password against community_portal_users.password_hash.
 * If an admin record exists (community_portal_admins.user_id referencing the
 * user) the server validates community_portal_admins.is_active before issuing
 * admin-scoped tokens. The response contains token expiry metadata and may
 * reference community_portal_admins.admin_level to indicate privilege level.
 *
 * Role-specific integration and business context: This is the admin login flow
 * and must integrate with the platform's admin roster represented by
 * community_portal_admins. The login operation is expected to enforce any
 * additional platform checks such as account suspension
 * (community_portal_members.is_suspended) or user deletion status
 * (community_portal_users.deleted_at) before granting tokens.
 *
 * Security considerations: Do not expose community_portal_users.password_hash
 * or any internal audit timestamps in the response. Authentication failure
 * should be generic and must not reveal whether an email or username exists in
 * community_portal_users. Successful logins should be audited using
 * community_portal_admins.user_id and community_portal_users.id, recording the
 * login event timestamp (server-side) and respecting rate-limits and
 * multi-factor policies if applied.
 *
 * Related operations and workflow: After successful login, clients should use
 * POST /auth/admin/refresh to renew tokens. Password lifecycle operations
 * (reset and change) that update community_portal_users.password_hash are
 * available as separate endpoints. Administrative account activation state can
 * be observed via community_portal_admins.is_active and adjusted via platform
 * management tools.
 *
 * @param props.connection
 * @param props.body Admin login credentials (email/username + password).
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/login
 * @accessor api.functional.auth.admin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Admin login credentials (email/username + password). */
    body: ICommunityPortalAdmin.ILogin;
  };
  export type Body = ICommunityPortalAdmin.ILogin;
  export type Response = ICommunityPortalAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/login";
  export const random = (): ICommunityPortalAdmin.IAuthorized =>
    typia.random<ICommunityPortalAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh admin tokens using refresh token (relates to community_portal_users
 * and community_portal_admins).
 *
 * Purpose and overview: This endpoint accepts a refresh token and returns a
 * renewed access token (and optionally a rotated refresh token) for an admin
 * represented in community_portal_users and community_portal_admins. The
 * operation ensures the token owner still maps to an active admin entry
 * (community_portal_admins.is_active) before issuing admin-scoped credentials.
 *
 * Implementation details and field usage: The request body contains the refresh
 * token and the server resolves the token to a user id that corresponds to
 * community_portal_users.id. The server validates that the resolved user has an
 * associated community_portal_admins entry and that
 * community_portal_admins.is_active is true. The response issues a new
 * ICommunityPortalAdmin.IAuthorized payload with updated token lifetimes.
 *
 * Role-specific integration and business context: This refresh flow is
 * specifically scoped to admin tokens and must consider admin lifecycle
 * changes: if community_portal_admins.is_active has been toggled to false or
 * the admin record removed, the refresh must be denied. Similarly, if
 * community_portal_users.deleted_at is set (user removed), refresh must be
 * denied.
 *
 * Security considerations: Refresh tokens must be validated securely; refresh
 * rotation and revocation are recommended. The endpoint should log token
 * refresh events with references to community_portal_admins.user_id and
 * community_portal_admins.admin_level for auditability. Failure to validate
 * admin state must return an appropriate unauthorized response.
 *
 * Related operations and workflow: Clients obtain initial tokens via POST
 * /auth/admin/login or POST /auth/admin/join and then call this endpoint to
 * renew access. Password resets or admin activation/deactivation (changes to
 * community_portal_admins.is_active) impact refresh behavior and should be
 * checked prior to issuing tokens.
 *
 * @param props.connection
 * @param props.body Refresh request payload containing refresh token.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/refresh
 * @accessor api.functional.auth.admin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh request payload containing refresh token. */
    body: ICommunityPortalAdmin.IRefresh;
  };
  export type Body = ICommunityPortalAdmin.IRefresh;
  export type Response = ICommunityPortalAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/refresh";
  export const random = (): ICommunityPortalAdmin.IAuthorized =>
    typia.random<ICommunityPortalAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
