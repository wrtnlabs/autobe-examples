import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalSubscription } from "../../../../structures/ICommunityPortalSubscription";
import { IPageICommunityPortalSubscription } from "../../../../structures/IPageICommunityPortalSubscription";

/**
 * List subscriptions with filters, sorting, and pagination
 * (community_portal_subscriptions).
 *
 * Purpose and overview: Return a paginated, filterable list of community
 * subscriptions (Prisma model: community_portal_subscriptions). Intended
 * primarily for "My subscriptions" UI but supports admin-scoped queries with
 * appropriate authorization.
 *
 * Security and privacy:
 *
 * - The endpoint requires authentication. By default it returns subscriptions for
 *   the authenticated user only.
 * - If the request includes a userId filter that differs from the authenticated
 *   user's id, the server MUST return 403 Forbidden unless the caller has admin
 *   privileges.
 * - The operation must never leak other users' subscription lists to unauthorized
 *   callers.
 *
 * Filtering, sorting, and pagination:
 *
 * - Filters supported: userId (UUID), communityId (UUID), activeOnly (boolean to
 *   exclude soft-deleted rows).
 * - Sorting: created_at asc/desc.
 * - Pagination: limit (positive integer), offset (non-negative integer).
 * - Implementers may optimize the common case (authenticated user's
 *   subscriptions) using indexes on user_id and community_id.
 *
 * Validation and errors:
 *
 * - 400 Bad Request: invalid UUIDs, negative offset, non-positive limit
 * - 401 Unauthorized: unauthenticated request
 * - 403 Forbidden: requesting another user's subscriptions without admin
 *   privileges
 * - 500 Internal Server Error: unexpected failures
 *
 * Response behavior: Return a paginated container: { total: number, limit:
 * number, offset: number, data: [ { id, user_id, community_id, created_at } ]
 * }
 *
 * @param props.connection
 * @param props.body Search and pagination parameters for subscription listing
 *   (filters: userId, communityId, activeOnly; pagination: limit, offset; sort:
 *   created_at asc/desc)
 * @path /communityPortal/member/subscriptions
 * @accessor api.functional.communityPortal.member.subscriptions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search and pagination parameters for subscription listing (filters:
     * userId, communityId, activeOnly; pagination: limit, offset; sort:
     * created_at asc/desc)
     */
    body: ICommunityPortalSubscription.IRequest;
  };
  export type Body = ICommunityPortalSubscription.IRequest;
  export type Response = IPageICommunityPortalSubscription.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPortal/member/subscriptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPortal/member/subscriptions";
  export const random = (): IPageICommunityPortalSubscription.ISummary =>
    typia.random<IPageICommunityPortalSubscription.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a subscription by ID.
 *
 * Purpose and overview: Return a subscription entry from the
 * community_portal_subscriptions table by its UUID identifier. The response
 * includes the subscription's id, user_id, community_id, created_at,
 * updated_at, and deleted_at so the authenticated owner can determine active vs
 * revoked status.
 *
 * Security and permissions: Requires an authenticated member. The service MUST
 * verify the requesting member is the owner of the subscription (match on
 * user_id) before returning the resource to avoid exposing other users'
 * subscriptions. If not authorized, return 403 Forbidden or 404 per policy.
 *
 * Relationship to DB entities: Operates on the Prisma model
 * community_portal_subscriptions. The response DTO corresponds to
 * ICommunityPortalSubscription and reflects the model attributes.
 *
 * Validation and business rules: Path parameter subscriptionId must be a UUID.
 * If the subscription does not exist return 404 Not Found. If the subscription
 * exists but is soft-deleted, this endpoint returns the record including
 * deleted_at for the owner to allow audit; product policy may choose to hide
 * revoked subscriptions (in which case return 404) â€” be explicit in
 * implementation.
 *
 * @param props.connection
 * @param props.subscriptionId Unique identifier of the target subscription
 *   (UUID)
 * @path /communityPortal/member/subscriptions/:subscriptionId
 * @accessor api.functional.communityPortal.member.subscriptions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target subscription (UUID) */
    subscriptionId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPortalSubscription;

  export const METADATA = {
    method: "GET",
    path: "/communityPortal/member/subscriptions/:subscriptionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPortal/member/subscriptions/${encodeURIComponent(props.subscriptionId ?? "null")}`;
  export const random = (): ICommunityPortalSubscription =>
    typia.random<ICommunityPortalSubscription>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("subscriptionId")(() => typia.assert(props.subscriptionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Revoke (soft-delete) a subscription.
 *
 * Purpose and overview: Mark a subscription as revoked by updating its
 * deleted_at timestamp. This preserves the subscription record in the
 * community_portal_subscriptions table for auditing and potential recovery.
 *
 * Security and permissions: Requires an authenticated member. The service MUST
 * verify the requesting member is the owner of the subscription (user_id)
 * before revoking it. This endpoint is for self-service revocation.
 *
 * Behavior and business rules: Path parameter subscriptionId must be a UUID. If
 * the subscription is already soft-deleted (deleted_at non-null) the endpoint
 * should be idempotent and return 204 No Content. If the subscription is not
 * found, return 404 Not Found. On successful revoke, return 204 No Content.
 * IMPORTANT: because the model enforces @@unique([user_id, community_id]),
 * re-subscribe behavior must be defined: either reactivate the existing row
 * (clear deleted_at) or implement a partial unique index WHERE deleted_at IS
 * NULL to allow new inserts.
 *
 * Error handling: 400 for invalid UUID, 401 if unauthenticated, 403 if the
 * authenticated user is not the subscription owner, 404 if not found. This
 * operation returns no response body on success.
 *
 * @param props.connection
 * @param props.subscriptionId Unique identifier of the target subscription
 *   (UUID)
 * @path /communityPortal/member/subscriptions/:subscriptionId
 * @accessor api.functional.communityPortal.member.subscriptions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the target subscription (UUID) */
    subscriptionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPortal/member/subscriptions/:subscriptionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPortal/member/subscriptions/${encodeURIComponent(props.subscriptionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("subscriptionId")(() => typia.assert(props.subscriptionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
