import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalPost } from "../../../../structures/ICommunityPortalPost";
export * as comments from "./comments/index";
export * as votes from "./votes/index";
export * as reports from "./reports/index";

/**
 * Create a post in a community (community_portal_posts).
 *
 * Create a new post in a specified community. This endpoint persists a
 * community_portal_posts record and supports three post types (text, link,
 * image) as defined by the Prisma model.
 *
 * Only authenticated, verified members may create posts. The server MUST verify
 * the caller's identity and membership/verification state and set
 * author_user_id to the authenticated user's id. The payload MUST include
 * community_id (target community), post_type ("text" | "link" | "image"), and
 * title. Depending on post_type, include the appropriate content field: for
 * "text" include body; for "link" include link_url (valid http/https URL); for
 * "image" include image_url or use a media upload pipeline. The server MUST
 * sanitize and validate all inputs (title, body, link_url, image_url) and
 * enforce configured size/format limits for media.
 *
 * Business behavior: If the target community requires moderator pre-approval,
 * the server SHOULD create the post with status "pending" and notify
 * moderators. created_at and updated_at are recorded by the server. The client
 * MUST NOT provide deleted_at. On success the created post representation is
 * returned.
 *
 * @param props.connection
 * @param props.body Post creation payload. Required fields: community_id
 *   (uuid), post_type ('text'|'link'|'image'), title (string). Include body for
 *   text posts, link_url for link posts, or image_url for image posts.
 * @path /communityPortal/member/posts
 * @accessor api.functional.communityPortal.member.posts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Post creation payload. Required fields: community_id (uuid),
     * post_type ('text'|'link'|'image'), title (string). Include body for
     * text posts, link_url for link posts, or image_url for image posts.
     */
    body: ICommunityPortalPost.ICreate;
  };
  export type Body = ICommunityPortalPost.ICreate;
  export type Response = ICommunityPortalPost;

  export const METADATA = {
    method: "POST",
    path: "/communityPortal/member/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPortal/member/posts";
  export const random = (): ICommunityPortalPost =>
    typia.random<ICommunityPortalPost>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing post (community_portal_posts).
 *
 * Update fields of an existing post record. This operation permits editing
 * mutable fields such as title, body, link_url, image_url, and status for the
 * post identified by postId.
 *
 * Authentication and authorization: Caller must be authenticated and authorized
 * to update the specified post (commonly the original author or a permitted
 * moderator/role as defined by platform policy). The server MUST verify the
 * post exists and is not soft-deleted (deleted_at is null) before applying
 * updates. created_at MUST be preserved by the server; updated_at MUST be set
 * to the current timestamp on successful update.
 *
 * Validation: If post_type is changed, the server MUST validate presence of
 * appropriate content for the new type. Status transitions (for example,
 * 'pending'â†’'published' or marking 'removed') may trigger audit records,
 * notifications, or moderation actions. The server MUST return 404 if postId
 * does not exist or is deleted, 403 if caller is not authorized, 400 for
 * validation errors, and 409 for business-rule conflicts.
 *
 * @param props.connection
 * @param props.postId Target post's ID
 * @param props.body Post update payload. Include only fields to be changed
 *   (title, body, link_url, image_url, status). Do not include created_at or
 *   deleted_at.
 * @path /communityPortal/member/posts/:postId
 * @accessor api.functional.communityPortal.member.posts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target post's ID */
    postId: string & tags.Format<"uuid">;

    /**
     * Post update payload. Include only fields to be changed (title, body,
     * link_url, image_url, status). Do not include created_at or
     * deleted_at.
     */
    body: ICommunityPortalPost.IUpdate;
  };
  export type Body = ICommunityPortalPost.IUpdate;
  export type Response = ICommunityPortalPost;

  export const METADATA = {
    method: "PUT",
    path: "/communityPortal/member/posts/:postId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPortal/member/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): ICommunityPortalPost =>
    typia.random<ICommunityPortalPost>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a post (community_portal_posts) by ID.
 *
 * This endpoint marks a post as deleted by setting the
 * community_portal_posts.deleted_at timestamp. It operates on the
 * community_portal_posts model and preserves the post record for audit,
 * moderation, and historical integrity. The caller must be authenticated and
 * authorized: the author (owner) may delete their own post, and
 * community-scoped moderators or platform admins may delete posts within their
 * scope. The server implementation MUST enforce ownership checks and moderator
 * scope before setting deleted_at.
 *
 * Validation: Validate path parameter postId as a UUID. If the post does not
 * exist or deleted_at is already set, return 404. If the post's status or
 * business rules prevent deletion, return 409 Conflict. On success set
 * deleted_at to current UTC timestamp, persist audit entry (actor id, reason)
 * at application level, and return 204 No Content.
 *
 * Security: Do not expose password_hash or other secrets. Ensure authorization
 * check enforces owner-or-scope-moderator/admin policy. Log the action for
 * audit.
 *
 * @param props.connection
 * @param props.postId Target post's ID (community_portal_posts.id)
 * @path /communityPortal/member/posts/:postId
 * @accessor api.functional.communityPortal.member.posts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target post's ID (community_portal_posts.id) */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPortal/member/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPortal/member/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
