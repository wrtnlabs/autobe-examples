import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalCommunity } from "../../../../structures/ICommunityPortalCommunity";
export * as subscriptions from "./subscriptions/index";

/**
 * Create a new community (community_portal_communities) in the CommunityPortal
 * service.
 *
 * Purpose and overview: This operation allows an authenticated user to create a
 * new community record that corresponds directly to the Prisma model
 * community_portal_communities. The request accepts the community's
 * human-readable name, an optional canonical slug (server may derive from
 * name), optional description, and visibility flags. The server derives the
 * creator_user_id from the authenticated caller and ignores client-supplied
 * id/timestamps.
 *
 * Security and permissions: Only authenticated users (role: "member") may
 * create communities. The API expects a bearer token; server maps token to user
 * and sets creator_user_id. Inputs must be validated for reserved names and
 * allowed visibility values.
 *
 * Validation rules and expected behavior:
 *
 * - Required: name and either provided slug or server will canonicalize slug from
 *   name.
 * - Description is optional and may be null.
 * - Is_private is required boolean indicating invite-only communities.
 * - Visibility is required and validated by application logic.
 * - If slug already exists, return 409 Conflict.
 *
 * Error handling:
 *
 * - 400 Bad Request: missing required fields or invalid formats.
 * - 401 Unauthorized: unauthenticated request.
 * - 409 Conflict: slug already in use.
 * - 422 Unprocessable Entity: business validation errors.
 *
 * @param props.connection
 * @param props.body Community creation payload. Client-supplied fields: name
 *   (required), slug (optional), description (optional), is_private (required),
 *   visibility (required). Server-derived: creator_user_id, id, created_at,
 *   updated_at, deleted_at (excluded).
 * @path /communityPortal/member/communities
 * @accessor api.functional.communityPortal.member.communities.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Community creation payload. Client-supplied fields: name (required),
     * slug (optional), description (optional), is_private (required),
     * visibility (required). Server-derived: creator_user_id, id,
     * created_at, updated_at, deleted_at (excluded).
     */
    body: ICommunityPortalCommunity.ICreate;
  };
  export type Body = ICommunityPortalCommunity.ICreate;
  export type Response = ICommunityPortalCommunity;

  export const METADATA = {
    method: "POST",
    path: "/communityPortal/member/communities",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPortal/member/communities";
  export const random = (): ICommunityPortalCommunity =>
    typia.random<ICommunityPortalCommunity>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing community (community_portal_communities) by ID.
 *
 * Update an existing community (community_portal_communities) by its ID.
 *
 * Purpose and overview: This operation updates mutable attributes of a
 * community stored in the Prisma model. Typical updates include name, slug,
 * description, is_private, and visibility. The operation requires communityId
 * path parameter and authentication. Server must verify caller's rights
 * (creator, assigned moderator, or admin) before applying changes.
 * Server-managed fields (created_at, deleted_at) cannot be modified via this
 * API.
 *
 * Security and permissions: Authenticated users (role: "member") may call this
 * endpoint, but the server MUST enforce that only the community creator, an
 * active moderator assigned to the community, or an admin may perform the
 * update. Requests from other members must return 403 Forbidden.
 *
 * Validation and behavior:
 *
 * - Path parameter communityId must be a valid UUID matching an existing
 *   non-deleted community.
 * - Request body properties are optional and only provided fields are applied.
 * - If slug is provided and changed, validate uniqueness and allowed characters;
 *   return 409 on conflict.
 * - Server must not allow updates to created_at or deleted_at via this endpoint.
 *
 * Errors:
 *
 * - 400 Bad Request: invalid input.
 * - 401 Unauthorized: unauthenticated request.
 * - 403 Forbidden: caller lacks owner/moderator/admin rights.
 * - 404 Not Found: communityId does not exist or is soft-deleted.
 * - 409 Conflict: slug already in use.
 *
 * @param props.connection
 * @param props.communityId Unique identifier (UUID) of the target community
 * @param props.body Community update payload (partial) - only provided fields
 *   will be updated. Allowed client-updatable fields: name, slug, description,
 *   is_private, visibility.
 * @path /communityPortal/member/communities/:communityId
 * @accessor api.functional.communityPortal.member.communities.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the target community */
    communityId: string & tags.Format<"uuid">;

    /**
     * Community update payload (partial) - only provided fields will be
     * updated. Allowed client-updatable fields: name, slug, description,
     * is_private, visibility.
     */
    body: ICommunityPortalCommunity.IUpdate;
  };
  export type Body = ICommunityPortalCommunity.IUpdate;
  export type Response = ICommunityPortalCommunity;

  export const METADATA = {
    method: "PUT",
    path: "/communityPortal/member/communities/:communityId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPortal/member/communities/${encodeURIComponent(props.communityId ?? "null")}`;
  export const random = (): ICommunityPortalCommunity =>
    typia.random<ICommunityPortalCommunity>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a community by setting deleted_at (community_portal_communities).
 *
 * Purpose and overview: This endpoint performs a controlled soft-delete of a
 * Community (Prisma model: community_portal_communities) by setting its
 * deleted_at timestamp. The intent is to hide the community from public
 * listings while preserving rows and related records (posts, subscriptions,
 * reports, moderators) for audit and appeal.
 *
 * Security and permissions: Only authorized actors may perform this action. The
 * service MUST enforce that the caller is either:
 *
 * - A platform-level admin (operation-level authorization), OR
 * - The community.creator_user_id (ownership check), OR
 * - An active assigned moderator for the community with removal privileges
 *   (checked via community_portal_moderators where is_active==true). If the
 *   caller is not authorized, return 403 Forbidden. If the community does not
 *   exist or deleted_at is already set, return 404 Not Found.
 *
 * Validation and business rules:
 *
 * - Validate communityId is a UUID and that the community exists with deleted_at
 *   == null before making changes.
 * - The operation MUST be idempotent: repeated requests do not produce duplicate
 *   side effects.
 * - The DB mutation sets deleted_at to current UTC timestamp; child records are
 *   preserved.
 * - Audit logging and downstream notifications are implementation-level
 *   responsibilities and must not be exposed as writeable API parameters.
 *
 * Errors and expected responses:
 *
 * - 400 Bad Request for malformed UUID
 * - 401 Unauthorized for unauthenticated calls
 * - 403 Forbidden for unauthorized callers
 * - 404 Not Found if community not found or already deleted
 * - 500 Internal Server Error for unexpected failures
 *
 * @param props.connection
 * @param props.communityId Target community's unique identifier (UUID)
 * @path /communityPortal/member/communities/:communityId
 * @accessor api.functional.communityPortal.member.communities.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target community's unique identifier (UUID) */
    communityId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPortal/member/communities/:communityId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPortal/member/communities/${encodeURIComponent(props.communityId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
