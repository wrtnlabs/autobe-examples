import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalVote } from "../../../../../structures/ICommunityPortalVote";

/**
 * Cast an upvote or downvote on a post (create community_portal_votes record).
 *
 * Cast a vote on a post and create a community_portal_votes record.
 *
 * Purpose and overview: This operation allows an authenticated member to cast a
 * vote (+1 for upvote, -1 for downvote) on a post identified by {postId}. It
 * records a community_portal_votes entry linked to post_id and the
 * authenticated user. The created vote record contains only the fields defined
 * on the vote model (id, user_id, post_id, comment_id (null), value,
 * created_at, updated_at, deleted_at).
 *
 * Security and permissions: Only authenticated, active members may call this
 * endpoint. The server MUST verify the caller's membership status using
 * community_portal_members (is_email_verified and is_suspended) and MUST NOT
 * accept client-supplied user_id values. Ownership is derived from the
 * authentication context.
 *
 * Relationship to DB and validation rules:
 *
 * - Maps directly to the community_portal_votes model.
 * - Enforce XOR target semantics: set post_id and leave comment_id null.
 * - Validate that {postId} exists and is visible to the caller (return 404 or 403
 *   as appropriate).
 * - Validate request value is exactly +1 or -1; return 400 for invalid values.
 * - Enforce one active vote per (user,post) via DB constraints and/or application
 *   logic. Document whether POST returns 409 on duplicates or performs upsert
 *   semantics.
 * - Respect soft-delete semantics: treat soft-deleted vote records as not-found
 *   for update flows unless policy allows reactivation.
 *
 * Expected responses and errors:
 *
 * - 201 Created: returns created vote resource (ICommunityPortalVote) with fields
 *   present on the vote model.
 * - 400 Bad Request: invalid payload or vote value.
 * - 401 Unauthorized: unauthenticated caller.
 * - 403 Forbidden: caller not permitted to vote (suspended/unverified or
 *   community-restricted).
 * - 404 Not Found: post not found or not visible.
 * - 409 Conflict: duplicate vote exists and server policy rejects duplicates on
 *   create.
 *
 * Implementation notes: Keep response limited to vote-model fields. If updated
 * post aggregates are required in the response, return a documented wrapper
 * type that includes a post summary DTO (e.g., ICommunityPortalPostSummary) and
 * declare that explicitly in the responseBody typeName.
 *
 * @param props.connection
 * @param props.postId Target post's ID (community_portal_posts.id)
 * @param props.body Vote creation payload. Body must provide the vote value (+1
 *   or -1). The server will associate the authenticated user as voter and set
 *   comment_id to null for post votes.
 * @path /communityPortal/member/posts/:postId/votes
 * @accessor api.functional.communityPortal.member.posts.votes.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Target post's ID (community_portal_posts.id) */
    postId: string & tags.Format<"uuid">;

    /**
     * Vote creation payload. Body must provide the vote value (+1 or -1).
     * The server will associate the authenticated user as voter and set
     * comment_id to null for post votes.
     */
    body: ICommunityPortalVote.ICreate;
  };
  export type Body = ICommunityPortalVote.ICreate;
  export type Response = ICommunityPortalVote;

  export const METADATA = {
    method: "POST",
    path: "/communityPortal/member/posts/:postId/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPortal/member/posts/${encodeURIComponent(props.postId ?? "null")}/votes`;
  export const random = (): ICommunityPortalVote =>
    typia.random<ICommunityPortalVote>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing vote on a post (modify community_portal_votes record).
 *
 * Modify an existing vote record for a post.
 *
 * Purpose and overview: Allows the authenticated owner of a vote to change its
 * value (e.g., +1 -> -1) for the vote identified by {voteId} and scoped to post
 * {postId}. The endpoint is scoped to post-targeted votes; comment-targeted
 * votes must use a comment-specific endpoint.
 *
 * Security and permissions: Only the vote owner (authenticated user whose id ==
 * vote.user_id) or an authorized system account may update the vote. The server
 * MUST verify ownership and membership status before applying changes.
 * Moderator/admin overrides are out of scope for this endpoint.
 *
 * Validation and business logic:
 *
 * - Validate path parameters postId and voteId are valid UUIDs.
 * - Confirm vote exists and its post_id matches postId; otherwise return 400 or
 *   404.
 * - Ensure vote is not soft-deleted (deleted_at is null); if soft-deleted treat
 *   as 404.
 * - Allowed updates should be limited (value); validate new value is exactly +1
 *   or -1.
 * - Define canonical removal flow: prefer DELETE
 *   /communityPortal/member/posts/{postId}/votes/{voteId} for vote removal
 *   (documented separately). If platform uses a sentinel value (e.g., 0) for
 *   removal, document that explicitly.
 * - Consider optimistic concurrency (ETag/If-Match) to avoid lost updates; return
 *   409 on conflict.
 *
 * Expected responses and errors:
 *
 * - 200 OK: returns updated vote resource (ICommunityPortalVote).
 * - 400 Bad Request: invalid payload or vote-post mismatch.
 * - 401 Unauthorized: unauthenticated caller.
 * - 403 Forbidden: caller not owner or not permitted.
 * - 404 Not Found: vote or post not found, or vote soft-deleted.
 * - 409 Conflict: concurrent modification detected (optional concurrency
 *   control).
 *
 * Implementation notes: Keep returned fields consistent with the vote model.
 * Use DELETE for removal flows and document the platform's canonical behavior
 * for removal and re-voting.
 *
 * @param props.connection
 * @param props.postId Target post's ID (community_portal_posts.id)
 * @param props.voteId Vote record ID to modify (community_portal_votes.id)
 * @param props.body Vote update payload. Typically includes the new vote value
 *   (e.g., +1 or -1). The server will enforce ownership and validate the
 *   value.
 * @path /communityPortal/member/posts/:postId/votes/:voteId
 * @accessor api.functional.communityPortal.member.posts.votes.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target post's ID (community_portal_posts.id) */
    postId: string & tags.Format<"uuid">;

    /** Vote record ID to modify (community_portal_votes.id) */
    voteId: string & tags.Format<"uuid">;

    /**
     * Vote update payload. Typically includes the new vote value (e.g., +1
     * or -1). The server will enforce ownership and validate the value.
     */
    body: ICommunityPortalVote.IUpdate;
  };
  export type Body = ICommunityPortalVote.IUpdate;
  export type Response = ICommunityPortalVote;

  export const METADATA = {
    method: "PUT",
    path: "/communityPortal/member/posts/:postId/votes/:voteId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPortal/member/posts/${encodeURIComponent(props.postId ?? "null")}/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): ICommunityPortalVote =>
    typia.random<ICommunityPortalVote>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("voteId")(() => typia.assert(props.voteId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a vote on a post.
 *
 * Remove (soft-delete) a vote on a post.
 *
 * Purpose and overview: This endpoint allows an authenticated member to remove
 * their previously cast vote on a post identified by {postId}. The specific
 * vote record to remove is identified by {voteId}. The backend MUST verify the
 * vote exists, is active (deleted_at is null), that it is associated with the
 * given post_id, and that the authenticated requester is authorized to remove
 * it (typically the vote owner). On success the service marks deleted_at on the
 * vote record and returns 204 No Content.
 *
 * Security and permissions: Only authenticated members may call this endpoint.
 * The server MUST verify the requester owns the vote (vote.user_id ==
 * authenticated user) or has explicit elevated rights per platform policy. If
 * the requester lacks permission, return 403 Forbidden.
 *
 * Relationship to DB entities and business rules: This operation updates the
 * community_portal_votes record's deleted_at field to preserve auditability.
 * Downstream effects include updating aggregates (post score, author karma).
 * The backend should emit events or perform aggregate reconciliation so system
 * state remains consistent.
 *
 * Validation and error responses:
 *
 * - 401 Unauthorized: missing or invalid authentication credentials.
 * - 403 Forbidden: authenticated user is not the owner of the vote and lacks
 *   elevated rights.
 * - 404 Not Found: post or vote not found or already soft-deleted.
 * - 409 Conflict: concurrent modification prevented deletion.
 *
 * @param props.connection
 * @param props.postId UUID of the post that the vote targets
 * @param props.voteId UUID of the vote to remove
 * @path /communityPortal/member/posts/:postId/votes/:voteId
 * @accessor api.functional.communityPortal.member.posts.votes.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the post that the vote targets */
    postId: string & tags.Format<"uuid">;

    /** UUID of the vote to remove */
    voteId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPortal/member/posts/:postId/votes/:voteId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPortal/member/posts/${encodeURIComponent(props.postId ?? "null")}/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("voteId")(() => typia.assert(props.voteId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
