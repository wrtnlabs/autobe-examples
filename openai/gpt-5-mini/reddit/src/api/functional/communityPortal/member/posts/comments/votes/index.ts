import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalVote } from "../../../../../../structures/ICommunityPortalVote";

/**
 * Create a vote on a comment within a post.
 *
 * Purpose and overview: This endpoint enables an authenticated member to cast a
 * vote (+1 or -1) on a comment identified by {commentId} within the post
 * identified by {postId}. The API persists a community_portal_votes record with
 * comment_id set (post_id must be null for comment-targeted votes), stores the
 * integer vote value, and returns the authoritative vote representation. The
 * backend MUST validate that the post exists and is active, the comment exists
 * and belongs to that post, and the requester is eligible to vote (e.g.,
 * verified and not suspended).
 *
 * Security and permissions: Only authenticated members may call this endpoint.
 * The server MUST derive the voter identity from the authenticated session and
 * must ignore any client-supplied user_id to prevent tampering. The backend
 * SHOULD verify membership status (community_portal_members.is_email_verified
 * and is_suspended) prior to creating the vote.
 *
 * Relationship to DB entities and business rules: This operation maps to the
 * community_portal_votes model in the Prisma schema. Business rules to
 * enforce:
 *
 * - A vote must target exactly one entity (post OR comment). For this endpoint,
 *   comment_id is populated and post_id must be null.
 * - Accept only integer vote values +1 or -1.
 * - Enforce one active vote per (user, comment) pair; the backend SHOULD perform
 *   an upsert/update existing vote behavior unless policy dictates otherwise.
 * - Persist created_at and updated_at timestamps and support soft-delete via
 *   deleted_at on the vote record.
 *
 * Validation and error responses:
 *
 * - 400 Bad Request: invalid vote value, mismatched post/comment relation, or
 *   malformed UUIDs.
 * - 401 Unauthorized: missing or invalid authentication credentials, or member
 *   not verified/suspended.
 * - 404 Not Found: post or comment not found or soft-deleted.
 * - 409 Conflict: duplicate vote attempts if backend policy rejects duplicates.
 *
 * @param props.connection
 * @param props.postId UUID of the parent post that contains the comment
 * @param props.commentId UUID of the comment to vote on
 * @param props.body Vote creation payload. The authenticated user is the voter;
 *   request body only needs the vote value (+1 or -1).
 * @path /communityPortal/member/posts/:postId/comments/:commentId/votes
 * @accessor api.functional.communityPortal.member.posts.comments.votes.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** UUID of the parent post that contains the comment */
    postId: string & tags.Format<"uuid">;

    /** UUID of the comment to vote on */
    commentId: string & tags.Format<"uuid">;

    /**
     * Vote creation payload. The authenticated user is the voter; request
     * body only needs the vote value (+1 or -1).
     */
    body: ICommunityPortalVote.ICreate;
  };
  export type Body = ICommunityPortalVote.ICreate;
  export type Response = ICommunityPortalVote;

  export const METADATA = {
    method: "POST",
    path: "/communityPortal/member/posts/:postId/comments/:commentId/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPortal/member/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/votes`;
  export const random = (): ICommunityPortalVote =>
    typia.random<ICommunityPortalVote>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a user's vote for a post or comment.
 *
 * Update a user's vote record for a specific post or comment.
 *
 * Purpose and overview: This endpoint updates the vote value and other
 * permitted mutable attributes of a vote record in the community_portal_votes
 * model. A vote targets either a post or a comment (XOR). The endpoint verifies
 * that the vote exists and is active, that the path parameters correspond to
 * the vote's target, and that the caller is authorized (the vote owner). The
 * response returns the updated vote, including id, user reference, target
 * reference, value, created_at, and updated_at.
 *
 * Security and authorization: Only the authenticated vote owner (member) may
 * update their vote. The service must verify the caller's identity matches
 * vote.user_id and enforce business gating (e.g., suspended members may be
 * prevented from changing votes). All modifications should update updated_at
 * and be auditable.
 *
 * Relationship to DB entity: Maps to the Prisma model community_portal_votes
 * (fields: id, user_id, post_id, comment_id, value, created_at, updated_at,
 * deleted_at). Do not assume additional fields beyond the model.
 *
 * Validation and business rules:
 *
 * - The vote record must exist and be active (deleted_at is null).
 * - The path parameters postId and commentId must match the vote's target
 *   reference (post_id or comment_id) depending on which target the vote has.
 * - The request must not change the vote's target or user_id; only 'value' and
 *   permitted metadata may be updated.
 *
 * Error handling: Return 400 for malformed input, 401 if unauthenticated, 403
 * if the caller is not the vote owner, 404 if the vote/post/comment is not
 * found or inactive, and 409 for conflicting state (e.g., attempting to change
 * the vote target).
 *
 * @param props.connection
 * @param props.postId Identifier of the parent post (community_portal_posts.id)
 *   - must match the vote's post_id if the vote targets a post
 * @param props.commentId Identifier of the parent comment
 *   (community_portal_comments.id) - must match the vote's comment_id if the
 *   vote targets a comment
 * @param props.voteId Identifier of the vote record to update
 *   (community_portal_votes.id)
 * @param props.body Updatable fields for a vote record (e.g., value). Must not
 *   include post_id, comment_id, or user_id.
 * @path /communityPortal/member/posts/:postId/comments/:commentId/votes/:voteId
 * @accessor api.functional.communityPortal.member.posts.comments.votes.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Identifier of the parent post (community_portal_posts.id) - must
     * match the vote's post_id if the vote targets a post
     */
    postId: string & tags.Format<"uuid">;

    /**
     * Identifier of the parent comment (community_portal_comments.id) -
     * must match the vote's comment_id if the vote targets a comment
     */
    commentId: string & tags.Format<"uuid">;

    /** Identifier of the vote record to update (community_portal_votes.id) */
    voteId: string & tags.Format<"uuid">;

    /**
     * Updatable fields for a vote record (e.g., value). Must not include
     * post_id, comment_id, or user_id.
     */
    body: ICommunityPortalVote.IUpdate;
  };
  export type Body = ICommunityPortalVote.IUpdate;
  export type Response = ICommunityPortalVote;

  export const METADATA = {
    method: "PUT",
    path: "/communityPortal/member/posts/:postId/comments/:commentId/votes/:voteId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPortal/member/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): ICommunityPortalVote =>
    typia.random<ICommunityPortalVote>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("voteId")(() => typia.assert(props.voteId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (soft-delete) a user's vote for a post or comment.
 *
 * Delete (soft-delete) a user's vote for a specific post or comment.
 *
 * Purpose and overview: This endpoint marks a vote record as deleted by setting
 * deleted_at on the community_portal_votes record. The vote remains in storage
 * for audit and reconciliation but is no longer treated as active for ranking
 * and aggregates. The operation must verify the vote exists, is active
 * (deleted_at is null), and that the caller is authorized to delete it (the
 * vote owner).
 *
 * Security and authorization: Only the authenticated vote owner (member) may
 * delete their vote. The service must verify caller identity matches
 * vote.user_id and enforce any additional business gating.
 *
 * Relationship to DB entity: Acts on the community_portal_votes model (id,
 * user_id, post_id, comment_id, value, created_at, updated_at, deleted_at). Use
 * soft-delete semantics as deleted_at exists.
 *
 * Validation and business rules:
 *
 * - Confirm the vote exists and is active.
 * - Ensure postId/commentId path parameters match the vote's target references.
 * - If the vote is already deleted, return 409 Conflict or 200 if idempotent
 *   deletion is chosen by policy.
 *
 * Error handling: Return 401 if unauthenticated, 403 if the caller is not the
 * vote owner, 404 if the vote/post/comment is not found, and 409 if the vote is
 * already deleted (unless idempotent semantics are used).
 *
 * @param props.connection
 * @param props.postId Identifier of the parent post (community_portal_posts.id)
 *   - must match the vote's post_id if the vote targets a post
 * @param props.commentId Identifier of the parent comment
 *   (community_portal_comments.id) - must match the vote's comment_id if the
 *   vote targets a comment
 * @param props.voteId Identifier of the vote record to delete
 *   (community_portal_votes.id)
 * @path /communityPortal/member/posts/:postId/comments/:commentId/votes/:voteId
 * @accessor api.functional.communityPortal.member.posts.comments.votes.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Identifier of the parent post (community_portal_posts.id) - must
     * match the vote's post_id if the vote targets a post
     */
    postId: string & tags.Format<"uuid">;

    /**
     * Identifier of the parent comment (community_portal_comments.id) -
     * must match the vote's comment_id if the vote targets a comment
     */
    commentId: string & tags.Format<"uuid">;

    /** Identifier of the vote record to delete (community_portal_votes.id) */
    voteId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPortal/member/posts/:postId/comments/:commentId/votes/:voteId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPortal/member/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("voteId")(() => typia.assert(props.voteId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
