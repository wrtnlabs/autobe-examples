import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalComment } from "../../../../../structures/ICommunityPortalComment";
export * as votes from "./votes/index";

/**
 * Create a new comment for a post (community_portal_comments).
 *
 * Purpose and overview: Create a comment attached to a post. The request
 * creates a new row in the community_portal_comments model. Input fields
 * allowed from clients are: parent_comment_id (optional) and body (required).
 * The server MUST populate author_user_id from the authenticated session and
 * set created_at/updated_at timestamps. deleted_at must be null on create.
 *
 * Security considerations and permissions: Only authenticated, verified members
 * may create comments. The endpoint requires membership/visibility checks for
 * the target post's community (private communities enforce access). Clients
 * MUST NOT supply author_user_id. If author_user_id is present in the payload,
 * the server SHOULD reject the request with 400 Bad Request and an explanatory
 * message to prevent spoofing.
 *
 * Validation and business logic:
 *
 * - Validate postId is a valid UUID and references an existing post; if not
 *   found, return 404 Not Found.
 * - Require a non-empty body string; if missing or empty, return 400 Bad Request.
 * - If parent_comment_id is provided, validate it is a UUID and that the parent
 *   comment exists and its post_id matches postId; otherwise return 400 Bad
 *   Request.
 * - Enforce maximum comment length and nesting depth per platform policy; if
 *   violated, return 400 Bad Request with an explanatory message.
 *
 * Responses and error handling:
 *
 * - 201 Created: returns the created comment payload. Recommend including a
 *   Location header pointing to GET
 *   /communityPortal/posts/{postId}/comments/{commentId}.
 * - 400 Bad Request: validation errors (missing body, invalid parent_comment_id,
 *   nesting depth exceeded, body too long), or if author_user_id is supplied by
 *   client.
 * - 401 Unauthorized: when authentication is missing or invalid.
 * - 403 Forbidden: user lacks access to the target community/post (private
 *   community).
 * - 404 Not Found: referenced postId or parent_comment_id does not exist.
 *
 * @param props.connection
 * @param props.postId Target post's unique identifier (UUID) under which the
 *   comment will be created.
 * @param props.body Comment creation payload. Allowed client fields:
 *   parent_comment_id (optional, UUID) and body (string, required). Clients
 *   MUST NOT supply author_user_id.
 * @path /communityPortal/member/posts/:postId/comments
 * @accessor api.functional.communityPortal.member.posts.comments.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Target post's unique identifier (UUID) under which the comment will
     * be created.
     */
    postId: string & tags.Format<"uuid">;

    /**
     * Comment creation payload. Allowed client fields: parent_comment_id
     * (optional, UUID) and body (string, required). Clients MUST NOT supply
     * author_user_id.
     */
    body: ICommunityPortalComment.ICreate;
  };
  export type Body = ICommunityPortalComment.ICreate;
  export type Response = ICommunityPortalComment;

  export const METADATA = {
    method: "POST",
    path: "/communityPortal/member/posts/:postId/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPortal/member/posts/${encodeURIComponent(props.postId ?? "null")}/comments`;
  export const random = (): ICommunityPortalComment =>
    typia.random<ICommunityPortalComment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a comment on a post (community_portal_comments).
 *
 * Update the text body of an existing comment attached to a specific post.
 *
 * Purpose and overview: This endpoint updates a single comment record in the
 * community_portal_comments table. The path parameters identify the post
 * (postId) and the comment (commentId). The request body supplies fields to
 * update (primarily the comment body). The operation validates that the comment
 * exists and belongs to the specified post, that the comment is not deleted
 * (deleted_at null), and that the caller is authorized to edit (author OR
 * community moderator OR admin). The updated comment, including updated_at, is
 * returned.
 *
 * Security and permissions: Requires an authenticated member (authorizationRole
 * = "member"). Implementation MUST verify that the caller is the comment's
 * author or an authorized moderator/admin. If the caller is unauthenticated,
 * return 401. If authenticated but not authorized, return 403. All successful
 * edits MUST be recorded in audit logs (actorId, action, targetId, timestamp).
 *
 * Relationship to DB entities: Directly tied to the community_portal_comments
 * Prisma model. Use postId to validate comment.post_id relation before
 * performing updates. This operation updates only mutable comment fields (body
 * and updated_at) and must not change post_id, parent_comment_id, created_at,
 * or deleted_at in this edit flow.
 *
 * Validation and business logic:
 *
 * - Request MUST include a non-empty body string for the comment text.
 * - Body must respect configured length limits (example default: max 10,000
 *   characters).
 * - If comment.deleted_at is set, return 404 Not Found.
 * - If postId does not match comment.post_id, return 404 Not Found.
 * - Edits should be idempotent: applying the same update repeatedly yields the
 *   same stored comment state.
 *
 * Errors and edge cases:
 *
 * - 400 Bad Request: missing/empty body or body exceeding allowed length.
 * - 401 Unauthorized: request unauthenticated.
 * - 403 Forbidden: authenticated but not authorized to edit.
 * - 404 Not Found: post or comment not found, or comment already deleted.
 *
 * @param props.connection
 * @param props.postId Target post identifier (community_portal_posts.id).
 * @param props.commentId Target comment identifier
 *   (community_portal_comments.id).
 * @param props.body Fields to update on the comment. Expected shape: { body:
 *   string } (ICommunityPortalComment.IUpdate).
 * @path /communityPortal/member/posts/:postId/comments/:commentId
 * @accessor api.functional.communityPortal.member.posts.comments.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target post identifier (community_portal_posts.id). */
    postId: string & tags.Format<"uuid">;

    /** Target comment identifier (community_portal_comments.id). */
    commentId: string & tags.Format<"uuid">;

    /**
     * Fields to update on the comment. Expected shape: { body: string }
     * (ICommunityPortalComment.IUpdate).
     */
    body: ICommunityPortalComment.IUpdate;
  };
  export type Body = ICommunityPortalComment.IUpdate;
  export type Response = ICommunityPortalComment;

  export const METADATA = {
    method: "PUT",
    path: "/communityPortal/member/posts/:postId/comments/:commentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPortal/member/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): ICommunityPortalComment =>
    typia.random<ICommunityPortalComment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (soft-delete) a comment on a post (community_portal_comments).
 *
 * Soft-delete a comment so it is no longer visible in public comment listings
 * while preserving the record for audit.
 *
 * Purpose and overview: This endpoint marks a comment as deleted by setting the
 * deleted_at timestamp on the community_portal_comments row identified by
 * postId and commentId. It ensures the comment belongs to the specified post
 * and that the caller is authorized to delete it (author OR community moderator
 * OR admin). Because the underlying model includes deleted_at, a soft-delete
 * approach is used to retain audit and moderation trails.
 *
 * Security and permissions: Requires an authenticated member (authorizationRole
 * = "member"). Implementation MUST verify ownership or moderator/admin
 * privilege. If unauthenticated return 401. If authenticated but not authorized
 * return 403. If the comment is already deleted (deleted_at non-null), return
 * 404 Not Found.
 *
 * Relationship to DB entities: Operates on community_portal_comments and must
 * not cascade-delete related entities. Votes, reports, and other related
 * records should remain for auditing. Implementation may trigger asynchronous
 * updates (e.g., decrement aggregated comment counts) but such side effects are
 * out of scope for this API contract.
 *
 * Validation and business logic:
 *
 * - Verify the comment exists and comment.post_id equals provided postId.
 * - If comment.deleted_at is not null, return 404 Not Found.
 * - Apply a soft-delete by setting deleted_at to server current timestamp.
 *
 * Errors and edge cases:
 *
 * - 401 Unauthorized: request unauthenticated.
 * - 403 Forbidden: authenticated but not authorized to delete.
 * - 404 Not Found: post or comment missing or comment already deleted.
 * - 500 Internal Server Error: unexpected server-side failure while applying
 *   deleted_at.
 *
 * Response: Prefer 204 No Content on successful soft-delete to indicate no
 * response body is returned.
 *
 * @param props.connection
 * @param props.postId Target post identifier (community_portal_posts.id).
 * @param props.commentId Target comment identifier
 *   (community_portal_comments.id).
 * @path /communityPortal/member/posts/:postId/comments/:commentId
 * @accessor api.functional.communityPortal.member.posts.comments.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target post identifier (community_portal_posts.id). */
    postId: string & tags.Format<"uuid">;

    /** Target comment identifier (community_portal_comments.id). */
    commentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPortal/member/posts/:postId/comments/:commentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPortal/member/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
