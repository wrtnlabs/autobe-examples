import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalVote } from "../../../../structures/ICommunityPortalVote";
import { IPageICommunityPortalVote } from "../../../../structures/IPageICommunityPortalVote";

/**
 * Search and retrieve a paginated list of vote events (community_portal_votes).
 *
 * Retrieve a filtered, sorted, and paginated list of vote events from the
 * community_portal_votes table.
 *
 * Purpose and overview: This operation enables clients to search vote events by
 * voter (user_id), by target (post_id or comment_id), by date ranges, and to
 * page and sort results. Typical use cases include a user reviewing their own
 * vote history on their profile and authorized audit/analytics views. Returned
 * items include id, userId, postId (nullable), commentId (nullable), value (+1
 * or -1), createdAt, and updatedAt.
 *
 * Security considerations and permissions: This endpoint requires an
 * authenticated member context. The server MUST ensure that user-scoped queries
 * (for example filtering by userId) return only records the caller is permitted
 * to view (commonly the caller's own votes). Aggregated or cross-user queries
 * require additional authorization checks implemented server-side. The
 * operation excludes soft-deleted votes by default (deleted_at not null) unless
 * includeDeleted=true is explicitly requested.
 *
 * Relationship to underlying DB entity: Maps directly to the
 * community_portal_votes Prisma model and uses the model fields and semantics
 * described in the schema. The API enforces XOR semantics at request validation
 * time by rejecting requests that provide both postId and commentId filters
 * simultaneously. Pagination and sorting operate over created_at and value
 * fields. Error handling: malformed UUIDs/date formats return 400;
 * unauthenticated calls return 401; attempts to query other users' votes
 * without authorization return 403.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for votes
 *   listing. Filters: userId (uuid), postId (uuid), commentId (uuid), value
 *   (+1/-1), date range (createdFrom, createdTo), sort (createdAt|value),
 *   limit, offset. Note: provide either postId or commentId, not both (XOR).
 * @path /communityPortal/member/votes
 * @accessor api.functional.communityPortal.member.votes.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria and pagination parameters for votes listing. Filters:
     * userId (uuid), postId (uuid), commentId (uuid), value (+1/-1), date
     * range (createdFrom, createdTo), sort (createdAt|value), limit,
     * offset. Note: provide either postId or commentId, not both (XOR).
     */
    body: ICommunityPortalVote.IRequest;
  };
  export type Body = ICommunityPortalVote.IRequest;
  export type Response = IPageICommunityPortalVote.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPortal/member/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPortal/member/votes";
  export const random = (): IPageICommunityPortalVote.ISummary =>
    typia.random<IPageICommunityPortalVote.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
