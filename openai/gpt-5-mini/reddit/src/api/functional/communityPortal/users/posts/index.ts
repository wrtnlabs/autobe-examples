import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalPost } from "../../../../structures/ICommunityPortalPost";
import { IPageICommunityPortalPost } from "../../../../structures/IPageICommunityPortalPost";

/**
 * Search and retrieve a paginated list of posts authored by a given user
 * (profile posts).
 *
 * Purpose and overview: Retrieve a filtered, sorted, and paginated list of
 * posts created by the specified user. This operation is intended for user
 * profile pages and for building user-centric feeds that show a user's public
 * contributions. It operates on the community_portal_posts table as defined in
 * the Prisma schema.
 *
 * Security considerations and user permissions: This is a read operation and is
 * public by default for published content. Visibility of specific posts is
 * subject to the post.status and community visibility rules. By default, posts
 * with deleted_at set (soft-deleted) are excluded. If includeDeleted is
 * requested, the implementation MUST validate the requesting user's
 * permissions: only community moderators and admins shall be permitted to view
 * soft-deleted records; unauthorized callers must receive 403 Forbidden.
 *
 * Relationship to underlying database entities: This operation maps directly to
 * the community_portal_posts model. Relevant columns include: id, community_id,
 * author_user_id, post_type, title, body, link_url, image_url, status,
 * created_at, updated_at, deleted_at. The operation may join or reference
 * community metadata where needed for display (e.g., community.slug/name) but
 * must not assume additional columns beyond those defined in the Prisma model.
 *
 * Validation rules and business logic:
 *
 * - UserId path parameter must be a UUID corresponding to
 *   community_portal_users.id.
 * - Request body may include pagination (limit, offset), sort mode
 *   (hot|new|top|controversial), post_type filter (text|link|image), status
 *   filter (published|pending|removed), and includeDeleted boolean. By default
 *   (includeDeleted=false) records where deleted_at IS NOT NULL MUST be
 *   omitted.
 * - If includeDeleted=true, the server MUST check caller authorization and only
 *   return deleted records to authorized roles (moderator/admin). Sorting modes
 *   "hot" and "controversial" are accepted as parameters but their algorithmic
 *   definitions are implementation details.
 *
 * Related API operations:
 *
 * - GET /communities/{communityId}/posts (list posts by community)
 * - GET /posts/{postId} (retrieve single post detail)
 *
 * Expected behavior and error handling:
 *
 * - Returns a paginated result set with post summaries. If userId does not exist,
 *   return 404 Not Found. If request validation fails (invalid pagination or
 *   filter values), return 400 Bad Request with field-level errors. If
 *   includeDeleted is true and the caller lacks permission to view deleted
 *   records, return 403 Forbidden.
 *
 * @param props.connection
 * @param props.userId Unique identifier (UUID) of the target user whose posts
 *   are being requested
 * @param props.body Search, filter, sort and pagination parameters for
 *   retrieving a user's posts
 * @path /communityPortal/users/:userId/posts
 * @accessor api.functional.communityPortal.users.posts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier (UUID) of the target user whose posts are being
     * requested
     */
    userId: string & tags.Format<"uuid">;

    /**
     * Search, filter, sort and pagination parameters for retrieving a
     * user's posts
     */
    body: ICommunityPortalPost.IRequest;
  };
  export type Body = ICommunityPortalPost.IRequest;
  export type Response = IPageICommunityPortalPost.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPortal/users/:userId/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPortal/users/${encodeURIComponent(props.userId ?? "null")}/posts`;
  export const random = (): IPageICommunityPortalPost.ISummary =>
    typia.random<IPageICommunityPortalPost.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
