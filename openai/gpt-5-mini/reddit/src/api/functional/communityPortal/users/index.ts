import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalUser } from "../../../structures/ICommunityPortalUser";
import { IPageICommunityPortalUser } from "../../../structures/IPageICommunityPortalUser";
export * as posts from "./posts/index";
export * as comments from "./comments/index";

/**
 * Search and retrieve a filtered, paginated list of CommunityPortal users.
 *
 * Retrieve a filtered and paginated list of user profiles from the
 * community_portal_users table. This operation supports complex queries such as
 * partial username/display_name matching, karma range filtering, sorting by
 * karma or creation date, and pagination. By default the operation excludes
 * soft-deleted users (community_portal_users.deleted_at IS NULL) and does not
 * expose sensitive fields such as password_hash.
 *
 * Security and permissions: Basic discovery of public profile summaries may be
 * permitted for unauthenticated callers, but any request that requests
 * sensitive fields (email), performs email-based lookup, requests
 * includeArchived=true, or requests bulk export must require authentication and
 * explicit authorization. Audit access to email-based searches is REQUIRED.
 * Returned user summaries include only public profile fields (id, username,
 * display_name, bio, avatar_uri, karma, created_at) unless the caller is
 * authorized to receive more details.
 *
 * Relationship to DB entity: This operation directly references the
 * community_portal_users Prisma model. The model's fields such as id, username,
 * email, password_hash, display_name, bio, avatar_uri, karma, created_at,
 * updated_at, deleted_at are present in schema. The operation may optionally
 * join to community_portal_members to restrict to verified members
 * (is_email_verified) when requested and authorized.
 *
 * Validation and error handling: The request body must conform to
 * ICommunityPortalUser.IRequest schema (search filters, pagination). Requests
 * with invalid pagination/sort parameters SHOULD return 400 Bad Request. If the
 * operation is rate-limited, return 429 with retry information. On internal
 * errors return 500. Empty result sets return an empty data array with
 * pagination meta.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for user
 *   filtering (ICommunityPortalUser.IRequest). Implementations MUST include
 *   controls for includeArchived and sensitive filters to enforce
 *   authorization.
 * @path /communityPortal/users
 * @accessor api.functional.communityPortal.users.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria and pagination parameters for user filtering
     * (ICommunityPortalUser.IRequest). Implementations MUST include
     * controls for includeArchived and sensitive filters to enforce
     * authorization.
     */
    body: ICommunityPortalUser.IRequest;
  };
  export type Body = ICommunityPortalUser.IRequest;
  export type Response = IPageICommunityPortalUser.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPortal/users",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPortal/users";
  export const random = (): IPageICommunityPortalUser.ISummary =>
    typia.random<IPageICommunityPortalUser.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single CommunityPortal user profile by ID.
 *
 * Return the public profile for a single user from the community_portal_users
 * table identified by the path parameter userId.
 *
 * Purpose and overview: This endpoint is intended for profile pages and content
 * attribution. It returns public profile fields (id, username, display_name,
 * bio, avatar_uri, karma, created_at, updated_at). It references the Prisma
 * schema comments that document these fields and the soft-delete behavior
 * (deleted_at).
 *
 * Security and user permissions: Public callers may retrieve basic profile
 * data. Any request that attempts to access sensitive details (email,
 * membership flags, internal notes) must require authentication and explicit
 * authorization. The API MUST NOT return password_hash under any circumstance.
 *
 * Relationship to DB entity and validation: The endpoint maps directly to the
 * community_portal_users model. Validate userId as a UUID and exclude records
 * where deleted_at is set by default. If not found, return 404 with a clear
 * message.
 *
 * Error handling: 400 for invalid UUID format, 404 when user not found or
 * soft-deleted (policy-dependent), 500 for internal errors. 401 when the
 * implementation requires authentication for this resource and the caller is
 * unauthenticated.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the target user
 * @path /communityPortal/users/:userId
 * @accessor api.functional.communityPortal.users.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target user */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPortalUser;

  export const METADATA = {
    method: "GET",
    path: "/communityPortal/users/:userId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPortal/users/${encodeURIComponent(props.userId ?? "null")}`;
  export const random = (): ICommunityPortalUser =>
    typia.random<ICommunityPortalUser>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
