import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalComment } from "../../../../structures/ICommunityPortalComment";
import { IPageICommunityPortalComment } from "../../../../structures/IPageICommunityPortalComment";

/**
 * List comments for a post with pagination and optional parent-thread filtering
 * (community_portal_comments).
 *
 * Purpose and overview:
 *
 * Return a paginated list of comments associated with a single post. This
 * operation queries the community_portal_comments Prisma model for comments
 * with the given post_id, excluding comments whose deleted_at is set. It
 * supports retrieving top-level comments or replies by accepting an optional
 * parentCommentId filter in the request body.
 *
 * Security considerations and permissions:
 *
 * Comments for posts in public communities are readable by unauthenticated
 * callers. For posts in private communities, the service MUST verify the
 * requesting user's access and return 403 Forbidden for unauthorized requests.
 * The operation must respect post status (e.g., hidden/removed) and not return
 * comments for posts that are not visible to the caller.
 *
 * Relationship to database entities:
 *
 * This operation is directly associated with community_portal_comments.
 * Returned summaries should include id, author_user_id (nullable if user was
 * deleted), parent_comment_id, body (truncated for summaries where applicable),
 * created_at, and any UI-friendly metadata like reply_count.
 *
 * Validation rules and business logic:
 *
 * - PostId path parameter MUST be a UUID and refer to an existing
 *   community_portal_posts record.
 * - ParentCommentId, if supplied in the request, MUST reference a comment that
 *   belongs to the same post; otherwise return 400 Bad Request.
 * - Deleted comments (deleted_at IS NOT NULL) MUST be excluded from results.
 * - Pagination and sorting parameters MUST be supported in the request body
 *   (limit, offset, sort).
 *
 * Related operations:
 *
 * - To list posts for the parent community use PATCH
 *   /communityPortal/communities/{communityId}/posts.
 * - To cast votes on comments use POST/PUT on
 *   /communityPortal/comments/{commentId}/votes or the votes endpoints defined
 *   elsewhere.
 *
 * Error handling and edge cases:
 *
 * - If the postId does not exist, return 404 Not Found.
 * - If parentCommentId does not belong to the specified post, return 400 Bad
 *   Request.
 * - If the post is not visible to the caller due to privacy or moderation state,
 *   return 403 Forbidden.
 *
 * @param props.connection
 * @param props.postId UUID of the target post (community_portal_posts.id)
 * @param props.body Search, filter and pagination parameters for post comments
 * @path /communityPortal/posts/:postId/comments
 * @accessor api.functional.communityPortal.posts.comments.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** UUID of the target post (community_portal_posts.id) */
    postId: string & tags.Format<"uuid">;

    /** Search, filter and pagination parameters for post comments */
    body: ICommunityPortalComment.IRequest;
  };
  export type Body = ICommunityPortalComment.IRequest;
  export type Response = IPageICommunityPortalComment.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPortal/posts/:postId/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPortal/posts/${encodeURIComponent(props.postId ?? "null")}/comments`;
  export const random = (): IPageICommunityPortalComment.ISummary =>
    typia.random<IPageICommunityPortalComment.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific comment for a post (community_portal_comments).
 *
 * Purpose and overview: Retrieve a single comment that belongs to a specific
 * post. This endpoint returns the canonical comment record from the
 * community_portal_comments Prisma model. The response includes the comment
 * fields: id, post_id, parent_comment_id (nullable), author_user_id (nullable),
 * body, created_at, updated_at, and deleted_at (nullable).
 *
 * Important behavior and visibility: Only active (non-deleted) comments are
 * returned. Although deleted_at is part of the model and present in the
 * response schema, this endpoint will only return comments where deleted_at ==
 * null. If a comment has deleted_at != null the endpoint MUST respond with 404
 * Not Found to avoid exposing deleted content.
 *
 * Security and permissions: This is a read operation that may be publicly
 * accessible for public communities. For private communities, the caller must
 * be an authorized member/subscriber or otherwise granted access; otherwise
 * return 403 Forbidden. If the implementation enriches the response with author
 * profile details, include only non-sensitive author fields (for example:
 * display_name, avatar_uri). Do NOT include password_hash, email, or other
 * sensitive data.
 *
 * Validation and relationship checks:
 *
 * - Validate postId and commentId are valid UUIDs; return 400 Bad Request for
 *   malformed UUIDs.
 * - Confirm the comment exists and comment.post_id equals the supplied postId; if
 *   not, return 404 Not Found.
 * - If the containing community is private and caller lacks access, return 403
 *   Forbidden.
 *
 * Responses and error handling:
 *
 * - 200 OK: comment payload when found and visible.
 * - 400 Bad Request: invalid UUID format for path parameters.
 * - 403 Forbidden: caller lacks access to the containing community/post (private
 *   community).
 * - 404 Not Found: comment not found, does not belong to the specified post, or
 *   has been soft-deleted (deleted_at != null).
 *
 * @param props.connection
 * @param props.postId Target post's unique identifier (UUID). The comment must
 *   belong to this post.
 * @param props.commentId Target comment's unique identifier (UUID).
 * @path /communityPortal/posts/:postId/comments/:commentId
 * @accessor api.functional.communityPortal.posts.comments.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Target post's unique identifier (UUID). The comment must belong to
     * this post.
     */
    postId: string & tags.Format<"uuid">;

    /** Target comment's unique identifier (UUID). */
    commentId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPortalComment;

  export const METADATA = {
    method: "GET",
    path: "/communityPortal/posts/:postId/comments/:commentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPortal/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): ICommunityPortalComment =>
    typia.random<ICommunityPortalComment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
