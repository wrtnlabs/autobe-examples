import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalPost } from "../../../../structures/ICommunityPortalPost";
import { IPageICommunityPortalPost } from "../../../../structures/IPageICommunityPortalPost";

/**
 * List posts in a community with pagination, filtering and sorting
 * (community_portal_posts).
 *
 * Purpose and overview:
 *
 * Retrieve a filtered, sorted, and paginated list of posts within a single
 * community. This operation queries the community_portal_posts table (Prisma
 * model community_portal_posts) for records whose community_id matches the
 * provided communityId, excluding records where deleted_at is set. It returns a
 * page container of post summary items suitable for list displays.
 *
 * Security considerations and permissions:
 *
 * Public access is allowed for posts in communities whose visibility is
 * 'public'. For communities with private visibility, the service MUST require
 * authentication and verify the requesting user is permitted to view that
 * community (membership or explicit access). The implementation MUST not expose
 * content for private communities to unauthenticated callers; when access is
 * denied the service returns 403 Forbidden.
 *
 * Relationship to database entities:
 *
 * This operation is directly associated with the community_portal_posts Prisma
 * model. Returned summaries should include core properties (id, title,
 * post_type, created_at, status, author_user_id, image_url/link_url where
 * applicable) and must not expose sensitive fields such as internal moderation
 * metadata beyond the documented response schema.
 *
 * Validation rules and business logic:
 *
 * - CommunityId path parameter MUST be a UUID identifying the target community.
 *   The service MUST verify the community exists.
 * - Deleted posts (deleted_at IS NOT NULL) MUST be excluded from results.
 * - Results MUST support pagination (limit, offset or page/size) and return total
 *   counts in the paginated response metadata.
 * - Sorting accepts sort values 'hot', 'new', 'top', 'controversial'. The exact
 *   ranking algorithms for 'hot' and 'controversial' are stakeholder-defined
 *   and are not implemented here; the API accepts the parameter and returns
 *   posts ordered accordingly by the backend implementation.
 *
 * Related operations:
 *
 * - Creating or updating posts is handled by POST/PUT endpoints on
 *   /communityPortal/communities/{communityId}/posts (not part of this
 *   operation).
 * - To view comments for a specific post use GET/PATCH on
 *   /communityPortal/posts/{postId}/comments.
 *
 * Error handling and edge cases:
 *
 * - If the communityId does not exist, the service SHALL return 404 Not Found.
 * - If the community is private and the caller is unauthenticated or
 *   unauthorized, the service SHALL return 403 Forbidden.
 * - If pagination parameters are invalid (e.g., limit too large), the service
 *   SHALL return 400 Bad Request with an explanatory message.
 *
 * @param props.connection
 * @param props.communityId UUID of the target community
 *   (community_portal_communities.id)
 * @param props.body Search, filter and pagination parameters for community
 *   posts
 * @path /communityPortal/communities/:communityId/posts
 * @accessor api.functional.communityPortal.communities.posts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** UUID of the target community (community_portal_communities.id) */
    communityId: string & tags.Format<"uuid">;

    /** Search, filter and pagination parameters for community posts */
    body: ICommunityPortalPost.IRequest;
  };
  export type Body = ICommunityPortalPost.IRequest;
  export type Response = IPageICommunityPortalPost.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPortal/communities/:communityId/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPortal/communities/${encodeURIComponent(props.communityId ?? "null")}/posts`;
  export const random = (): IPageICommunityPortalPost.ISummary =>
    typia.random<IPageICommunityPortalPost.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
