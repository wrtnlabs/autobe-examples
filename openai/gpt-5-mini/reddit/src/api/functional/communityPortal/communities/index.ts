import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPortalCommunity } from "../../../structures/ICommunityPortalCommunity";
import { IPageICommunityPortalCommunity } from "../../../structures/IPageICommunityPortalCommunity";
export * as posts from "./posts/index";

/**
 * Search and retrieve a filtered, paginated list of communities.
 *
 * Retrieve a filtered and paginated list of communities from the system. This
 * operation supports name/slug search, visibility filtering, pagination, and
 * sorting. It returns community summary information optimized for list displays
 * (slug, name, short description, is_private, visibility, creator reference and
 * timestamps).
 *
 * Security considerations and permissions: public communities are visible to
 * unauthenticated callers; private communities are only included when the
 * requesting user is authorized to view them (membership, subscription, or
 * explicit access). The endpoint returns only communities with deleted_at set
 * to null (archived records are omitted). When clients request extra detail
 * (e.g., includeModeratorSummary), results may be restricted to authorized
 * callers.
 *
 * Relationship to the Prisma schema: maps to the community_portal_communities
 * model. The slug field is unique and suitable for canonical lookups;
 * creator_user_id is nullable per schema comments and must be handled
 * accordingly in result shaping. Use the provided DB indexes (created_at,
 * visibility, name trigram) to implement performant listing and search.
 *
 * Validation and business logic: validate pagination params (limit, offset),
 * enforce maximum allowed page size, validate sort mode values, and
 * canonicalize slug filters. If a caller supplies an invalid visibility filter
 * or unsupported sort value, return 400 with validation details.
 *
 * Related API operations: GET /communities/{communityId} for detail retrieval.
 * Error behavior: 400 for invalid inputs, 401 when requesting private data
 * without authentication, 500 for server errors.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for community
 *   filtering
 * @path /communityPortal/communities
 * @accessor api.functional.communityPortal.communities.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search criteria and pagination parameters for community filtering */
    body: ICommunityPortalCommunity.IRequest;
  };
  export type Body = ICommunityPortalCommunity.IRequest;
  export type Response = IPageICommunityPortalCommunity.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPortal/communities",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPortal/communities";
  export const random = (): IPageICommunityPortalCommunity.ISummary =>
    typia.random<IPageICommunityPortalCommunity.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve community details by ID.
 *
 * Fetch detailed information for a single community identified by its UUID. The
 * response includes canonical fields: id, name, slug, description, is_private,
 * visibility, creator reference (if present), and timestamps. The API handles
 * nullable creator_user_id per schema guidance and returns a normalized
 * representation suitable for community detail pages.
 *
 * Security considerations and user permissions: Public communities are viewable
 * by any caller. Private communities are visible only to authorized members or
 * subscribers; unauthenticated callers will receive a 401 or a 403 according to
 * policy. The endpoint excludes archived records (deleted_at not null) from
 * normal results; attempts to access archived communities without elevated
 * privileges should yield 404 to avoid information leakage.
 *
 * Relationship to underlying DB entity: maps directly to
 * community_portal_communities in the Prisma schema. The slug field is suitable
 * for alternate lookups (frontend-friendly); however, this endpoint is
 * specifically by UUID. Validation rules: communityId must be a UUID; return
 * 400 for invalid format.
 *
 * Validation and error handling: 400 for invalid UUID format, 404 when
 * community does not exist or is not visible to caller, 401 for unauthenticated
 * requests to private communities, and 500 for server errors. Related API
 * operations: PATCH /communities for searching and listing communities.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the target community
 * @path /communityPortal/communities/:communityId
 * @accessor api.functional.communityPortal.communities.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target community */
    communityId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPortalCommunity;

  export const METADATA = {
    method: "GET",
    path: "/communityPortal/communities/:communityId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPortal/communities/${encodeURIComponent(props.communityId ?? "null")}`;
  export const random = (): ICommunityPortalCommunity =>
    typia.random<ICommunityPortalCommunity>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
