import { tags } from "typia";

import { IAuthorizationToken } from "./IAuthorizationToken";
import { ICommunityPortalUser } from "./ICommunityPortalUser";

export namespace ICommunityPortalMember {
  /**
   * Request payload to register a new member.
   *
   * This DTO is used by POST /auth/member/join to create a new
   * community_portal_users row and the corresponding community_portal_members
   * record. Required properties: username, email, and password. Optional
   * property: display_name. The server will create the user record and a
   * membership record (community_portal_members) with is_email_verified=false
   * and member_since set to the current timestamp. Passwords are never stored
   * in plaintext; the server is responsible for hashing and storing the
   * password in community_portal_users.password_hash.
   *
   * Validation rules (business-level): the server will enforce uniqueness for
   * username and email and apply password-strength checks. Returns 409 on
   * uniqueness conflicts and 400 for invalid formats.
   */
  export type ICreate = {
    /**
     * Unique login handle for the new account. Maps to
     * community_portal_users.username in the Prisma schema.
     *
     * The value should be a user-visible identifier (3-30 characters
     * recommended) and will be validated for uniqueness by the server. Do
     * not include whitespace-only values. The server enforces username
     * uniqueness and will return 409 Conflict on duplicates.
     */
    username: string;

    /**
     * Primary email address for the account. Maps to
     * community_portal_users.email.
     *
     * This address is used for verification and account recovery. The
     * server will validate format and uniqueness. For privacy and security
     * the API will not return whether an email exists in verbose error
     * messages; on registration conflicts the server returns 409 Conflict.
     */
    email: string & tags.Format<"email">;

    /**
     * Plain-text password supplied by the client. The server MUST hash and
     * salt this value and persist the result into
     * community_portal_users.password_hash. Clients MUST NOT send
     * pre-hashed passwords. Password strength requirements are enforced
     * server-side (example: minimum length and complexity).
     */
    password: string;

    /**
     * Optional human-friendly display name. Maps to
     * community_portal_users.display_name.
     *
     * This value is shown in UI contexts and is not required to be unique.
     * If omitted, the server may derive a display name from the username.
     */
    display_name?: string | undefined;
  };

  /**
   * Authorization response returned after successful member authentication or
   * registration.
   *
   * This schema represents a safe, public-facing view of the authenticated
   * user combined with issued token information. It intentionally excludes
   * sensitive storage fields such as `password_hash` and `email` (these exist
   * on the `community_portal_users` Prisma model but are never exposed).
   *
   * The `token` property reuses the central `IAuthorizationToken` component
   * to standardize token format across authentication responses.
   */
  export type IAuthorized = {
    /**
     * Unique identifier of the authenticated user. This property
     * corresponds to the `id` column on the Prisma model
     * `community_portal_users` and is the primary key used across the
     * platform to reference the user.
     *
     * This value is generated by the system at account creation and MUST be
     * returned to clients to identify the authenticated principal in
     * subsequent calls.
     */
    id: string & tags.Format<"uuid">;

    /**
     * Canonical login handle of the authenticated user as stored in
     * `community_portal_users.username`.
     *
     * This value is the public short identifier displayed in UI attribution
     * and used for sign-in (or an alternative identifier such as email,
     * depending on frontend flows).
     */
    username?: string | undefined;

    /**
     * Human-friendly display name stored in
     * `community_portal_users.display_name`.
     *
     * This field may be null when a user has not configured a display name.
     * When present, it is intended for UI display and may contain spaces
     * and punctuation.
     */
    display_name?: string | null | undefined;

    /**
     * Aggregated reputation score persisted on the Prisma model as
     * `community_portal_users.karma`.
     *
     * Karma is an integer used for reputation and gating. The exact
     * calculation of karma is a platform business rule and is derived from
     * vote events and other actions; this schema property provides the
     * current stored value for client display.
     */
    karma?: (number & tags.Type<"int32">) | undefined;

    /**
     * Optional avatar image URI mapped from
     * `community_portal_users.avatar_uri`.
     *
     * May be null when the user has not set an avatar. When present, this
     * URI should be treated as a pointer to a media resource and must not
     * contain secrets.
     */
    avatar_uri?: (string & tags.Format<"uri">) | null | undefined;

    /**
     * Account creation timestamp mapped from
     * `community_portal_users.created_at` in the Prisma schema.
     *
     * This is returned for informational purposes (for example, "joined on"
     * displays) and is represented in ISO 8601 UTC date-time format.
     */
    created_at?: (string & tags.Format<"date-time">) | undefined;

    /** JWT token information for authentication */
    token: IAuthorizationToken;
  };

  /**
   * Login request payload for member authentication.
   *
   * `identifier` may be either username or email; `password` is the
   * plain-text credential. The server will perform credential verification
   * against the `community_portal_users` model and validate membership state
   * via `community_portal_members.is_email_verified` as appropriate. This DTO
   * is intentionally minimal and does not include tokens or server-managed
   * fields.
   */
  export type ILogin = {
    /**
     * Identifier for authentication. Accepts either the user's username or
     * their verified email address. The server will resolve this value
     * against `community_portal_users.username` and
     * `community_portal_users.email` to locate the account.
     *
     * Clients SHOULD normalize the identifier (trim whitespace) prior to
     * submission.
     */
    identifier: string;

    /**
     * Plain-text password supplied by the user for authentication. The
     * server MUST validate the provided password against the stored
     * `community_portal_users.password_hash` and MUST NOT accept a
     * pre-hashed value from clients.
     *
     * Passwords are transmitted only over secure channels (TLS) and MUST
     * meet platform-defined strength requirements enforced server-side.
     */
    password: string;

    /**
     * Optional flag indicating whether the client requests a long-lived
     * session (refresh token issuance/extended session). This field is
     * advisory and the server may ignore it based on policy.
     */
    remember?: boolean | undefined;
  };

  /**
   * Request body to refresh member authentication tokens.
   *
   * Clients call this endpoint to exchange a valid refresh token for a new
   * access token (and optionally a rotated refresh token). The request
   * contains only the opaque refreshToken value; the server is responsible
   * for validating the token, ensuring the referenced community_portal_users
   * record still exists and is eligible (not suspended), and returning a new
   * authorization payload.
   *
   * This DTO intentionally contains only the refresh token to minimize
   * sensitive payload surface area and to keep token handling server-driven.
   * Do not include credentials, user-identifying fields, or other sensitive
   * material in this request object.
   */
  export type IRefresh = {
    /**
     * Refresh token string previously issued by the authentication service.
     *
     * This token is a time-limited credential that the client presents to
     * obtain a new access token without re-supplying primary credentials.
     * The token value MUST be treated as sensitive and transported only
     * over TLS. The server validates the token against its authorization
     * store and may rotate it on successful refresh.
     */
    refreshToken: string;
  };

  /**
   * Request to initiate a password-reset flow for a member.
   *
   * The request contains the target email address for which a password reset
   * should be initiated. The implementation will look up the corresponding
   * community_portal_users record, generate a single-use, time-limited reset
   * token, and deliver it to the supplied email address. This DTO
   * intentionally carries only the email field to minimize information
   * exposure and to align with privacy-preserving practices.
   */
  export type IRequestPasswordReset = {
    /**
     * Email address associated with the member's account in
     * community_portal_users.email.
     *
     * This address is used to locate the account and to deliver a
     * single-use password reset artifact (token or link). For privacy, the
     * API that accepts this DTO SHOULD respond generically (for example,
     * always returning a success acknowledgement) so as not to reveal
     * whether the email is present in the system. The server MUST validate
     * the syntax of the email and enforce anti-abuse protections (rate
     * limits, CAPTCHA) before issuing a reset token.
     */
    email: string & tags.Format<"email">;
  };

  /**
   * Acknowledgement returned after initiating a password reset request.
   *
   * This response confirms that the system has processed the password reset
   * request. For privacy and security, the message is deliberately
   * non-committal about whether an account exists for the supplied email
   * address. The payload may include an optional internal request identifier
   * for support and tracing but MUST NOT include any secrets (reset tokens)
   * or user-sensitive fields.
   *
   * Use this DTO to display a consistent confirmation to users after they
   * request a password reset.
   */
  export type IPasswordResetRequested = {
    /**
     * User-facing confirmation message indicating that a password reset
     * request was received.
     *
     * This message is intentionally generic to avoid account enumeration.
     * It does not confirm the existence of an account for the supplied
     * email and provides guidance about next steps (for example, checking
     * the inbox for a reset link). Use this message to inform the user that
     * the reset flow was initiated.
     */
    message: string;

    /**
     * Optional opaque identifier for the password reset request created by
     * the system.
     *
     * This identifier may be used for internal tracing or support
     * follow-up. It MUST NOT contain secrets or the reset token.
     * Implementations may omit this property in the response; when present
     * it provides an audit reference for support and diagnostics.
     */
    request_id?: string | undefined;
  };

  /**
   * Request body for setting a new password. Accepts exactly one of the
   * supported flows:
   *
   * 1. Token flow: the client supplies a single-use reset token and the new
   *    password. Used when the user follows a password-reset link delivered
   *    via email.
   * 2. Current-password flow: the authenticated user supplies their current
   *    password together with the desired new password. Used when a logged-in
   *    user changes their password.
   *
   * The API validates which flow is being used by the presence of the
   * respective required properties. Implementations MUST NOT accept both
   * flows in the same request. Passwords are provided in plaintext in the
   * request and MUST be hashed server-side before persisting; the API MUST
   * never return password hashes in responses.
   */
  export type IChangePassword =
    | ICommunityPortalMember.IChangePassword.ITokenFlow
    | ICommunityPortalMember.IChangePassword.ICurrentPasswordFlow;
  export namespace IChangePassword {
    /**
     * Change-password payload using a reset token.
     *
     * Use this shape when the caller has a valid reset token issued by the
     * password-reset request flow. The server will validate the token,
     * locate the bound user, and replace the stored password_hash with a
     * securely hashed representation of newPassword. The response to this
     * operation is an acknowledgement and must not contain password or
     * password_hash values.
     */
    export type ITokenFlow = {
      /**
       * Single-use password reset token issued by the password-reset
       * initiation flow. The token MUST be validated server-side for
       * expiry and binding to a user account. Tokens are time-limited and
       * single-use; treat them as secrets.
       */
      resetToken: string;

      /**
       * The new plaintext password the user wishes to set.
       *
       * Password strength requirements: recommended minimum 8 characters
       * including at least one letter and one number. Server-side
       * policies may enforce additional checks (special character
       * requirements, breached-password checks, reuse prevention). The
       * client MUST submit the raw password; the server is responsible
       * for hashing and securely storing the derived password_hash.
       */
      newPassword: string & tags.MinLength<8>;
    };

    /**
     * Change-password payload for authenticated users using their current
     * password. The server MUST verify currentPassword, apply password
     * strength validation to newPassword, hash it securely, update the
     * stored password_hash for the authenticated user, and revoke or rotate
     * active refresh tokens as policy dictates.
     */
    export type ICurrentPasswordFlow = {
      /**
       * The user's current plaintext password. The server MUST validate
       * this value against the stored password_hash prior to applying the
       * new password.
       */
      currentPassword: string & tags.MinLength<8>;

      /**
       * The new plaintext password the user wishes to set. See
       * server-side password strength/rotation policy; the server will
       * hash and store the derived password_hash and must not return it
       * in responses.
       */
      newPassword: string & tags.MinLength<8>;
    };
  }

  /**
   * Result returned after a change-password operation.
   *
   * This DTO represents the business-level outcome of updating the caller's
   * credential (the server-side update of
   * community_portal_users.password_hash). It intentionally contains no
   * sensitive fields (e.g., password_hash) and provides a simple success flag
   * and a user-facing message. Use this response to acknowledge completion or
   * surface expected next steps (for example, prompting re-login if the
   * implementation invalidates active sessions).
   */
  export type IChangePasswordResult = {
    /**
     * Indicates whether the password change operation completed
     * successfully.
     *
     * True when the server accepted and applied the new password hash for
     * the authenticated user; false when the operation failed due to
     * validation, authorization, or other server-side errors.
     */
    success: boolean;

    /**
     * Human-readable message describing the outcome of the password change
     * operation.
     *
     * This message is intended for display in the client UI and should be
     * non-sensitive. Examples: "Password changed successfully." or "Current
     * password is incorrect." Do not include raw password data or internal
     * error traces in this message.
     */
    message: string;
  };

  /**
   * Response returned after consuming an email verification token.
   *
   * This DTO communicates whether the verification completed and provides
   * optional linkage to the verified user's id. It is designed to be safe for
   * client consumption: no authentication secrets or internal hashes are
   * included. The implementation may optionally include userId when
   * appropriate for the client workflow, but it MUST omit any sensitive
   * fields such as password_hash.
   */
  export type IVerifyEmail = {
    /**
     * Indicates whether the email verification succeeded.
     *
     * True when the verification token was valid and the membership record
     * was updated (community_portal_members.is_email_verified set to true).
     * False when the token was invalid, expired, or the account cannot be
     * verified for business reasons.
     */
    success: boolean;

    /**
     * The UUID of the user whose email was verified.
     *
     * This field mirrors the primary key of the corresponding
     * community_portal_users record when the verification is successful and
     * the server elects to return it. It may be null in cases where the
     * server chooses not to return identifying information (for privacy) or
     * when verification failed.
     */
    userId?: (string & tags.Format<"uuid">) | null | undefined;

    /**
     * A descriptive, non-sensitive message intended for client display.
     *
     * On success this typically reads: "Email verified successfully." On
     * failure provide a clear, actionable message such as: "Verification
     * token expired. Request a new verification email." Avoid returning
     * internal diagnostics or security-sensitive details.
     */
    message: string;
  };

  /**
   * Result of an email verification operation for a member.
   *
   * This DTO is returned after consuming a verification token. The 'success'
   * flag is REQUIRED and MUST be true when verification succeeded. The
   * optional 'user' property references a public-safe user summary
   * (ICommunityPortalUser.ISummary) to avoid leaking sensitive authentication
   * fields.
   *
   * Security note: Under no circumstances shall this response include
   * password hashes, salts, tokens, or other secrets. Any schema referenced
   * by 'user' MUST be validated to ensure it contains only public-facing
   * fields.
   */
  export type IVerifyEmailResult = {
    /**
     * Indicates whether the email verification operation completed
     * successfully.
     *
     * True when the verification token was accepted and the membership
     * record (community_portal_members.is_email_verified) was updated.
     * False when the token was invalid, expired, or verification could not
     * be completed.
     */
    success: boolean;

    /**
     * Human-friendly message describing the verification result suitable
     * for direct display in client UI. Avoid returning internal diagnostics
     * or sensitive data.
     */
    message?: string | undefined;

    /**
     * Optional public-safe summary of the user record after verification.
     * This object MUST follow the ICommunityPortalUser.ISummary schema and
     * therefore MUST NOT expose sensitive fields such as password_hash,
     * password_hash variants, salts, refresh tokens, or internal system
     * flags. It is included only when the server chooses to surface minimal
     * profile information to the client.
     */
    user?: ICommunityPortalUser.ISummary | undefined;
  };
}
