import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthUserJoin } from "../../../providers/postAuthUserJoin";
import { UserAuth } from "../../../decorators/UserAuth";
import { UserPayload } from "../../../decorators/payload/UserPayload";
import { postAuthUserLogin } from "../../../providers/postAuthUserLogin";
import { postAuthUserRefresh } from "../../../providers/postAuthUserRefresh";

import { ITodoListUser } from "../../../api/structures/ITodoListUser";

@Controller("/auth/user")
export class AuthUserController {
  /**
   * Register new user account in todo_list_users with secure password hashing
   * and token issuance.
   *
   * This operation registers a new authenticated user by collecting a unique
   * email and password. It securely stores the user's credentials in the
   * todo_list_users table with the password saved as a hash in the
   * password_hash column. The user's account lifecycle timestamps (created_at,
   * updated_at) are managed accordingly. The email field must be unique,
   * preventing duplicate registrations. Upon successful registration, the
   * system issues JWT tokens for immediate use, encapsulated in the
   * I{PascalPrefixName}{RoleName}.IAuthorized response format.
   *
   * The registration process ensures the user identity is unique via email and
   * prepares the user for application login. No direct login is performed here;
   * instead, tokens are issued after account creation.
   *
   * This operation is designed for authenticated member users with full access
   * to personal todo task management.
   *
   * Security considerations include proper password hashing and secure token
   * issuance. The API ensures soft deletion awareness by monitoring the
   * deleted_at field.
   *
   * This operation complements the login and refresh token endpoints for a
   * complete authentication flow for member users.
   *
   * @param connection
   * @param body User registration data including unique email and plain
   *   password to be hashed.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @UserAuth()
    user: UserPayload,
    @TypedBody()
    body: ITodoListUser.ICreate,
  ): Promise<ITodoListUser.IAuthorized> {
    try {
      return await postAuthUserJoin({
        user,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate user via email and password from todo_list_users and issue JWT
   * tokens.
   *
   * Log in an existing authenticated user by validating their email and
   * password. The system verifies credentials against the todo_list_users
   * table, specifically the password_hash field, and confirms the account is
   * not soft deleted (deleted_at is null). Upon successful authentication, a
   * JWT access token and refresh token are issued, returned in the
   * I{PascalPrefixName}{RoleName}.IAuthorized response format.
   *
   * This endpoint is essential for member users to access their todo tasks and
   * personal data. It ensures security by enforcing proper authentication
   * checks, credential validation, and token issuance.
   *
   * The login operation depends on no other API endpoints but complements
   * registration and token refresh endpoints to provide a full authentication
   * lifecycle.
   *
   * Security mechanisms include password hashing verification, account state
   * validation via deleted_at, and secure token generation.
   *
   * The operation path and method reflect standard RESTful practices for user
   * authentication.
   *
   * @param connection
   * @param body User login credentials containing email and plain password for
   *   authentication.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @UserAuth()
    user: UserPayload,
    @TypedBody()
    body: ITodoListUser.ILogin,
  ): Promise<ITodoListUser.IAuthorized> {
    try {
      return await postAuthUserLogin({
        user,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh access and refresh JWT tokens for authenticated user in
   * todo_list_users.
   *
   * Refresh JWT tokens for an authenticated user by validating and rotating
   * refresh token. The system selects the user from todo_list_users to confirm
   * active status (deleted_at is null). Upon success, a new pair of access and
   * refresh tokens is issued, returned in the
   * I{PascalPrefixName}{RoleName}.IAuthorized response.
   *
   * This endpoint prolongs the session without requiring the user to login
   * again. It completes the standard JWT token lifecycle for member users.
   *
   * Security protections include refresh token rotation to mitigate replay
   * attacks and checks for account soft deletion.
   *
   * The operation is integral to secure session management in the Todo list
   * application backend.
   *
   * It is distinct from join and login endpoints by focusing solely on existing
   * valid session extension.
   *
   * The endpoint path and method follow best RESTful patterns for security
   * token renewal processes.
   *
   * @param connection
   * @param body Refresh token request containing valid refresh token for
   *   session continuation.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @UserAuth()
    user: UserPayload,
    @TypedBody()
    body: ITodoListUser.IRefresh,
  ): Promise<ITodoListUser.IAuthorized> {
    try {
      return await postAuthUserRefresh({
        user,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
