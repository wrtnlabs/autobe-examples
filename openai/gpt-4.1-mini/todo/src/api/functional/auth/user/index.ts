import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListUser } from "../../../structures/ITodoListUser";

/**
 * Register new user account in todo_list_users with secure password hashing and
 * token issuance.
 *
 * This operation registers a new authenticated user by collecting a unique
 * email and password. It securely stores the user's credentials in the
 * todo_list_users table with the password saved as a hash in the password_hash
 * column. The user's account lifecycle timestamps (created_at, updated_at) are
 * managed accordingly. The email field must be unique, preventing duplicate
 * registrations. Upon successful registration, the system issues JWT tokens for
 * immediate use, encapsulated in the I{PascalPrefixName}{RoleName}.IAuthorized
 * response format.
 *
 * The registration process ensures the user identity is unique via email and
 * prepares the user for application login. No direct login is performed here;
 * instead, tokens are issued after account creation.
 *
 * This operation is designed for authenticated member users with full access to
 * personal todo task management.
 *
 * Security considerations include proper password hashing and secure token
 * issuance. The API ensures soft deletion awareness by monitoring the
 * deleted_at field.
 *
 * This operation complements the login and refresh token endpoints for a
 * complete authentication flow for member users.
 *
 * @param props.connection
 * @param props.body User registration data including unique email and plain
 *   password to be hashed.
 * @setHeader token.access Authorization
 *
 * @path /auth/user/join
 * @accessor api.functional.auth.user.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * User registration data including unique email and plain password to
     * be hashed.
     */
    body: ITodoListUser.ICreate;
  };
  export type Body = ITodoListUser.ICreate;
  export type Response = ITodoListUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/user/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/user/join";
  export const random = (): ITodoListUser.IAuthorized =>
    typia.random<ITodoListUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate user via email and password from todo_list_users and issue JWT
 * tokens.
 *
 * Log in an existing authenticated user by validating their email and password.
 * The system verifies credentials against the todo_list_users table,
 * specifically the password_hash field, and confirms the account is not soft
 * deleted (deleted_at is null). Upon successful authentication, a JWT access
 * token and refresh token are issued, returned in the
 * I{PascalPrefixName}{RoleName}.IAuthorized response format.
 *
 * This endpoint is essential for member users to access their todo tasks and
 * personal data. It ensures security by enforcing proper authentication checks,
 * credential validation, and token issuance.
 *
 * The login operation depends on no other API endpoints but complements
 * registration and token refresh endpoints to provide a full authentication
 * lifecycle.
 *
 * Security mechanisms include password hashing verification, account state
 * validation via deleted_at, and secure token generation.
 *
 * The operation path and method reflect standard RESTful practices for user
 * authentication.
 *
 * @param props.connection
 * @param props.body User login credentials containing email and plain password
 *   for authentication.
 * @setHeader token.access Authorization
 *
 * @path /auth/user/login
 * @accessor api.functional.auth.user.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * User login credentials containing email and plain password for
     * authentication.
     */
    body: ITodoListUser.ILogin;
  };
  export type Body = ITodoListUser.ILogin;
  export type Response = ITodoListUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/user/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/user/login";
  export const random = (): ITodoListUser.IAuthorized =>
    typia.random<ITodoListUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh access and refresh JWT tokens for authenticated user in
 * todo_list_users.
 *
 * Refresh JWT tokens for an authenticated user by validating and rotating
 * refresh token. The system selects the user from todo_list_users to confirm
 * active status (deleted_at is null). Upon success, a new pair of access and
 * refresh tokens is issued, returned in the
 * I{PascalPrefixName}{RoleName}.IAuthorized response.
 *
 * This endpoint prolongs the session without requiring the user to login again.
 * It completes the standard JWT token lifecycle for member users.
 *
 * Security protections include refresh token rotation to mitigate replay
 * attacks and checks for account soft deletion.
 *
 * The operation is integral to secure session management in the Todo list
 * application backend.
 *
 * It is distinct from join and login endpoints by focusing solely on existing
 * valid session extension.
 *
 * The endpoint path and method follow best RESTful patterns for security token
 * renewal processes.
 *
 * @param props.connection
 * @param props.body Refresh token request containing valid refresh token for
 *   session continuation.
 * @setHeader token.access Authorization
 *
 * @path /auth/user/refresh
 * @accessor api.functional.auth.user.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh token request containing valid refresh token for session
     * continuation.
     */
    body: ITodoListUser.IRefresh;
  };
  export type Body = ITodoListUser.IRefresh;
  export type Response = ITodoListUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/user/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/user/refresh";
  export const random = (): ITodoListUser.IAuthorized =>
    typia.random<ITodoListUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
