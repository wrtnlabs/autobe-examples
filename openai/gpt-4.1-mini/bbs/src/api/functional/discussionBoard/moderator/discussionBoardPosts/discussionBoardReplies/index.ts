import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardDiscussionBoardReply } from "../../../../../structures/IDiscussionBoardDiscussionBoardReply";
import { IDiscussionBoardDiscussionBoardReplies } from "../../../../../structures/IDiscussionBoardDiscussionBoardReplies";

/**
 * Retrieve a specific discussion board reply by post and reply IDs.
 *
 * Retrieve an individual reply within a discussion board post, identified by
 * discussionBoardPostId and discussionBoardReplyId.
 *
 * This operation fetches the reply's detailed information from the
 * discussion_board_replies Prisma table.
 *
 * Security considerations include ensuring the requesting user has appropriate
 * access rights, typically requiring authentication as a member or higher
 * role.
 *
 * The retrieved data include the reply content, authoring member, status, and
 * timestamps. This facilitates display of the reply in UI discussions and
 * supports detailed reply inspection.
 *
 * No request body is required as this is a read operation.
 *
 * If the specified post or reply does not exist, the operation should return an
 * appropriate 404 error response.
 *
 * This endpoint complements other operations such as listing replies for a post
 * or managing replies via create/update/delete operations.
 *
 * @param props.connection
 * @param props.discussionBoardPostId Unique identifier of the parent discussion
 *   board post
 * @param props.discussionBoardReplyId Unique identifier of the discussion board
 *   reply
 * @path /discussionBoard/moderator/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies/:discussionBoardReplyId
 * @accessor api.functional.discussionBoard.moderator.discussionBoardPosts.discussionBoardReplies.getByDiscussionboardpostidAndDiscussionboardreplyid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getByDiscussionboardpostidAndDiscussionboardreplyid(
  connection: IConnection,
  props: getByDiscussionboardpostidAndDiscussionboardreplyid.Props,
): Promise<getByDiscussionboardpostidAndDiscussionboardreplyid.Response> {
  return true === connection.simulate
    ? getByDiscussionboardpostidAndDiscussionboardreplyid.simulate(
        connection,
        props,
      )
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByDiscussionboardpostidAndDiscussionboardreplyid.METADATA,
          path: getByDiscussionboardpostidAndDiscussionboardreplyid.path(props),
          status: null,
        },
      );
}
export namespace getByDiscussionboardpostidAndDiscussionboardreplyid {
  export type Props = {
    /** Unique identifier of the parent discussion board post */
    discussionBoardPostId: string & tags.Format<"uuid">;

    /** Unique identifier of the discussion board reply */
    discussionBoardReplyId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardDiscussionBoardReply;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/moderator/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies/:discussionBoardReplyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/moderator/discussionBoardPosts/${encodeURIComponent(props.discussionBoardPostId ?? "null")}/discussionBoardReplies/${encodeURIComponent(props.discussionBoardReplyId ?? "null")}`;
  export const random = (): IDiscussionBoardDiscussionBoardReply =>
    typia.random<IDiscussionBoardDiscussionBoardReply>();
  export const simulate = (
    connection: IConnection,
    props: getByDiscussionboardpostidAndDiscussionboardreplyid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByDiscussionboardpostidAndDiscussionboardreplyid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("discussionBoardPostId")(() =>
        typia.assert(props.discussionBoardPostId),
      );
      assert.param("discussionBoardReplyId")(() =>
        typia.assert(props.discussionBoardReplyId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing reply to a discussion board post.
 *
 * Update a reply to a discussion board post with validated content.
 *
 * This operation allows the reply author or an authorized moderator to update
 * the content of a reply. The reply content must be between 5 and 1000
 * characters and pass the system's profanity filter.
 *
 * Security is enforced so only the reply owner or moderators can perform this
 * update. The operation uses the discussion_board_replies table from the Prisma
 * schema, ensuring referential integrity to the parent post and member.
 *
 * The request body must conform to the
 * IDiscussionBoardDiscussionBoardReply.IUpdate DTO schema, ensuring correct
 * input validation. The response returns the updated reply entity with its full
 * details.
 *
 * Error scenarios include validation failures for content length or profanity,
 * unauthorized access, and resource not found errors if the reply or post does
 * not exist.
 *
 * @param props.connection
 * @param props.body Request body containing updated reply data
 * @path /discussionBoard/moderator/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies/:discussionBoardReplyId
 * @accessor api.functional.discussionBoard.moderator.discussionBoardPosts.discussionBoardReplies.putByDiscussionboardpostidAndDiscussionboardreplyid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putByDiscussionboardpostidAndDiscussionboardreplyid(
  connection: IConnection,
  props: putByDiscussionboardpostidAndDiscussionboardreplyid.Props,
): Promise<putByDiscussionboardpostidAndDiscussionboardreplyid.Response> {
  return true === connection.simulate
    ? putByDiscussionboardpostidAndDiscussionboardreplyid.simulate(
        connection,
        props,
      )
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByDiscussionboardpostidAndDiscussionboardreplyid.METADATA,
          path: putByDiscussionboardpostidAndDiscussionboardreplyid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putByDiscussionboardpostidAndDiscussionboardreplyid {
  export type Props = {
    discussionBoardPostId: string;
    discussionBoardReplyId: string;

    /** Request body containing updated reply data */
    body: IDiscussionBoardDiscussionBoardReply.IUpdate;
  };
  export type Body = IDiscussionBoardDiscussionBoardReply.IUpdate;
  export type Response = IDiscussionBoardDiscussionBoardReply;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/moderator/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies/:discussionBoardReplyId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/moderator/discussionBoardPosts/${encodeURIComponent(props.discussionBoardPostId ?? "null")}/discussionBoardReplies/${encodeURIComponent(props.discussionBoardReplyId ?? "null")}`;
  export const random = (): IDiscussionBoardDiscussionBoardReply =>
    typia.random<IDiscussionBoardDiscussionBoardReply>();
  export const simulate = (
    connection: IConnection,
    props: putByDiscussionboardpostidAndDiscussionboardreplyid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByDiscussionboardpostidAndDiscussionboardreplyid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("discussionBoardPostId")(() =>
        typia.assert(props.discussionBoardPostId),
      );
      assert.param("discussionBoardReplyId")(() =>
        typia.assert(props.discussionBoardReplyId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a reply from a discussion board post by authorized moderators.
 *
 * This operation permanently removes the specified reply record from the
 * database. It requires the IDs of the parent post and the reply.
 *
 * Only users with moderator or admin roles may perform this action. The
 * operation references the discussion_board_replies table in the Prisma schema,
 * confirming the data is deleted fully and irreversibly.
 *
 * No request body is needed. The response is empty, indicating successful
 * deletion or an appropriate error if the reply or post does not exist.
 *
 * @param props.connection
 * @path /discussionBoard/moderator/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies/:discussionBoardReplyId
 * @accessor api.functional.discussionBoard.moderator.discussionBoardPosts.discussionBoardReplies.eraseByDiscussionboardpostidAndDiscussionboardreplyid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseByDiscussionboardpostidAndDiscussionboardreplyid(
  connection: IConnection,
  props: eraseByDiscussionboardpostidAndDiscussionboardreplyid.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseByDiscussionboardpostidAndDiscussionboardreplyid.simulate(
        connection,
        props,
      )
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseByDiscussionboardpostidAndDiscussionboardreplyid.METADATA,
          path: eraseByDiscussionboardpostidAndDiscussionboardreplyid.path(
            props,
          ),
          status: null,
        },
      );
}
export namespace eraseByDiscussionboardpostidAndDiscussionboardreplyid {
  export type Props = {
    discussionBoardPostId: string;
    discussionBoardReplyId: string;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/moderator/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies/:discussionBoardReplyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/moderator/discussionBoardPosts/${encodeURIComponent(props.discussionBoardPostId ?? "null")}/discussionBoardReplies/${encodeURIComponent(props.discussionBoardReplyId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseByDiscussionboardpostidAndDiscussionboardreplyid.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseByDiscussionboardpostidAndDiscussionboardreplyid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("discussionBoardPostId")(() =>
        typia.assert(props.discussionBoardPostId),
      );
      assert.param("discussionBoardReplyId")(() =>
        typia.assert(props.discussionBoardReplyId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information of a specific reply for a discussion post.
 *
 * Retrieve a specific reply by its replyId associated with a particular post
 * identified by postId.
 *
 * This operation fetches the detailed reply including content, author, status,
 * and timestamps. It helps clients view detailed information about a reply in
 * the context of a specific discussion post.
 *
 * Security requires that only authenticated users with roles 'member',
 * 'moderator', or 'admin' can access this endpoint.
 *
 * This endpoint directly maps to the discussion_board_replies table and
 * respects soft deletion by ignoring replies marked as deleted.
 *
 * Clients should handle errors gracefully such as 404 Not Found or 403
 * Unauthorized.
 *
 * Related operations include listing replies for a post and creating new
 * replies under a post.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the target discussion post
 * @param props.replyId Unique identifier of the target reply
 * @path /discussionBoard/moderator/discussionBoardPosts/:postId/discussionBoardReplies/:replyId
 * @accessor api.functional.discussionBoard.moderator.discussionBoardPosts.discussionBoardReplies.getByPostidAndReplyid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getByPostidAndReplyid(
  connection: IConnection,
  props: getByPostidAndReplyid.Props,
): Promise<getByPostidAndReplyid.Response> {
  return true === connection.simulate
    ? getByPostidAndReplyid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByPostidAndReplyid.METADATA,
          path: getByPostidAndReplyid.path(props),
          status: null,
        },
      );
}
export namespace getByPostidAndReplyid {
  export type Props = {
    /** Unique identifier of the target discussion post */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the target reply */
    replyId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardDiscussionBoardReply;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/moderator/discussionBoardPosts/:postId/discussionBoardReplies/:replyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/moderator/discussionBoardPosts/${encodeURIComponent(props.postId ?? "null")}/discussionBoardReplies/${encodeURIComponent(props.replyId ?? "null")}`;
  export const random = (): IDiscussionBoardDiscussionBoardReply =>
    typia.random<IDiscussionBoardDiscussionBoardReply>();
  export const simulate = (
    connection: IConnection,
    props: getByPostidAndReplyid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByPostidAndReplyid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("replyId")(() => typia.assert(props.replyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a reply to a discussion board post.
 *
 * Update a reply to a specific discussion board post identified by postId and
 * replyId. This operation validates and updates the reply's content and status
 * fields according to discussion board business rules.
 *
 * Security considerations: Only authenticated members and moderators with edit
 * permissions may use this operation. Member edits are restricted to replies
 * they own and within 24 hours of creation, while moderators can edit any reply
 * at any time.
 *
 * This operation references the discussion_board_replies table, which stores
 * replies linked to posts and authors. It enforces content length restrictions
 * (5 to 1000 characters) and moderation status management.
 *
 * Validation rules require profanity filtering on the reply content before
 * acceptance.
 *
 * Related operations include creating new replies, deleting replies, and
 * managing posts.
 *
 * Error handling includes responding with authorization errors if the user
 * lacks permission, and validation errors if content does not meet criteria.
 *
 * @param props.connection
 * @param props.body Updated reply content and status
 * @path /discussionBoard/moderator/discussionBoardPosts/:postId/discussionBoardReplies/:replyId
 * @accessor api.functional.discussionBoard.moderator.discussionBoardPosts.discussionBoardReplies.putByPostidAndReplyid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putByPostidAndReplyid(
  connection: IConnection,
  props: putByPostidAndReplyid.Props,
): Promise<putByPostidAndReplyid.Response> {
  return true === connection.simulate
    ? putByPostidAndReplyid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByPostidAndReplyid.METADATA,
          path: putByPostidAndReplyid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putByPostidAndReplyid {
  export type Props = {
    postId: string;
    replyId: string;

    /** Updated reply content and status */
    body: IDiscussionBoardDiscussionBoardReplies.IUpdate;
  };
  export type Body = IDiscussionBoardDiscussionBoardReplies.IUpdate;
  export type Response = IDiscussionBoardDiscussionBoardReplies;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/moderator/discussionBoardPosts/:postId/discussionBoardReplies/:replyId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/moderator/discussionBoardPosts/${encodeURIComponent(props.postId ?? "null")}/discussionBoardReplies/${encodeURIComponent(props.replyId ?? "null")}`;
  export const random = (): IDiscussionBoardDiscussionBoardReplies =>
    typia.random<IDiscussionBoardDiscussionBoardReplies>();
  export const simulate = (
    connection: IConnection,
    props: putByPostidAndReplyid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByPostidAndReplyid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("replyId")(() => typia.assert(props.replyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a reply from a discussion board post.
 *
 * Delete a reply from a specific discussion board post identified by postId and
 * replyId.
 *
 * Security considerations: Only moderators or admins have permission to delete
 * replies.
 *
 * This operation references the discussion_board_replies table and removes the
 * reply record permanently.
 *
 * Constraints and referential integrity ensure that related data is handled
 * appropriately by database cascading.
 *
 * Error handling involves permission denial responses and not found errors if
 * the reply is absent.
 *
 * No request or response body is involved in this deletion operation.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the target discussion board post
 * @param props.replyId Unique identifier of the target reply
 * @path /discussionBoard/moderator/discussionBoardPosts/:postId/discussionBoardReplies/:replyId
 * @accessor api.functional.discussionBoard.moderator.discussionBoardPosts.discussionBoardReplies.eraseByPostidAndReplyid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseByPostidAndReplyid(
  connection: IConnection,
  props: eraseByPostidAndReplyid.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseByPostidAndReplyid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseByPostidAndReplyid.METADATA,
          path: eraseByPostidAndReplyid.path(props),
          status: null,
        },
      );
}
export namespace eraseByPostidAndReplyid {
  export type Props = {
    /** Unique identifier of the target discussion board post */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the target reply */
    replyId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/moderator/discussionBoardPosts/:postId/discussionBoardReplies/:replyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/moderator/discussionBoardPosts/${encodeURIComponent(props.postId ?? "null")}/discussionBoardReplies/${encodeURIComponent(props.replyId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseByPostidAndReplyid.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseByPostidAndReplyid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("replyId")(() => typia.assert(props.replyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
