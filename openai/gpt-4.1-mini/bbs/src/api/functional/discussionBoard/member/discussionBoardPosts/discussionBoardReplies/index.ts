import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardDiscussionBoardReply } from "../../../../../structures/IDiscussionBoardDiscussionBoardReply";
import { IDiscussionBoardDiscussionBoardReplies } from "../../../../../structures/IDiscussionBoardDiscussionBoardReplies";
import { IPageIDiscussionBoardDiscussionBoardReplies } from "../../../../../structures/IPageIDiscussionBoardDiscussionBoardReplies";

/**
 * Create a new reply for a given discussion board post.
 *
 * Create a new reply to a discussion board post.
 *
 * The request body must include reply content adhering to length constraints
 * (5-1000 characters) and pass profanity filters.
 *
 * The reply is linked to the specified discussionBoardPostId, associating it to
 * the parent post.
 *
 * Security requires the authenticated user to possess the member role to create
 * replies.
 *
 * On successful creation, the new reply entity is returned with full details,
 * including identifiers, timestamps, and status.
 *
 * This operation complements the retrieval and management of discussion board
 * replies, facilitating active user engagement in discussions.
 *
 * @param props.connection
 * @param props.discussionBoardPostId Unique identifier of the parent discussion
 *   board post
 * @param props.body Details of the reply to be created
 * @path /discussionBoard/member/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies
 * @accessor api.functional.discussionBoard.member.discussionBoardPosts.discussionBoardReplies.postByDiscussionboardpostid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function postByDiscussionboardpostid(
  connection: IConnection,
  props: postByDiscussionboardpostid.Props,
): Promise<postByDiscussionboardpostid.Response> {
  return true === connection.simulate
    ? postByDiscussionboardpostid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...postByDiscussionboardpostid.METADATA,
          path: postByDiscussionboardpostid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace postByDiscussionboardpostid {
  export type Props = {
    /** Unique identifier of the parent discussion board post */
    discussionBoardPostId: string & tags.Format<"uuid">;

    /** Details of the reply to be created */
    body: IDiscussionBoardDiscussionBoardReply.ICreate;
  };
  export type Body = IDiscussionBoardDiscussionBoardReply.ICreate;
  export type Response = IDiscussionBoardDiscussionBoardReply;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/member/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/discussionBoardPosts/${encodeURIComponent(props.discussionBoardPostId ?? "null")}/discussionBoardReplies`;
  export const random = (): IDiscussionBoardDiscussionBoardReply =>
    typia.random<IDiscussionBoardDiscussionBoardReply>();
  export const simulate = (
    connection: IConnection,
    props: postByDiscussionboardpostid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: postByDiscussionboardpostid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("discussionBoardPostId")(() =>
        typia.assert(props.discussionBoardPostId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a filtered, paginated list of replies for a discussion board post.
 *
 * Allows authenticated members to retrieve a filtered and paginated list of
 * replies for a given discussion board post. The post is identified by its UUID
 * path parameter. The request body accepts filtering, searching, sorting, and
 * pagination parameters encapsulated in
 * IDiscussionBoardDiscussionBoardReplies.IRequest. The response body returns
 * paginated reply summaries in
 * IPageIDiscussionBoardDiscussionBoardReplies.ISummary format. Replies marked
 * as deleted (with deleted_at values) should be excluded by business logic
 * outside of this API definition. Access is restricted to users with the member
 * role to reflect the business requirement that members can browse replies.
 *
 * @param props.connection
 * @param props.discussionBoardPostId Unique identifier of the discussion board
 *   post to retrieve replies for
 * @param props.body Filtering and pagination criteria for replies
 * @path /discussionBoard/member/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies
 * @accessor api.functional.discussionBoard.member.discussionBoardPosts.discussionBoardReplies.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the discussion board post to retrieve replies
     * for
     */
    discussionBoardPostId: string & tags.Format<"uuid">;

    /** Filtering and pagination criteria for replies */
    body: IDiscussionBoardDiscussionBoardReplies.IRequest;
  };
  export type Body = IDiscussionBoardDiscussionBoardReplies.IRequest;
  export type Response = IPageIDiscussionBoardDiscussionBoardReplies.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/member/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/discussionBoardPosts/${encodeURIComponent(props.discussionBoardPostId ?? "null")}/discussionBoardReplies`;
  export const random =
    (): IPageIDiscussionBoardDiscussionBoardReplies.ISummary =>
      typia.random<IPageIDiscussionBoardDiscussionBoardReplies.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("discussionBoardPostId")(() =>
        typia.assert(props.discussionBoardPostId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific discussion board reply by post and reply IDs.
 *
 * Retrieve an individual reply within a discussion board post, identified by
 * discussionBoardPostId and discussionBoardReplyId.
 *
 * This operation fetches the reply's detailed information from the
 * discussion_board_replies Prisma table.
 *
 * Security considerations include ensuring the requesting user has appropriate
 * access rights, typically requiring authentication as a member or higher
 * role.
 *
 * The retrieved data include the reply content, authoring member, status, and
 * timestamps. This facilitates display of the reply in UI discussions and
 * supports detailed reply inspection.
 *
 * No request body is required as this is a read operation.
 *
 * If the specified post or reply does not exist, the operation should return an
 * appropriate 404 error response.
 *
 * This endpoint complements other operations such as listing replies for a post
 * or managing replies via create/update/delete operations.
 *
 * @param props.connection
 * @param props.discussionBoardPostId Unique identifier of the parent discussion
 *   board post
 * @param props.discussionBoardReplyId Unique identifier of the discussion board
 *   reply
 * @path /discussionBoard/member/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies/:discussionBoardReplyId
 * @accessor api.functional.discussionBoard.member.discussionBoardPosts.discussionBoardReplies.getByDiscussionboardpostidAndDiscussionboardreplyid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getByDiscussionboardpostidAndDiscussionboardreplyid(
  connection: IConnection,
  props: getByDiscussionboardpostidAndDiscussionboardreplyid.Props,
): Promise<getByDiscussionboardpostidAndDiscussionboardreplyid.Response> {
  return true === connection.simulate
    ? getByDiscussionboardpostidAndDiscussionboardreplyid.simulate(
        connection,
        props,
      )
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByDiscussionboardpostidAndDiscussionboardreplyid.METADATA,
          path: getByDiscussionboardpostidAndDiscussionboardreplyid.path(props),
          status: null,
        },
      );
}
export namespace getByDiscussionboardpostidAndDiscussionboardreplyid {
  export type Props = {
    /** Unique identifier of the parent discussion board post */
    discussionBoardPostId: string & tags.Format<"uuid">;

    /** Unique identifier of the discussion board reply */
    discussionBoardReplyId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardDiscussionBoardReply;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/member/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies/:discussionBoardReplyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/discussionBoardPosts/${encodeURIComponent(props.discussionBoardPostId ?? "null")}/discussionBoardReplies/${encodeURIComponent(props.discussionBoardReplyId ?? "null")}`;
  export const random = (): IDiscussionBoardDiscussionBoardReply =>
    typia.random<IDiscussionBoardDiscussionBoardReply>();
  export const simulate = (
    connection: IConnection,
    props: getByDiscussionboardpostidAndDiscussionboardreplyid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByDiscussionboardpostidAndDiscussionboardreplyid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("discussionBoardPostId")(() =>
        typia.assert(props.discussionBoardPostId),
      );
      assert.param("discussionBoardReplyId")(() =>
        typia.assert(props.discussionBoardReplyId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing reply to a discussion board post.
 *
 * Update a reply to a discussion board post with validated content.
 *
 * This operation allows the reply author or an authorized moderator to update
 * the content of a reply. The reply content must be between 5 and 1000
 * characters and pass the system's profanity filter.
 *
 * Security is enforced so only the reply owner or moderators can perform this
 * update. The operation uses the discussion_board_replies table from the Prisma
 * schema, ensuring referential integrity to the parent post and member.
 *
 * The request body must conform to the
 * IDiscussionBoardDiscussionBoardReply.IUpdate DTO schema, ensuring correct
 * input validation. The response returns the updated reply entity with its full
 * details.
 *
 * Error scenarios include validation failures for content length or profanity,
 * unauthorized access, and resource not found errors if the reply or post does
 * not exist.
 *
 * @param props.connection
 * @param props.body Request body containing updated reply data
 * @path /discussionBoard/member/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies/:discussionBoardReplyId
 * @accessor api.functional.discussionBoard.member.discussionBoardPosts.discussionBoardReplies.putByDiscussionboardpostidAndDiscussionboardreplyid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putByDiscussionboardpostidAndDiscussionboardreplyid(
  connection: IConnection,
  props: putByDiscussionboardpostidAndDiscussionboardreplyid.Props,
): Promise<putByDiscussionboardpostidAndDiscussionboardreplyid.Response> {
  return true === connection.simulate
    ? putByDiscussionboardpostidAndDiscussionboardreplyid.simulate(
        connection,
        props,
      )
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByDiscussionboardpostidAndDiscussionboardreplyid.METADATA,
          path: putByDiscussionboardpostidAndDiscussionboardreplyid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putByDiscussionboardpostidAndDiscussionboardreplyid {
  export type Props = {
    discussionBoardPostId: string;
    discussionBoardReplyId: string;

    /** Request body containing updated reply data */
    body: IDiscussionBoardDiscussionBoardReply.IUpdate;
  };
  export type Body = IDiscussionBoardDiscussionBoardReply.IUpdate;
  export type Response = IDiscussionBoardDiscussionBoardReply;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/member/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies/:discussionBoardReplyId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/discussionBoardPosts/${encodeURIComponent(props.discussionBoardPostId ?? "null")}/discussionBoardReplies/${encodeURIComponent(props.discussionBoardReplyId ?? "null")}`;
  export const random = (): IDiscussionBoardDiscussionBoardReply =>
    typia.random<IDiscussionBoardDiscussionBoardReply>();
  export const simulate = (
    connection: IConnection,
    props: putByDiscussionboardpostidAndDiscussionboardreplyid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByDiscussionboardpostidAndDiscussionboardreplyid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("discussionBoardPostId")(() =>
        typia.assert(props.discussionBoardPostId),
      );
      assert.param("discussionBoardReplyId")(() =>
        typia.assert(props.discussionBoardReplyId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information of a specific reply for a discussion post.
 *
 * Retrieve a specific reply by its replyId associated with a particular post
 * identified by postId.
 *
 * This operation fetches the detailed reply including content, author, status,
 * and timestamps. It helps clients view detailed information about a reply in
 * the context of a specific discussion post.
 *
 * Security requires that only authenticated users with roles 'member',
 * 'moderator', or 'admin' can access this endpoint.
 *
 * This endpoint directly maps to the discussion_board_replies table and
 * respects soft deletion by ignoring replies marked as deleted.
 *
 * Clients should handle errors gracefully such as 404 Not Found or 403
 * Unauthorized.
 *
 * Related operations include listing replies for a post and creating new
 * replies under a post.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the target discussion post
 * @param props.replyId Unique identifier of the target reply
 * @path /discussionBoard/member/discussionBoardPosts/:postId/discussionBoardReplies/:replyId
 * @accessor api.functional.discussionBoard.member.discussionBoardPosts.discussionBoardReplies.getByPostidAndReplyid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getByPostidAndReplyid(
  connection: IConnection,
  props: getByPostidAndReplyid.Props,
): Promise<getByPostidAndReplyid.Response> {
  return true === connection.simulate
    ? getByPostidAndReplyid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByPostidAndReplyid.METADATA,
          path: getByPostidAndReplyid.path(props),
          status: null,
        },
      );
}
export namespace getByPostidAndReplyid {
  export type Props = {
    /** Unique identifier of the target discussion post */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the target reply */
    replyId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardDiscussionBoardReply;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/member/discussionBoardPosts/:postId/discussionBoardReplies/:replyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/discussionBoardPosts/${encodeURIComponent(props.postId ?? "null")}/discussionBoardReplies/${encodeURIComponent(props.replyId ?? "null")}`;
  export const random = (): IDiscussionBoardDiscussionBoardReply =>
    typia.random<IDiscussionBoardDiscussionBoardReply>();
  export const simulate = (
    connection: IConnection,
    props: getByPostidAndReplyid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByPostidAndReplyid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("replyId")(() => typia.assert(props.replyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a reply to a discussion board post.
 *
 * Update a reply to a specific discussion board post identified by postId and
 * replyId. This operation validates and updates the reply's content and status
 * fields according to discussion board business rules.
 *
 * Security considerations: Only authenticated members and moderators with edit
 * permissions may use this operation. Member edits are restricted to replies
 * they own and within 24 hours of creation, while moderators can edit any reply
 * at any time.
 *
 * This operation references the discussion_board_replies table, which stores
 * replies linked to posts and authors. It enforces content length restrictions
 * (5 to 1000 characters) and moderation status management.
 *
 * Validation rules require profanity filtering on the reply content before
 * acceptance.
 *
 * Related operations include creating new replies, deleting replies, and
 * managing posts.
 *
 * Error handling includes responding with authorization errors if the user
 * lacks permission, and validation errors if content does not meet criteria.
 *
 * @param props.connection
 * @param props.body Updated reply content and status
 * @path /discussionBoard/member/discussionBoardPosts/:postId/discussionBoardReplies/:replyId
 * @accessor api.functional.discussionBoard.member.discussionBoardPosts.discussionBoardReplies.putByPostidAndReplyid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putByPostidAndReplyid(
  connection: IConnection,
  props: putByPostidAndReplyid.Props,
): Promise<putByPostidAndReplyid.Response> {
  return true === connection.simulate
    ? putByPostidAndReplyid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByPostidAndReplyid.METADATA,
          path: putByPostidAndReplyid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putByPostidAndReplyid {
  export type Props = {
    postId: string;
    replyId: string;

    /** Updated reply content and status */
    body: IDiscussionBoardDiscussionBoardReplies.IUpdate;
  };
  export type Body = IDiscussionBoardDiscussionBoardReplies.IUpdate;
  export type Response = IDiscussionBoardDiscussionBoardReplies;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/member/discussionBoardPosts/:postId/discussionBoardReplies/:replyId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/discussionBoardPosts/${encodeURIComponent(props.postId ?? "null")}/discussionBoardReplies/${encodeURIComponent(props.replyId ?? "null")}`;
  export const random = (): IDiscussionBoardDiscussionBoardReplies =>
    typia.random<IDiscussionBoardDiscussionBoardReplies>();
  export const simulate = (
    connection: IConnection,
    props: putByPostidAndReplyid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByPostidAndReplyid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("replyId")(() => typia.assert(props.replyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new reply under a discussion board post.
 *
 * Create a new reply to a specified discussion board post.
 *
 * The reply content and associated member ID are required in the request body.
 * The operation validates content length and profanity externally, ensuring
 * that only appropriate replies are persisted.
 *
 * Authorization is restricted to authenticated members. Moderators and admins
 * can also create replies via member accounts.
 *
 * Upon success, the newly created reply resource with all its details (id,
 * content, timestamps, statuses) is returned as per the
 * IDiscussionBoardDiscussionBoardReply schema.
 *
 * This endpoint interacts with the discussion_board_replies table and links
 * replies to discussion_board_posts and discussion_board_members.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the parent discussion post where the
 *   reply will be added
 * @param props.body Information required to create a new reply
 * @path /discussionBoard/member/discussionBoardPosts/:postId/discussionBoardReplies
 * @accessor api.functional.discussionBoard.member.discussionBoardPosts.discussionBoardReplies.postByPostid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function postByPostid(
  connection: IConnection,
  props: postByPostid.Props,
): Promise<postByPostid.Response> {
  return true === connection.simulate
    ? postByPostid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...postByPostid.METADATA,
          path: postByPostid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace postByPostid {
  export type Props = {
    /**
     * Unique identifier of the parent discussion post where the reply will
     * be added
     */
    postId: string & tags.Format<"uuid">;

    /** Information required to create a new reply */
    body: IDiscussionBoardDiscussionBoardReply.ICreate;
  };
  export type Body = IDiscussionBoardDiscussionBoardReply.ICreate;
  export type Response = IDiscussionBoardDiscussionBoardReply;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/member/discussionBoardPosts/:postId/discussionBoardReplies",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/discussionBoardPosts/${encodeURIComponent(props.postId ?? "null")}/discussionBoardReplies`;
  export const random = (): IDiscussionBoardDiscussionBoardReply =>
    typia.random<IDiscussionBoardDiscussionBoardReply>();
  export const simulate = (
    connection: IConnection,
    props: postByPostid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: postByPostid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
