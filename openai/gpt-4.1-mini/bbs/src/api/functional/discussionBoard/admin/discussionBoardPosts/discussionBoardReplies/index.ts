import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardDiscussionBoardReply } from "../../../../../structures/IDiscussionBoardDiscussionBoardReply";

/**
 * Retrieve a specific discussion board reply by post and reply IDs.
 *
 * Retrieve an individual reply within a discussion board post, identified by
 * discussionBoardPostId and discussionBoardReplyId.
 *
 * This operation fetches the reply's detailed information from the
 * discussion_board_replies Prisma table.
 *
 * Security considerations include ensuring the requesting user has appropriate
 * access rights, typically requiring authentication as a member or higher
 * role.
 *
 * The retrieved data include the reply content, authoring member, status, and
 * timestamps. This facilitates display of the reply in UI discussions and
 * supports detailed reply inspection.
 *
 * No request body is required as this is a read operation.
 *
 * If the specified post or reply does not exist, the operation should return an
 * appropriate 404 error response.
 *
 * This endpoint complements other operations such as listing replies for a post
 * or managing replies via create/update/delete operations.
 *
 * @param props.connection
 * @param props.discussionBoardPostId Unique identifier of the parent discussion
 *   board post
 * @param props.discussionBoardReplyId Unique identifier of the discussion board
 *   reply
 * @path /discussionBoard/admin/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies/:discussionBoardReplyId
 * @accessor api.functional.discussionBoard.admin.discussionBoardPosts.discussionBoardReplies.getByDiscussionboardpostidAndDiscussionboardreplyid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getByDiscussionboardpostidAndDiscussionboardreplyid(
  connection: IConnection,
  props: getByDiscussionboardpostidAndDiscussionboardreplyid.Props,
): Promise<getByDiscussionboardpostidAndDiscussionboardreplyid.Response> {
  return true === connection.simulate
    ? getByDiscussionboardpostidAndDiscussionboardreplyid.simulate(
        connection,
        props,
      )
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByDiscussionboardpostidAndDiscussionboardreplyid.METADATA,
          path: getByDiscussionboardpostidAndDiscussionboardreplyid.path(props),
          status: null,
        },
      );
}
export namespace getByDiscussionboardpostidAndDiscussionboardreplyid {
  export type Props = {
    /** Unique identifier of the parent discussion board post */
    discussionBoardPostId: string & tags.Format<"uuid">;

    /** Unique identifier of the discussion board reply */
    discussionBoardReplyId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardDiscussionBoardReply;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/admin/discussionBoardPosts/:discussionBoardPostId/discussionBoardReplies/:discussionBoardReplyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/discussionBoardPosts/${encodeURIComponent(props.discussionBoardPostId ?? "null")}/discussionBoardReplies/${encodeURIComponent(props.discussionBoardReplyId ?? "null")}`;
  export const random = (): IDiscussionBoardDiscussionBoardReply =>
    typia.random<IDiscussionBoardDiscussionBoardReply>();
  export const simulate = (
    connection: IConnection,
    props: getByDiscussionboardpostidAndDiscussionboardreplyid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByDiscussionboardpostidAndDiscussionboardreplyid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("discussionBoardPostId")(() =>
        typia.assert(props.discussionBoardPostId),
      );
      assert.param("discussionBoardReplyId")(() =>
        typia.assert(props.discussionBoardReplyId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information of a specific reply for a discussion post.
 *
 * Retrieve a specific reply by its replyId associated with a particular post
 * identified by postId.
 *
 * This operation fetches the detailed reply including content, author, status,
 * and timestamps. It helps clients view detailed information about a reply in
 * the context of a specific discussion post.
 *
 * Security requires that only authenticated users with roles 'member',
 * 'moderator', or 'admin' can access this endpoint.
 *
 * This endpoint directly maps to the discussion_board_replies table and
 * respects soft deletion by ignoring replies marked as deleted.
 *
 * Clients should handle errors gracefully such as 404 Not Found or 403
 * Unauthorized.
 *
 * Related operations include listing replies for a post and creating new
 * replies under a post.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the target discussion post
 * @param props.replyId Unique identifier of the target reply
 * @path /discussionBoard/admin/discussionBoardPosts/:postId/discussionBoardReplies/:replyId
 * @accessor api.functional.discussionBoard.admin.discussionBoardPosts.discussionBoardReplies.getByPostidAndReplyid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getByPostidAndReplyid(
  connection: IConnection,
  props: getByPostidAndReplyid.Props,
): Promise<getByPostidAndReplyid.Response> {
  return true === connection.simulate
    ? getByPostidAndReplyid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByPostidAndReplyid.METADATA,
          path: getByPostidAndReplyid.path(props),
          status: null,
        },
      );
}
export namespace getByPostidAndReplyid {
  export type Props = {
    /** Unique identifier of the target discussion post */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the target reply */
    replyId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardDiscussionBoardReply;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/admin/discussionBoardPosts/:postId/discussionBoardReplies/:replyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/discussionBoardPosts/${encodeURIComponent(props.postId ?? "null")}/discussionBoardReplies/${encodeURIComponent(props.replyId ?? "null")}`;
  export const random = (): IDiscussionBoardDiscussionBoardReply =>
    typia.random<IDiscussionBoardDiscussionBoardReply>();
  export const simulate = (
    connection: IConnection,
    props: getByPostidAndReplyid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByPostidAndReplyid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("replyId")(() => typia.assert(props.replyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
