import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallReviewModeration } from "../../../../../structures/IShoppingMallReviewModeration";
import { IPageIShoppingMallReviewModeration } from "../../../../../structures/IPageIShoppingMallReviewModeration";

/**
 * Create a new review moderation record for a product review.
 *
 * Create a new administrative moderation record for a specific product review.
 *
 * The request must include the 'productReviewId' as a path parameter to specify
 * which product review is being moderated.
 *
 * Request body requires:
 *
 * - 'shopping_mall_admin_id': UUID of the administrator performing the
 *   moderation.
 * - 'action': The moderation action taken (e.g., 'approve', 'reject', 'flag').
 * - 'comment': Optional string comments for additional context.
 *
 * Authorization is restricted to admin users.
 *
 * Successful creation returns the created moderation record including
 * timestamps and linked review and admin information.
 *
 * This operation enables structured moderation workflows and audit trails for
 * product reviews within the platform.
 *
 * @param props.connection
 * @param props.productReviewId Unique identifier of the product review to
 *   moderate
 * @param props.body New review moderation record creation
 * @path /shoppingMall/admin/productReviews/:productReviewId/reviewModerations
 * @accessor api.functional.shoppingMall.admin.productReviews.reviewModerations.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the product review to moderate */
    productReviewId: string & tags.Format<"uuid">;

    /** New review moderation record creation */
    body: IShoppingMallReviewModeration.ICreate;
  };
  export type Body = IShoppingMallReviewModeration.ICreate;
  export type Response = IShoppingMallReviewModeration;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/productReviews/:productReviewId/reviewModerations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/productReviews/${encodeURIComponent(props.productReviewId ?? "null")}/reviewModerations`;
  export const random = (): IShoppingMallReviewModeration =>
    typia.random<IShoppingMallReviewModeration>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productReviewId")(() =>
        typia.assert(props.productReviewId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List moderation records for a product review.
 *
 * This API operation provides administrators with the ability to search and
 * retrieve paginated moderation records associated with a particular product
 * review. Moderation records include details of actions taken by admins such as
 * approvals, rejections, and flags, with timestamps and optional comments.
 *
 * The endpoint requires the product review ID as part of the path and a complex
 * search request in the body to support filtering and pagination. Access is
 * restricted to users with the 'admin' role.
 *
 * This resource relates to the 'shopping_mall_review_moderations' table as
 * defined in the Prisma schema, which stores detailed administrative moderation
 * histories for product reviews.
 *
 * A typical response includes paginated lists of moderation actions affecting a
 * single product review. Proper error handling is necessary for invalid IDs or
 * permission issues.
 *
 * @param props.connection
 * @param props.productReviewId Target product review's unique identifier
 * @param props.body Search criteria and pagination parameters for moderation
 *   records filtering
 * @path /shoppingMall/admin/productReviews/:productReviewId/reviewModerations
 * @accessor api.functional.shoppingMall.admin.productReviews.reviewModerations.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Target product review's unique identifier */
    productReviewId: string & tags.Format<"uuid">;

    /**
     * Search criteria and pagination parameters for moderation records
     * filtering
     */
    body: IShoppingMallReviewModeration.IRequest;
  };
  export type Body = IShoppingMallReviewModeration.IRequest;
  export type Response = IPageIShoppingMallReviewModeration;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/productReviews/:productReviewId/reviewModerations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/productReviews/${encodeURIComponent(props.productReviewId ?? "null")}/reviewModerations`;
  export const random = (): IPageIShoppingMallReviewModeration =>
    typia.random<IPageIShoppingMallReviewModeration>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productReviewId")(() =>
        typia.assert(props.productReviewId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific review moderation record by productReviewId and ID.
 *
 * Retrieve one specific administrative moderation record of a product review in
 * the shopping mall platform.
 *
 * This operation requires two path parameters: 'productReviewId' - the unique
 * identifier of the product review being moderated, and 'id' - the unique
 * identifier of the moderation record itself. These ensure precise retrieval of
 * the moderation record. Only authorized users with appropriate roles can
 * access moderation details.
 *
 * The 'shopping_mall_review_moderations' table stores records of moderation
 * actions taken by administrators, including approval, rejection, and related
 * comments. Each record links to a product review and the admin responsible.
 * This operation is essential for audit trails and transparency of review
 * moderation.
 *
 * Validation ensures the requested moderation record exists under the specified
 * product review. Errors are returned if not found or unauthorized.
 *
 * Related operations include creation of new moderation records when an admin
 * acts on a review, accessible through the POST operation on the moderation
 * collection.
 *
 * This retrieval operation returns complete moderation details suitable for
 * administrative dashboards or audit logs.
 *
 * @param props.connection
 * @param props.productReviewId Unique identifier of the product review being
 *   moderated
 * @param props.id Unique identifier of the review moderation record
 * @path /shoppingMall/admin/productReviews/:productReviewId/reviewModerations/:id
 * @accessor api.functional.shoppingMall.admin.productReviews.reviewModerations.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the product review being moderated */
    productReviewId: string & tags.Format<"uuid">;

    /** Unique identifier of the review moderation record */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallReviewModeration;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/productReviews/:productReviewId/reviewModerations/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/productReviews/${encodeURIComponent(props.productReviewId ?? "null")}/reviewModerations/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IShoppingMallReviewModeration =>
    typia.random<IShoppingMallReviewModeration>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productReviewId")(() =>
        typia.assert(props.productReviewId),
      );
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a product review moderation by ID for a specific product review.
 *
 * Update a specific product review moderation record identified by its unique
 * ID and associated product review ID. This operation allows admins to modify
 * the moderation action (like approve, reject, or flag) and add optional
 * comments. It refers to the shopping_mall_review_moderations table which
 * records administrative moderation actions on product reviews. Only authorized
 * admin users can perform this update. The operation also ensures proper
 * validation of input fields, preserves audit trail integrity, and adjusts
 * timestamps if needed.
 *
 * Security requires that only administrative users can update review moderation
 * records. The moderation record must exist and belong to the specified product
 * review. Updates to action and comments are validated against allowed values
 * and content policies. This operation complements the review moderation
 * retrieval and deletion endpoints and is essential for maintaining review
 * content quality.
 *
 * Expected behavior includes validation of the existence of IDs, permission
 * checking, and propagation of updated moderation status to related product
 * reviews if applicable. Errors include 404 if record not found, 403 if
 * unauthorized, and 400 for validation failures.
 *
 * No request body besides the permissible fields for update is expected, and
 * the response includes the updated review moderation record object.
 *
 * @param props.connection
 * @param props.productReviewId ID of the product review associated with the
 *   moderation
 * @param props.id ID of the review moderation record to update
 * @param props.body Updated information for the product review moderation
 * @path /shoppingMall/admin/productReviews/:productReviewId/reviewModerations/:id
 * @accessor api.functional.shoppingMall.admin.productReviews.reviewModerations.updateReviewModeration
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateReviewModeration(
  connection: IConnection,
  props: updateReviewModeration.Props,
): Promise<updateReviewModeration.Response> {
  return true === connection.simulate
    ? updateReviewModeration.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateReviewModeration.METADATA,
          path: updateReviewModeration.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateReviewModeration {
  export type Props = {
    /** ID of the product review associated with the moderation */
    productReviewId: string & tags.Format<"uuid">;

    /** ID of the review moderation record to update */
    id: string & tags.Format<"uuid">;

    /** Updated information for the product review moderation */
    body: IShoppingMallReviewModeration.IUpdate;
  };
  export type Body = IShoppingMallReviewModeration.IUpdate;
  export type Response = IShoppingMallReviewModeration;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/productReviews/:productReviewId/reviewModerations/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/productReviews/${encodeURIComponent(props.productReviewId ?? "null")}/reviewModerations/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IShoppingMallReviewModeration =>
    typia.random<IShoppingMallReviewModeration>();
  export const simulate = (
    connection: IConnection,
    props: updateReviewModeration.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateReviewModeration.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productReviewId")(() =>
        typia.assert(props.productReviewId),
      );
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a product review moderation by ID for a specific product review.
 *
 * Delete a specific product review moderation record by ID linked to a product
 * review given by productReviewId. This operation permanently removes the
 * record from the database and cleans up related audit trails. It is critical
 * that only authorized admin users can perform deletions to maintain content
 * moderation integrity.
 *
 * This operation corresponds to a hard delete; the record is completely erased
 * and cannot be restored. It should be used with caution. The operation
 * complements retrieval, creation, and update endpoints of review moderations.
 *
 * Expected errors include 404 if the record does not exist or 403 if the
 * requester lacks proper permissions.
 *
 * No request body is required for this operation, and no response body is
 * returned upon successful deletion.
 *
 * Security best practices enforce strict role-based access and audit trail
 * logging of deletions.
 *
 * @param props.connection
 * @param props.productReviewId ID of the product review associated with the
 *   moderation
 * @param props.id ID of the review moderation record to delete
 * @path /shoppingMall/admin/productReviews/:productReviewId/reviewModerations/:id
 * @accessor api.functional.shoppingMall.admin.productReviews.reviewModerations.eraseReviewModeration
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseReviewModeration(
  connection: IConnection,
  props: eraseReviewModeration.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseReviewModeration.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseReviewModeration.METADATA,
          path: eraseReviewModeration.path(props),
          status: null,
        },
      );
}
export namespace eraseReviewModeration {
  export type Props = {
    /** ID of the product review associated with the moderation */
    productReviewId: string & tags.Format<"uuid">;

    /** ID of the review moderation record to delete */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/productReviews/:productReviewId/reviewModerations/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/productReviews/${encodeURIComponent(props.productReviewId ?? "null")}/reviewModerations/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseReviewModeration.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseReviewModeration.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productReviewId")(() =>
        typia.assert(props.productReviewId),
      );
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
