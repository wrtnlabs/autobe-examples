import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallRefundRequest } from "../../../../../structures/IShoppingMallRefundRequest";

/**
 * Create refund request for an order.
 *
 * Create a new refund request for the specified order on behalf of a customer.
 * This operation validates that the order exists and that the customer is
 * authorized to initiate a refund request. The refund request includes the
 * reason for refund and the requested refund amount, both required for
 * processing. The initial status of the refund request will be set to 'pending'
 * and await review and approval by administrators. Security measures ensure
 * that only authenticated customers with legitimate orders can perform this
 * action.
 *
 * This operation directly manipulates the shopping_mall_refund_requests table
 * in Prisma schema. It enforces business rules that refunds can only be
 * requested on existing orders that belong to the requesting customer.
 *
 * Expected behavior includes validation errors if the order does not exist or
 * does not belong to the customer, and successful creation returns the new
 * refund request record.
 *
 * No response body is provided on creation to minimize exposure of refund
 * details. Confirmation is conveyed by HTTP status code 201 Created.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the target order
 * @param props.body Information required to create a refund request
 * @path /shoppingMall/customer/orders/:orderId/refundRequests
 * @accessor api.functional.shoppingMall.customer.orders.refundRequests.createRefundRequest
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createRefundRequest(
  connection: IConnection,
  props: createRefundRequest.Props,
): Promise<void> {
  return true === connection.simulate
    ? createRefundRequest.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createRefundRequest.METADATA,
          path: createRefundRequest.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace createRefundRequest {
  export type Props = {
    /** Unique identifier of the target order */
    orderId: string & tags.Format<"uuid">;

    /** Information required to create a refund request */
    body: IShoppingMallRefundRequest.ICreate;
  };
  export type Body = IShoppingMallRefundRequest.ICreate;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/orders/:orderId/refundRequests",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/refundRequests`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: createRefundRequest.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createRefundRequest.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a refund request for the specified order.
 *
 * Update an existing refund request associated with a given order. This
 * operation targets the shopping_mall_refund_requests table, which captures
 * refund requests initiated by customers for order refunds.
 *
 * The update request allows authorized users, such as the refund request owner
 * or an admin, to modify refund details like status and processing timestamps.
 * Validation includes verifying permission to update the refund request and
 * ensuring data integrity.
 *
 * This operation enables refund request management as part of the order
 * lifecycle, supporting workflows like approval, rejection, or processing
 * progress updates.
 *
 * Proper error handling is expected when invalid updates or unauthorized
 * attempts are made.
 *
 * It complements refund request retrieval to ensure full management of refund
 * records associated with orders.
 *
 * @param props.connection
 * @param props.orderId Target order's unique identifier
 * @param props.body Refund request update payload
 * @path /shoppingMall/customer/orders/:orderId/refundRequests
 * @accessor api.functional.shoppingMall.customer.orders.refundRequests.patchByOrderid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patchByOrderid(
  connection: IConnection,
  props: patchByOrderid.Props,
): Promise<patchByOrderid.Response> {
  return true === connection.simulate
    ? patchByOrderid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patchByOrderid.METADATA,
          path: patchByOrderid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace patchByOrderid {
  export type Props = {
    /** Target order's unique identifier */
    orderId: string & tags.Format<"uuid">;

    /** Refund request update payload */
    body: IShoppingMallRefundRequest.IUpdate;
  };
  export type Body = IShoppingMallRefundRequest.IUpdate;
  export type Response = IShoppingMallRefundRequest;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/orders/:orderId/refundRequests",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/refundRequests`;
  export const random = (): IShoppingMallRefundRequest =>
    typia.random<IShoppingMallRefundRequest>();
  export const simulate = (
    connection: IConnection,
    props: patchByOrderid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patchByOrderid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed refund request information by order ID and refund request
 * ID.
 *
 * Retrieve detailed information of a specific refund request associated with an
 * order. This operation targets the shopping_mall_refund_requests table, which
 * captures refund requests initiated by customers for their orders.
 *
 * The refund request includes the reason, requested refund amount, current
 * status (e.g., pending, approved, rejected), and timestamps for request and
 * processing. The operation provides comprehensive data for administrative
 * review and customer service.
 *
 * Security considerations include restricting access to users with appropriate
 * roles authorized to view refund details, such as admins or the customer who
 * submitted the request. Sensitive financial data such as refund amount and
 * payment method details are included.
 *
 * Validation ensures that both orderId and refundRequestId are valid UUIDs
 * corresponding to existing records, rejecting invalid or unauthorized access
 * requests. Related order and customer information can be queried separately as
 * needed.
 *
 * This API operation complements refund request creation and processing
 * endpoints, enabling a full lifecycle view of refund management within the
 * shopping mall platform.
 *
 * @param props.connection
 * @param props.orderId Target order's unique identifier
 * @param props.refundRequestId Specific refund request's unique identifier
 * @path /shoppingMall/customer/orders/:orderId/refundRequests/:refundRequestId
 * @accessor api.functional.shoppingMall.customer.orders.refundRequests.atRefundRequest
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atRefundRequest(
  connection: IConnection,
  props: atRefundRequest.Props,
): Promise<atRefundRequest.Response> {
  return true === connection.simulate
    ? atRefundRequest.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atRefundRequest.METADATA,
          path: atRefundRequest.path(props),
          status: null,
        },
      );
}
export namespace atRefundRequest {
  export type Props = {
    /** Target order's unique identifier */
    orderId: string & tags.Format<"uuid">;

    /** Specific refund request's unique identifier */
    refundRequestId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallRefundRequest;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/orders/:orderId/refundRequests/:refundRequestId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/refundRequests/${encodeURIComponent(props.refundRequestId ?? "null")}`;
  export const random = (): IShoppingMallRefundRequest =>
    typia.random<IShoppingMallRefundRequest>();
  export const simulate = (
    connection: IConnection,
    props: atRefundRequest.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atRefundRequest.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("refundRequestId")(() =>
        typia.assert(props.refundRequestId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update refund request for an order.
 *
 * Update details of a specific refund request associated with an order. This
 * enables modification of the refund reason, amount, and status (such as
 * approving or rejecting the refund). Input validation verifies that the refund
 * request exists and belongs to the authenticated user.
 *
 * The updated refund request is persisted to the shopping_mall_refund_requests
 * table in Prisma schema. Authorization is checked to ensure only the owning
 * customer or authorized personnel can update the request. No response content
 * is returned to reduce exposure of sensitive refund information.
 *
 * This operation supports the refund management lifecycle and integrates with
 * administrative refund approval processes.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the target order
 * @param props.refundRequestId Unique identifier of the target refund request
 * @param props.body Information for updating a refund request
 * @path /shoppingMall/customer/orders/:orderId/refundRequests/:refundRequestId
 * @accessor api.functional.shoppingMall.customer.orders.refundRequests.putByOrderidAndRefundrequestid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putByOrderidAndRefundrequestid(
  connection: IConnection,
  props: putByOrderidAndRefundrequestid.Props,
): Promise<void> {
  return true === connection.simulate
    ? putByOrderidAndRefundrequestid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByOrderidAndRefundrequestid.METADATA,
          path: putByOrderidAndRefundrequestid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putByOrderidAndRefundrequestid {
  export type Props = {
    /** Unique identifier of the target order */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the target refund request */
    refundRequestId: string & tags.Format<"uuid">;

    /** Information for updating a refund request */
    body: IShoppingMallRefundRequest.IUpdate;
  };
  export type Body = IShoppingMallRefundRequest.IUpdate;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/orders/:orderId/refundRequests/:refundRequestId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/refundRequests/${encodeURIComponent(props.refundRequestId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: putByOrderidAndRefundrequestid.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByOrderidAndRefundrequestid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("refundRequestId")(() =>
        typia.assert(props.refundRequestId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific refund request for an order.
 *
 * This operation deletes a refund request record in the shopping mall platform
 * database. It requires both the order ID and refund request ID to uniquely
 * identify the refund request to delete. Upon execution, the refund request
 * linked to the specified order is permanently removed from the database and
 * cannot be recovered.
 *
 * Authorization is required: typically, only customers linked to the order or
 * administrators with proper permissions may perform this action.
 *
 * As per the Prisma database schema, shopping_mall_refund_requests is a main
 * entity tracking refund requests with properties such as refund amount,
 * reason, status, and timestamps. Deleting a refund request reflects that the
 * refund claim is cancelled or invalidated.
 *
 * No request body is needed as the operation is identified fully via the path
 * parameters. No response body is returned on success.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order
 * @param props.refundRequestId Unique identifier of the refund request to be
 *   deleted
 * @path /shoppingMall/customer/orders/:orderId/refundRequests/:refundRequestId
 * @accessor api.functional.shoppingMall.customer.orders.refundRequests.eraseRefundRequest
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseRefundRequest(
  connection: IConnection,
  props: eraseRefundRequest.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseRefundRequest.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseRefundRequest.METADATA,
          path: eraseRefundRequest.path(props),
          status: null,
        },
      );
}
export namespace eraseRefundRequest {
  export type Props = {
    /** Unique identifier of the order */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the refund request to be deleted */
    refundRequestId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/orders/:orderId/refundRequests/:refundRequestId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/refundRequests/${encodeURIComponent(props.refundRequestId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseRefundRequest.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseRefundRequest.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("refundRequestId")(() =>
        typia.assert(props.refundRequestId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
