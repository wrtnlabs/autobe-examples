import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallWishlistItem } from "../../../../../structures/IShoppingMallWishlistItem";
import { IPageIShoppingMallWishlistItem } from "../../../../../structures/IPageIShoppingMallWishlistItem";

/**
 * Create a new wishlist item under specific wishlist.
 *
 * Create a new wishlist item in a specific wishlist owned by the authenticated
 * customer.
 *
 * Request body must include the SKU id to be added.
 *
 * The system validates that the SKU exists and the wishlist belongs to the
 * authenticated customer.
 *
 * On success, returns the created wishlist item including identifiers and
 * timestamps.
 *
 * Only the owning customer may perform this operation.
 *
 * No direct request body or parameters other than wishlistId to identify the
 * wishlist.
 *
 * Returns the created wishlist item entity.
 *
 * @param props.connection
 * @param props.wishlistId Unique identifier of the target wishlist
 * @param props.body Data payload for adding a wishlist item
 * @path /shoppingMall/customer/wishlists/:wishlistId/wishlistItems
 * @accessor api.functional.shoppingMall.customer.wishlists.wishlistItems.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the target wishlist */
    wishlistId: string & tags.Format<"uuid">;

    /** Data payload for adding a wishlist item */
    body: IShoppingMallWishlistItem.ICreate;
  };
  export type Body = IShoppingMallWishlistItem.ICreate;
  export type Response = IShoppingMallWishlistItem;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/wishlists/:wishlistId/wishlistItems",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}/wishlistItems`;
  export const random = (): IShoppingMallWishlistItem =>
    typia.random<IShoppingMallWishlistItem>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and update shopping mall wishlist items.
 *
 * Search and update items in a specific shopping mall wishlist identified by
 * wishlistId. This operation allows clients to retrieve a filtered and
 * paginated list of wishlist items, and perform batch updates on the wishlist
 * contents if supported.
 *
 * The operation manipulates the shopping_mall_wishlist_items table which holds
 * individual SKU items for each wishlist. Authorization restricts access to the
 * wishlist owner.
 *
 * Request parameters specify filtering options such as SKU, quantity ranges, or
 * pagination details. The response delivers a page of wishlist items reflecting
 * current data after updates.
 *
 * Clients can use this endpoint to synchronize UI wishlist views and perform
 * bulk wishlist item modifications as needed.
 *
 * Refer to the Prisma schema for detailed column and relation descriptions for
 * wishlist items.
 *
 * @param props.connection
 * @param props.wishlistId Unique identifier of the wishlist whose items are
 *   managed
 * @param props.body Search criteria and update instructions for wishlist items
 * @path /shoppingMall/customer/wishlists/:wishlistId/wishlistItems
 * @accessor api.functional.shoppingMall.customer.wishlists.wishlistItems.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the wishlist whose items are managed */
    wishlistId: string & tags.Format<"uuid">;

    /** Search criteria and update instructions for wishlist items */
    body: IShoppingMallWishlistItem.IRequest;
  };
  export type Body = IShoppingMallWishlistItem.IRequest;
  export type Response = IPageIShoppingMallWishlistItem;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/wishlists/:wishlistId/wishlistItems",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}/wishlistItems`;
  export const random = (): IPageIShoppingMallWishlistItem =>
    typia.random<IPageIShoppingMallWishlistItem>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific wishlist item by wishlistId and wishlistItemId.
 *
 * Retrieve detailed information about a specific wishlist item belonging to a
 * customer's wishlist. This item represents a SKU variant saved by a customer
 * for potential future purchase.
 *
 * Security considerations require that only the authenticated customer owning
 * the wishlist may access this item.
 *
 * The operation references the shopping_mall_wishlist_items model, including
 * fields such as the wishlist identifier, SKU identifier, creation and update
 * timestamps.
 *
 * Parameters:
 *
 * - WishlistId: UUID of the customer's wishlist
 * - WishlistItemId: UUID of the specific wishlist item
 *
 * No request body is needed.
 *
 * On success, returns the full wishlist item data.
 *
 * Errors return appropriate HTTP status codes such as 404 for not found, or 403
 * for unauthorized access.
 *
 * @param props.connection
 * @param props.wishlistId Unique identifier of the target wishlist
 * @param props.wishlistItemId Unique identifier of the target wishlist item
 * @path /shoppingMall/customer/wishlists/:wishlistId/wishlistItems/:wishlistItemId
 * @accessor api.functional.shoppingMall.customer.wishlists.wishlistItems.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target wishlist */
    wishlistId: string & tags.Format<"uuid">;

    /** Unique identifier of the target wishlist item */
    wishlistItemId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallWishlistItem;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/wishlists/:wishlistId/wishlistItems/:wishlistItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}/wishlistItems/${encodeURIComponent(props.wishlistItemId ?? "null")}`;
  export const random = (): IShoppingMallWishlistItem =>
    typia.random<IShoppingMallWishlistItem>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
      assert.param("wishlistItemId")(() => typia.assert(props.wishlistItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific wishlist item in a wishlist.
 *
 * Update a wishlist item identified by wishlistId and wishlistItemId. This
 * operation enables an authenticated customer to modify the SKU associated with
 * the wishlist item and update any relevant metadata such as timestamps.
 *
 * This operation enforces that only the owning customer may update their
 * wishlist items. It validates the existence and active status of the
 * referenced SKU variant. This ensures customers can manage their wishlists
 * effectively with accurate and up-to-date product variant references.
 *
 * The operation updates timestamps to reflect changes and maintains referential
 * integrity with the parent wishlist and SKU entities.
 *
 * Successful responses return the fully updated wishlist item entity. Failure
 * cases include invalid identifiers, unauthorized access, or schema validation
 * failures.
 *
 * @param props.connection
 * @param props.wishlistId Target wishlist's ID
 * @param props.wishlistItemId Target wishlist item's ID
 * @param props.body Fields for updating a wishlist item
 * @path /shoppingMall/customer/wishlists/:wishlistId/wishlistItems/:wishlistItemId
 * @accessor api.functional.shoppingMall.customer.wishlists.wishlistItems.updateWishlistItem
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateWishlistItem(
  connection: IConnection,
  props: updateWishlistItem.Props,
): Promise<updateWishlistItem.Response> {
  return true === connection.simulate
    ? updateWishlistItem.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateWishlistItem.METADATA,
          path: updateWishlistItem.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateWishlistItem {
  export type Props = {
    /** Target wishlist's ID */
    wishlistId: string & tags.Format<"uuid">;

    /** Target wishlist item's ID */
    wishlistItemId: string & tags.Format<"uuid">;

    /** Fields for updating a wishlist item */
    body: IShoppingMallWishlistItem.IUpdate;
  };
  export type Body = IShoppingMallWishlistItem.IUpdate;
  export type Response = IShoppingMallWishlistItem;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/wishlists/:wishlistId/wishlistItems/:wishlistItemId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}/wishlistItems/${encodeURIComponent(props.wishlistItemId ?? "null")}`;
  export const random = (): IShoppingMallWishlistItem =>
    typia.random<IShoppingMallWishlistItem>();
  export const simulate = (
    connection: IConnection,
    props: updateWishlistItem.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateWishlistItem.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
      assert.param("wishlistItemId")(() => typia.assert(props.wishlistItemId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific wishlist item in a wishlist.
 *
 * Delete a wishlist item from the specified wishlist. This operation
 * permanently removes the wishlist item record from the database. Only the
 * authenticated owning customer with the customer role is authorized to perform
 * this deletion.
 *
 * Referential integrity is ensured via composite identification of wishlist and
 * wishlist item IDs.
 *
 * Successful deletion returns no content, conforming to RESTful API standards.
 *
 * Failure scenarios include invalid IDs, unauthorized access, or non-existent
 * items.
 *
 * @param props.connection
 * @param props.wishlistId Target wishlist's ID
 * @param props.wishlistItemId Target wishlist item's ID
 * @path /shoppingMall/customer/wishlists/:wishlistId/wishlistItems/:wishlistItemId
 * @accessor api.functional.shoppingMall.customer.wishlists.wishlistItems.eraseWishlistItem
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseWishlistItem(
  connection: IConnection,
  props: eraseWishlistItem.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseWishlistItem.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseWishlistItem.METADATA,
          path: eraseWishlistItem.path(props),
          status: null,
        },
      );
}
export namespace eraseWishlistItem {
  export type Props = {
    /** Target wishlist's ID */
    wishlistId: string & tags.Format<"uuid">;

    /** Target wishlist item's ID */
    wishlistItemId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/wishlists/:wishlistId/wishlistItems/:wishlistItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/wishlists/${encodeURIComponent(props.wishlistId ?? "null")}/wishlistItems/${encodeURIComponent(props.wishlistItemId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseWishlistItem.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseWishlistItem.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("wishlistId")(() => typia.assert(props.wishlistId));
      assert.param("wishlistItemId")(() => typia.assert(props.wishlistItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
