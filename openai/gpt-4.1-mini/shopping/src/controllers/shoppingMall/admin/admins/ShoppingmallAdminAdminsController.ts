import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallAdminAdmins } from "../../../../providers/postShoppingMallAdminAdmins";
import { AdminAuth } from "../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../decorators/payload/AdminPayload";
import { patchShoppingMallAdminAdmins } from "../../../../providers/patchShoppingMallAdminAdmins";
import { getShoppingMallAdminAdminsId } from "../../../../providers/getShoppingMallAdminAdminsId";
import { putShoppingMallAdminAdminsId } from "../../../../providers/putShoppingMallAdminAdminsId";
import { deleteShoppingMallAdminAdminsId } from "../../../../providers/deleteShoppingMallAdminAdminsId";

import { IShoppingMallAdmin } from "../../../../api/structures/IShoppingMallAdmin";
import { IPageIShoppingMallAdmin } from "../../../../api/structures/IPageIShoppingMallAdmin";

@Controller("/shoppingMall/admin/admins")
export class ShoppingmallAdminAdminsController {
  /**
   * Create new administrator account in shopping_mall_admins.
   *
   * Create a new administrator account with the provided information in the
   * request body.
   *
   * The operation requires admin-level authorization for security.
   *
   * It accepts all required fields to create a new admin user: unique email,
   * hashed password, optional full name and phone number, and status.
   *
   * Email uniqueness and password security must be enforced during creation.
   *
   * Successful creation returns the full admin account details including unique
   * ID and timestamps.
   *
   * Errors such as conflict on email duplication or validation failures must be
   * handled gracefully.
   *
   * This operation supports the expansion of admin personnel in the shopping
   * mall platform.
   *
   * @param connection
   * @param body Creation info of the administrator account
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @AdminAuth()
    admin: AdminPayload,
    @TypedBody()
    body: IShoppingMallAdmin.ICreate,
  ): Promise<IShoppingMallAdmin> {
    try {
      return await postShoppingMallAdminAdmins({
        admin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and retrieve a filtered, paginated list of admin users.
   *
   * Retrieve a filtered and paginated list of admin user accounts from the
   * system. This operation allows searching by email, filtering by account
   * status, and sorting results.
   *
   * Security considerations require at least administrative role access to
   * protect sensitive user account details.
   *
   * The operation interacts with the shopping_mall_admins table, incorporating
   * columns like email, status, full name, and creation date.
   *
   * The request body includes advanced search parameters, and the response body
   * returns a paginated collection of summarized administrator information.
   *
   * @param connection
   * @param body Search criteria and pagination parameters for admin user
   *   filtering
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AdminAuth()
    admin: AdminPayload,
    @TypedBody()
    body: IShoppingMallAdmin.IRequest,
  ): Promise<IPageIShoppingMallAdmin.ISummary> {
    try {
      return await patchShoppingMallAdminAdmins({
        admin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve detailed administrator information by ID from
   * shopping_mall_admins.
   *
   * Retrieve detailed information about a specific administrator identified by
   * the unique ID from the shopping_mall_admins table.
   *
   * This operation requires authorization and is restricted to users with the
   * admin role to ensure sensitive administrator data is protected.
   *
   * The response includes all available administrator fields including email,
   * full name, contact phone number, account status, and audit timestamps for
   * tracking changes over time.
   *
   * Path parameter 'id' corresponds to the primary key of the
   * shopping_mall_admins table.
   *
   * Errors such as not found or unauthorized access should be handled by the
   * system robustly.
   *
   * This operation is essential for administrative user management and
   * auditing.
   *
   * @param connection
   * @param id Unique identifier of the target administrator
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":id")
  public async at(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("id")
    id: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallAdmin> {
    try {
      return await getShoppingMallAdminAdminsId({
        admin,
        id,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update administrator account by ID.
   *
   * Update an existing administrator account's information by specifying the
   * admin's unique ID. This operation modifies the admin's full name, phone
   * number, status, and password hash, allowing administrators to manage their
   * own profile or other admin accounts with sufficient permissions.
   *
   * Security considerations mandate authenticated admin role access only. Email
   * addresses are immutable through this endpoint to maintain identity
   * integrity. The status field indicates account activity state, which affects
   * login permissions.
   *
   * This API interacts directly with the shopping_mall_admins Prisma table,
   * respecting all relational and soft deletion logic. Updates to the password
   * hash must follow security protocols outside this API scope.
   *
   * Typical usage scenarios include admin profile updates and account status
   * changes. Validation errors will be returned if provided input values are
   * invalid or violate unique constraints.
   *
   * No request body changes other than defined fields are permitted. Error
   * handling includes proper HTTP status codes and messages for unauthorized
   * access or resource not found.
   *
   * @param connection
   * @param id Unique identifier of the administrator
   * @param body Updated administrator account data
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":id")
  public async updateAdmin(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("id")
    id: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallAdmin.IUpdate,
  ): Promise<IShoppingMallAdmin> {
    try {
      return await putShoppingMallAdminAdminsId({
        admin,
        id,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Permanently delete administrator account by ID.
   *
   * Delete an administrator account by ID, permanently removing the record from
   * the database. This endpoint ensures that administrative accounts no longer
   * needed are fully erased from the system.
   *
   * Security considerations require authenticated admin role access only, with
   * elevated privileges to perform this destructive action. The operation does
   * not allow soft deletion, so the record is completely removed, which means
   * no recovery is possible after this action.
   *
   * This API interacts with the shopping_mall_admins table respecting database
   * integrity constraints and cascading effects if applicable.
   *
   * Common error scenarios include attempting to delete a non-existent admin or
   * lack of sufficient authorization.
   *
   * @param connection
   * @param id Unique identifier of the administrator
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":id")
  public async eraseAdmin(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("id")
    id: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallAdminAdminsId({
        admin,
        id,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
