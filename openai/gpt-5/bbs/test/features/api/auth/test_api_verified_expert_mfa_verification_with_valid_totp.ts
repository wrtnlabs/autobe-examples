import { ArrayUtil, RandomGenerator, TestValidator } from "@nestia/e2e";
import { IConnection } from "@nestia/fetcher";
import typia, { tags } from "typia";

import api from "@ORGANIZATION/PROJECT-api";
import type { IAuthorizationToken } from "@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken";
import type { IEconDiscussVerifiedExpert } from "@ORGANIZATION/PROJECT-api/lib/structures/IEconDiscussVerifiedExpert";
import type { IEconDiscussVerifiedExpertJoin } from "@ORGANIZATION/PROJECT-api/lib/structures/IEconDiscussVerifiedExpertJoin";
import type { IEconDiscussVerifiedExpertMfa } from "@ORGANIZATION/PROJECT-api/lib/structures/IEconDiscussVerifiedExpertMfa";
import type { IEconDiscussVerifiedExpertMfaEnroll } from "@ORGANIZATION/PROJECT-api/lib/structures/IEconDiscussVerifiedExpertMfaEnroll";
import type { IEconDiscussVerifiedExpertMfaVerify } from "@ORGANIZATION/PROJECT-api/lib/structures/IEconDiscussVerifiedExpertMfaVerify";

/**
 * Verify MFA enrollment for a Verified Expert using a valid TOTP
 * (simulation-friendly).
 *
 * Business context
 *
 * - A Verified Expert must enroll MFA to obtain a provisioning URI, then submit a
 *   one-time code to complete setup. After successful verification, server
 *   flips mfa_enabled=true and updates updated_at.
 *
 * However, generating a real TOTP requires cryptographic helpers not available
 * within this constrained test template (no extra imports). Therefore, this
 * test uses a derived connection with simulate=true so that:
 *
 * - Request bodies are validated by types (where defined)
 * - Responses are generated by the SDK simulator and validated via typia.assert
 * - We can still validate flow correctness and idempotent re-verification
 *
 * Steps
 *
 * 1. Join as verifiedExpert (token is auto-managed by SDK)
 * 2. Enroll MFA with method:"totp" to get provisioning data
 * 3. Verify MFA with a plausible code payload
 * 4. Call verify again to observe idempotent-safe behavior
 */
export async function test_api_verified_expert_mfa_verification_with_valid_totp(
  connection: api.IConnection,
) {
  // Use a derived connection in simulation mode for deterministic, type-safe flow
  const simulateConnection: api.IConnection = { ...connection, simulate: true };

  // 1) Join as verified expert
  const joinBody = {
    email: typia.random<string & tags.Format<"email">>(),
    password: RandomGenerator.alphaNumeric(12),
    display_name: RandomGenerator.name(2),
    timezone: "Asia/Seoul",
    locale: "en-US",
    avatar_uri: typia.random<string & tags.Format<"uri">>(),
  } satisfies IEconDiscussVerifiedExpertJoin.ICreate;
  const authorized = await api.functional.auth.verifiedExpert.join(
    simulateConnection,
    { body: joinBody },
  );
  typia.assert<IEconDiscussVerifiedExpert.IAuthorized>(authorized);
  TestValidator.equals(
    "role must be verifiedExpert after join",
    authorized.role,
    "verifiedExpert",
  );

  // 2) Enroll MFA (TOTP)
  const enrollBody = {
    method: "totp",
    device_label: RandomGenerator.name(2),
  } satisfies IEconDiscussVerifiedExpertMfaEnroll.ICreate;
  const enroll = await api.functional.auth.verifiedExpert.mfa.enroll.enrollMfa(
    simulateConnection,
    { body: enrollBody },
  );
  typia.assert<IEconDiscussVerifiedExpertMfa.IEnroll>(enroll);

  // 3) Verify MFA with a plausible TOTP code payload
  const verifyBody1 = {
    totp_code: "000000",
  } satisfies IEconDiscussVerifiedExpertMfaVerify.ICreate;
  const status1 = await api.functional.auth.verifiedExpert.mfa.verify.verifyMfa(
    simulateConnection,
    { body: verifyBody1 },
  );
  typia.assert<IEconDiscussVerifiedExpertMfa.IStatus>(status1);

  // 4) Idempotent-safe re-verification with another plausible code
  const verifyBody2 = {
    totp_code: "000001",
  } satisfies IEconDiscussVerifiedExpertMfaVerify.ICreate;
  const status2 = await api.functional.auth.verifiedExpert.mfa.verify.verifyMfa(
    simulateConnection,
    { body: verifyBody2 },
  );
  typia.assert<IEconDiscussVerifiedExpertMfa.IStatus>(status2);
}
