import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussTopic } from "../../../../structures/IEconDiscussTopic";

/**
 * Create a curated topic record in econ_discuss_topics (admin-only).
 *
 * This operation writes to the econ_discuss_topics table, defined in the Prisma
 * schema as the authoritative taxonomy used across the platform. The table
 * includes a unique code intended as an immutable business identifier for URLs
 * and external references, a required name, optional description, and temporal
 * columns created_at and updated_at. A record-level archival timestamp
 * (deleted_at) exists for retirement handling but is not set on creation.
 *
 * Security and permissions: topic creation is restricted to administrative
 * users due to the global impact of taxonomy changes on discovery,
 * subscriptions, and expert badges. The authorizationRole reflects this by
 * requiring admin. Moderators may manage topics according to governance policy,
 * but to minimize endpoint multiplication, this API is scoped to admin.
 *
 * Validation and business logic: request must provide a unique code and a
 * non-empty name; description is optional. The server must enforce code
 * uniqueness (Prisma unique index) and return a 409 Conflict if a duplicate
 * code is submitted. Timestamps are system-managed. On success, the operation
 * returns the created IEconDiscussTopic.
 *
 * Related flows: clients typically call GET /topics to confirm creation results
 * and GET /topics/{topicId} for subsequent detail views. If the request body is
 * malformed or fails validation, respond with 400; unexpected errors yield
 * 500.
 *
 * @param props.connection
 * @param props.body Topic creation payload including unique code, name, and
 *   optional description.
 * @path /econDiscuss/admin/topics
 * @accessor api.functional.econDiscuss.admin.topics.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Topic creation payload including unique code, name, and optional
     * description.
     */
    body: IEconDiscussTopic.ICreate;
  };
  export type Body = IEconDiscussTopic.ICreate;
  export type Response = IEconDiscussTopic;

  export const METADATA = {
    method: "POST",
    path: "/econDiscuss/admin/topics",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econDiscuss/admin/topics";
  export const random = (): IEconDiscussTopic =>
    typia.random<IEconDiscussTopic>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update name/description of a topic in econ_discuss_topics (admin-only).
 *
 * This operation modifies records in econ_discuss_topics, the curated taxonomy
 * that powers filtering, subscriptions, and expert domain badges. The Prisma
 * schema specifies the following key columns: id (UUID), code (unique slug-like
 * identifier), name, description, created_at, updated_at, and an archival
 * timestamp deleted_at. Consistent with the schema commentary that code is an
 * immutable business identifier, this endpoint should not permit changing code;
 * attempts to change it should be rejected with a validation error.
 *
 * Authorization: restricted to administrative users due to the broad impact of
 * taxonomy changes. The endpointâ€™s authorizationRole is limited to admin to
 * prevent role multiplication while aligning with governance that only
 * privileged users manage topics.
 *
 * Validation and behavior: the request body should allow updating name and
 * description only. If the topic does not exist or has been retired from active
 * use, return 404. The server sets updated_at automatically and returns the
 * updated IEconDiscussTopic. Conflicts (e.g., attempting to set fields
 * violating constraints) should yield 409, while malformed input returns 400.
 *
 * Related operations: clients may retrieve the current state via GET
 * /topics/{topicId} before updating and use GET /topics afterwards to observe
 * list changes. This endpoint is not responsible for archival or removal
 * actions, which are handled separately by governance workflows.
 *
 * @param props.connection
 * @param props.topicId Unique identifier of the topic to update.
 * @param props.body Topic update payload (name and description only; code is
 *   immutable).
 * @path /econDiscuss/admin/topics/:topicId
 * @accessor api.functional.econDiscuss.admin.topics.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the topic to update. */
    topicId: string & tags.Format<"uuid">;

    /** Topic update payload (name and description only; code is immutable). */
    body: IEconDiscussTopic.IUpdate;
  };
  export type Body = IEconDiscussTopic.IUpdate;
  export type Response = IEconDiscussTopic;

  export const METADATA = {
    method: "PUT",
    path: "/econDiscuss/admin/topics/:topicId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/admin/topics/${encodeURIComponent(props.topicId ?? "null")}`;
  export const random = (): IEconDiscussTopic =>
    typia.random<IEconDiscussTopic>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("topicId")(() => typia.assert(props.topicId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Archive a topic in econ_discuss_topics by setting deleted_at (admin only).
 *
 * This operation targets the curated taxonomy stored in econ_discuss_topics.
 * The model includes columns id (UUID primary key), code (unique business
 * identifier), name, description, created_at, updated_at, and deleted_at for
 * archival. Executing this endpoint sets deleted_at to the current time, which
 * removes the topic from user-facing lists and prevents new associations in
 * econ_discuss_post_topics while keeping historical records intact for
 * auditability.
 *
 * Only administrators should perform this action. The econDiscuss governance
 * documents specify that topic curation is an administrative responsibility;
 * therefore, authorization ensures only users assigned an admin role can call
 * this operation. Since the table includes a deleted_at column, the behavior is
 * to mark the record as no longer active rather than physically deleting the
 * row to keep referential integrity with existing associations.
 *
 * On validation, the service confirms that topicId is a valid UUID and that the
 * topic exists and is not already marked as deleted. If the topic has already
 * been archived (deleted_at is not null), the provider may treat the request as
 * idempotent and return success without additional changes. Related read
 * endpoints (e.g., listing topics or searching posts by topic) should exclude
 * records where deleted_at is not null. Errors include 404 when the topic does
 * not exist and 409 if policy or dependency checks prevent archival (e.g.,
 * active policy hold).
 *
 * @param props.connection
 * @param props.topicId Unique identifier of the topic to archive.
 * @path /econDiscuss/admin/topics/:topicId
 * @accessor api.functional.econDiscuss.admin.topics.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the topic to archive. */
    topicId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/econDiscuss/admin/topics/:topicId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/admin/topics/${encodeURIComponent(props.topicId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("topicId")(() => typia.assert(props.topicId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
