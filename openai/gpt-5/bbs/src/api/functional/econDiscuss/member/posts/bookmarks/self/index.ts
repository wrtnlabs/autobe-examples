import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

/**
 * Remove a user's post bookmark in econ_discuss_post_bookmarks.
 *
 * This endpoint removes the current user's bookmark of a target post identified
 * by postId. It operates on the econ_discuss_post_bookmarks table, which
 * according to the Prisma schema keeps a unique pair of econ_discuss_user_id
 * and econ_discuss_post_id with a created_at and updated_at timeline and a
 * deleted_at column for retiring records. The model also includes an optional
 * note property that remains private to the owner and is not exposed via this
 * endpoint.
 *
 * Security and permissions: only authenticated users can call this API, and the
 * provider must enforce ownership by matching the authenticated user with
 * econ_discuss_user_id. Attempting to remove a bookmark that does not exist
 * should be treated as idempotent success or return a 404 based on product
 * policy; in all cases, no other user's bookmarks are impacted. The operation
 * does not return a response body on success.
 *
 * Relationship to underlying entities: bookmarks reference posts via
 * econ_discuss_post_id and users via econ_discuss_user_id (both with onDelete
 * Cascade in the schema), ensuring automatic cleanup when either side is
 * deleted. Business logic may choose to retire a record by setting deleted_at
 * for reversibility and audit or permanently delete it when policy allows.
 *
 * Validation and errors: the postId must be a valid UUID referencing an
 * existing post; if the post is not visible to the user due to policy, the
 * provider should still permit removal of the user’s bookmark record if
 * present. Typical errors include 401 for unauthenticated requests and 403 if
 * cross-user attempts are detected.
 *
 * @param props.connection
 * @param props.postId Target post ID to remove current user’s bookmark for
 * @path /econDiscuss/member/posts/:postId/bookmarks/self
 * @accessor api.functional.econDiscuss.member.posts.bookmarks.self.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target post ID to remove current user’s bookmark for */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/econDiscuss/member/posts/:postId/bookmarks/self",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/bookmarks/self`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
