import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussUserProfile } from "../../../../structures/IEconDiscussUserProfile";
export * as profile from "./profile/index";
export * as reputation from "./reputation/index";
export * as topics from "./topics/index";
export * as votes from "./votes/index";
export * as bookmarks from "./bookmarks/index";
export * as notifications from "./notifications/index";

/**
 * Get the current user’s self profile from econ_discuss_users and
 * econ_discuss_user_profiles.
 *
 * This endpoint returns the caller’s own profile by joining econ_discuss_users
 * and econ_discuss_user_profiles via user_id. The econ_discuss_users model
 * provides identity and preference columns such as id, email (not necessarily
 * returned), display_name, avatar_uri, timezone, locale, and boolean flags like
 * email_verified and mfa_enabled with timestamps (created_at, updated_at). The
 * econ_discuss_user_profiles model adds extended profile fields: bio,
 * affiliation, website, and location. Together, they represent the self-profile
 * view suitable for account pages and editors.
 *
 * Security and permissions: Access requires authentication and operates in the
 * caller’s own context (authorizationRole: "member"). Provider logic must
 * ensure the returned profile belongs to the authenticated principal and that
 * sensitive secrets (password_hash, mfa_secret, mfa_recovery_codes) are never
 * exposed. Email may be redacted per policy if needed; the contract focuses on
 * display and preference fields.
 *
 * Relationships and behavior: The profile is one-to-one to the user
 * (econ_discuss_user_profiles has a unique user_id). If the profile row does
 * not yet exist, the provider may return reasonable defaults (null/empty
 * strings) or create a stub on write operations; read operations should simply
 * reflect current persisted state.
 *
 * Validation and error handling: Success returns a single
 * IEconDiscussUserProfile object. If the session is unauthenticated or invalid,
 * return 401. If the account has been deactivated (indicated by deleted_at in
 * either table), implementation may deny access or reflect a policy-specific
 * error. No request body is required.
 *
 * Related operations: Use PUT /me to update profile fields like display_name,
 * avatar_uri, timezone, locale, bio, affiliation, website, and location. Use
 * other endpoints for follows, topics, notifications, and drafts as needed.
 *
 * @param props.connection
 * @path /econDiscuss/member/me
 * @accessor api.functional.econDiscuss.member.me.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(connection: IConnection): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(),
          status: null,
        },
      );
}
export namespace at {
  export type Response = IEconDiscussUserProfile;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/member/me",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econDiscuss/member/me";
  export const random = (): IEconDiscussUserProfile =>
    typia.random<IEconDiscussUserProfile>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Update current user’s profile (econ_discuss_users +
 * econ_discuss_user_profiles) and return the updated record.
 *
 * This operation updates editable profile attributes for the caller. The
 * underlying Prisma schema includes econ_discuss_users with public-facing and
 * preference fields: display_name, avatar_uri, timezone, and locale; and
 * econ_discuss_user_profiles with bio, affiliation, website, and location.
 * Write operations must never allow updates to sensitive columns such as
 * password_hash or MFA secrets, and must not change email verification flags
 * directly via this endpoint.
 *
 * Security and ownership: Requires authentication (authorizationRole:
 * "member"). The provider must enforce that only the authenticated user’s own
 * records are modified. Attempts to update another user’s profile are
 * forbidden. The provider should apply validation—e.g., display_name presence
 * and length constraints (as per business policy), website as a URI string, and
 * timezone as an IANA identifier—consistent with the schema comments
 * (avatar_uri is an optional URI, timezone is optional IANA ID, locale is
 * optional preferred locale string).
 *
 * Relationships and persistence: econ_discuss_user_profiles is unique per
 * user_id. If a profile row doesn’t exist yet, the provider may create it when
 * processing the update to keep the one-to-one relationship intact. Timestamps
 * updated_at in both tables should be maintained by the persistence layer. If
 * either record is logically retired per lifecycle policies, the provider
 * should return 403/409 per policy.
 *
 * Error handling: On validation failures (e.g., malformed website URI,
 * unsupported timezone/locale format), return 400 with field-level messages. On
 * unauthenticated requests, return 401. On successful update, return the fully
 * refreshed IEconDiscussUserProfile, allowing clients to reflect the persisted
 * changes immediately.
 *
 * @param props.connection
 * @param props.body Fields to update on the caller’s profile (identity display
 *   and extended biography details).
 * @path /econDiscuss/member/me
 * @accessor api.functional.econDiscuss.member.me.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Fields to update on the caller’s profile (identity display and
     * extended biography details).
     */
    body: IEconDiscussUserProfile.IUpdate;
  };
  export type Body = IEconDiscussUserProfile.IUpdate;
  export type Response = IEconDiscussUserProfile;

  export const METADATA = {
    method: "PUT",
    path: "/econDiscuss/member/me",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econDiscuss/member/me";
  export const random = (): IEconDiscussUserProfile =>
    typia.random<IEconDiscussUserProfile>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
