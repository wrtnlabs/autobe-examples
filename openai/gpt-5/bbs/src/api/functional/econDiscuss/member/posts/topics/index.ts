import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussPostTopic } from "../../../../../structures/IEconDiscussPostTopic";

/**
 * Attach a topic to a post by creating an econ_discuss_post_topics row.
 *
 * Attach a curated topic to a post by inserting a row into
 * econ_discuss_post_topics. The junction model comment describes uniqueness per
 * (econ_discuss_post_id, econ_discuss_topic_id) and temporal fields including
 * deleted_at for logical removal. The target topic must exist in
 * econ_discuss_topics (which holds code, name, description, and deleted_at) and
 * must not be archived. The parent post must exist in econ_discuss_posts and
 * not be marked as deleted.
 *
 * Security and permissions: Only the post author or privileged roles should
 * manage topic associations. Authorization is represented here as a generic
 * member role; ownership checks and moderator/admin elevation occur in business
 * logic. Rate-limits and content policy constraints (e.g., required 1–5
 * controlled topics as per business rules) should be enforced server-side.
 *
 * Validation rules and conflicts: Reject duplicate associations based on the
 * unique constraint in econ_discuss_post_topics; return 409 conflict when the
 * (post, topic) link already exists or when the association was previously
 * retired but policy forbids reactivation. Ensure the topicId is a valid UUID
 * referencing an active topic. If the post is scheduled (scheduled_publish_at
 * set) or unpublished, the association remains valid but will influence
 * discovery upon publication.
 *
 * Related operations: Use GET/PATCH /posts/{postId}/topics to read current
 * associations. To remove an association, implement a dedicated endpoint that
 * sets deleted_at on the junction or performs a hard delete per policy (not
 * included here).
 *
 * @param props.connection
 * @param props.postId Target post's ID
 * @param props.body Association creation payload containing the target topic
 *   identifier
 * @path /econDiscuss/member/posts/:postId/topics
 * @accessor api.functional.econDiscuss.member.posts.topics.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Target post's ID */
    postId: string & tags.Format<"uuid">;

    /** Association creation payload containing the target topic identifier */
    body: IEconDiscussPostTopic.ICreate;
  };
  export type Body = IEconDiscussPostTopic.ICreate;
  export type Response = IEconDiscussPostTopic;

  export const METADATA = {
    method: "POST",
    path: "/econDiscuss/member/posts/:postId/topics",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/topics`;
  export const random = (): IEconDiscussPostTopic =>
    typia.random<IEconDiscussPostTopic>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a topic association from a post via econ_discuss_post_topics.
 *
 * This operation removes a topic association from a post by targeting the
 * junction entity econ_discuss_post_topics that links econ_discuss_posts and
 * econ_discuss_topics. The junction model includes created_at, updated_at, and
 * a deleted_at timestamp used to retire the association without losing audit
 * history. By setting the deleted_at column on the matching (postId, topicId)
 * record, the platform excludes the association from user-facing topic lists
 * and searches while keeping historical traceability.
 *
 * Security and permissions should be enforced so that only the post’s author
 * (identified by econ_discuss_posts.econ_discuss_user_id) or elevated roles
 * (moderator/admin) may disassociate topics. Attempts by other users must
 * result in 403 Forbidden. The operation also validates that both the target
 * post and topic exist and are not already retired; a missing association
 * should produce 404 Not Found. Business logic should also ensure that topic
 * integrity rules (e.g., minimum required controlled tags) remain satisfied
 * after removal, otherwise the provider should reject the request with 409
 * Conflict and explain which policy would be violated.
 *
 * This endpoint interacts with the following Prisma entities:
 * econ_discuss_posts (the authored post), econ_discuss_topics (the curated
 * taxonomy entry), and econ_discuss_post_topics (the many-to-many link). On
 * success, the system updates the deleted_at of the link row rather than
 * physically removing it, allowing restoration flows if needed by governance
 * tools. Errors include 400 for malformed identifiers, 401 for unauthenticated
 * access, 403 for insufficient permission, 404 when the association cannot be
 * located, and 409 when post–topic constraints would be violated.
 *
 * @param props.connection
 * @param props.postId Target post identifier (econ_discuss_posts.id).
 * @param props.topicId Target topic identifier (econ_discuss_topics.id).
 * @path /econDiscuss/member/posts/:postId/topics/:topicId
 * @accessor api.functional.econDiscuss.member.posts.topics.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target post identifier (econ_discuss_posts.id). */
    postId: string & tags.Format<"uuid">;

    /** Target topic identifier (econ_discuss_topics.id). */
    topicId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/econDiscuss/member/posts/:postId/topics/:topicId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/topics/${encodeURIComponent(props.topicId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("topicId")(() => typia.assert(props.topicId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
