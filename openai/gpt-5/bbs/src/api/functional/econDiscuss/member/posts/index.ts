import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussPost } from "../../../../structures/IEconDiscussPost";
export * as topics from "./topics/index";
export * as votes from "./votes/index";
export * as bookmarks from "./bookmarks/index";
export * as poll from "./poll/index";
export * as live from "./live/index";

/**
 * Create a new post record in econ_discuss_posts.
 *
 * Insert a new record into econ_discuss_posts as the authenticated author.
 * Required business fields typically include title and body; optional fields
 * include summary and scheduled_publish_at to enable scheduled publication. The
 * schema stores timestamps as timestamptz and provides text indexes over
 * title/body/summary for discovery.
 *
 * Security and permissions: only authenticated members may create posts. The
 * author is bound via econ_discuss_user_id from the authenticated session.
 * Implementations may validate required topic bindings by inserting rows into
 * econ_discuss_post_topics linking to econ_discuss_topics. Validation errors
 * (400) occur for missing/invalid fields; 403 is returned when the actor lacks
 * permission.
 *
 * @param props.connection
 * @param props.body Data for creating a post (title, body, optional summary and
 *   scheduling, optional topic bindings)
 * @path /econDiscuss/member/posts
 * @accessor api.functional.econDiscuss.member.posts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Data for creating a post (title, body, optional summary and
     * scheduling, optional topic bindings)
     */
    body: IEconDiscussPost.ICreate;
  };
  export type Body = IEconDiscussPost.ICreate;
  export type Response = IEconDiscussPost;

  export const METADATA = {
    method: "POST",
    path: "/econDiscuss/member/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econDiscuss/member/posts";
  export const random = (): IEconDiscussPost =>
    typia.random<IEconDiscussPost>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a post in econ_discuss_posts by ID.
 *
 * Modify an existing post’s fields in econ_discuss_posts. Common updates
 * include title, body, summary, and publication/scheduling adjustments
 * (published_at or scheduled_publish_at where policy allows). The model
 * maintains created_at/updated_at for auditing. Version history can be recorded
 * in econ_discuss_post_snapshots using a monotonic per-post version.
 *
 * Security and validation: only the author or appropriately privileged roles
 * may update a post. Ownership checks should use the authenticated user
 * context, and an edit window policy may apply after publication. The path
 * parameter must be a valid UUID. Typical errors include 400 (invalid data),
 * 403 (forbidden), and 404 (not found).
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post to update
 * @param props.body Fields permitted to be updated for the target post
 * @path /econDiscuss/member/posts/:postId
 * @accessor api.functional.econDiscuss.member.posts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the post to update */
    postId: string & tags.Format<"uuid">;

    /** Fields permitted to be updated for the target post */
    body: IEconDiscussPost.IUpdate;
  };
  export type Body = IEconDiscussPost.IUpdate;
  export type Response = IEconDiscussPost;

  export const METADATA = {
    method: "PUT",
    path: "/econDiscuss/member/posts/:postId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): IEconDiscussPost =>
    typia.random<IEconDiscussPost>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Mark a post (econ_discuss_posts) as deleted by setting deleted_at.
 *
 * Remove a published or draft-backed post from public visibility by setting the
 * deleted_at timestamp in econ_discuss_posts. The Posts model comment states it
 * supports publication timestamps, scheduled publishing, and a soft deletion
 * timestamp when the post is removed from public visibility. This operation
 * leverages that deleted_at field to retire a post without erasing historical
 * data or breaking referential integrity.
 *
 * Security and permissions: Only the owning author or elevated roles
 * (moderator/admin) should be allowed to delete. Moderators and admins may
 * require 2FA per platform policy (see role tables econ_discuss_moderators and
 * econ_discuss_admins) and actions must be audited. Ownership and sanction
 * checks occur in service logic. Attempts by unauthorized users should return a
 * suitable error (403 if authenticated but not permitted, 401 if
 * unauthenticated).
 *
 * Database relationships: The econ_discuss_posts record is connected to
 * multiple tables, including econ_discuss_post_topics (post–topic junction),
 * econ_discuss_post_votes (member votes and statuses),
 * econ_discuss_post_bookmarks (owner-only saved items with notes),
 * econ_discuss_polls (one-to-one poll attached to a post),
 * econ_discuss_live_threads (one-to-one live room), and
 * econ_discuss_post_snapshots (version history). Setting deleted_at on the post
 * preserves these relationships for audit and internal analytics while
 * excluding the post from public discovery. Because this is a deletion via
 * deleted_at, hard-delete cascades are not triggered; repository queries should
 * consistently filter deleted_at IS NULL for user-facing listings.
 *
 * Validation and business rules: If a post is already marked as deleted
 * (deleted_at IS NOT NULL), return a 409 conflict or idempotent success
 * depending on policy. If compliance/legal holds are active at higher layers,
 * the deletion should be blocked with a reason. Implementers should ensure that
 * search indices and caches are updated to remove the post from public results
 * shortly after the operation.
 *
 * Related operations: Use GET /posts/{postId} to read details prior to deletion
 * and POST /posts to create new posts. After deletion, list endpoints and
 * trending queries must ignore the record. Error handling should include 404
 * when the postId does not exist or the caller lacks access to view it, 403 for
 * permission failures, and 429 when rate limits are exceeded.
 *
 * @param props.connection
 * @param props.postId Target post's ID
 * @path /econDiscuss/member/posts/:postId
 * @accessor api.functional.econDiscuss.member.posts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target post's ID */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/econDiscuss/member/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
