import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussLiveMessage } from "../../../../../../structures/IEconDiscussLiveMessage";

/**
 * Create a live message (econ_discuss_live_messages) in a post’s live thread.
 *
 * Publish a live message to the live thread attached to the given post. The
 * Prisma schema for econ_discuss_live_messages specifies fields including
 * message_type (with allowed values enforced in application), content (nullable
 * for certain system messages), pinned (boolean), edited_at (set when updated),
 * and created_at/updated_at timestamps. The related econ_discuss_live_threads
 * record determines whether participation is allowed (expert_only,
 * access_scope) and tracks the room lifecycle state (scheduled, waiting, live,
 * paused, ended, archived).
 *
 * Security considerations: this endpoint requires an authenticated user (role
 * "member" or above in this API) and server-side enforcement that the user is
 * allowed to post given econ_discuss_live_threads.expert_only and access_scope.
 * Writing is typically allowed when state is live (or as configured), and
 * should be blocked when ended/archived. Implementations should enforce
 * per-room rate limits and slow mode via slow_mode_interval_seconds when
 * present.
 *
 * Validation rules include ensuring the target post exists, there is a live
 * thread bound to it, and the message_type/content combination is valid (e.g.,
 * text messages should include non-empty content). On success, the created
 * message is returned with identifiers and timestamps. Errors include 404 for
 * missing post/thread, 403 for disallowed participation, and 409/422 for
 * invalid state or payload.
 *
 * @param props.connection
 * @param props.postId Target post’s ID whose live thread will receive the
 *   message
 * @param props.body Payload to create a live message including content, message
 *   type, and optional pin flag
 * @path /econDiscuss/member/posts/:postId/live/messages
 * @accessor api.functional.econDiscuss.member.posts.live.messages.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Target post’s ID whose live thread will receive the message */
    postId: string & tags.Format<"uuid">;

    /**
     * Payload to create a live message including content, message type, and
     * optional pin flag
     */
    body: IEconDiscussLiveMessage.ICreate;
  };
  export type Body = IEconDiscussLiveMessage.ICreate;
  export type Response = IEconDiscussLiveMessage;

  export const METADATA = {
    method: "POST",
    path: "/econDiscuss/member/posts/:postId/live/messages",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/live/messages`;
  export const random = (): IEconDiscussLiveMessage =>
    typia.random<IEconDiscussLiveMessage>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a live message (econ_discuss_live_messages) within a post’s live
 * thread.
 *
 * Modify an existing live message belonging to a post’s live thread. The Prisma
 * model econ_discuss_live_messages includes editable fields such as content
 * (nullable for system types), pinned, and implicitly message_type where policy
 * allows. Edits should respect window limits described in business rules, and
 * set edited_at to reflect changes. The parent econ_discuss_live_threads
 * (state, expert_only, access_scope) governs whether updates are allowed in
 * current state and who may perform them (e.g., only author can edit within a
 * short window; hosts/moderators can toggle pinned).
 *
 * Security: This endpoint requires authentication (role "member" or above) and
 * must enforce ownership or role-based authorization. It should also ensure the
 * message belongs to the live thread for the supplied postId, preventing
 * cross-thread updates. When the thread is ended or archived, edits should
 * typically be rejected except for governance actions.
 *
 * Error handling: 404 when the post/thread/message linkage is invalid; 403 for
 * insufficient permissions; 409/422 for invalid state transitions (e.g.,
 * editing after window, disallowed type changes). On success, returns the
 * updated message including edited_at.
 *
 * @param props.connection
 * @param props.postId Owning post’s ID used to resolve the live thread
 * @param props.messageId Identifier of the live message to update
 * @param props.body Fields to update on the live message (e.g., content, pin)
 * @path /econDiscuss/member/posts/:postId/live/messages/:messageId
 * @accessor api.functional.econDiscuss.member.posts.live.messages.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Owning post’s ID used to resolve the live thread */
    postId: string & tags.Format<"uuid">;

    /** Identifier of the live message to update */
    messageId: string & tags.Format<"uuid">;

    /** Fields to update on the live message (e.g., content, pin) */
    body: IEconDiscussLiveMessage.IUpdate;
  };
  export type Body = IEconDiscussLiveMessage.IUpdate;
  export type Response = IEconDiscussLiveMessage;

  export const METADATA = {
    method: "PUT",
    path: "/econDiscuss/member/posts/:postId/live/messages/:messageId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/live/messages/${encodeURIComponent(props.messageId ?? "null")}`;
  export const random = (): IEconDiscussLiveMessage =>
    typia.random<IEconDiscussLiveMessage>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("messageId")(() => typia.assert(props.messageId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a live message (econ_discuss_live_messages) for a post’s live thread.
 *
 * This operation removes a specific live message from user-visible streams by
 * updating the econ_discuss_live_messages record identified by {messageId} so
 * that its deleted_at column is populated. According to the Prisma schema
 * comments for econ_discuss_live_messages, the model stores per-message
 * lifecycle fields and includes a deleted_at timestamp for moderated or removed
 * messages while preserving transcript placeholders as required. The deletion
 * must be constrained to messages that belong to the live thread associated
 * with the post identified by {postId}, which is modeled by
 * econ_discuss_live_threads (one-to-one with econ_discuss_posts) through
 * econ_discuss_live_threads.econ_discuss_post_id.
 *
 * Security and authorization should follow business policies: only the message
 * author (econ_discuss_live_messages.econ_discuss_user_id), the live thread
 * host (econ_discuss_live_threads.host_user_id), or governance roles
 * (moderators/admins) may remove a message. Moderation-related removals should
 * be auditable, aligning with governance requirements. Even though
 * authorization is enforced in business logic, this endpoint is exposed to
 * authenticated users and must return 403 when the caller lacks permission.
 *
 * From a data relationship perspective, econ_discuss_live_messages references
 * econ_discuss_live_threads via econ_discuss_live_thread_id, and the thread
 * references econ_discuss_posts via econ_discuss_post_id. The provider should
 * verify that the targeted message belongs to the thread whose
 * econ_discuss_post_id equals {postId}. If the thread is archived or ended (see
 * econ_discuss_live_threads.state and archived_at/ended_at), business rules may
 * restrict message removal; implementations can enforce such constraints
 * consistently with platform policy.
 *
 * Validation and error handling include: returning 404 when the message does
 * not exist or is not linked to the specified post; 403 when the caller is not
 * permitted to remove the message; and 409 where applicable if concurrent state
 * prevents the operation (e.g., thread already archived in a stricter policy).
 * On repeated calls where the message already has deleted_at populated, the
 * provider may treat the request as idempotent and return 204.
 *
 * Related operations that are commonly used together include retrieving live
 * messages for a post’s live thread (GET /posts/{postId}/live/messages) and
 * posting a new live message (POST /posts/{postId}/live/messages). Together,
 * these enable full lifecycle management of live conversation content while
 * respecting auditability and integrity described in the Prisma schema
 * comments.
 *
 * @param props.connection
 * @param props.postId Owning post’s ID associated with the target live message
 *   via its live thread.
 * @param props.messageId Identifier of the live message to remove from active
 *   visibility.
 * @path /econDiscuss/member/posts/:postId/live/messages/:messageId
 * @accessor api.functional.econDiscuss.member.posts.live.messages.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Owning post’s ID associated with the target live message via its live
     * thread.
     */
    postId: string & tags.Format<"uuid">;

    /** Identifier of the live message to remove from active visibility. */
    messageId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/econDiscuss/member/posts/:postId/live/messages/:messageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/live/messages/${encodeURIComponent(props.messageId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("messageId")(() => typia.assert(props.messageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
