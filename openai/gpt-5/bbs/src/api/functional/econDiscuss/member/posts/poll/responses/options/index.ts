import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussPollResponseOption } from "../../../../../../../structures/IEconDiscussPollResponseOption";
import { IEconDiscussPollResponse } from "../../../../../../../structures/IEconDiscussPollResponse";

/**
 * Add option selections to a poll response
 * (econ_discuss_poll_response_options).
 *
 * This endpoint appends option selections to the current responseâ€™s selection
 * set. Per schema, econ_discuss_poll_response_options links a response to
 * options with an optional position for ranking questions. For multiple_choice,
 * ensure that after adding, the total selections do not exceed max_selections
 * defined on econ_discuss_polls. For single_choice questions, clients SHOULD
 * NOT use this endpoint (use the PATCH replacement instead) because only one
 * selection is permitted. For ranking, each added option may include a position
 * that must be unique and within the 1..N range, and must not conflict with
 * existing positions.
 *
 * Security and permissions: only the authenticated owner may append selections,
 * and the server SHOULD enforce allow_vote_change=true, active poll windows
 * (start_at/end_at), and eligibility checks (min_voter_reputation,
 * min_account_age_hours). If the response belongs to a poll that is closed or
 * change is disallowed, reject with 400/403 accordingly.
 *
 * Validation and integrity: all option IDs must reference options from the same
 * poll; duplicates with existing selections must be rejected. For ranking,
 * adding an option with a position already taken must fail validation. This
 * operation does not remove prior selections; use the PATCH endpoint for
 * replacement semantics. Related operations include the PATCH options
 * replacement endpoint, the response PUT endpoint for scalar value updates, and
 * the DELETE response endpoint for withdrawal.
 *
 * @param props.connection
 * @param props.postId Host post ID that owns the poll for this response
 * @param props.responseId Target poll response ID to which options will be
 *   added
 * @param props.body Options to append to the existing selection set. Provide
 *   optionIds (and positions for ranking). Reject duplicates or capacity
 *   violations.
 * @path /econDiscuss/member/posts/:postId/poll/responses/:responseId/options
 * @accessor api.functional.econDiscuss.member.posts.poll.responses.options.addOptions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function addOptions(
  connection: IConnection,
  props: addOptions.Props,
): Promise<addOptions.Response> {
  return true === connection.simulate
    ? addOptions.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...addOptions.METADATA,
          path: addOptions.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace addOptions {
  export type Props = {
    /** Host post ID that owns the poll for this response */
    postId: string & tags.Format<"uuid">;

    /** Target poll response ID to which options will be added */
    responseId: string & tags.Format<"uuid">;

    /**
     * Options to append to the existing selection set. Provide optionIds
     * (and positions for ranking). Reject duplicates or capacity
     * violations.
     */
    body: IEconDiscussPollResponseOption.ICreate;
  };
  export type Body = IEconDiscussPollResponseOption.ICreate;
  export type Response = IEconDiscussPollResponse;

  export const METADATA = {
    method: "POST",
    path: "/econDiscuss/member/posts/:postId/poll/responses/:responseId/options",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/poll/responses/${encodeURIComponent(props.responseId ?? "null")}/options`;
  export const random = (): IEconDiscussPollResponse =>
    typia.random<IEconDiscussPollResponse>();
  export const simulate = (
    connection: IConnection,
    props: addOptions.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: addOptions.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("responseId")(() => typia.assert(props.responseId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Replace selection options for a poll response
 * (econ_discuss_poll_response_options).
 *
 * This endpoint updates option selections for a given response by replacing the
 * entire selection set in econ_discuss_poll_response_options. The schema models
 * selections with a response-to-option link and an optional position for
 * ranking questions. For multiple_choice, the number of selected options must
 * respect min_selections and max_selections on econ_discuss_polls; for
 * single_choice, exactly one option should be provided; for ranking, each
 * provided option may include a unique position (1..N) with no duplicates.
 *
 * Security and permissions: only the authenticated owner of the response may
 * modify selections, and the server SHOULD enforce allow_vote_change=true, poll
 * open windows (start_at/end_at), and user eligibility (min_voter_reputation,
 * min_account_age_hours) from econ_discuss_polls. If the poll is closed or
 * edits are disallowed, the server SHOULD return 400/403 with an explanatory
 * message.
 *
 * Data integrity and validation: all option IDs in the request MUST belong to
 * the same poll tied to the response, or the request MUST be rejected. For
 * ranking, positions MUST be unique and within bounds of provided options; for
 * multiple_choice/single_choice, positions SHOULD be omitted. The operation
 * should delete any prior econ_discuss_poll_response_options rows not present
 * in the new set, then insert or update rows to match the provided list.
 * Related operations include POST to add options incrementally and the response
 * PUT endpoint for scalar updates (likert_value or numeric_value).
 *
 * @param props.connection
 * @param props.postId Host post ID that owns the poll for this response
 * @param props.responseId Target poll response ID whose selections will be
 *   replaced
 * @param props.body Complete set of option selections for this response. For
 *   multiple_choice provide 1..N optionIds; for single_choice provide exactly
 *   1; for ranking include positions.
 * @path /econDiscuss/member/posts/:postId/poll/responses/:responseId/options
 * @accessor api.functional.econDiscuss.member.posts.poll.responses.options.putByPostidAndResponseid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putByPostidAndResponseid(
  connection: IConnection,
  props: putByPostidAndResponseid.Props,
): Promise<putByPostidAndResponseid.Response> {
  return true === connection.simulate
    ? putByPostidAndResponseid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByPostidAndResponseid.METADATA,
          path: putByPostidAndResponseid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putByPostidAndResponseid {
  export type Props = {
    /** Host post ID that owns the poll for this response */
    postId: string & tags.Format<"uuid">;

    /** Target poll response ID whose selections will be replaced */
    responseId: string & tags.Format<"uuid">;

    /**
     * Complete set of option selections for this response. For
     * multiple_choice provide 1..N optionIds; for single_choice provide
     * exactly 1; for ranking include positions.
     */
    body: IEconDiscussPollResponseOption.IRequest;
  };
  export type Body = IEconDiscussPollResponseOption.IRequest;
  export type Response = IEconDiscussPollResponse;

  export const METADATA = {
    method: "PUT",
    path: "/econDiscuss/member/posts/:postId/poll/responses/:responseId/options",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/poll/responses/${encodeURIComponent(props.responseId ?? "null")}/options`;
  export const random = (): IEconDiscussPollResponse =>
    typia.random<IEconDiscussPollResponse>();
  export const simulate = (
    connection: IConnection,
    props: putByPostidAndResponseid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByPostidAndResponseid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("responseId")(() => typia.assert(props.responseId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Replace selection options for a poll response
 * (econ_discuss_poll_response_options).
 *
 * This endpoint updates option selections for a given response by replacing the
 * entire selection set in econ_discuss_poll_response_options. The schema models
 * selections with a response-to-option link and an optional position for
 * ranking questions. For multiple_choice, the number of selected options must
 * respect min_selections and max_selections on econ_discuss_polls; for
 * single_choice, exactly one option should be provided; for ranking, each
 * provided option may include a unique position (1..N) with no duplicates.
 *
 * Security and permissions: only the authenticated owner of the response may
 * modify selections, and the server SHOULD enforce allow_vote_change=true, poll
 * open windows (start_at/end_at), and user eligibility (min_voter_reputation,
 * min_account_age_hours) from econ_discuss_polls. If the poll is closed or
 * edits are disallowed, the server SHOULD return 400/403 with an explanatory
 * message.
 *
 * Data integrity and validation: all option IDs in the request MUST belong to
 * the same poll tied to the response, or the request MUST be rejected. For
 * ranking, positions MUST be unique and within bounds of provided options; for
 * multiple_choice/single_choice, positions SHOULD be omitted. The operation
 * should delete any prior econ_discuss_poll_response_options rows not present
 * in the new set, then insert or update rows to match the provided list.
 * Related operations include POST to add options incrementally and the response
 * PUT endpoint for scalar updates (likert_value or numeric_value).
 *
 * @param props.connection
 * @param props.postId Host post ID that owns the poll for this response
 * @param props.responseId Target poll response ID whose selections will be
 *   replaced
 * @param props.body Complete set of option selections for this response. For
 *   multiple_choice provide 1..N optionIds; for single_choice provide exactly
 *   1; for ranking include positions.
 * @path /econDiscuss/member/posts/:postId/poll/responses/:responseId/options
 * @accessor api.functional.econDiscuss.member.posts.poll.responses.options.patchByPostidAndResponseid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patchByPostidAndResponseid(
  connection: IConnection,
  props: patchByPostidAndResponseid.Props,
): Promise<patchByPostidAndResponseid.Response> {
  return true === connection.simulate
    ? patchByPostidAndResponseid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patchByPostidAndResponseid.METADATA,
          path: patchByPostidAndResponseid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace patchByPostidAndResponseid {
  export type Props = {
    /** Host post ID that owns the poll for this response */
    postId: string & tags.Format<"uuid">;

    /** Target poll response ID whose selections will be replaced */
    responseId: string & tags.Format<"uuid">;

    /**
     * Complete set of option selections for this response. For
     * multiple_choice provide 1..N optionIds; for single_choice provide
     * exactly 1; for ranking include positions.
     */
    body: IEconDiscussPollResponseOption.IRequest;
  };
  export type Body = IEconDiscussPollResponseOption.IRequest;
  export type Response = IEconDiscussPollResponse;

  export const METADATA = {
    method: "PATCH",
    path: "/econDiscuss/member/posts/:postId/poll/responses/:responseId/options",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/poll/responses/${encodeURIComponent(props.responseId ?? "null")}/options`;
  export const random = (): IEconDiscussPollResponse =>
    typia.random<IEconDiscussPollResponse>();
  export const simulate = (
    connection: IConnection,
    props: patchByPostidAndResponseid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patchByPostidAndResponseid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("responseId")(() => typia.assert(props.responseId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific response option (econ_discuss_poll_response_options) for a
 * poll response.
 *
 * Fetch a single poll response option entry associated with a respondentâ€™s
 * selection. According to the Prisma schema, econ_discuss_poll_response_options
 * is a junction table that links a response (econ_discuss_poll_responses.id) to
 * one selected option (econ_discuss_poll_options.id), with an optional position
 * field used when the question type is ranking. Each row represents either one
 * of multiple selections (multiple_choice) or the sole selection
 * (single_choice), and persists even if the authorâ€™s account is anonymized, per
 * auditability rules in the schema comments.
 *
 * Security and privacy considerations: the schema for
 * econ_discuss_poll_responses explicitly models response status states (active,
 * withdrawn, quarantined, invalidated), and the platformâ€™s business rules
 * require that individual selections are private. Implementations must restrict
 * access so that only the response owner (econ_discuss_users.id matching the
 * authenticated user), or authorized moderation/admin roles, can read raw
 * selection rows. This endpoint should therefore be protected for authenticated
 * users and perform ownership checks; public aggregation is exposed via the
 * separate results endpoint.
 *
 * Entity relationships: the path requires a valid postId that owns a poll
 * (econ_discuss_polls with unique econ_discuss_post_id), then a responseId that
 * belongs to that poll (econ_discuss_poll_responses with unique (poll,user)),
 * then a responseOptionId that belongs to that response
 * (econ_discuss_poll_response_options). The provider should verify these
 * relationships to prevent IDOR issues. The returned object corresponds to
 * IEconDiscussPollResponseOption, reflecting fields from
 * econ_discuss_poll_response_options (ids, foreign keys, position,
 * created_at/updated_at).
 *
 * Validation and errors: return 404 if the response or option does not exist
 * under the specified postâ€™s poll; 403 if the caller is not permitted to see
 * raw response content; 409 if state prohibits reading (e.g., response
 * invalidated and hidden by policy). Timestamps are ISO 8601 strings; follow
 * the standard error model.
 *
 * @param props.connection
 * @param props.postId Host post ID (UUID) that owns the poll
 * @param props.responseId Poll response ID (UUID) belonging to the postâ€™s poll
 * @param props.responseOptionId Response option row ID (UUID) within the
 *   response
 * @path /econDiscuss/member/posts/:postId/poll/responses/:responseId/options/:responseOptionId
 * @accessor api.functional.econDiscuss.member.posts.poll.responses.options.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Host post ID (UUID) that owns the poll */
    postId: string & tags.Format<"uuid">;

    /** Poll response ID (UUID) belonging to the postâ€™s poll */
    responseId: string & tags.Format<"uuid">;

    /** Response option row ID (UUID) within the response */
    responseOptionId: string & tags.Format<"uuid">;
  };
  export type Response = IEconDiscussPollResponseOption;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/member/posts/:postId/poll/responses/:responseId/options/:responseOptionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/poll/responses/${encodeURIComponent(props.responseId ?? "null")}/options/${encodeURIComponent(props.responseOptionId ?? "null")}`;
  export const random = (): IEconDiscussPollResponseOption =>
    typia.random<IEconDiscussPollResponseOption>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("responseId")(() => typia.assert(props.responseId));
      assert.param("responseOptionId")(() =>
        typia.assert(props.responseOptionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a response option row in econ_discuss_poll_response_options.
 *
 * Modify the selected option row linked to a poll response. The
 * econ_discuss_poll_response_options table stores the mapping between a
 * response (econ_discuss_poll_responses) and a selected option
 * (econ_discuss_poll_options), with an optional position used for ranking
 * questions. Per schema comments, these rows are retained for history, with
 * deleted_at supporting removal while preserving auditability.
 *
 * Security and permissions: because raw selections are private, only the
 * response owner (econ_discuss_poll_responses.econ_discuss_user_id) or
 * authorized staff may update this row. Implementation must also enforce
 * business rules from econDiscuss polls: for example, allow updates only if
 * allow_vote_change is true on econ_discuss_polls and the poll is within its
 * open window (start_at/end_at). For ranking, position may be adjusted; for
 * multiple_choice, switching the option may be allowed; for single_choice,
 * updates typically replace the selected option.
 *
 * Validation and relationships: verify that postId â†’ poll
 * (econ_discuss_polls.econ_discuss_post_id) exists, that responseId belongs to
 * that poll (via econ_discuss_poll_responses.econ_discuss_poll_id), and that
 * responseOptionId belongs to the response
 * (econ_discuss_poll_response_options.econ_discuss_poll_response_id). Return
 * 404 for non-existent chains or mismatches; 403 on permission failures; 409 if
 * the response is in a terminal status (withdrawn/invalidated) or the poll
 * configuration disallows changes.
 *
 * Error handling and auditing: apply standard error model with clear messages,
 * and record changes for auditability. Timestamps are ISO 8601 strings in
 * responses.
 *
 * @param props.connection
 * @param props.postId Host post ID (UUID) that owns the poll
 * @param props.responseId Poll response ID (UUID) belonging to the postâ€™s poll
 * @param props.responseOptionId Response option row ID (UUID) within the
 *   response
 * @param props.body Fields to update for the response option (e.g.,
 *   econ_discuss_poll_option_id and/or ranking position) within policy
 *   constraints
 * @path /econDiscuss/member/posts/:postId/poll/responses/:responseId/options/:responseOptionId
 * @accessor api.functional.econDiscuss.member.posts.poll.responses.options.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Host post ID (UUID) that owns the poll */
    postId: string & tags.Format<"uuid">;

    /** Poll response ID (UUID) belonging to the postâ€™s poll */
    responseId: string & tags.Format<"uuid">;

    /** Response option row ID (UUID) within the response */
    responseOptionId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the response option (e.g.,
     * econ_discuss_poll_option_id and/or ranking position) within policy
     * constraints
     */
    body: IEconDiscussPollResponseOption.IUpdate;
  };
  export type Body = IEconDiscussPollResponseOption.IUpdate;
  export type Response = IEconDiscussPollResponseOption;

  export const METADATA = {
    method: "PUT",
    path: "/econDiscuss/member/posts/:postId/poll/responses/:responseId/options/:responseOptionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/poll/responses/${encodeURIComponent(props.responseId ?? "null")}/options/${encodeURIComponent(props.responseOptionId ?? "null")}`;
  export const random = (): IEconDiscussPollResponseOption =>
    typia.random<IEconDiscussPollResponseOption>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("responseId")(() => typia.assert(props.responseId));
      assert.param("responseOptionId")(() =>
        typia.assert(props.responseOptionId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a response option (econ_discuss_poll_response_options) from a poll
 * response.
 *
 * Remove a selected option entry from a poll response. In the Prisma schema,
 * econ_discuss_poll_response_options includes a deleted_at field to support
 * reversible removals. Business logic should honor polling policy: e.g., allow
 * removal only when allow_vote_change is true and the poll window is still
 * open, or when a withdrawal process is invoked. For ranking questions,
 * deletion removes that ranked item from the userâ€™s ordering; for multiple
 * choice, it unselects that option.
 *
 * Security and relationships: enforce that postId resolves to a poll
 * (econ_discuss_polls unique per post), responseId belongs to that poll, and
 * responseOptionId belongs to the response. Only the response owner or
 * authorized moderators/admins may remove selections. Return 404 for missing
 * resources, 403 for permission issues, and 409 if removal conflicts with poll
 * state (e.g., closed or response invalidated by moderation).
 *
 * Behavior and auditing: This operation typically sets deleted_at on the
 * response-option record; records so marked are excluded from tallies. No body
 * is returned on success.
 *
 * @param props.connection
 * @param props.postId Host post ID (UUID) that owns the poll
 * @param props.responseId Poll response ID (UUID) belonging to the postâ€™s poll
 * @param props.responseOptionId Response option row ID (UUID) within the
 *   response
 * @path /econDiscuss/member/posts/:postId/poll/responses/:responseId/options/:responseOptionId
 * @accessor api.functional.econDiscuss.member.posts.poll.responses.options.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Host post ID (UUID) that owns the poll */
    postId: string & tags.Format<"uuid">;

    /** Poll response ID (UUID) belonging to the postâ€™s poll */
    responseId: string & tags.Format<"uuid">;

    /** Response option row ID (UUID) within the response */
    responseOptionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/econDiscuss/member/posts/:postId/poll/responses/:responseId/options/:responseOptionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/poll/responses/${encodeURIComponent(props.responseId ?? "null")}/options/${encodeURIComponent(props.responseOptionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("responseId")(() => typia.assert(props.responseId));
      assert.param("responseOptionId")(() =>
        typia.assert(props.responseOptionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
