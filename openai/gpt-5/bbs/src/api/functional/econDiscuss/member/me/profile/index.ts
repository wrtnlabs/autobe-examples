import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussUserProfile } from "../../../../../structures/IEconDiscussUserProfile";

/**
 * Get authenticated user profile from econ_discuss_users and
 * econ_discuss_user_profiles.
 *
 * Retrieve the current user’s profile by combining identity and preference
 * fields from econ_discuss_users with optional extended profile details from
 * econ_discuss_user_profiles.
 *
 * The econ_discuss_users table stores the core account information required
 * across the platform: email (unique), display_name, optional avatar_uri,
 * timezone for notifications and scheduling, preferred locale, email_verified
 * flag, and MFA state (mfa_enabled). Timestamps include created_at and
 * updated_at, with deleted_at indicating the record is no longer active. This
 * endpoint never exposes sensitive authentication fields such as password_hash,
 * mfa_secret, or mfa_recovery_codes.
 *
 * The econ_discuss_user_profiles table augments the base identity with
 * public-facing fields like bio, affiliation, website, and location, as
 * described in its schema comments. These fields are optional and exist only
 * when a profile record has been created for the user. When present, they are
 * merged into the response so clients can render a single coherent profile
 * view.
 *
 * Security considerations: access requires an authenticated session mapped to a
 * valid econ_discuss_users.id. The response is always scoped to the caller; no
 * additional path parameters are required. If the underlying user record has a
 * non-null deleted_at, the account is considered inactive and the provider
 * should deny access appropriately.
 *
 * Error handling: return 200 with the consolidated profile when successful. If
 * the base user row is missing or inactive, return an appropriate error (e.g.,
 * 404 or 403) according to business policy. The operation is read-only and does
 * not modify any database state.
 *
 * @param props.connection
 * @path /econDiscuss/member/me/profile
 * @accessor api.functional.econDiscuss.member.me.profile.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(connection: IConnection): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(),
          status: null,
        },
      );
}
export namespace at {
  export type Response = IEconDiscussUserProfile;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/member/me/profile",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econDiscuss/member/me/profile";
  export const random = (): IEconDiscussUserProfile =>
    typia.random<IEconDiscussUserProfile>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Update authenticated user profile fields across econ_discuss_users and
 * econ_discuss_user_profiles.
 *
 * Modify the current user’s profile by updating allowed fields on
 * econ_discuss_users and econ_discuss_user_profiles.
 *
 * Core identity and preference updates occur in econ_discuss_users:
 * display_name (public handle), avatar_uri (validated URI string), timezone
 * (IANA identifier used for notifications and scheduling), and locale (UI
 * language like en-US). The schema tracks updated_at for this table, and email
 * uniqueness and security-related columns (password_hash, mfa_secret,
 * mfa_recovery_codes) are never writable through this endpoint.
 *
 * Extended profile information is maintained in econ_discuss_user_profiles with
 * optional fields bio, affiliation, website, and location. When a profile row
 * does not yet exist for the authenticated user, provider logic may create it
 * and persist the requested updates. Records where deleted_at is non-null
 * should be treated as inactive and disallowed for modification.
 *
 * Validation rules include reasonable length checks for display_name and bio,
 * URI format validation for avatar_uri and website, and verification that
 * timezone corresponds to a valid IANA identifier. Business logic should ensure
 * that only the owner can update these fields.
 *
 * Error handling returns the fully refreshed consolidated profile on success.
 * If the base user is missing, inactive, or the payload fails validation,
 * return appropriate errors (e.g., 400, 403/404, or 409 on conflicting
 * constraints). The operation updates updated_at fields accordingly.
 *
 * @param props.connection
 * @param props.body Fields to update on the authenticated user’s profile and
 *   preferences
 * @path /econDiscuss/member/me/profile
 * @accessor api.functional.econDiscuss.member.me.profile.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Fields to update on the authenticated user’s profile and preferences */
    body: IEconDiscussUserProfile.IUpdate;
  };
  export type Body = IEconDiscussUserProfile.IUpdate;
  export type Response = IEconDiscussUserProfile;

  export const METADATA = {
    method: "PUT",
    path: "/econDiscuss/member/me/profile",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econDiscuss/member/me/profile";
  export const random = (): IEconDiscussUserProfile =>
    typia.random<IEconDiscussUserProfile>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
