import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussPollOption } from "../../../../../../structures/IEconDiscussPollOption";

/**
 * Create a new poll option for a post’s poll (Prisma:
 * econ_discuss_poll_options).
 *
 * This operation appends a new option to the poll that belongs to the given
 * post. Storage is in econ_discuss_poll_options, which includes id,
 * econ_discuss_poll_id, option_text, position, created_at, updated_at, and
 * deleted_at columns. The parent poll must exist in econ_discuss_polls for the
 * specified post (unique econ_discuss_post_id). For question types that utilize
 * options (single_choice, multiple_choice, ranking), creation is permitted; for
 * types like likert and numeric_estimate, business logic should prevent
 * creation or ignore options according to policy.
 *
 * Security considerations: only authenticated users with rights to modify the
 * poll (typically the post owner or privileged staff) can create options. This
 * endpoint requires authentication and performs authorization/ownership checks
 * in the provider. The provider should also normalize and validate option_text,
 * and assign or validate position while respecting the unique constraints
 * (econ_discuss_poll_id, option_text) and (econ_discuss_poll_id, position). If
 * a duplicate is attempted, return a conflict error.
 *
 * Validation and error handling: verify the postId exists and has a poll;
 * validate that the request body includes a non-empty option_text and a valid
 * position integer if provided; ensure deleted options are not reused in a way
 * that violates uniqueness without proper handling. Typical errors: 400 on
 * validation failure, 401 when unauthenticated, 403 when not authorized to
 * modify the poll, 404 if the post or poll is missing, 409 on uniqueness
 * violation, and 500 for unexpected errors.
 *
 * @param props.connection
 * @param props.postId Post identifier whose poll will receive the new option
 * @param props.body Creation payload for a poll option, including option text
 *   and ordering
 * @path /econDiscuss/member/posts/:postId/poll/options
 * @accessor api.functional.econDiscuss.member.posts.poll.options.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Post identifier whose poll will receive the new option */
    postId: string & tags.Format<"uuid">;

    /**
     * Creation payload for a poll option, including option text and
     * ordering
     */
    body: IEconDiscussPollOption.ICreate;
  };
  export type Body = IEconDiscussPollOption.ICreate;
  export type Response = IEconDiscussPollOption;

  export const METADATA = {
    method: "POST",
    path: "/econDiscuss/member/posts/:postId/poll/options",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/poll/options`;
  export const random = (): IEconDiscussPollOption =>
    typia.random<IEconDiscussPollOption>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing poll option for a post’s poll (Prisma:
 * econ_discuss_poll_options).
 *
 * This operation updates a poll option identified by optionId under the poll
 * associated with the given postId. The underlying table
 * econ_discuss_poll_options stores option_text and position and enforces
 * uniqueness within each poll for both fields combined with the poll FK. The
 * provider must ensure the target option belongs to the poll attached to the
 * specified post, and that the new values respect uniqueness and ordering
 * constraints.
 *
 * Security: authenticated users with appropriate permissions (typically the
 * post owner or privileged roles) may update options. The provider should
 * enforce authorization and ownership checks. Records with deleted_at not null
 * should be considered unavailable for updates.
 *
 * Validation and business rules: ensure non-empty option_text when provided;
 * validate position as an integer consistent with intended display order;
 * prevent duplication across (econ_discuss_poll_id, option_text) and
 * (econ_discuss_poll_id, position). For polls whose question_type does not
 * utilize options, providers should reject updates with a clear validation
 * error. Expected errors: 400 for validation issues, 401 for unauthenticated,
 * 403 for unauthorized, 404 when the post/poll/option is not found or is not
 * associated as required, 409 for uniqueness conflicts, and 500 on unexpected
 * failures.
 *
 * @param props.connection
 * @param props.postId Post identifier whose poll owns the option being updated
 * @param props.optionId Target poll option’s ID to update
 * @param props.body Update payload for a poll option, such as text or position
 *   changes
 * @path /econDiscuss/member/posts/:postId/poll/options/:optionId
 * @accessor api.functional.econDiscuss.member.posts.poll.options.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Post identifier whose poll owns the option being updated */
    postId: string & tags.Format<"uuid">;

    /** Target poll option’s ID to update */
    optionId: string & tags.Format<"uuid">;

    /** Update payload for a poll option, such as text or position changes */
    body: IEconDiscussPollOption.IUpdate;
  };
  export type Body = IEconDiscussPollOption.IUpdate;
  export type Response = IEconDiscussPollOption;

  export const METADATA = {
    method: "PUT",
    path: "/econDiscuss/member/posts/:postId/poll/options/:optionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/poll/options/${encodeURIComponent(props.optionId ?? "null")}`;
  export const random = (): IEconDiscussPollOption =>
    typia.random<IEconDiscussPollOption>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("optionId")(() => typia.assert(props.optionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
