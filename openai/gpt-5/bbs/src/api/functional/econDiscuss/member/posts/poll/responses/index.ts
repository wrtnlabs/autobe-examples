import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussPollResponse } from "../../../../../../structures/IEconDiscussPollResponse";
export * as options from "./options/index";

/**
 * Submit a poll response (econ_discuss_poll_responses) for a post’s poll.
 *
 * This endpoint records a member’s response to the poll associated with the
 * provided post. The econ_discuss_polls table defines configuration such as
 * question_type (single_choice, multiple_choice, likert, ranking,
 * numeric_estimate), visibility_mode, expert_only flag, allow_vote_change, and
 * optional eligibility constraints like min_voter_reputation and
 * min_account_age_hours. The response itself is stored in
 * econ_discuss_poll_responses with status (typically active on acceptance),
 * created_at, and type-specific value columns (likert_value or numeric_value).
 * When selections involve options (single/multiple/ranking), the chosen options
 * are recorded via econ_discuss_poll_response_options linked to the response.
 *
 * Business logic must ensure idempotency and uniqueness per (poll, user) as
 * enforced by the schema’s unique composite key. If allow_vote_change is
 * enabled and the poll is still open (between start_at and end_at), subsequent
 * submissions may switch or overwrite prior values within policy. The endpoint
 * should validate that the post has a poll (econ_discuss_polls unique per
 * post), that the poll is open for participation, and that the caller meets
 * eligibility constraints. On success, the operation returns no body (204
 * semantics) to align with lightweight interaction patterns.
 *
 * Error handling should cover: 400 for invalid payloads relative to question
 * type (e.g., out-of-range likert_value), 401/403 for unauthenticated or
 * ineligible users (including expert-only), 404 for missing post/poll, 409 for
 * duplicate responses when vote-change is not allowed, and 422 for attempts
 * after closure. This operation complements listing and detail retrieval
 * endpoints for governance and auditing purposes.
 *
 * @param props.connection
 * @param props.postId Identifier of the host post whose poll is being answered
 * @param props.body Poll response payload compatible with the poll’s question
 *   type
 * @path /econDiscuss/member/posts/:postId/poll/responses
 * @accessor api.functional.econDiscuss.member.posts.poll.responses.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<void> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Identifier of the host post whose poll is being answered */
    postId: string & tags.Format<"uuid">;

    /** Poll response payload compatible with the poll’s question type */
    body: IEconDiscussPollResponse.ICreate;
  };
  export type Body = IEconDiscussPollResponse.ICreate;

  export const METADATA = {
    method: "POST",
    path: "/econDiscuss/member/posts/:postId/poll/responses",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/poll/responses`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific poll response (econ_discuss_poll_responses) by ID for a post.
 *
 * This endpoint returns detailed information about one poll response linked to
 * the poll for the specified post. The econ_discuss_poll_responses table stores
 * per-user responses with fields including status (active, withdrawn,
 * quarantined, invalidated), created_at, updated_at, and type-specific values
 * (likert_value or numeric_value). For question types involving predefined
 * options, the selections are represented in econ_discuss_poll_response_options
 * and can be included by the provider when building the
 * IEconDiscussPollResponse representation.
 *
 * Access should be restricted: end users typically may only view their own
 * response, while governance roles may view others where policy permits. The
 * controller/provider should perform ownership or permission checks and return
 * 404 or 403 appropriately. Validation also confirms that the response belongs
 * to the poll that is uniquely tied to the given post via econ_discuss_polls.
 *
 * Expected errors include 404 when the response does not exist or does not
 * belong to the post’s poll, and 403 for insufficient permissions. This
 * operation complements the poll response creation and the moderation-oriented
 * list operation.
 *
 * @param props.connection
 * @param props.postId Identifier of the post whose poll contains the response
 * @param props.responseId Identifier of the poll response to retrieve
 * @path /econDiscuss/member/posts/:postId/poll/responses/:responseId
 * @accessor api.functional.econDiscuss.member.posts.poll.responses.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the post whose poll contains the response */
    postId: string & tags.Format<"uuid">;

    /** Identifier of the poll response to retrieve */
    responseId: string & tags.Format<"uuid">;
  };
  export type Response = IEconDiscussPollResponse;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/member/posts/:postId/poll/responses/:responseId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/poll/responses/${encodeURIComponent(props.responseId ?? "null")}`;
  export const random = (): IEconDiscussPollResponse =>
    typia.random<IEconDiscussPollResponse>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("responseId")(() => typia.assert(props.responseId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a poll response (econ_discuss_poll_responses) for a post.
 *
 * This endpoint updates a single poll response row in the
 * econ_discuss_poll_responses table. Per the Prisma schema, a response belongs
 * to a poll (econ_discuss_polls) which itself is one-to-one with a host post
 * (econ_discuss_posts). The response row includes: status (active, withdrawn,
 * quarantined, invalidated), likert_value for Likert-type questions,
 * numeric_value for numeric estimate questions, and lifecycle timestamps like
 * created_at, updated_at, withdrawn_at, and deleted_at. Use this endpoint when
 * the response needs to change scalar values or lifecycle state — for example,
 * a user withdrawing their response or adjusting a Likert score within the
 * allowed change window.
 *
 * Security and permissions: only the authenticated owner of the response should
 * be permitted to update it, except in governance scenarios where moderators or
 * admins may set status to quarantined or invalidated. Business logic SHOULD
 * enforce poll-level gating configured in econ_discuss_polls, such as
 * allow_vote_change, start_at/end_at windows, min_voter_reputation, and
 * min_account_age_hours. If the poll is closed (end_at passed) and
 * allow_vote_change is false, attempts to edit SHOULD be rejected with a
 * validation error.
 *
 * Entity relations and constraints: econ_discuss_poll_responses has a unique
 * constraint on (econ_discuss_poll_id, econ_discuss_user_id), ensuring exactly
 * one response per user per poll. For question types driven by options
 * (single_choice, multiple_choice, ranking), use the companion options
 * endpoints to edit selections in the econ_discuss_poll_response_options table;
 * this update endpoint should not attempt to modify option selections. For
 * Likert or numeric types, validate that likert_value is within the poll’s
 * scale_points range and that numeric_value is within numeric_min/numeric_max
 * with numeric_step rounding as defined in econ_discuss_polls.
 *
 * Validation and error handling: reject edits that violate poll configuration
 * (e.g., changing after closure, failing eligibility checks), or attempts to
 * set values that are incompatible with the poll’s question_type.
 * Reference-related errors include mismatched postId/responseId (e.g., response
 * does not belong to the poll under the given post). Return standard errors for
 * 400 (validation), 403 (forbidden), and 404 (not found). Related endpoints
 * include POST /polls/{pollId}/responses for creation, DELETE of this response
 * for withdrawal, and the options management endpoints for selection changes.
 *
 * @param props.connection
 * @param props.postId Host post ID that owns the poll for this response
 * @param props.responseId Target poll response ID to update
 * @param props.body Fields allowed to update on a poll response: status (e.g.,
 *   withdrawn), or scalar values likert_value / numeric_value according to poll
 *   question_type
 * @path /econDiscuss/member/posts/:postId/poll/responses/:responseId
 * @accessor api.functional.econDiscuss.member.posts.poll.responses.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Host post ID that owns the poll for this response */
    postId: string & tags.Format<"uuid">;

    /** Target poll response ID to update */
    responseId: string & tags.Format<"uuid">;

    /**
     * Fields allowed to update on a poll response: status (e.g.,
     * withdrawn), or scalar values likert_value / numeric_value according
     * to poll question_type
     */
    body: IEconDiscussPollResponse.IUpdate;
  };
  export type Body = IEconDiscussPollResponse.IUpdate;
  export type Response = IEconDiscussPollResponse;

  export const METADATA = {
    method: "PUT",
    path: "/econDiscuss/member/posts/:postId/poll/responses/:responseId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/poll/responses/${encodeURIComponent(props.responseId ?? "null")}`;
  export const random = (): IEconDiscussPollResponse =>
    typia.random<IEconDiscussPollResponse>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("responseId")(() => typia.assert(props.responseId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Withdraw/delete a poll response (econ_discuss_poll_responses) for a post.
 *
 * This endpoint deletes a single response in the sense of making it
 * non-participating going forward. In econ_discuss_poll_responses, the schema
 * supports lifecycle management through status, withdrawn_at, updated_at, and a
 * deleted_at timestamp. Implementations SHOULD transition status to withdrawn
 * and record appropriate timestamps so that historical audit of the response
 * remains possible, matching the schema’s lifecycle intent.
 *
 * Security and permissions: only the authenticated owner of the response should
 * be able to withdraw it under normal circumstances. Moderation workflows may
 * also remove or invalidate responses when integrity anomalies are detected
 * (e.g., set status to invalidated), but those governance paths remain
 * separate. Business rules SHOULD prohibit withdrawals after the poll has
 * closed when such behavior is disallowed by policy; if withdrawals are allowed
 * while open and within the permitted window, execute the lifecycle
 * transition.
 *
 * Relationships and expectations: the response belongs to a poll
 * (econ_discuss_polls) that is one-to-one with a post (econ_discuss_posts).
 * Ensure the responseId corresponds to the given postId via its poll
 * association; otherwise return 404. Removing a response should also remove its
 * effect from aggregates and segments, and associated
 * econ_discuss_poll_response_options rows should no longer be counted. Error
 * cases include 403 for forbidden withdrawal, and 404 for nonexistent or
 * mismatched identifiers.
 *
 * @param props.connection
 * @param props.postId Host post ID that owns the poll for this response
 * @param props.responseId Target poll response ID to withdraw/delete
 * @path /econDiscuss/member/posts/:postId/poll/responses/:responseId
 * @accessor api.functional.econDiscuss.member.posts.poll.responses.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Host post ID that owns the poll for this response */
    postId: string & tags.Format<"uuid">;

    /** Target poll response ID to withdraw/delete */
    responseId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/econDiscuss/member/posts/:postId/poll/responses/:responseId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/member/posts/${encodeURIComponent(props.postId ?? "null")}/poll/responses/${encodeURIComponent(props.responseId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("responseId")(() => typia.assert(props.responseId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
