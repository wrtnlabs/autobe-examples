import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIEconDiscussReputationEvent } from "../../../../../../structures/IPageIEconDiscussReputationEvent";
import { IEconDiscussReputationEvent } from "../../../../../../structures/IEconDiscussReputationEvent";

/**
 * List recent reputation events (econ_discuss_reputation_events) for a user.
 *
 * This operation retrieves a default, paginated list of the latest reputation
 * events for the specified user from econ_discuss_reputation_events. The Prisma
 * schema defines each ledger entry with id, user_id, optional actor_user_id,
 * optional post_id, points (signed integer), reason, source (optional),
 * occurred_at, created_at, updated_at, and optional deleted_at. Records where
 * deleted_at is set should be excluded from normal lists.
 *
 * Security: Requires authentication (role "member"). Business rules commonly
 * restrict detailed ledger visibility to the owner; providers should ensure
 * that the caller is authorized to view the specified userId or apply
 * policy-based redaction as necessary.
 *
 * Behavior: Sorting defaults to occurred_at descending. Pagination, search, or
 * sorting parameters (if any) should be provided via conventional query params
 * handled by the controller, while this contract focuses on path parameters.
 * For complex queries, use the PATCH variant on the same path. Related
 * operations include the aggregate retrieval and detailed event retrieval by
 * ID.
 *
 * @param props.connection
 * @param props.userId Target user’s ID whose reputation events are listed
 * @path /econDiscuss/member/users/:userId/reputation/events
 * @accessor api.functional.econDiscuss.member.users.reputation.events.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /** Target user’s ID whose reputation events are listed */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIEconDiscussReputationEvent;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/member/users/:userId/reputation/events",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/member/users/${encodeURIComponent(props.userId ?? "null")}/reputation/events`;
  export const random = (): IPageIEconDiscussReputationEvent =>
    typia.random<IPageIEconDiscussReputationEvent>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search paginated reputation ledger (econ_discuss_reputation_events) for a
 * user.
 *
 * This operation provides advanced search over the
 * econ_discuss_reputation_events ledger for a given user. The Prisma model
 * includes id, user_id, optional actor_user_id, optional post_id, points
 * (signed integer), reason (categorical/human-readable), source (optional),
 * occurred_at, created_at, updated_at, and an optional deleted_at used for
 * exceptional corrections. Indexes on (user_id, occurred_at) and (post_id,
 * occurred_at) make time-window queries efficient.
 *
 * Security: Access should be limited to authenticated viewers (role "member").
 * While the ledger supports audit and recomputation, user-facing exposure
 * should include only the target user’s own events unless policy permits
 * broader visibility. The provider should enforce that the path userId matches
 * the authenticated principal or apply role-based checks. The results must
 * exclude entries where deleted_at is set.
 *
 * Validation and business logic: The IEconDiscussReputationEvent.IRequest body
 * should support pagination (page, pageSize), sorting (e.g., occurred_at desc),
 * and optional filters: occurred_at range, points min/max, reason substring
 * match, actor_user_id, post_id, and status categories if represented in
 * reason/source. Related operations include GET /users/{userId}/reputation for
 * the aggregate and GET /users/{userId}/reputation/events/{eventId} for a
 * specific ledger entry. Standard error handling applies for invalid filters or
 * unauthorized access.
 *
 * @param props.connection
 * @param props.userId Target user’s ID whose reputation events are being
 *   queried
 * @param props.body Search criteria, sorting, and pagination for reputation
 *   events
 * @path /econDiscuss/member/users/:userId/reputation/events
 * @accessor api.functional.econDiscuss.member.users.reputation.events.search
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Target user’s ID whose reputation events are being queried */
    userId: string & tags.Format<"uuid">;

    /** Search criteria, sorting, and pagination for reputation events */
    body: IEconDiscussReputationEvent.IRequest;
  };
  export type Body = IEconDiscussReputationEvent.IRequest;
  export type Response = IPageIEconDiscussReputationEvent;

  export const METADATA = {
    method: "PATCH",
    path: "/econDiscuss/member/users/:userId/reputation/events",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/member/users/${encodeURIComponent(props.userId ?? "null")}/reputation/events`;
  export const random = (): IPageIEconDiscussReputationEvent =>
    typia.random<IPageIEconDiscussReputationEvent>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific reputation event (econ_discuss_reputation_events) by ID for a
 * user.
 *
 * This operation fetches a single event from econ_discuss_reputation_events.
 * The Prisma schema includes fields id, user_id, optional actor_user_id,
 * optional post_id, points (signed integer), reason, source (optional),
 * occurred_at, created_at, updated_at, and optional deleted_at. The controller
 * must enforce that the path userId matches the row’s user_id and that the
 * eventId matches id. If the event is marked inactive via deleted_at, it should
 * not be returned in active views.
 *
 * Security: Authentication (role "member") is required. The provider should
 * ensure only authorized viewers access the event details, typically
 * restricting to the owner of the events unless policy permits broader
 * visibility.
 *
 * Error handling: Return 404 if no matching event is found for the given userId
 * and eventId, or if it is not visible due to retirement. Related endpoints
 * include the aggregate reputation retrieval and the events listing/search
 * endpoints for the same user.
 *
 * @param props.connection
 * @param props.userId Owner user’s ID used to validate the event belongs to
 *   this account
 * @param props.eventId Reputation event’s ID to retrieve
 * @path /econDiscuss/member/users/:userId/reputation/events/:eventId
 * @accessor api.functional.econDiscuss.member.users.reputation.events.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Owner user’s ID used to validate the event belongs to this account */
    userId: string & tags.Format<"uuid">;

    /** Reputation event’s ID to retrieve */
    eventId: string & tags.Format<"uuid">;
  };
  export type Response = IEconDiscussReputationEvent;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/member/users/:userId/reputation/events/:eventId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/member/users/${encodeURIComponent(props.userId ?? "null")}/reputation/events/${encodeURIComponent(props.eventId ?? "null")}`;
  export const random = (): IEconDiscussReputationEvent =>
    typia.random<IEconDiscussReputationEvent>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("eventId")(() => typia.assert(props.eventId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
