import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIEconDiscussPostDraft } from "../../../../structures/IPageIEconDiscussPostDraft";
import { IEconDiscussPostDraft } from "../../../../structures/IEconDiscussPostDraft";
import { IEconDiscussPost } from "../../../../structures/IEconDiscussPost";

/**
 * List user’s private drafts from econ_discuss_post_drafts (simple).
 *
 * This endpoint lists the caller’s drafts from econ_discuss_post_drafts with
 * default paging and ordering (typically updated_at descending). The Prisma
 * schema comments define drafts as private, autosaved works with optional
 * linkage to a published post via econ_discuss_post_id and timestamps for
 * created_at/updated_at, plus a deleted_at column used to retire discarded
 * drafts. Implementations must ensure results are restricted to the
 * authenticated user via econ_discuss_user_id and that retired drafts
 * (deleted_at not null) are excluded from active listings.
 *
 * Security and permissions: only authenticated users may access this endpoint.
 * The provider enforces ownership and basic pagination. Because GET cannot
 * carry a complex request body, advanced filtering and full-text search should
 * be offered through PATCH /drafts instead.
 *
 * Related operations: use PATCH /drafts for complex search, and GET
 * /drafts/{draftId} to retrieve a specific draft object by identifier. Errors
 * include 401 when not authenticated.
 *
 * @param props.connection
 * @path /econDiscuss/member/drafts
 * @accessor api.functional.econDiscuss.member.drafts.search
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
      );
}
export namespace search {
  export type Response = IPageIEconDiscussPostDraft;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/member/drafts",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econDiscuss/member/drafts";
  export const random = (): IPageIEconDiscussPostDraft =>
    typia.random<IPageIEconDiscussPostDraft>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create a new draft in econ_discuss_post_drafts for the authenticated user.
 *
 * This endpoint creates a new draft for long-form authoring using the
 * econ_discuss_post_drafts table. Per the schema comments, drafts are private,
 * autosaved artifacts that support cross-device workflows before publication.
 * The model provides optional title and body fields so early autosave can occur
 * before the author determines final content. Ownership is recorded through
 * econ_discuss_user_id and the created_at/updated_at timestamps are populated
 * for ordering and concurrency behaviors.
 *
 * Security and permissions follow the business rules: only authenticated
 * members may create drafts. The draft is private to the owner; it is not
 * discoverable through public content surfaces until published. The operation
 * writes to econ_discuss_post_drafts and does not touch publication entities
 * such as econ_discuss_posts. If a client needs to publish later, use the
 * dedicated publish endpoint which will create the post and link it back using
 * econ_discuss_post_id.
 *
 * The database relationship is explicit: econ_discuss_post_drafts.author
 * references econ_discuss_users, and an optional publishedPost relation
 * references econ_discuss_posts through econ_discuss_post_id. No soft deletion
 * occurs during creation; however, the model supports soft deletion via
 * deleted_at for future discard operations.
 *
 * Validation and business logic: title and body are optional in the draft stage
 * by design (see schema comments) to support early autosave. Clients typically
 * include minimal fields on first save and expand during editing. The API must
 * ensure the created draft belongs to the authenticated user by setting
 * econ_discuss_user_id accordingly.
 *
 * Related operations: clients usually call PUT /drafts/{draftId} to update
 * content, DELETE /drafts/{draftId} to discard via soft deletion, and POST
 * /drafts/{draftId}/publish to create a post from the draft. Error handling
 * includes 401 for unauthenticated requests and 429 per platform rate limits
 * during burst autosaves.
 *
 * @param props.connection
 * @param props.body Creation payload for a private draft. Title/body are
 *   optional to support early autosave.
 * @path /econDiscuss/member/drafts
 * @accessor api.functional.econDiscuss.member.drafts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Creation payload for a private draft. Title/body are optional to
     * support early autosave.
     */
    body: IEconDiscussPostDraft.ICreate;
  };
  export type Body = IEconDiscussPostDraft.ICreate;
  export type Response = IEconDiscussPostDraft;

  export const METADATA = {
    method: "POST",
    path: "/econDiscuss/member/drafts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econDiscuss/member/drafts";
  export const random = (): IEconDiscussPostDraft =>
    typia.random<IEconDiscussPostDraft>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate user’s drafts from econ_discuss_post_drafts.
 *
 * This endpoint retrieves a filtered, paginated list of the caller’s private
 * drafts from econ_discuss_post_drafts. The schema describes drafts as private,
 * autosaved content owned by a user (econ_discuss_user_id), optionally linked
 * to a published post via econ_discuss_post_id, and timestamped via created_at
 * and updated_at, with deleted_at used to retire discarded drafts. Providers
 * must scope queries to the authenticated user and exclude records where
 * deleted_at is set when listing active drafts.
 *
 * Security and permissions: only authenticated users may access their own
 * drafts. Business rules should ensure that records are filtered by
 * econ_discuss_user_id matching the requester. The endpoint supports advanced
 * search use cases such as partial title matching (leveraging trigram indexes
 * on title/body noted in schema), updated_at ranges for recent work, and
 * default sorting by updated_at desc unless otherwise specified in the request
 * body.
 *
 * Validation and behavior: the request body IEconDiscussPostDraft.IRequest
 * should include pagination properties (page, pageSize) and optional filters
 * such as q (keyword against title/body), updatedFrom/updatedTo (ISO 8601), and
 * publishedLink (boolean indicating whether econ_discuss_post_id is non-null).
 * Results are returned as IPageIEconDiscussPostDraft, where each draft item
 * includes schema-aligned properties such as id, title, body (optional),
 * econ_discuss_post_id (nullable), and timestamps. Related operations include
 * GET /drafts for a default listing and GET /drafts/{draftId} for detail.
 *
 * @param props.connection
 * @param props.body Advanced filters, sorting, and pagination for listing
 *   drafts
 * @path /econDiscuss/member/drafts
 * @accessor api.functional.econDiscuss.member.drafts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Advanced filters, sorting, and pagination for listing drafts */
    body: IEconDiscussPostDraft.IRequest;
  };
  export type Body = IEconDiscussPostDraft.IRequest;
  export type Response = IPageIEconDiscussPostDraft;

  export const METADATA = {
    method: "PATCH",
    path: "/econDiscuss/member/drafts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econDiscuss/member/drafts";
  export const random = (): IPageIEconDiscussPostDraft =>
    typia.random<IPageIEconDiscussPostDraft>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single draft from econ_discuss_post_drafts by ID.
 *
 * This endpoint returns one draft from econ_discuss_post_drafts using its id.
 * The Prisma schema documents drafts as private, autosaved items owned by a
 * user (econ_discuss_user_id) with optional linkage to a published post
 * (econ_discuss_post_id) and timestamps for created_at/updated_at.
 * Implementations must verify ownership by matching the authenticated user to
 * econ_discuss_user_id and ensure that retired drafts (where deleted_at is set)
 * are handled per policy (typically not returned as active).
 *
 * Security and permissions: only authenticated users can access this endpoint,
 * and access is limited to the owner of the draft. A 404 should be returned if
 * the draft does not exist or is not accessible by the current user. This
 * endpoint is commonly used to resume editing, coordinate autosave
 * synchronization, and prepare for publishing the draft into a post.
 *
 * Related operations: PATCH /drafts supports list/search of multiple drafts,
 * and GET /drafts provides a simple paginated listing. Publishing is managed by
 * a separate endpoint outside this set (e.g., POST /drafts/{id}/publish) where
 * implemented.
 *
 * @param props.connection
 * @param props.draftId Identifier of the draft to retrieve
 * @path /econDiscuss/member/drafts/:draftId
 * @accessor api.functional.econDiscuss.member.drafts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the draft to retrieve */
    draftId: string & tags.Format<"uuid">;
  };
  export type Response = IEconDiscussPostDraft;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/member/drafts/:draftId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/member/drafts/${encodeURIComponent(props.draftId ?? "null")}`;
  export const random = (): IEconDiscussPostDraft =>
    typia.random<IEconDiscussPostDraft>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("draftId")(() => typia.assert(props.draftId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing draft (econ_discuss_post_drafts) by ID.
 *
 * This endpoint updates a draft stored in econ_discuss_post_drafts, which, per
 * schema comments, supports private autosave and cross-device editing prior to
 * publication. The model contains optional title and body fields so that
 * clients can perform frequent partial saves. The server sets updated_at to
 * reflect the most recent change.
 *
 * Security and permissions: only the owner (econ_discuss_user_id) may modify a
 * draft. The draft remains private; no post visibility changes occur here. If
 * the draft has been previously linked to a published post via
 * econ_discuss_post_id, the link remains intact; updating the draft does not
 * alter the published post. Publication is performed exclusively through the
 * publish endpoint.
 *
 * Database relationship context: econ_discuss_post_drafts.user references
 * econ_discuss_users and optionally references econ_discuss_posts via
 * econ_discuss_post_id. The operation should reject updates to soft-deleted
 * drafts where deleted_at is set, or treat them as not found based on service
 * policy.
 *
 * Validation and business logic: because title and body are optional in the
 * schema, the update accepts partial fields. The API must ensure the path
 * parameter draftId is a valid UUID referencing an existing row, and that the
 * authenticated user is the owner. Related operations include creating drafts
 * (POST /drafts), discarding drafts via soft deletion (DELETE
 * /drafts/{draftId}), and publication (POST /drafts/{draftId}/publish).
 *
 * Error handling covers: 400 for malformed UUID, 401 for unauthenticated
 * requests, 403 when the caller is not the owner, 404 if the draft does not
 * exist or is discarded, and 409 if business invariants would be violated by
 * the requested change.
 *
 * @param props.connection
 * @param props.draftId Identifier of the target draft (UUID).
 * @param props.body Fields to update on a private draft. Accepts partial fields
 *   like title/body.
 * @path /econDiscuss/member/drafts/:draftId
 * @accessor api.functional.econDiscuss.member.drafts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Identifier of the target draft (UUID). */
    draftId: string & tags.Format<"uuid">;

    /**
     * Fields to update on a private draft. Accepts partial fields like
     * title/body.
     */
    body: IEconDiscussPostDraft.IUpdate;
  };
  export type Body = IEconDiscussPostDraft.IUpdate;
  export type Response = IEconDiscussPostDraft;

  export const METADATA = {
    method: "PUT",
    path: "/econDiscuss/member/drafts/:draftId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/member/drafts/${encodeURIComponent(props.draftId ?? "null")}`;
  export const random = (): IEconDiscussPostDraft =>
    typia.random<IEconDiscussPostDraft>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("draftId")(() => typia.assert(props.draftId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Discard a draft by setting deleted_at in econ_discuss_post_drafts.
 *
 * This endpoint performs a discard operation on a draft by updating the
 * econ_discuss_post_drafts.deleted_at column. The schema explicitly documents a
 * soft deletion timestamp when the draft is discarded, indicating that removal
 * from active use should not permanently delete the row. This preserves
 * auditability and enables potential restore workflows if the service later
 * adds them.
 *
 * Security and permissions: only the authenticated owner (econ_discuss_user_id)
 * can discard their own draft. The operation does not affect any published
 * content in econ_discuss_posts if econ_discuss_post_id is present; it only
 * changes the draft’s lifecycle state.
 *
 * Database relations and behavior: econ_discuss_post_drafts references
 * econ_discuss_users (owner) and may optionally reference econ_discuss_posts.
 * Setting deleted_at hides the draft from normal retrievals. Subsequent update
 * attempts should be rejected as the draft is no longer active. The operation
 * returns no content upon success.
 *
 * Error handling: 400 for malformed UUID, 401 for unauthenticated requests, 403
 * for non-owners, and 404 if the draft is not found or is already discarded.
 * This is a soft deletion per the schema; records are not physically removed.
 *
 * @param props.connection
 * @param props.draftId Identifier of the draft to discard (UUID).
 * @path /econDiscuss/member/drafts/:draftId
 * @accessor api.functional.econDiscuss.member.drafts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Identifier of the draft to discard (UUID). */
    draftId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/econDiscuss/member/drafts/:draftId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/member/drafts/${encodeURIComponent(props.draftId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("draftId")(() => typia.assert(props.draftId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Publish a draft to a post (creates econ_discuss_posts and links from
 * econ_discuss_post_drafts).
 *
 * This endpoint publishes content from a draft in econ_discuss_post_drafts by
 * creating a post in econ_discuss_posts and linking the draft via
 * econ_discuss_post_id. As documented in the schema, econ_discuss_posts stores
 * the human-readable title, full body, optional summary, and publication
 * timestamps including published_at and optional scheduled_publish_at. On
 * publish here, the service performs immediate publication by setting
 * published_at and persisting the new post row (or reusing an existing linked
 * post if the service defines idempotency for repeated calls).
 *
 * Security and permissions: only the draft owner may publish. Because
 * econ_discuss_posts requires title and body at publication time, the server
 * validates that the draft contains non-null title and body. If validation
 * fails, the server returns a validation error and leaves the draft unchanged.
 *
 * Database relationships: econ_discuss_posts.author references
 * econ_discuss_users; econ_discuss_post_drafts.publishedPost references
 * econ_discuss_posts via econ_discuss_post_id. The operation also integrates
 * with related entities in later workflows (e.g., topic associations via
 * econ_discuss_post_topics, snapshots via econ_discuss_post_snapshots) though
 * this endpoint itself focuses on core post creation from the draft.
 *
 * Related operations: create drafts (POST /drafts), edit drafts (PUT
 * /drafts/{draftId}), and optionally discard drafts (DELETE /drafts/{draftId}).
 * Error handling includes 400 for malformed UUID, 401 unauthenticated, 403 not
 * owner, 404 draft not found or discarded, and 409 if the draft is already
 * published and the service treats re-publish as conflict.
 *
 * Note on timestamps and timezone: the database stores timestamps in UTC
 * (Timestamptz). Client-facing displays should honor the user’s configured
 * timezone (e.g., Asia/Seoul) and locale when rendering publish times.
 *
 * @param props.connection
 * @param props.draftId Identifier of the draft to publish (UUID).
 * @path /econDiscuss/member/drafts/:draftId/publish
 * @accessor api.functional.econDiscuss.member.drafts.publish
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function publish(
  connection: IConnection,
  props: publish.Props,
): Promise<publish.Response> {
  return true === connection.simulate
    ? publish.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...publish.METADATA,
          path: publish.path(props),
          status: null,
        },
      );
}
export namespace publish {
  export type Props = {
    /** Identifier of the draft to publish (UUID). */
    draftId: string & tags.Format<"uuid">;
  };
  export type Response = IEconDiscussPost;

  export const METADATA = {
    method: "POST",
    path: "/econDiscuss/member/drafts/:draftId/publish",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/member/drafts/${encodeURIComponent(props.draftId ?? "null")}/publish`;
  export const random = (): IEconDiscussPost =>
    typia.random<IEconDiscussPost>();
  export const simulate = (
    connection: IConnection,
    props: publish.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: publish.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("draftId")(() => typia.assert(props.draftId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
