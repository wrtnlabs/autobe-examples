import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussExpertDomainBadge } from "../../../../structures/IEconDiscussExpertDomainBadge";
import { IPageIEconDiscussExpertDomainBadge } from "../../../../structures/IPageIEconDiscussExpertDomainBadge";

/**
 * List expert domain badges (econ_discuss_expert_domain_badges) for a user with
 * pagination and filters.
 *
 * Retrieve a paginated, filterable list of expert domain badges associated with
 * a given user. According to the Prisma schema,
 * econ_discuss_expert_domain_badges stores per-domain badges with fields
 * including id (PK), user_id (FK to econ_discuss_users), econ_discuss_topic_id
 * (FK to econ_discuss_topics), verified_at, valid_until, revoked_at,
 * revoked_reason, created_at, updated_at, and deleted_at. These columns enable
 * client-side experiences like showing when an expert was verified, whether a
 * badge is still within validity, and if it has ever been revoked for policy
 * reasons.
 *
 * Security and visibility: expert badges are designed to be publicly visible on
 * user profiles to promote trust and expertise emphasis. This endpoint does not
 * require authentication and exposes only non-sensitive badge information.
 * Governance staff may have additional internal views; however, this public
 * list restricts itself to badge-level metadata and associated topic labels
 * derived via econ_discuss_topics.
 *
 * Relationships and behavior: Each badge belongs to a single user (user_id) and
 * a single curated topic (econ_discuss_topic_id). Clients typically join with
 * econ_discuss_topics to present human-readable domain names (name/code).
 * Consumers can filter by effective status, such as currently active
 * (revoked_at is null and (valid_until is null or in the future)), expired
 * (valid_until in the past), or revoked (revoked_at not null). Sorting commonly
 * uses verified_at or created_at to present the chronology of recognition.
 *
 * Validation and request model: The request body
 * (IEconDiscussExpertDomainBadge.IRequest) may include page/pageSize for
 * pagination, optional status filters (active/expired/revoked), optional
 * topicId filters, and sort directives (e.g., verified_at desc). The provider
 * should normalize inputs and apply safe defaults. If the specified userId does
 * not exist, return an empty page rather than an error.
 *
 * Related operations: Use GET /users/{userId}/expertDomainBadges/{badgeId} to
 * retrieve a single badge’s full details including revocation rationale if the
 * requester is authorized to see it. Topic catalog is exposed separately by
 * topic endpoints. Error handling should favor 404 only when the user is not
 * addressable according to policy; otherwise return an empty result set.
 *
 * Expected behavior and errors: Returns a page container with pagination
 * metadata and an array of badge summaries. Common errors include invalid
 * page/pageSize (400), or nonexistent identifiers in filters (ignored or 400
 * depending on policy).
 *
 * @param props.connection
 * @param props.userId Target user’s ID whose badges are being listed.
 * @param props.body Search, filter, and pagination parameters for listing a
 *   user’s expert domain badges.
 * @path /econDiscuss/users/:userId/expertDomainBadges
 * @accessor api.functional.econDiscuss.users.expertDomainBadges.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Target user’s ID whose badges are being listed. */
    userId: string & tags.Format<"uuid">;

    /**
     * Search, filter, and pagination parameters for listing a user’s expert
     * domain badges.
     */
    body: IEconDiscussExpertDomainBadge.IRequest;
  };
  export type Body = IEconDiscussExpertDomainBadge.IRequest;
  export type Response = IPageIEconDiscussExpertDomainBadge.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/econDiscuss/users/:userId/expertDomainBadges",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/users/${encodeURIComponent(props.userId ?? "null")}/expertDomainBadges`;
  export const random = (): IPageIEconDiscussExpertDomainBadge.ISummary =>
    typia.random<IPageIEconDiscussExpertDomainBadge.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific expert domain badge (econ_discuss_expert_domain_badges) for a
 * user.
 *
 * This operation returns one expert domain badge for a given user using the
 * econ_discuss_expert_domain_badges entity. The Prisma schema defines key
 * columns: id (badge identifier), user_id (owner), econ_discuss_topic_id
 * (linked curated topic), verified_at (approval time), valid_until (optional
 * expiry), revoked_at and revoked_reason (policy-driven lifecycle fields), and
 * timestamps (created_at, updated_at). These reflect the verification flow
 * described in the requirements, including approvals, expirations, and
 * revocations.
 *
 * Security and permissions: Badge visibility is generally public to promote
 * transparency of expertise. This endpoint is therefore unauthenticated.
 * Sensitive rationale fields such as revoked_reason may be redacted unless the
 * requester has appropriate governance roles; the provider logic should enforce
 * such redaction policies while keeping the contract stable.
 *
 * Entity relationships: The badge ties to econ_discuss_users via user_id and to
 * econ_discuss_topics via econ_discuss_topic_id. Clients commonly present
 * topic.name and topic.code to display the domain succinctly. The provider
 * should validate that the badgeId belongs to the given userId; otherwise,
 * respond with 404 to prevent leaking cross-user existence.
 *
 * Validation and behavior: The provider looks up a record where id = {badgeId}
 * AND user_id = {userId}. If not found, return 404. If found but marked revoked
 * or beyond validity, still return the object, allowing the client to render
 * appropriate state (e.g., inactive). The response type
 * (IEconDiscussExpertDomainBadge) contains full details needed for profile
 * rendering and auditing cues consistent with public visibility.
 *
 * Related operations: For collections, use PATCH
 * /users/{userId}/expertDomainBadges. Topic metadata is managed via topics
 * endpoints. Governance-specific mutation endpoints are out of scope here per
 * business constraints.
 *
 * @param props.connection
 * @param props.userId Owner user’s ID for scoping the badge lookup.
 * @param props.badgeId Identifier of the expert domain badge to retrieve.
 * @path /econDiscuss/users/:userId/expertDomainBadges/:badgeId
 * @accessor api.functional.econDiscuss.users.expertDomainBadges.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Owner user’s ID for scoping the badge lookup. */
    userId: string & tags.Format<"uuid">;

    /** Identifier of the expert domain badge to retrieve. */
    badgeId: string & tags.Format<"uuid">;
  };
  export type Response = IEconDiscussExpertDomainBadge;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/users/:userId/expertDomainBadges/:badgeId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/users/${encodeURIComponent(props.userId ?? "null")}/expertDomainBadges/${encodeURIComponent(props.badgeId ?? "null")}`;
  export const random = (): IEconDiscussExpertDomainBadge =>
    typia.random<IEconDiscussExpertDomainBadge>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("badgeId")(() => typia.assert(props.badgeId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
