import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussUserProfile } from "../../../../structures/IEconDiscussUserProfile";

/**
 * Get a user’s extended profile from econ_discuss_user_profiles (Actors
 * schema).
 *
 * This operation returns a user’s extended profile from
 * econ_discuss_user_profiles using the owner’s UUID in the path. The Prisma
 * schema documents fields including bio (short biography), affiliation (current
 * organization), website (public URI), and location (freeform string), as well
 * as created_at and updated_at timestamps. A profile exists at most once per
 * user (unique user_id). Implementations should only serve profiles where
 * deleted_at is null.
 *
 * Security considerations: This is typically a public read endpoint. Ensure
 * that only public profile attributes are returned. Private account attributes
 * from econ_discuss_users such as email, password_hash, mfa_secret, or recovery
 * codes must never be exposed here. The application may pair this endpoint with
 * the user core endpoint to compose a complete public profile view.
 *
 * Database relationships: The profile is owned by econ_discuss_users via
 * user_id. If a profile does not exist for a given user, return a 404 or a
 * representation consistent with your API’s not-found policy. This resource is
 * distinct from role assignment tables like econ_discuss_members or
 * econ_discuss_verified_experts, which are not part of the profile payload.
 *
 * Validation and behavior: The userId must be a valid UUID referencing
 * econ_discuss_users.id. The provider should query econ_discuss_user_profiles
 * by user_id. If no row exists or if the profile is inactive (deleted_at not
 * null), respond with not found. Timestamps should be returned as ISO 8601
 * strings.
 *
 * Related operations include GET /users/{userId} for core identity and the
 * followers endpoints for social graph views.
 *
 * Error handling: Return 404 when no active profile is found. Apply rate
 * limiting to reduce enumeration risks.
 *
 * @param props.connection
 * @param props.userId Owner user’s unique identifier (econ_discuss_users.id).
 * @path /econDiscuss/users/:userId/profile
 * @accessor api.functional.econDiscuss.users.profile.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Owner user’s unique identifier (econ_discuss_users.id). */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = IEconDiscussUserProfile;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/users/:userId/profile",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/users/${encodeURIComponent(props.userId ?? "null")}/profile`;
  export const random = (): IEconDiscussUserProfile =>
    typia.random<IEconDiscussUserProfile>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
