import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIEconDiscussTopic } from "../../../structures/IPageIEconDiscussTopic";
import { IEconDiscussTopic } from "../../../structures/IEconDiscussTopic";

/**
 * List public curated topics from econ_discuss_topics with pagination.
 *
 * This operation reads from the econ_discuss_topics table, which the Prisma
 * schema describes as a curated taxonomy of economics subjects used across the
 * platform. The table defines a unique code (immutable slug-like identifier), a
 * human-readable name, optional description, and temporal columns (created_at,
 * updated_at). The deleted_at column indicates a record is retired from active
 * use and should not appear in user-facing lists. Clients should expect that
 * only records with a null deleted_at value are returned.
 *
 * Security-wise, this is a public discovery endpoint that does not require
 * authentication. Administrative creation and maintenance of topics are handled
 * by separate restricted endpoints. Consumers can cache responses briefly;
 * however, administrators may update topic names or descriptions, so clients
 * should handle eventual consistency.
 *
 * In relation to other database entities, topics are referenced by
 * econ_discuss_post_topics (post-to-topic junction),
 * econ_discuss_user_topic_subscriptions (user subscriptions), and
 * econ_discuss_expert_domain_badges (per-domain expert badges). Changes in
 * topics may affect discovery and personalization surfaces. The list endpoint
 * is optimized for read scenarios and can be paired with GET /topics/{topicId}
 * for detailed retrieval.
 *
 * Validation and behavior: the endpoint returns a paginated container
 * (IPageIEconDiscussTopic). Although pagination and search filters are
 * implemented at the application level, the response always conforms to the
 * page wrapper. Server-side errors include 500 for unexpected failures. If the
 * catalog is empty, the data array is empty with appropriate pagination
 * metadata.
 *
 * @param props.connection
 * @path /econDiscuss/topics
 * @accessor api.functional.econDiscuss.topics.get
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function get(connection: IConnection): Promise<get.Response> {
  return true === connection.simulate
    ? get.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...get.METADATA,
          path: get.path(),
          status: null,
        },
      );
}
export namespace get {
  export type Response = IPageIEconDiscussTopic;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/topics",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econDiscuss/topics";
  export const random = (): IPageIEconDiscussTopic =>
    typia.random<IPageIEconDiscussTopic>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Search/paginate topics (econ_discuss_topics) with keyword and sorting.
 *
 * Retrieve a filtered and paginated list of economics topics for discovery
 * based on the econ_discuss_topics entity.
 *
 * Purpose and overview: Clients use this endpoint to power topic search,
 * selection dialogs, and topic pages. It supports free-text search across name
 * and description and returns a page of concise records.
 *
 * Security considerations: This endpoint is public read and does not require
 * authentication. It must only return non-archived topics by default (i.e.,
 * exclude records whose archival timestamp is set). Administrative creation or
 * modification of topics is out of scope here.
 *
 * Database relationship: The econ_discuss_topics table defines id (UUID PK),
 * code (unique slug), name, optional description, created/updated timestamps,
 * and an archival timestamp used to hide topics from user-facing lists. This
 * endpoint transforms those rows into summary DTOs suitable for list
 * presentation.
 *
 * Validation and business logic: Validate pagination bounds (page â‰¥ 1,
 * reasonable pageSize limits). Apply keyword filtering to name/description
 * fields. Sorting may include name asc/desc or recency by
 * created_at/updated_at. Exclude archived records by default, with no way to
 * include them via this public endpoint to avoid exposing retired topics.
 *
 * Related operations: Topic detail retrieval (e.g., GET /topics/{topicId}) and
 * subscription endpoints are separate concerns. This endpoint focuses solely on
 * list/search.
 *
 * @param props.connection
 * @param props.body Search, pagination, and sorting parameters for topics
 *   listing
 * @path /econDiscuss/topics
 * @accessor api.functional.econDiscuss.topics.patch
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search, pagination, and sorting parameters for topics listing */
    body: IEconDiscussTopic.IRequest;
  };
  export type Body = IEconDiscussTopic.IRequest;
  export type Response = IPageIEconDiscussTopic.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/econDiscuss/topics",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econDiscuss/topics";
  export const random = (): IPageIEconDiscussTopic.ISummary =>
    typia.random<IPageIEconDiscussTopic.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single topic from econ_discuss_topics by its UUID.
 *
 * This operation targets the econ_discuss_topics table, which holds the curated
 * taxonomy used throughout the platform. The schema defines the following
 * notable columns: id (UUID primary key), code (unique slug-like business
 * identifier), name (display name), description (optional), created_at,
 * updated_at, and an archival marker deleted_at. When deleted_at is non-null,
 * the record is considered retired from active use and should not be served to
 * end users.
 *
 * Authorization: public read access. Administrative writes occur through
 * restricted endpoints. The operation should be safe to use across pages that
 * need to show topic details, including topic pages and post authoring flows.
 *
 * Relationships: topics are joined from econ_discuss_post_topics for filtering
 * posts, from econ_discuss_user_topic_subscriptions for personalization, and
 * from econ_discuss_expert_domain_badges for expert domain badges. If the
 * requested topic does not exist or is retired, the server returns 404.
 * Validation consists of verifying that the provided topicId is a valid UUID
 * and that the record is present and active.
 *
 * @param props.connection
 * @param props.topicId Unique identifier of the target topic.
 * @path /econDiscuss/topics/:topicId
 * @accessor api.functional.econDiscuss.topics.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target topic. */
    topicId: string & tags.Format<"uuid">;
  };
  export type Response = IEconDiscussTopic;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/topics/:topicId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/topics/${encodeURIComponent(props.topicId ?? "null")}`;
  export const random = (): IEconDiscussTopic =>
    typia.random<IEconDiscussTopic>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("topicId")(() => typia.assert(props.topicId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
