import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussLiveThread } from "../../../structures/IEconDiscussLiveThread";
import { IPageIEconDiscussLiveThread } from "../../../structures/IPageIEconDiscussLiveThread";

/**
 * Search and paginate live threads (econ_discuss_live_threads) with filters and
 * sorting.
 *
 * Retrieve a filtered, paginated index of live discussion threads. The backing
 * schema econ_discuss_live_threads tracks lifecycle fields state,
 * scheduled_start_at, started_at, paused_at, ended_at, archived_at, as well as
 * governance flags expert_only and access_scope and performance affordances
 * like slow_mode_interval_seconds. Timestamps are stored as timestamptz.
 * Because there is exactly one live thread per post (unique
 * econ_discuss_post_id), clients can tie threads to their host content in
 * econ_discuss_posts for display contexts.
 *
 * Security considerations: this read endpoint is public, but business logic
 * should exclude threads that the current viewer cannot access (e.g.,
 * invite_only without authorization) and any rows marked inactive via
 * deleted_at. The access_scope influences who may view or participate; this
 * index should list only those threads visible to the requester. For curated or
 * role-restricted views, the provider may add further filtering based on
 * current user privileges.
 *
 * Validation and behavior: the request body supports pagination (page,
 * pageSize), sorting (e.g., created_at or started_at desc), and filters by
 * state, expert_only, access_scope, host_user_id, and scheduled time ranges.
 * The response returns a paginated summary optimized for list UIs, including
 * identifiers, current state, key timestamps, host reference, and flags.
 * Related operations include GET /liveThreads/{liveThreadId} for detail
 * retrieval and GET /posts/{postId}/live to fetch the thread bound to a
 * specific post.
 *
 * @param props.connection
 * @param props.body Filter, sort, and paginate live threads (state,
 *   expert_only, access_scope, host, time windows)
 * @path /econDiscuss/liveThreads
 * @accessor api.functional.econDiscuss.liveThreads.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filter, sort, and paginate live threads (state, expert_only,
     * access_scope, host, time windows)
     */
    body: IEconDiscussLiveThread.IRequest;
  };
  export type Body = IEconDiscussLiveThread.IRequest;
  export type Response = IPageIEconDiscussLiveThread.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/econDiscuss/liveThreads",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econDiscuss/liveThreads";
  export const random = (): IPageIEconDiscussLiveThread.ISummary =>
    typia.random<IPageIEconDiscussLiveThread.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a live thread by ID from econ_discuss_live_threads.
 *
 * Return the full live thread resource identified by liveThreadId. The
 * econ_discuss_live_threads schema includes state (scheduled, waiting, live,
 * paused, ended, archived), scheduling/transition timestamps
 * (scheduled_start_at, started_at, paused_at, ended_at, archived_at), an
 * expert_only boolean, access_scope string, and slow_mode_interval_seconds.
 * Associations link to the host post (econ_discuss_post_id) and the host user
 * (host_user_id). Timestamps are timestamptz and should be serialized as ISO
 * 8601.
 *
 * Security and visibility: although the route is public read, provider logic
 * must enforce access_scope and exclude records where deleted_at is set. If the
 * thread is invite_only and the requester lacks permission, a 404 or forbidden
 * should be returned according to policy. For archived threads, content remains
 * readable but participation is disabled by state.
 *
 * Validation and related operations: validate that the identifier is a proper
 * UUID and that the record exists. For message retrieval use the dedicated
 * messages route (e.g., per-post live messages), while this endpoint returns
 * the threadâ€™s metadata and current state. Related discovery is provided by
 * PATCH /liveThreads for search and by GET /posts/{postId}/live to fetch a
 * thread via its host post.
 *
 * @param props.connection
 * @param props.liveThreadId Identifier of the target live thread
 * @path /econDiscuss/liveThreads/:liveThreadId
 * @accessor api.functional.econDiscuss.liveThreads.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the target live thread */
    liveThreadId: string & tags.Format<"uuid">;
  };
  export type Response = IEconDiscussLiveThread;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/liveThreads/:liveThreadId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/liveThreads/${encodeURIComponent(props.liveThreadId ?? "null")}`;
  export const random = (): IEconDiscussLiveThread =>
    typia.random<IEconDiscussLiveThread>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("liveThreadId")(() => typia.assert(props.liveThreadId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
