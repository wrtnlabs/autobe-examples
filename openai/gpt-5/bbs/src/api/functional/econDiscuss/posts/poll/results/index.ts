import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussPollResults } from "../../../../../structures/IEconDiscussPollResults";
import { IEconDiscussPollResult } from "../../../../../structures/IEconDiscussPollResult";

/**
 * Get aggregated poll results derived from poll/response tables.
 *
 * Get aggregated results for the poll associated with a post. The Prisma schema
 * defines econ_discuss_polls (question, type, expert_only, visibility_mode,
 * allow_vote_change, start_at/end_at), answer options in
 * econ_discuss_poll_options, and respondent data in econ_discuss_poll_responses
 * and econ_discuss_poll_response_options. This endpoint must not reveal
 * individual responses; instead, it publishes aggregate counts and, when
 * applicable, rankings or numeric summaries.
 *
 * Security and visibility: results must respect
 * econ_discuss_polls.visibility_mode. For hidden_until_close, do not return
 * running results before end_at; for visible_after_vote, require the caller to
 * have a recorded econ_discuss_poll_responses row; for always_visible, show
 * running totals. Additionally, apply any minimum thresholds for segments as
 * per business rules (e.g., hide segments that do not meet k-anonymity). The
 * endpoint is read-only and typically public; enforcement of expert_only
 * participation does not imply restricted read access unless policy dictates.
 *
 * Validation and behavior: verify that the postId has a poll
 * (econ_discuss_polls unique on econ_discuss_post_id). Calculate option counts
 * using econ_discuss_poll_response_options (including ranking positions if
 * needed) and include totalResponses. Exclude responses marked
 * quarantined/invalidated from tallies as required by integrity policy. Return
 * 404 when the post has no poll, and 409 when policy forbids showing results at
 * this time. Timestamps are in ISO 8601 where included, and the standard error
 * model applies.
 *
 * @param props.connection
 * @param props.postId Host post ID (UUID) that owns the poll
 * @path /econDiscuss/posts/:postId/poll/results
 * @accessor api.functional.econDiscuss.posts.poll.results.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Host post ID (UUID) that owns the poll */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = IEconDiscussPollResults;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/posts/:postId/poll/results",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/posts/${encodeURIComponent(props.postId ?? "null")}/poll/results`;
  export const random = (): IEconDiscussPollResults =>
    typia.random<IEconDiscussPollResults>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Aggregate and return poll results for a post’s poll (econ_discuss_polls and
 * related tables).
 *
 * Compute and return aggregated results for the poll attached to a specific
 * post. The underlying schema stores one poll per post in econ_discuss_polls,
 * with configuration fields such as question (text), question_type
 * (single_choice, multiple_choice, likert, ranking, numeric_estimate),
 * visibility_mode (hidden_until_close, visible_after_vote, always_visible),
 * expert_only (boolean), allow_vote_change (boolean), optional
 * min_voter_reputation and min_account_age_hours, and the start_at/end_at
 * schedule (all as timestamptz). Options are stored in
 * econ_discuss_poll_options with per-poll uniqueness and ordering via position.
 * Respondent data lives in econ_discuss_poll_responses with status (active,
 * withdrawn, quarantined, invalidated), and type-specific values (likert_value,
 * numeric_value). For multiple-choice and ranking types, selected options are
 * in econ_discuss_poll_response_options with an optional position for ranking.
 *
 * Security and visibility rules follow the poll’s business configuration and
 * policy. For example, if visibility_mode is hidden_until_close and the poll
 * has not ended (end_at), the service must return either a minimal envelope or
 * deny access to running tallies according to application policy. For
 * expert_only polls, the results may still be viewable by the public after
 * close, but the provider should consult policy before exposing running
 * tallies. Records with deleted_at set in any of the relevant tables are
 * treated as inactive and excluded from results. The endpoint itself is public
 * for read, but the provider must enforce the poll’s visibility constraints
 * derived from econ_discuss_polls.
 *
 * This operation is related to detail retrieval of the poll configuration
 * (e.g., GET /posts/{postId}/poll) which can inform clients of question_type,
 * visibility_mode, and schedule before requesting results. Validation includes
 * ensuring the postId maps to an existing econ_discuss_posts row that has an
 * attached econ_discuss_polls row, verifying schedule windows (start_at and
 * end_at) against current time, and applying minimum segment thresholds if the
 * provider supports segmented outputs. If the poll is not found or visibility
 * rules prevent disclosure, return a not-found or appropriate denial. Error
 * handling should surface invalid states (e.g., question_type unsupported) as
 * 400-level errors and missing resources as 404.
 *
 * @param props.connection
 * @param props.postId Target post’s ID that hosts the poll
 * @param props.body Result computation parameters (e.g., segmentation controls,
 *   normalization window, pagination for option-level breakdowns)
 * @path /econDiscuss/posts/:postId/poll/results
 * @accessor api.functional.econDiscuss.posts.poll.results.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Target post’s ID that hosts the poll */
    postId: string & tags.Format<"uuid">;

    /**
     * Result computation parameters (e.g., segmentation controls,
     * normalization window, pagination for option-level breakdowns)
     */
    body: IEconDiscussPollResult.IRequest;
  };
  export type Body = IEconDiscussPollResult.IRequest;
  export type Response = IEconDiscussPollResult;

  export const METADATA = {
    method: "PATCH",
    path: "/econDiscuss/posts/:postId/poll/results",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/posts/${encodeURIComponent(props.postId ?? "null")}/poll/results`;
  export const random = (): IEconDiscussPollResult =>
    typia.random<IEconDiscussPollResult>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
