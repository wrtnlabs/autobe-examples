import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIEconDiscussPost } from "../../../structures/IPageIEconDiscussPost";
import { IEconDiscussPost } from "../../../structures/IEconDiscussPost";
export * as topics from "./topics/index";
export * as versions from "./versions/index";
export * as poll from "./poll/index";
export * as live from "./live/index";

/**
 * List published posts from econ_discuss_posts with pagination.
 *
 * Retrieve a paginated list of publicly visible posts from econ_discuss_posts.
 * The model includes title, body, summary (optional), and publication
 * timestamps. Only posts with a non-null published_at and a null deleted_at
 * should be included for public callers.
 *
 * Security and visibility: this is a public read operation. Business logic may
 * further exclude scheduled posts (scheduled_publish_at in the future) and
 * enforce any moderation visibility rules. Ownership or elevated roles are not
 * required for this endpoint.
 *
 * Related entities include econ_discuss_users (author attribution) and
 * econ_discuss_post_topics (topic links to econ_discuss_topics). Clients often
 * call this endpoint to render a home or explore feed and then use GET
 * /econDiscuss/posts/{postId} to load full details of a selected item.
 *
 * @param props.connection
 * @path /econDiscuss/posts
 * @accessor api.functional.econDiscuss.posts.get
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function get(connection: IConnection): Promise<get.Response> {
  return true === connection.simulate
    ? get.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...get.METADATA,
          path: get.path(),
          status: null,
        },
      );
}
export namespace get {
  export type Response = IPageIEconDiscussPost.ISummary;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/posts",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econDiscuss/posts";
  export const random = (): IPageIEconDiscussPost.ISummary =>
    typia.random<IPageIEconDiscussPost.ISummary>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Search and paginate posts from econ_discuss_posts with rich filters and
 * sorting.
 *
 * This collection operation reads from econ_discuss_posts, which includes id
 * (UUID), econ_discuss_user_id (author), title, body, summary, published_at,
 * scheduled_publish_at, created_at, updated_at, and deleted_at. Results exclude
 * rows where deleted_at is not null and typically prefer published_at for
 * ordering when available. Topic filtering leverages econ_discuss_post_topics
 * (unique per post/topic), and expert-only filtering is implemented by joining
 * author ids to econ_discuss_verified_experts (verified_at and optional
 * badge_valid_until) to restrict results to verified expert authors.
 *
 * The request body (IEconDiscussPost.IRequest) should provide pagination fields
 * (page, pageSize), free-text query, optional authorId, array of topicIds,
 * expertOnly boolean, dateFrom/dateTo targeting published_at, and sort options
 * such as new or trending. Trending may consider recent weighted interactions
 * using econ_discuss_post_votes (vote_type up/down and status) alongside
 * recency; exact ranking is provider-defined but consistent with business
 * policies. The response returns a paginated container
 * (IPageIEconDiscussPost.ISummary) optimized for list views, containing
 * summaries rather than full text where appropriate.
 *
 * Security-wise, this is a public read endpoint, so authorizationRole is null.
 * Validation enforces UUID formats for identifiers, ensures page/pageSize
 * bounds, normalizes date ranges, and rejects queries referencing archived
 * topics. Errors include 400 for invalid filters, 404 only when a strictly
 * scoped filter yields a missing referenced entity, and 429 when rate limits
 * apply. Related endpoints include GET /posts/{id} to fetch a single post and
 * topic subscription operations that influence personalization but not the
 * search scope directly.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination parameters for post
 *   discovery.
 * @path /econDiscuss/posts
 * @accessor api.functional.econDiscuss.posts.patch
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search, filter, and pagination parameters for post discovery. */
    body: IEconDiscussPost.IRequest;
  };
  export type Body = IEconDiscussPost.IRequest;
  export type Response = IPageIEconDiscussPost.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/econDiscuss/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/econDiscuss/posts";
  export const random = (): IPageIEconDiscussPost.ISummary =>
    typia.random<IPageIEconDiscussPost.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single post from econ_discuss_posts by ID.
 *
 * Retrieve a specific post from econ_discuss_posts using its UUID. The model
 * defines title, body, optional summary, publication timestamps (published_at,
 * scheduled_publish_at), and lifecycle timestamps (created_at, updated_at). For
 * public callers, only posts that are currently visible should be
 * returnedâ€”typically those with published_at set and deleted_at null.
 * Implementations may enforce exclusion of scheduled or hidden items per
 * policy.
 *
 * This operation relates to taxonomy and authoring: topic associations are in
 * econ_discuss_post_topics referencing econ_discuss_topics, and author
 * attribution uses econ_discuss_users via econ_discuss_user_id. Interaction
 * aggregates (votes/bookmarks) live in econ_discuss_post_votes and
 * econ_discuss_post_bookmarks, but they do not alter the core post entity.
 *
 * Validation includes ensuring the path parameter is a valid UUID and applying
 * visibility checks. Expected errors include 404 when the post does not exist
 * or is not visible to the caller.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the target post
 * @path /econDiscuss/posts/:postId
 * @accessor api.functional.econDiscuss.posts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target post */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = IEconDiscussPost;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): IEconDiscussPost =>
    typia.random<IEconDiscussPost>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
