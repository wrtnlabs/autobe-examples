import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIEconDiscussLiveMessage } from "../../../../../structures/IPageIEconDiscussLiveMessage";
import { IEconDiscussLiveMessage } from "../../../../../structures/IEconDiscussLiveMessage";

/**
 * List live messages for a post’s live thread (econ_discuss_live_messages).
 *
 * Fetch live discussion messages for a post’s associated live thread. According
 * to the Prisma schema comments, econ_discuss_live_threads “represents a live
 * discussion thread (room) attached to a specific post” (1:1 with
 * econ_discuss_posts), and econ_discuss_live_messages stores “raw message
 * content, type, and lifecycle timestamps” with allowed message_type values
 * (text, system, poll_prompt, poll_result, moderation_notice, pinned). Results
 * are chronologically ordered by created_at for fan-out and transcript views,
 * and the pinned boolean can be used by clients for contextual pinning.
 *
 * Security and permissions follow the live thread’s configuration. While many
 * threads are publicly readable, access_scope on econ_discuss_live_threads
 * (public, followers_only, topic_subscribers_only, invite_only) governs
 * visibility. Expert-only participation does not necessarily restrict reading,
 * but implementers must enforce visibility checks based on the live thread
 * record. No authentication is required for publicly readable threads; private
 * scopes must be handled by business logic.
 *
 * Database linkage uses postId to resolve econ_discuss_live_threads via
 * econ_discuss_post_id, then returns associated econ_discuss_live_messages.
 * Only non-removed messages should be returned to end-users; records with
 * internal removal timestamps should be filtered out by provider logic. The API
 * supports paging (page, pageSize) and may accept a client-provided time cursor
 * (e.g., since as ISO 8601) to reduce payloads between polls.
 *
 * Related operations include creating a new message (POST
 * /posts/{postId}/live/messages), reading a specific message (GET
 * /posts/{postId}/live/messages/{messageId}), and updating a message (PUT
 * /posts/{postId}/live/messages/{messageId}). Error cases include 404 when the
 * post or its live thread does not exist, and 403 when access_scope disallows
 * reading for the current user context.
 *
 * @param props.connection
 * @param props.postId Target post’s ID whose live thread messages are requested
 * @path /econDiscuss/posts/:postId/live/messages
 * @accessor api.functional.econDiscuss.posts.live.messages.getByPostid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getByPostid(
  connection: IConnection,
  props: getByPostid.Props,
): Promise<getByPostid.Response> {
  return true === connection.simulate
    ? getByPostid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByPostid.METADATA,
          path: getByPostid.path(props),
          status: null,
        },
      );
}
export namespace getByPostid {
  export type Props = {
    /** Target post’s ID whose live thread messages are requested */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIEconDiscussLiveMessage;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/posts/:postId/live/messages",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/posts/${encodeURIComponent(props.postId ?? "null")}/live/messages`;
  export const random = (): IPageIEconDiscussLiveMessage =>
    typia.random<IPageIEconDiscussLiveMessage>();
  export const simulate = (
    connection: IConnection,
    props: getByPostid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByPostid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate live messages for a post’s live thread
 * (econ_discuss_live_messages).
 *
 * List messages belonging to a post’s live thread. The
 * econ_discuss_live_messages schema stores each message with a foreign key to
 * econ_discuss_live_threads (econ_discuss_live_thread_id), an optional author
 * econ_discuss_user_id to preserve transcripts when accounts are anonymized,
 * and fields such as message_type (e.g., text, system, poll_prompt,
 * poll_result, moderation_notice, pinned via the pinned boolean), edited_at for
 * limited edit windows, and deleted_at for removal that retains transcript
 * placeholders. Messages are ordered and queried using created_at and indexed
 * composite keys to support efficient retrieval.
 *
 * Security and visibility are governed by the parent thread’s access controls
 * on econ_discuss_live_threads (expert_only, access_scope). While the route is
 * public for read, the service must enforce scope, e.g., public vs
 * followers_only vs topic_subscribers_only vs invite_only. The read_at concept
 * is not part of this model; clients should rely on message timestamps. The
 * response uses a paginated container and can support real-time refresh by
 * specifying a since (ISO 8601) filter in the request body to return only newer
 * messages.
 *
 * Validation and errors: return 404 if the post does not exist or if no live
 * thread is associated; 400 for invalid pagination or filter values; and 403 if
 * access_scope or expert_only rules disallow viewing for the caller.
 *
 * @param props.connection
 * @param props.postId Target post’s ID whose live messages are being requested
 * @param props.body Filter and pagination criteria for retrieving live messages
 *   (e.g., since, message types, pinned, page, pageSize)
 * @path /econDiscuss/posts/:postId/live/messages
 * @accessor api.functional.econDiscuss.posts.live.messages.patchByPostid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patchByPostid(
  connection: IConnection,
  props: patchByPostid.Props,
): Promise<patchByPostid.Response> {
  return true === connection.simulate
    ? patchByPostid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patchByPostid.METADATA,
          path: patchByPostid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace patchByPostid {
  export type Props = {
    /** Target post’s ID whose live messages are being requested */
    postId: string & tags.Format<"uuid">;

    /**
     * Filter and pagination criteria for retrieving live messages (e.g.,
     * since, message types, pinned, page, pageSize)
     */
    body: IEconDiscussLiveMessage.IRequest;
  };
  export type Body = IEconDiscussLiveMessage.IRequest;
  export type Response = IPageIEconDiscussLiveMessage;

  export const METADATA = {
    method: "PATCH",
    path: "/econDiscuss/posts/:postId/live/messages",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/posts/${encodeURIComponent(props.postId ?? "null")}/live/messages`;
  export const random = (): IPageIEconDiscussLiveMessage =>
    typia.random<IPageIEconDiscussLiveMessage>();
  export const simulate = (
    connection: IConnection,
    props: patchByPostid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patchByPostid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific live message (econ_discuss_live_messages) by ID for a post.
 *
 * Return a specific live message from the live discussion attached to a post.
 * Per Prisma schema, econ_discuss_live_messages stores the message metadata
 * (message_type, content, pinned, edited_at, created_at) and links to the
 * thread via econ_discuss_live_thread_id. The enclosing
 * econ_discuss_live_threads record provides access_scope and expert_only flags
 * that must be enforced to protect visibility, and its lifecycle state
 * (scheduled, live, paused, ended, archived) guides read expectations (e.g.,
 * archived threads remain readable per policy).
 *
 * Security: Typically public reads are allowed for public threads, but
 * access_scope may restrict viewing (followers_only, topic_subscribers_only,
 * invite_only). Implementations must validate that the message’s thread
 * corresponds to the provided postId to avoid cross-thread access, and filter
 * out messages not eligible for end-user display.
 *
 * Error handling: 404 when the post, thread, or message is not found or does
 * not belong together; 403 when access is not permitted. This endpoint does not
 * modify data and returns the full message object on success.
 *
 * @param props.connection
 * @param props.postId Owning post’s ID for the live thread
 * @param props.messageId Live message ID within the post’s live thread
 * @path /econDiscuss/posts/:postId/live/messages/:messageId
 * @accessor api.functional.econDiscuss.posts.live.messages.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Owning post’s ID for the live thread */
    postId: string & tags.Format<"uuid">;

    /** Live message ID within the post’s live thread */
    messageId: string & tags.Format<"uuid">;
  };
  export type Response = IEconDiscussLiveMessage;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/posts/:postId/live/messages/:messageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/posts/${encodeURIComponent(props.postId ?? "null")}/live/messages/${encodeURIComponent(props.messageId ?? "null")}`;
  export const random = (): IEconDiscussLiveMessage =>
    typia.random<IEconDiscussLiveMessage>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("messageId")(() => typia.assert(props.messageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
