import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIEconDiscussTopic } from "../../../../structures/IPageIEconDiscussTopic";
import { IEconDiscussPostTopic } from "../../../../structures/IEconDiscussPostTopic";

/**
 * List topics linked to a post using econ_discuss_post_topics and
 * econ_discuss_topics.
 *
 * Retrieve the curated topics linked to a post through the
 * econ_discuss_post_topics junction. The Topics schema comment explains that
 * econ_discuss_topics is the curated taxonomy used for organizing content and
 * personalization, with code, name, description, and deleted_at for archival.
 * The postâ€“topic relationships are stored in econ_discuss_post_topics, which
 * enforces uniqueness per (econ_discuss_post_id, econ_discuss_topic_id) and
 * includes created_at/updated_at and deleted_at.
 *
 * Security and visibility: Topic associations for a publicly visible post are
 * generally public. If the target post is retired (deleted_at in
 * econ_discuss_posts) or otherwise restricted, application logic should adjust
 * visibility or respond with a suitable error per policy. This endpoint does
 * not require authentication by default, and it returns only non-deleted topics
 * and active associations (junction rows where deleted_at is null).
 *
 * Data model context: econ_discuss_post_topics references econ_discuss_posts
 * and econ_discuss_topics with onDelete: Cascade. Since this is a read-only
 * query, it simply joins the junction with the topics table and returns
 * relevant Topic fields in a summary form suitable for lists. Implementers
 * should consistently filter both the junction and topics where deleted_at IS
 * NULL to avoid returning archived data. Sorting may default to association
 * created_at or topic name.
 *
 * Error handling: Return 404 if the post does not exist or is inaccessible.
 * Support typical pagination parameters in the response container. This
 * endpoint complements the PATCH variant for advanced searching/filtering of
 * attached topics.
 *
 * @param props.connection
 * @param props.postId Target post's ID
 * @path /econDiscuss/posts/:postId/topics
 * @accessor api.functional.econDiscuss.posts.topics.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /** Target post's ID */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIEconDiscussTopic.ISummary;

  export const METADATA = {
    method: "GET",
    path: "/econDiscuss/posts/:postId/topics",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/econDiscuss/posts/${encodeURIComponent(props.postId ?? "null")}/topics`;
  export const random = (): IPageIEconDiscussTopic.ISummary =>
    typia.random<IPageIEconDiscussTopic.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Advanced search over topics linked to a post (econ_discuss_post_topics +
 * econ_discuss_topics).
 *
 * This advanced retrieval endpoint returns a filtered, sorted, and paginated
 * list of topics attached to a given post. It uses the econ_discuss_post_topics
 * junction (which includes created_at, updated_at, and deleted_at) to constrain
 * results to those linked to the target post, and pulls display metadata from
 * econ_discuss_topics (code, name, description, deleted_at). The Topics schema
 * emphasizes curated taxonomy and discoverability; this endpoint aligns by
 * providing server-side search over topic name/description with appropriate
 * indexes (gin_trgm_ops on name/description) as indicated in the Prisma
 * comments.
 *
 * Security and visibility: Designed as a public read operation; however, if the
 * parent post is retired (deleted_at set in econ_discuss_posts) or
 * access-limited, the service layer should respond accordingly. Only active
 * associations (junction deleted_at is null) and non-deleted topics
 * (topics.deleted_at is null) are returned.
 *
 * Validation and business rules: The request body
 * (IEconDiscussPostTopic.IRequest) may include parameters such as keyword q,
 * sort (e.g., created_at desc or name asc), and pagination fields. Service code
 * should sanitize inputs, apply indexes efficiently, and enforce reasonable
 * pageSize limits. This endpoint is complementary to the simpler GET variant;
 * clients may prefer PATCH when complex filtering is required.
 *
 * Related operations: Use GET /posts/{postId}/topics for a simple listing, and
 * POST /posts/{postId}/topics to attach a new topic to the post. Error handling
 * includes 404 for missing/hidden post, and 400 for invalid filter inputs.
 *
 * @param props.connection
 * @param props.postId Target post's ID
 * @param props.body Search, sort, and pagination parameters for topics attached
 *   to the post
 * @path /econDiscuss/posts/:postId/topics
 * @accessor api.functional.econDiscuss.posts.topics.search
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Target post's ID */
    postId: string & tags.Format<"uuid">;

    /**
     * Search, sort, and pagination parameters for topics attached to the
     * post
     */
    body: IEconDiscussPostTopic.IRequest;
  };
  export type Body = IEconDiscussPostTopic.IRequest;
  export type Response = IPageIEconDiscussTopic.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/econDiscuss/posts/:postId/topics",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/econDiscuss/posts/${encodeURIComponent(props.postId ?? "null")}/topics`;
  export const random = (): IPageIEconDiscussTopic.ISummary =>
    typia.random<IPageIEconDiscussTopic.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
