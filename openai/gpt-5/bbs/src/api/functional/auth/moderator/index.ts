import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussModerator } from "../../../structures/IEconDiscussModerator";

/**
 * Register a moderator by creating econ_discuss_users and assigning
 * econ_discuss_moderators, returning an authorized session.
 *
 * Purpose and overview: This endpoint registers a new moderator by creating a
 * user identity in Actors.econ_discuss_users and attaching a role record in
 * Actors.econ_discuss_moderators. The econ_discuss_users table holds the
 * authentication backbone with fields like email (unique identifier) and
 * password_hash (never plaintext), as well as profile-adjacent preferences such
 * as timezone and locale. The econ_discuss_moderators table confirms the user’s
 * moderator scope and includes enforced_2fa to reflect policy that moderators
 * require multi-factor authentication.
 *
 * Implementation details: On success, a new econ_discuss_users row is inserted
 * using the provided email, a securely derived password_hash, and a
 * display_name. Optional preferences timezone and locale are persisted if
 * provided. The email_verified flag can be initialized according to business
 * policy; the mfa_enabled flag should be false at registration until setup
 * occurs. Immediately after, a row in econ_discuss_moderators is created for
 * this user_id, and enforced_2fa should be set true to signal mandatory 2FA for
 * elevated actions. Timestamps created_at and updated_at are managed
 * consistently with schema expectations.
 *
 * Role-specific integration and context: Because moderators have governance
 * capabilities, this registration path is restricted to creating users who will
 * act under the moderator role as represented by econ_discuss_moderators.
 * Downstream services use joins from econ_discuss_users →
 * econ_discuss_moderators to authorize access to moderation tools and queues.
 *
 * Security considerations: Passwords must be hashed before storage in
 * password_hash. Since econ_discuss_users also supports mfa_secret and
 * mfa_recovery_codes, the system should prompt the new moderator to enable 2FA
 * promptly, honoring the enforced_2fa flag in econ_discuss_moderators. Token
 * issuance returns a short-lived access token and a longer-lived refresh token,
 * consistent with session rotation policies.
 *
 * Related operations and workflow: Typical flows continue with
 * /auth/moderator/login for subsequent sessions and /auth/moderator/refresh for
 * token renewal. Email ownership confirmation can be handled by separate
 * verification processes referencing econ_discuss_users.email_verified.
 *
 * Error handling expectations: Return 409 when email in econ_discuss_users
 * violates the unique constraint. Return 400 for invalid timezone (IANA) or
 * locale (BCP 47) formats, and 422 for password strength policy failures.
 * Rate-limit repeated attempts and consider 429 responses when exceeded.
 *
 * @param props.connection
 * @param props.body Moderator registration payload including email, password,
 *   display name, and optional timezone/locale.
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/join
 * @accessor api.functional.auth.moderator.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Moderator registration payload including email, password, display
     * name, and optional timezone/locale.
     */
    body: IEconDiscussModerator.ICreate;
  };
  export type Body = IEconDiscussModerator.ICreate;
  export type Response = IEconDiscussModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/join";
  export const random = (): IEconDiscussModerator.IAuthorized =>
    typia.random<IEconDiscussModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate a moderator using econ_discuss_users and confirm role via
 * econ_discuss_moderators; return an authorized session.
 *
 * Purpose and overview: This endpoint authenticates a moderator by verifying
 * econ_discuss_users.email and password_hash, then confirming moderator scope
 * via econ_discuss_moderators for the same user. It creates a new session and
 * returns tokens in a single response.
 *
 * Implementation details: Credentials are matched to econ_discuss_users.email
 * and checked against password_hash. If email verification gating is in effect,
 * econ_discuss_users.email_verified can be consulted to restrict elevated
 * actions. The endpoint also checks for a corresponding econ_discuss_moderators
 * row and evaluates enforced_2fa together with econ_discuss_users.mfa_enabled
 * to determine whether a one-time code is required and validate it against
 * mfa_secret as applicable.
 *
 * Role-specific integration and context: Moderator access is derived from the
 * presence of a role record in econ_discuss_moderators tied to the same
 * econ_discuss_users.id. Authentication succeeds only when both identity and
 * role conditions pass.
 *
 * Security considerations: On success, return short-lived access and
 * longer-lived refresh tokens. Apply rotation and replay protections per
 * policy. Support recovery codes stored in
 * econ_discuss_users.mfa_recovery_codes for emergency access flows when allowed
 * by policy. Consider lockout/cooldown on repeated failures without disclosing
 * whether email exists.
 *
 * Related operations and workflow: Use /auth/moderator/join to register new
 * accounts and /auth/moderator/refresh to renew expired access tokens.
 * Post-login flows may prompt enabling 2FA if
 * econ_discuss_moderators.enforced_2fa is true and
 * econ_discuss_users.mfa_enabled is false.
 *
 * Error handling expectations: Respond with a generic 401 for invalid
 * credentials. Respond with 403 if role assignment in econ_discuss_moderators
 * is missing or lacks required 2FA conditions. Enforce rate limits and return
 * 429 when thresholds are exceeded.
 *
 * @param props.connection
 * @param props.body Login payload including email, password, and, when
 *   required, a second-factor code.
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/login
 * @accessor api.functional.auth.moderator.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Login payload including email, password, and, when required, a
     * second-factor code.
     */
    body: IEconDiscussModerator.ILogin;
  };
  export type Body = IEconDiscussModerator.ILogin;
  export type Response = IEconDiscussModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/login";
  export const random = (): IEconDiscussModerator.IAuthorized =>
    typia.random<IEconDiscussModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh a moderator session by validating refresh token and role in
 * econ_discuss_moderators, issuing new tokens.
 *
 * Purpose and overview: This endpoint exchanges a valid refresh token for a new
 * access token for a moderator session. It ensures the identity in
 * econ_discuss_users is still active and that the moderator role assignment in
 * econ_discuss_moderators remains present.
 *
 * Implementation details: Upon receiving the refresh token, validate signature,
 * expiration, and rotation rules. Resolve the associated econ_discuss_users.id
 * from claims, confirm role assignment by querying econ_discuss_moderators
 * using the same user_id, and then mint a new short-lived access token and
 * rotated refresh token.
 *
 * Role-specific integration and context: Because moderator privileges can
 * change over time, the operation re-checks econ_discuss_moderators on each
 * refresh to prevent continued elevated access after role removal.
 *
 * Security considerations: Implement token rotation to mitigate theft and
 * revoke prior tokens upon use. Respect enforced_2fa policies established via
 * econ_discuss_moderators and any mfa_enabled state recorded on
 * econ_discuss_users; when policy requires, step-up authentication should be
 * enforced before granting elevated actions.
 *
 * Related operations and workflow: This operation complements
 * /auth/moderator/login for initial sessions and /auth/moderator/join for new
 * registrations. Downstream APIs should rely on the access token claims derived
 * from econ_discuss_users.
 *
 * Error handling expectations: Return 401 if the refresh token is invalid,
 * expired, or revoked. Return 403 if moderator role assignment no longer
 * exists. Apply 429 on excessive attempts and include generic error messaging
 * to avoid enumerating account details.
 *
 * @param props.connection
 * @param props.body Refresh payload containing a valid refresh token requiring
 *   rotation upon success.
 * @setHeader token.access Authorization
 *
 * @path /auth/moderator/refresh
 * @accessor api.functional.auth.moderator.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh payload containing a valid refresh token requiring rotation
     * upon success.
     */
    body: IEconDiscussModerator.IRefresh;
  };
  export type Body = IEconDiscussModerator.IRefresh;
  export type Response = IEconDiscussModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/moderator/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/moderator/refresh";
  export const random = (): IEconDiscussModerator.IAuthorized =>
    typia.random<IEconDiscussModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
