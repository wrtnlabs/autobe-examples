import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussMember } from "../../../structures/IEconDiscussMember";
export * as email from "./email/index";
export * as password from "./password/index";
export * as mfa from "./mfa/index";

/**
 * Register a new Member by creating econ_discuss_users and assigning
 * econ_discuss_members (issue tokens).
 *
 * This endpoint registers a new Member using the Actors schema. It persists a
 * user in econ_discuss_users with the provided email (email), a securely
 * derived password_hash from the submitted password, a human-readable
 * display_name, and optional timezone and locale fields, as documented in the
 * Prisma comments. At creation time, email_verified is set to false to reflect
 * that email verification is pending; mfa_enabled is false and both mfa_secret
 * and mfa_recovery_codes are null as no multi-factor enrollment has happened.
 *
 * Upon successful user creation, the API also establishes role membership by
 * inserting an econ_discuss_members record referencing the user via user_id and
 * populating joined_at, created_at, and updated_at. This follows the role model
 * where membership capabilities derive from the existence of an
 * econ_discuss_members row linked to econ_discuss_users.
 *
 * Security-wise, the operation validates uniqueness of econ_discuss_users.email
 * and rejects duplicates. Passwords are never stored in plaintext; only
 * password_hash is persisted according to the schema comment. The response
 * includes signed JWTs (access and refresh) and essential subject claims
 * derived from econ_discuss_users.id and role context.
 *
 * This operation relates to subsequent flows like email verification
 * (email_verified flag) and 2FA enablement (mfa_enabled, mfa_secret,
 * mfa_recovery_codes). Clients commonly call
 * /auth/member/email/verification/resend to send a verification message after
 * registration.
 *
 * Error handling includes conflict on existing email (unique constraint on
 * econ_discuss_users.email), validation errors for required properties, and
 * generic server errors. All timestamps are populated using
 * created_at/updated_at columns as per Prisma definitions.
 *
 * @param props.connection
 * @param props.body Registration payload with credentials and profile basics.
 * @setHeader token.access Authorization
 *
 * @path /auth/member/join
 * @accessor api.functional.auth.member.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Registration payload with credentials and profile basics. */
    body: IEconDiscussMember.ICreate;
  };
  export type Body = IEconDiscussMember.ICreate;
  export type Response = IEconDiscussMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/join";
  export const random = (): IEconDiscussMember.IAuthorized =>
    typia.random<IEconDiscussMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate a Member based on econ_discuss_users credentials and issue
 * tokens.
 *
 * This operation authenticates via the Actors schema: it loads
 * econ_discuss_users by email, verifies the provided password against
 * password_hash, and confirms the presence of an econ_discuss_members row for
 * role membership. If email_verified is false, the system may restrict certain
 * actions while still allowing login, consistent with the business
 * requirements.
 *
 * Multi-factor state derives from mfa_enabled; if true, the server may require
 * a valid one-time code before finalizing authentication. The database stores
 * 2FA artifacts in mfa_secret and mfa_recovery_codes; these are never returned
 * to clients.
 *
 * On success, the service issues access and refresh JWTs containing subject
 * identifiers derived from econ_discuss_users.id and role "member". Timestamps
 * like updated_at may be touched depending on auditing policies but are
 * schema-available.
 *
 * Related operations include /auth/member/refresh for token renewal,
 * /auth/member/mfa/setup and /auth/member/mfa/verify for enabling 2FA, and
 * /auth/member/password/reset for recovery.
 *
 * Errors include invalid credentials, missing member assignment (no
 * econ_discuss_members row), account restrictions, or rate-limit cooldowns. The
 * email uniqueness on econ_discuss_users is central to identity lookup.
 *
 * @param props.connection
 * @param props.body Email/password (and optional 2FA code) for authentication.
 * @setHeader token.access Authorization
 *
 * @path /auth/member/login
 * @accessor api.functional.auth.member.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Email/password (and optional 2FA code) for authentication. */
    body: IEconDiscussMember.ILogin;
  };
  export type Body = IEconDiscussMember.ILogin;
  export type Response = IEconDiscussMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/login";
  export const random = (): IEconDiscussMember.IAuthorized =>
    typia.random<IEconDiscussMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh JWT tokens for a Member using submitted refresh token (stateless;
 * user in econ_discuss_users).
 *
 * This operation performs token renewal for authenticated sessions. It accepts
 * a refresh token in the request, validates its signature and claims, and
 * issues a new access token. Rotation of refresh tokens may be performed per
 * policy. The underlying user belongs to econ_discuss_users; the Member role is
 * indicated by the presence of an econ_discuss_members record.
 *
 * Because tokens are short-lived and not stored in the database schema, the
 * operation is stateless with respect to persistence. However, it may include
 * role data (member) and security flags like mfa_enabled in claims for
 * client-side hints.
 *
 * This endpoint is often invoked after /auth/member/login or after access token
 * expiration. If the refresh token is expired or revoked, the operation fails,
 * requiring a new login.
 *
 * No database write is required beyond optional audit trails; no Prisma table
 * is updated in this flow under the given schema.
 *
 * @param props.connection
 * @param props.body Refresh token payload for renewal/rotation.
 * @setHeader token.access Authorization
 *
 * @path /auth/member/refresh
 * @accessor api.functional.auth.member.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token payload for renewal/rotation. */
    body: IEconDiscussMember.IRefresh;
  };
  export type Body = IEconDiscussMember.IRefresh;
  export type Response = IEconDiscussMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/refresh";
  export const random = (): IEconDiscussMember.IAuthorized =>
    typia.random<IEconDiscussMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Global logout for a Member (revoke active sessions across devices).
 *
 * This operation implements a global sign-out. It invalidates active refresh
 * tokens for the user across devices and requires re-authentication. The Actors
 * schema (econ_discuss_users) does not define token tables, so revocation is
 * managed out-of-band. The endpoint may update updated_at for audit
 * consistency.
 *
 * This is aligned with the business requirement to support "log out on all
 * devices" within 30 seconds.
 *
 * @param props.connection
 * @path /auth/member/logoutAll
 * @accessor api.functional.auth.member.logoutAll
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logoutAll(connection: IConnection): Promise<void> {
  return true === connection.simulate
    ? logoutAll.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logoutAll.METADATA,
          path: logoutAll.path(),
          status: null,
        },
      );
}
export namespace logoutAll {
  export const METADATA = {
    method: "POST",
    path: "/auth/member/logoutAll",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/logoutAll";
  export const random = (): void => typia.random<void>();
  export const simulate = (_connection: IConnection): void => {
    return random();
  };
}

/**
 * Logout current session for a Member (revoke presented refresh token).
 *
 * This operation logs out only the current device/session. As in the schema, no
 * token persistence table exists; therefore, the server invalidates the
 * presented refresh token and prevents further renewals.
 *
 * This complements logoutAll and standard session lifecycle, with no changes to
 * econ_discuss_users beyond optional updated_at.
 *
 * @param props.connection
 * @path /auth/member/logout
 * @accessor api.functional.auth.member.logout
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logout(connection: IConnection): Promise<void> {
  return true === connection.simulate
    ? logout.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logout.METADATA,
          path: logout.path(),
          status: null,
        },
      );
}
export namespace logout {
  export const METADATA = {
    method: "POST",
    path: "/auth/member/logout",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/logout";
  export const random = (): void => typia.random<void>();
  export const simulate = (_connection: IConnection): void => {
    return random();
  };
}
