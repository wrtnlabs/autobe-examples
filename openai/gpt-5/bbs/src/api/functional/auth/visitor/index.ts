import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussVisitorJoin } from "../../../structures/IEconDiscussVisitorJoin";
import { IEconDiscussVisitor } from "../../../structures/IEconDiscussVisitor";
import { IEconDiscussVisitorRefresh } from "../../../structures/IEconDiscussVisitorRefresh";

/**
 * Register a Visitor account in econ_discuss_users and assign
 * econ_discuss_visitors, returning Visitor authorization.
 *
 * Purpose and overview This operation registers a new account intended for the
 * Visitor role and returns authorized session tokens. It persists a base
 * identity in the Actors namespace using econ_discuss_users (id, email,
 * password_hash, display_name, avatar_uri?, timezone?, locale?, email_verified,
 * mfa_enabled, mfa_secret?, mfa_recovery_codes?, created_at, updated_at,
 * deleted_at?) and then assigns the role in econ_discuss_visitors (id, user_id,
 * notes?, created_at, updated_at, deleted_at?). The API produces an
 * authorization payload for client-side session establishment.
 *
 * Implementation details and schema alignment At minimum, the service writes
 * econ_discuss_users.email (unique per @@unique[email]) and
 * econ_discuss_users.password_hash (derived server-side from the plaintext
 * credential received), along with econ_discuss_users.display_name. It may also
 * record optional preferences to econ_discuss_users.timezone (e.g.,
 * "Asia/Seoul") and econ_discuss_users.locale (e.g., "en-US"). The operation
 * initializes econ_discuss_users.email_verified to false and
 * econ_discuss_users.mfa_enabled to false unless policy indicates otherwise.
 * Creation and update timestamps populate econ_discuss_users.created_at and
 * econ_discuss_users.updated_at. After creating the base user, it inserts an
 * econ_discuss_visitors record referencing the same user via
 * econ_discuss_visitors.user_id and initializes its created_at and updated_at.
 *
 * Role relationship and business context The visitor capability is represented
 * explicitly by econ_discuss_visitors linked to econ_discuss_users via user_id.
 * Assigning this record signals platform behavior consistent with a read-only
 * baseline. The system may also create a profile row later in
 * econ_discuss_user_profiles, but that is not required for registration. No
 * moderator, admin, or member role rows are created by this operation; it
 * focuses on visitor onboarding only.
 *
 * Security considerations Passwords are never persisted in plaintext; the
 * requestâ€™s password is transformed into econ_discuss_users.password_hash by
 * the server. JWTs issued on success include at least claims for
 * econ_discuss_users.id and the Visitor role. If multi-factor authentication is
 * introduced later, econ_discuss_users.mfa_enabled and related secret/recovery
 * fields (mfa_secret, mfa_recovery_codes) remain unset here. Email verification
 * is tracked by econ_discuss_users.email_verified and may gate certain
 * capabilities until confirmed by separate flows.
 *
 * Related operations and error handling Clients typically call the refresh
 * endpoint (/auth/visitor/refresh) to rotate tokens. Conflicts on email are
 * returned as 409 when econ_discuss_users.email violates the unique constraint.
 * Validation problems on required inputs return 400. Excessive attempts should
 * return 429 according to policy. Successful registration returns an
 * authorization structure with access and refresh tokens aligned to the Visitor
 * role.
 *
 * @param props.connection
 * @param props.body Visitor registration payload including credentials and
 *   optional preferences.
 * @setHeader token.access Authorization
 *
 * @path /auth/visitor/join
 * @accessor api.functional.auth.visitor.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Visitor registration payload including credentials and optional
     * preferences.
     */
    body: IEconDiscussVisitorJoin.ICreate;
  };
  export type Body = IEconDiscussVisitorJoin.ICreate;
  export type Response = IEconDiscussVisitor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/visitor/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/visitor/join";
  export const random = (): IEconDiscussVisitor.IAuthorized =>
    typia.random<IEconDiscussVisitor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh Visitor JWTs after validating refresh token and confirming visitor
 * role via econ_discuss_visitors.
 *
 * Purpose and overview This operation rotates JWTs for a Visitor by consuming a
 * presented refresh token and returning a new authorized session. While no
 * content entities are changed, the service may check the underlying Actors
 * tables for account and role status: econ_discuss_users (id, email_verified,
 * mfa_enabled, created_at, updated_at, deleted_at?) and econ_discuss_visitors
 * (user_id). The objective is to sustain authenticated sessions with
 * short-lived access tokens and longer-lived refresh tokens.
 *
 * Implementation details and schema alignment The controller validates the
 * refresh token and, if accepted, issues new tokens associated with
 * econ_discuss_users.id and the Visitor role. The refresh logic can deny
 * rotation if the linked econ_discuss_users row indicates a state that
 * disallows continued sessions (e.g., removal signaled via deleted_at) or if
 * the econ_discuss_visitors relation no longer exists for the user_id. This
 * preserves coherence with role assignment represented in the
 * econ_discuss_visitors table.
 *
 * Role-specific integration and business context Visitor is a read-oriented
 * role captured by a row in econ_discuss_visitors. The refresh process confirms
 * the role remains applicable before minting new credentials. The endpoint does
 * not alter moderator, member, or admin tables.
 *
 * Security considerations The handler ensures refresh token validity and
 * rotation policy, producing new short-lived access tokens and an updated
 * refresh token where appropriate. Tokens embed minimal claims (user id and
 * Visitor role). Two-factor flags (econ_discuss_users.mfa_enabled) are
 * advisory; this endpoint does not enroll or verify second factors. Email
 * verification (econ_discuss_users.email_verified) can influence downstream
 * capabilities but does not prevent token issuance unless policy dictates.
 *
 * Related operations and error handling Use /auth/visitor/join to create an
 * initial account. Refresh token errors yield 401 or 403. Accounts without a
 * corresponding econ_discuss_visitors assignment or with states that disallow
 * continuation should return 403. On success, the response returns an
 * authorization structure suitable for client storage and subsequent API
 * access.
 *
 * @param props.connection
 * @param props.body Refresh request including an existing refresh token.
 * @setHeader token.access Authorization
 *
 * @path /auth/visitor/refresh
 * @accessor api.functional.auth.visitor.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh request including an existing refresh token. */
    body: IEconDiscussVisitorRefresh.IRequest;
  };
  export type Body = IEconDiscussVisitorRefresh.IRequest;
  export type Response = IEconDiscussVisitor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/visitor/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/visitor/refresh";
  export const random = (): IEconDiscussVisitor.IAuthorized =>
    typia.random<IEconDiscussVisitor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
