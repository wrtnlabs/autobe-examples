import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussVerifiedExpertJoin } from "../../../structures/IEconDiscussVerifiedExpertJoin";
import { IEconDiscussVerifiedExpert } from "../../../structures/IEconDiscussVerifiedExpert";
import { IEconDiscussVerifiedExpertLogin } from "../../../structures/IEconDiscussVerifiedExpertLogin";
import { IEconDiscussVerifiedExpertRefresh } from "../../../structures/IEconDiscussVerifiedExpertRefresh";
export * as password from "./password/index";
export * as email from "./email/index";
export * as mfa from "./mfa/index";

/**
 * Register verified expert account into econ_discuss_users and issue initial
 * tokens.
 *
 * This endpoint registers a new account intended to participate as a verified
 * expert after completing the separate verification program. It persists
 * identity in the Actors schema table econ_discuss_users, populating email,
 * password_hash (derived from the submitted password), and display_name.
 * Optional preferences such as timezone and locale are stored to support
 * notification scheduling and localization. Columns email_verified and
 * mfa_enabled are initialized to false, with mfa_secret and mfa_recovery_codes
 * left null until multi‑factor enrollment. Timestamps created_at and updated_at
 * are recorded by the application layer.
 *
 * Security considerations include secure password hashing mapped to
 * econ_discuss_users.password_hash and immediate token issuance. The new
 * account’s email_verified remains false, which allows read access but may
 * restrict posting or voting per policy until the email is confirmed. MFA is
 * not enabled at join time; enrollment occurs via dedicated MFA endpoints
 * backed by econ_discuss_users.mfa_enabled, mfa_secret, and
 * mfa_recovery_codes.
 *
 * From a data model perspective, this writes to econ_discuss_users only. Role
 * assignment tables such as econ_discuss_verified_experts are not modified
 * here; expert status is granted later through the verification workflow. If
 * the service maintains a general membership record in econ_discuss_members,
 * that may be created by downstream business logic but is not required for the
 * join call itself.
 *
 * Validation requires unique email (enforced by @@unique([email]) on
 * econ_discuss_users), non‑empty display_name, and a compliant password that
 * can be hashed into password_hash. The operation should reject duplicate
 * emails and return a conflict error without leaking whether an address already
 * exists, following authentication UX guidelines.
 *
 * This operation is typically followed by email verification (to toggle
 * econ_discuss_users.email_verified via a separate verify endpoint) and
 * optional MFA enrollment (which sets mfa_enabled and secrets). After
 * verification, users may proceed to post, vote, and start expert verification,
 * which eventually populates econ_discuss_verified_experts.
 *
 * @param props.connection
 * @param props.body Registration payload for a verified expert account.
 * @setHeader token.access Authorization
 *
 * @path /auth/verifiedExpert/join
 * @accessor api.functional.auth.verifiedExpert.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Registration payload for a verified expert account. */
    body: IEconDiscussVerifiedExpertJoin.ICreate;
  };
  export type Body = IEconDiscussVerifiedExpertJoin.ICreate;
  export type Response = IEconDiscussVerifiedExpert.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/verifiedExpert/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/verifiedExpert/join";
  export const random = (): IEconDiscussVerifiedExpert.IAuthorized =>
    typia.random<IEconDiscussVerifiedExpert.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate econ_discuss_users and issue tokens for verifiedExpert context.
 *
 * This login endpoint checks the submitted email and password against
 * econ_discuss_users.email and econ_discuss_users.password_hash, issuing tokens
 * on success. If econ_discuss_users.mfa_enabled is true, it requires a valid
 * one‑time code derived from mfa_secret or a valid value from
 * mfa_recovery_codes. Email verification state is read from
 * econ_discuss_users.email_verified for post‑login gating in downstream
 * features; the login may still succeed while the platform limits write actions
 * until verification is complete.
 *
 * The operation does not modify database rows on success except for typical
 * updated_at handling in econ_discuss_users performed by the application where
 * appropriate. It does not create or remove role records; presence of a row in
 * econ_discuss_verified_experts linked via
 * econ_discuss_verified_experts.user_id may be used by token generation to
 * include verifiedExpert claims used by authorization decorators.
 *
 * Security rules should enforce generic error messages on failure, rate
 * limiting after repeated failures, and optional device/session metadata
 * capture outside of this schema. MFA enforcement strictly relies on
 * econ_discuss_users.mfa_enabled and associated secret/recovery data columns.
 *
 * This login is commonly paired with token refresh to rotate refresh tokens and
 * with email verification and MFA endpoints for strengthening account
 * assurance. Error handling should include invalid credentials, missing second
 * factor when required, and disabled accounts if deleted_at is set on
 * econ_discuss_users.
 *
 * @param props.connection
 * @param props.body Credentials (and optional 2FA code) for verified expert
 *   login.
 * @setHeader token.access Authorization
 *
 * @path /auth/verifiedExpert/login
 * @accessor api.functional.auth.verifiedExpert.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Credentials (and optional 2FA code) for verified expert login. */
    body: IEconDiscussVerifiedExpertLogin.ICreate;
  };
  export type Body = IEconDiscussVerifiedExpertLogin.ICreate;
  export type Response = IEconDiscussVerifiedExpert.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/verifiedExpert/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/verifiedExpert/login";
  export const random = (): IEconDiscussVerifiedExpert.IAuthorized =>
    typia.random<IEconDiscussVerifiedExpert.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh verifiedExpert JWTs without modifying econ_discuss_users.
 *
 * The refresh endpoint returns a new authorized session for a verified expert
 * using a valid refresh token presented via secure channel (e.g., httpOnly
 * cookie or header as per policy). It does not create or update rows in
 * econ_discuss_users or role tables. Because token rotation and revocation
 * lists are implementation details, the database schema does not constrain this
 * operation; however, email_verified and mfa_enabled readouts may inform claim
 * composition.
 *
 * Security considerations include rotation on use, revocation on anomalies, and
 * denial when the refresh token is expired or invalid. The endpoint should not
 * require an access token and should produce a new token pair following the
 * project’s JWT policy. Error responses must be generic to avoid leaking token
 * state.
 *
 * Use this together with login to maintain short‑lived access tokens for
 * verified experts and to support concurrent device sessions consistent with
 * business policies.
 *
 * @param props.connection
 * @param props.body Refresh token container as defined by the service policy.
 * @setHeader token.access Authorization
 *
 * @path /auth/verifiedExpert/refresh
 * @accessor api.functional.auth.verifiedExpert.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token container as defined by the service policy. */
    body: IEconDiscussVerifiedExpertRefresh.ICreate;
  };
  export type Body = IEconDiscussVerifiedExpertRefresh.ICreate;
  export type Response = IEconDiscussVerifiedExpert.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/verifiedExpert/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/verifiedExpert/refresh";
  export const random = (): IEconDiscussVerifiedExpert.IAuthorized =>
    typia.random<IEconDiscussVerifiedExpert.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
