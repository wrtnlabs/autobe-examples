import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEconDiscussAdmin } from "../../../structures/IEconDiscussAdmin";
export * as email from "./email/index";
export * as password from "./password/index";
export * as mfa from "./mfa/index";

/**
 * Register a new admin by creating econ_discuss_users and econ_discuss_admins
 * and return tokens.
 *
 * This endpoint registers a new administrator account and immediately issues
 * JWT tokens upon successful creation. It persists the base identity into the
 * Actors.econ_discuss_users table, specifically setting fields such as email
 * (unique identifier), password_hash (application-generated from the submitted
 * password), display_name, optional avatar_uri, timezone, and locale. As per
 * schema comments, email_verified should start as false until verification
 * completes, mfa_enabled should be false, with mfa_secret and
 * mfa_recovery_codes null.
 *
 * After creating the user, the operation inserts a corresponding role
 * assignment row into Actors.econ_discuss_admins using the new
 * econ_discuss_users.id as the user_id. This role record persists
 * administrative capabilities and policy flags including superuser (full
 * platform administration) and enforced_2fa (policy-relevant enforcement for
 * administrators), both documented in the Prisma schema.
 *
 * The endpoint is designed with security considerations in mind. Passwords are
 * never stored in plaintext and map to econ_discuss_users.password_hash. MFA is
 * not enabled at join time; admins can subsequently enable TOTP using dedicated
 * MFA endpoints tied to econ_discuss_users.mfa_enabled, mfa_secret, and
 * mfa_recovery_codes. Token issuance occurs only after both econ_discuss_users
 * and econ_discuss_admins are persisted.
 *
 * From a relational perspective, econ_discuss_admins has a unique constraint on
 * user_id, and a strict one-to-one relationship with econ_discuss_users,
 * ensuring a single administrator assignment per user. The login and refresh
 * flows later rely on econ_discuss_users.email and password_hash for credential
 * validation and on the presence of an econ_discuss_admins record to assert
 * admin scope.
 *
 * Validation rules align with the schema characteristics: email must be unique;
 * display_name is required for the identity surface; timezone is an IANA
 * identifier (e.g., Asia/Seoul) as stored in econ_discuss_users.timezone; and
 * locale aligns with econ_discuss_users.locale. The provider should also
 * initialize email_verified=false with a follow-up verification flow using the
 * dedicated email endpoints.
 *
 * Related operations include POST /auth/admin/login for credential
 * authentication, POST /auth/admin/refresh for token rotation, and POST
 * /auth/admin/mfa/* endpoints for enabling TOTP-based MFA informed by
 * econ_discuss_users.mfa_secret and mfa_recovery_codes. Email verification
 * flows are available via /auth/admin/email/* and toggle
 * econ_discuss_users.email_verified once completed.
 *
 * @param props.connection
 * @param props.body Admin registration payload including email, password,
 *   display name, and optional preferences.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/join
 * @accessor api.functional.auth.admin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Admin registration payload including email, password, display name,
     * and optional preferences.
     */
    body: IEconDiscussAdmin.ICreate;
  };
  export type Body = IEconDiscussAdmin.ICreate;
  export type Response = IEconDiscussAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/join";
  export const random = (): IEconDiscussAdmin.IAuthorized =>
    typia.random<IEconDiscussAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate an admin using econ_discuss_users and econ_discuss_admins and
 * issue tokens.
 *
 * This operation authenticates an administrator using the econ_discuss_users
 * table fields email and password_hash, ensuring that plaintext credentials are
 * hashed and compared securely. It also verifies that a role assignment exists
 * in econ_discuss_admins (unique per user_id) to confirm the admin scope
 * documented by the schema.
 *
 * If the userâ€™s econ_discuss_users.email_verified is false, business policy may
 * restrict certain actions until verification completes; the table column is
 * designed to signal verification state. If econ_discuss_admins.enforced_2fa is
 * true, the service SHOULD require a successful second factor, leveraging
 * econ_discuss_users.mfa_enabled, mfa_secret, and potential TOTP codes before
 * issuing final tokens.
 *
 * On success, the endpoint issues JWT tokens and returns an authorized payload
 * typed as IEconDiscussAdmin.IAuthorized. The payload may include role and
 * permission claims derived from the existence of econ_discuss_admins, and
 * optional context like timezone (econ_discuss_users.timezone) and locale
 * (econ_discuss_users.locale) for client experience.
 *
 * This endpoint aligns with schema relationships: econ_discuss_admins
 * references econ_discuss_users via user_id under a one-to-one unique
 * constraint. It does not create or modify role records; it only validates
 * their presence. Passwords are never stored or returned, and password_hash
 * remains confidential within econ_discuss_users.
 *
 * Use this in conjunction with the registration endpoint (/auth/admin/join),
 * token refresh (/auth/admin/refresh), and the MFA management endpoints that
 * directly reflect econ_discuss_users.mfa_* fields. Error handling should not
 * disclose whether the email exists, to avoid user enumeration.
 *
 * @param props.connection
 * @param props.body Admin login credentials and optional MFA code when required
 *   by policy.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/login
 * @accessor api.functional.auth.admin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Admin login credentials and optional MFA code when required by
     * policy.
     */
    body: IEconDiscussAdmin.ILogin;
  };
  export type Body = IEconDiscussAdmin.ILogin;
  export type Response = IEconDiscussAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/login";
  export const random = (): IEconDiscussAdmin.IAuthorized =>
    typia.random<IEconDiscussAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh administrator JWT tokens after validating econ_discuss_users and
 * econ_discuss_admins state.
 *
 * This endpoint accepts a valid refresh token and returns a new access/refresh
 * token pair. Before issuing new tokens, the service validates that the subject
 * corresponds to an existing econ_discuss_users row and that a linked
 * econ_discuss_admins record still exists, preserving admin scope. If the admin
 * role record has been removed, the operation must decline refresh.
 *
 * The Actors.econ_discuss_users table provides core identity fields that can be
 * embedded as claims (e.g., userId from id, email, timezone, and locale), while
 * econ_discuss_admins confirms role-based privileges and can drive claims such
 * as superuser and enforced_2fa from its columns. The refresh flow does not
 * modify any of these tables directly.
 *
 * Security-wise, the endpoint supports rotation-on-use semantics. If policy
 * requires MFA enforcement (econ_discuss_admins.enforced_2fa) and the account
 * has econ_discuss_users.mfa_enabled=true, ensure that the session has
 * satisfied recent 2FA checks before token renewal.
 *
 * This endpoint should be paired with /auth/admin/login and /auth/admin/join
 * for initial issuance, and with MFA and email verification endpoints for
 * account hardening. Failures should be generic to avoid leaking token validity
 * details.
 *
 * @param props.connection
 * @param props.body Refresh token request payload (rotation-on-use).
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/refresh
 * @accessor api.functional.auth.admin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token request payload (rotation-on-use). */
    body: IEconDiscussAdmin.IRefresh;
  };
  export type Body = IEconDiscussAdmin.IRefresh;
  export type Response = IEconDiscussAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/refresh";
  export const random = (): IEconDiscussAdmin.IAuthorized =>
    typia.random<IEconDiscussAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
