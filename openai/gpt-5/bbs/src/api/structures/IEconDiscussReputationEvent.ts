import { tags } from "typia";

import { IEReputationEventSortBy } from "./IEReputationEventSortBy";
import { IESortOrder } from "./IESortOrder";

/**
 * Reputation ledger entry DTO representing a single immutable event.
 *
 * Backed by Prisma model: econ_discuss_reputation_events. Key columns: id
 * (UUID), user_id, optional actor_user_id, optional post_id, points (Int),
 * reason (String), source (String?), occurred_at (DateTime),
 * created_at/updated_at. This response omits soft-deletion internals
 * (deleted_at) from public views.
 *
 * Security: contains no passwords, tokens, or other secrets.
 * Ownership/authorization is enforced externally; this type is safe for
 * user-facing history views.
 *
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export type IEconDiscussReputationEvent = {
  /**
   * Unique identifier of the ledger entry.
   *
   * Maps to econ_discuss_reputation_events.id (UUID PK).
   */
  id: string & tags.Format<"uuid">;

  /**
   * Beneficiary user's ID receiving the reputation delta.
   *
   * Maps to econ_discuss_reputation_events.user_id (FK â†’
   * econ_discuss_users.id).
   */
  userId: string & tags.Format<"uuid">;

  /**
   * Optional actor responsible for the event (e.g., curator, voter).
   *
   * Maps to econ_discuss_reputation_events.actor_user_id. Nullable in schema,
   * hence union string|null.
   */
  actorUserId?: (string & tags.Format<"uuid">) | null | undefined;

  /**
   * Optional related post ID for content-scoped events.
   *
   * Maps to econ_discuss_reputation_events.post_id. Nullable in schema, hence
   * union string|null.
   */
  postId?: (string & tags.Format<"uuid">) | null | undefined;

  /**
   * Signed integer delta applied to the user's reputation for this event.
   *
   * Maps to econ_discuss_reputation_events.points. Positive for gains,
   * negative for penalties.
   */
  points: number & tags.Type<"int32">;

  /**
   * Human-readable category for the points change.
   *
   * Maps to econ_discuss_reputation_events.reason (e.g., upvote_post,
   * curated_feature, moderation_penalty).
   */
  reason: string;

  /**
   * Optional source system or process identifier for traceability.
   *
   * Maps to econ_discuss_reputation_events.source.
   */
  source?: string | null | undefined;

  /**
   * Timestamp when the underlying action occurred; used for time-window
   * calculations and decay.
   *
   * Maps to econ_discuss_reputation_events.occurred_at (timestamptz).
   */
  occurredAt: string & tags.Format<"date-time">;

  /**
   * Ledger entry creation timestamp.
   *
   * Maps to econ_discuss_reputation_events.created_at.
   */
  createdAt: string & tags.Format<"date-time">;

  /**
   * Last update timestamp (rare for append-only ledgers, but present in
   * schema).
   *
   * Maps to econ_discuss_reputation_events.updated_at.
   */
  updatedAt: string & tags.Format<"date-time">;
};
export namespace IEconDiscussReputationEvent {
  /**
   * Request parameters for searching and paginating the reputation ledger per
   * user.
   *
   * Backed by Prisma model: econ_discuss_reputation_events columns include
   * occurred_at (DateTime), points (Int), reason (String), post_id (String?
   * UUID), created_at/updated_at. This DTO carries filters only; controllers
   * enforce ownership/authorization using the authenticated principal and
   * path parameters.
   *
   * Security: No direct user-id filters are accepted to comply with platform
   * policy. Use path scoping and server-side context for user identity.
   *
   * Pagination: follows platform conventions (page, limit).
   */
  export type IRequest = {
    /**
     * Page index for pagination (1-based).
     *
     * Business: request a specific page of the reputation ledger.
     * Validation: positive integer. Maps to standard pagination semantics.
     */
    page?: (number & tags.Type<"int32"> & tags.Minimum<1>) | undefined;

    /**
     * Maximum number of records to return per page.
     *
     * Business: bound result size for stable paging and performance. Server
     * may enforce upper bound (e.g., 200).
     */
    limit?:
      | (number & tags.Type<"int32"> & tags.Minimum<1> & tags.Maximum<200>)
      | undefined;

    /**
     * Inclusive lower bound for occurred_at filtering (ISO 8601).
     *
     * Maps to econ_discuss_reputation_events.occurred_at >= dateFrom.
     */
    dateFrom?: (string & tags.Format<"date-time">) | undefined;

    /**
     * Inclusive upper bound for occurred_at filtering (ISO 8601).
     *
     * Maps to econ_discuss_reputation_events.occurred_at <= dateTo.
     */
    dateTo?: (string & tags.Format<"date-time">) | undefined;

    /**
     * Minimum points (delta) to include.
     *
     * Maps to econ_discuss_reputation_events.points >= pointsMin.
     */
    pointsMin?: (number & tags.Type<"int32">) | undefined;

    /**
     * Maximum points (delta) to include.
     *
     * Maps to econ_discuss_reputation_events.points <= pointsMax.
     */
    pointsMax?: (number & tags.Type<"int32">) | undefined;

    /**
     * Substring filter applied to econ_discuss_reputation_events.reason.
     *
     * Examples: upvote_post, curated_feature, moderation_penalty.
     */
    reason?: string | undefined;

    /**
     * Filter events linked to a specific post.
     *
     * Maps to econ_discuss_reputation_events.post_id (UUID).
     */
    postId?: (string & tags.Format<"uuid">) | undefined;

    /** Sort key applied to the results. See IEReputationEventSortBy. */
    sortBy?: IEReputationEventSortBy | undefined;

    /** Sort direction applied alongside sortBy: asc | desc. */
    sortOrder?: IESortOrder | undefined;
  };
}
