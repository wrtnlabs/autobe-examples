import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postEconDiscussMemberPostsPostIdLiveMessages } from "../../../../../../providers/postEconDiscussMemberPostsPostIdLiveMessages";
import { MemberAuth } from "../../../../../../decorators/MemberAuth";
import { MemberPayload } from "../../../../../../decorators/payload/MemberPayload";
import { putEconDiscussMemberPostsPostIdLiveMessagesMessageId } from "../../../../../../providers/putEconDiscussMemberPostsPostIdLiveMessagesMessageId";
import { deleteEconDiscussMemberPostsPostIdLiveMessagesMessageId } from "../../../../../../providers/deleteEconDiscussMemberPostsPostIdLiveMessagesMessageId";

import { IEconDiscussLiveMessage } from "../../../../../../api/structures/IEconDiscussLiveMessage";

@Controller("/econDiscuss/member/posts/:postId/live/messages")
export class EcondiscussMemberPostsLiveMessagesController {
  /**
   * Create a live message (econ_discuss_live_messages) in a post’s live thread.
   *
   * Publish a live message to the live thread attached to the given post. The
   * Prisma schema for econ_discuss_live_messages specifies fields including
   * message_type (with allowed values enforced in application), content
   * (nullable for certain system messages), pinned (boolean), edited_at (set
   * when updated), and created_at/updated_at timestamps. The related
   * econ_discuss_live_threads record determines whether participation is
   * allowed (expert_only, access_scope) and tracks the room lifecycle state
   * (scheduled, waiting, live, paused, ended, archived).
   *
   * Security considerations: this endpoint requires an authenticated user (role
   * "member" or above in this API) and server-side enforcement that the user is
   * allowed to post given econ_discuss_live_threads.expert_only and
   * access_scope. Writing is typically allowed when state is live (or as
   * configured), and should be blocked when ended/archived. Implementations
   * should enforce per-room rate limits and slow mode via
   * slow_mode_interval_seconds when present.
   *
   * Validation rules include ensuring the target post exists, there is a live
   * thread bound to it, and the message_type/content combination is valid
   * (e.g., text messages should include non-empty content). On success, the
   * created message is returned with identifiers and timestamps. Errors include
   * 404 for missing post/thread, 403 for disallowed participation, and 409/422
   * for invalid state or payload.
   *
   * @param connection
   * @param postId Target post’s ID whose live thread will receive the message
   * @param body Payload to create a live message including content, message
   *   type, and optional pin flag
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IEconDiscussLiveMessage.ICreate,
  ): Promise<IEconDiscussLiveMessage> {
    try {
      return await postEconDiscussMemberPostsPostIdLiveMessages({
        member,
        postId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a live message (econ_discuss_live_messages) within a post’s live
   * thread.
   *
   * Modify an existing live message belonging to a post’s live thread. The
   * Prisma model econ_discuss_live_messages includes editable fields such as
   * content (nullable for system types), pinned, and implicitly message_type
   * where policy allows. Edits should respect window limits described in
   * business rules, and set edited_at to reflect changes. The parent
   * econ_discuss_live_threads (state, expert_only, access_scope) governs
   * whether updates are allowed in current state and who may perform them
   * (e.g., only author can edit within a short window; hosts/moderators can
   * toggle pinned).
   *
   * Security: This endpoint requires authentication (role "member" or above)
   * and must enforce ownership or role-based authorization. It should also
   * ensure the message belongs to the live thread for the supplied postId,
   * preventing cross-thread updates. When the thread is ended or archived,
   * edits should typically be rejected except for governance actions.
   *
   * Error handling: 404 when the post/thread/message linkage is invalid; 403
   * for insufficient permissions; 409/422 for invalid state transitions (e.g.,
   * editing after window, disallowed type changes). On success, returns the
   * updated message including edited_at.
   *
   * @param connection
   * @param postId Owning post’s ID used to resolve the live thread
   * @param messageId Identifier of the live message to update
   * @param body Fields to update on the live message (e.g., content, pin)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":messageId")
  public async update(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedParam("messageId")
    messageId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IEconDiscussLiveMessage.IUpdate,
  ): Promise<IEconDiscussLiveMessage> {
    try {
      return await putEconDiscussMemberPostsPostIdLiveMessagesMessageId({
        member,
        postId,
        messageId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Remove a live message (econ_discuss_live_messages) for a post’s live
   * thread.
   *
   * This operation removes a specific live message from user-visible streams by
   * updating the econ_discuss_live_messages record identified by {messageId} so
   * that its deleted_at column is populated. According to the Prisma schema
   * comments for econ_discuss_live_messages, the model stores per-message
   * lifecycle fields and includes a deleted_at timestamp for moderated or
   * removed messages while preserving transcript placeholders as required. The
   * deletion must be constrained to messages that belong to the live thread
   * associated with the post identified by {postId}, which is modeled by
   * econ_discuss_live_threads (one-to-one with econ_discuss_posts) through
   * econ_discuss_live_threads.econ_discuss_post_id.
   *
   * Security and authorization should follow business policies: only the
   * message author (econ_discuss_live_messages.econ_discuss_user_id), the live
   * thread host (econ_discuss_live_threads.host_user_id), or governance roles
   * (moderators/admins) may remove a message. Moderation-related removals
   * should be auditable, aligning with governance requirements. Even though
   * authorization is enforced in business logic, this endpoint is exposed to
   * authenticated users and must return 403 when the caller lacks permission.
   *
   * From a data relationship perspective, econ_discuss_live_messages references
   * econ_discuss_live_threads via econ_discuss_live_thread_id, and the thread
   * references econ_discuss_posts via econ_discuss_post_id. The provider should
   * verify that the targeted message belongs to the thread whose
   * econ_discuss_post_id equals {postId}. If the thread is archived or ended
   * (see econ_discuss_live_threads.state and archived_at/ended_at), business
   * rules may restrict message removal; implementations can enforce such
   * constraints consistently with platform policy.
   *
   * Validation and error handling include: returning 404 when the message does
   * not exist or is not linked to the specified post; 403 when the caller is
   * not permitted to remove the message; and 409 where applicable if concurrent
   * state prevents the operation (e.g., thread already archived in a stricter
   * policy). On repeated calls where the message already has deleted_at
   * populated, the provider may treat the request as idempotent and return
   * 204.
   *
   * Related operations that are commonly used together include retrieving live
   * messages for a post’s live thread (GET /posts/{postId}/live/messages) and
   * posting a new live message (POST /posts/{postId}/live/messages). Together,
   * these enable full lifecycle management of live conversation content while
   * respecting auditability and integrity described in the Prisma schema
   * comments.
   *
   * @param connection
   * @param postId Owning post’s ID associated with the target live message via
   *   its live thread.
   * @param messageId Identifier of the live message to remove from active
   *   visibility.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":messageId")
  public async erase(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedParam("messageId")
    messageId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteEconDiscussMemberPostsPostIdLiveMessagesMessageId({
        member,
        postId,
        messageId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
