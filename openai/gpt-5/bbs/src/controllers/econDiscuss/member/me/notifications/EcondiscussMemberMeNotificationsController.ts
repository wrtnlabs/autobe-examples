import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { getEconDiscussMemberMeNotifications } from "../../../../../providers/getEconDiscussMemberMeNotifications";
import { MemberAuth } from "../../../../../decorators/MemberAuth";
import { MemberPayload } from "../../../../../decorators/payload/MemberPayload";
import { patchEconDiscussMemberMeNotifications } from "../../../../../providers/patchEconDiscussMemberMeNotifications";
import { getEconDiscussMemberMeNotificationsNotificationId } from "../../../../../providers/getEconDiscussMemberMeNotificationsNotificationId";
import { putEconDiscussMemberMeNotificationsNotificationId } from "../../../../../providers/putEconDiscussMemberMeNotificationsNotificationId";
import { postEconDiscussMemberMeNotificationsMarkAllRead } from "../../../../../providers/postEconDiscussMemberMeNotificationsMarkAllRead";

import { IPageIEconDiscussNotification } from "../../../../../api/structures/IPageIEconDiscussNotification";
import { IEconDiscussNotification } from "../../../../../api/structures/IEconDiscussNotification";

@Controller("/econDiscuss/member/me/notifications")
export class EcondiscussMemberMeNotificationsController {
  /**
   * List member’s notifications (econ_discuss_notifications) with defaults.
   *
   * Return the current member’s active notifications by selecting from
   * econ_discuss_notifications where recipient_user_id equals the authenticated
   * user and deleted_at is null. Exposed fields include id, type, title, body,
   * read_at, created_at, updated_at, and optional entity_type/entity_id for
   * deep-linking. Default sort is typically created_at desc.
   *
   * Security limits access strictly to the owner. An empty page indicates no
   * available notifications. For advanced filtering (e.g., unread-only, by
   * type, or per entity), use PATCH /me/notifications with a request body.
   * Standard error handling applies for authorization failures and transient
   * server issues.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get()
  public async index(
    @MemberAuth()
    member: MemberPayload,
  ): Promise<IPageIEconDiscussNotification> {
    try {
      return await getEconDiscussMemberMeNotifications({
        member,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and paginate member’s notifications from econ_discuss_notifications.
   *
   * This operation lists inbox-style notifications for the signed-in member by
   * selecting from econ_discuss_notifications with recipient_user_id equal to
   * the authenticated user. Records with deleted_at set are excluded from
   * normal responses. Relevant columns include the categorical type,
   * title/body, optional polymorphic linkage via entity_type/entity_id, and
   * read state represented by read_at (null indicates unread).
   *
   * Security ensures that only the intended recipient can access their
   * notifications. Providers must enforce ownership using the authenticated
   * context. The endpoint supports rich filtering—such as isRead (mapped to
   * read_at non-null), type lists, entity scoping, and created_at time
   * windows—and uses pagination to deliver stable, ordered pages (commonly
   * created_at desc). Invalid inputs produce validation errors; authorization
   * failures return 401/403; empty pages are valid outcomes. For simpler
   * defaults without complex criteria, clients may call GET /me/notifications.
   *
   * @param connection
   * @param body Search criteria and pagination for notifications (read state,
   *   type, entities, time range)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async search(
    @MemberAuth()
    member: MemberPayload,
    @TypedBody()
    body: IEconDiscussNotification.IRequest,
  ): Promise<IPageIEconDiscussNotification> {
    try {
      return await patchEconDiscussMemberMeNotifications({
        member,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get one notification (econ_discuss_notifications) belonging to current
   * user.
   *
   * Fetch a specific persisted notification for the current authenticated user
   * using its UUID.
   *
   * Security and permissions: Only the notification recipient may access the
   * record. Authorization checks ensure that
   * econ_discuss_notifications.recipient_user_id equals the authenticated
   * user's econ_discuss_users.id. Attempts to access another user's
   * notification must result in a 403 Forbidden. If the record is not found or
   * is marked removed (deleted_at is set), return 404 Not Found.
   *
   * Database relationship: The econ_discuss_notifications table stores per-user
   * notifications with columns id (UUID primary key), recipient_user_id (FK to
   * econ_discuss_users), optional actor_user_id (FK), type, title, body,
   * optional entity_type/entity_id for deep links, read_at for read state, and
   * created_at/updated_at for ordering and auditing. This operation returns a
   * materialized view of those fields via the IEconDiscussNotification DTO,
   * excluding anything removed for the user.
   *
   * Validation and behavior: Validate that notificationId is a UUID. Enforce
   * ownership checks and hidden/removed states. No request body is required.
   * The endpoint is designed to complement list/search endpoints and the update
   * endpoint that toggles read state.
   *
   * Related operations: Use PUT /me/notifications/{notificationId} to update
   * read state and POST /me/notifications/markAllRead to set read_at on
   * multiple notifications.
   *
   * @param connection
   * @param notificationId Notification UUID to retrieve for the current user
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":notificationId")
  public async at(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("notificationId")
    notificationId: string & tags.Format<"uuid">,
  ): Promise<IEconDiscussNotification> {
    try {
      return await getEconDiscussMemberMeNotificationsNotificationId({
        member,
        notificationId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update user notification read state (econ_discuss_notifications).
   *
   * Mark or unmark a notification as read for the current user by updating
   * econ_discuss_notifications.read_at.
   *
   * Security and permissions: The authenticated user must match
   * econ_discuss_notifications.recipient_user_id. If the notification does not
   * belong to the user, return 403. If not found or marked removed (deleted_at
   * set), return 404. All changes are limited to the read state; other columns
   * like type, title, body, entity metadata are not editable by recipients.
   *
   * Database relationship: econ_discuss_notifications stores id (UUID),
   * recipient_user_id (FK), optional actor_user_id (FK), type, title, body,
   * optional entity_type/entity_id, read_at, created_at, updated_at, and a
   * removal timestamp. This operation updates read_at based on client intent
   * while preserving immutability of other system-managed fields.
   *
   * Validation and business rules: The request body
   * IEconDiscussNotification.IUpdate should contain an isRead boolean (and may
   * include no other modifiable fields). On isRead=true, set read_at to the
   * current time; on isRead=false, set read_at to null. The response returns
   * the updated notification via IEconDiscussNotification. Handle id format
   * validation and ownership checks.
   *
   * Related operations: GET /me/notifications/{notificationId} retrieves a
   * single notification. POST /me/notifications/markAllRead updates multiple
   * notifications for the current user.
   *
   * @param connection
   * @param notificationId Notification UUID to update for the current user
   * @param body Fields to update on the notification (read/unread intent only)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":notificationId")
  public async update(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("notificationId")
    notificationId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IEconDiscussNotification.IUpdate,
  ): Promise<IEconDiscussNotification> {
    try {
      return await putEconDiscussMemberMeNotificationsNotificationId({
        member,
        notificationId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Mark all current user notifications as read (econ_discuss_notifications).
   *
   * Bulk-set read_at for all unread notifications belonging to the current
   * user.
   *
   * Security and permissions: Only authenticated users can invoke this
   * operation. It updates only rows where
   * econ_discuss_notifications.recipient_user_id equals the caller’s
   * econ_discuss_users.id. It must ignore records flagged as removed. If no
   * records are affected, still return 204 to indicate success.
   *
   * Database relationship: Operates on econ_discuss_notifications by updating
   * read_at in bulk based on recipient ownership. No other columns are
   * modified.
   *
   * Behavior and errors: The endpoint is idempotent. Concurrent executions
   * should be safe; subsequent calls will do nothing and still succeed. This
   * endpoint complements single-record update and retrieval operations.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("markAllRead")
  public async markAllRead(
    @MemberAuth()
    member: MemberPayload,
  ): Promise<void> {
    try {
      return await postEconDiscussMemberMeNotificationsMarkAllRead({
        member,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
