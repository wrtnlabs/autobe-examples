import { Controller } from "@nestjs/common";
import { TypedRoute } from "@nestia/core";
import typia from "typia";
import { getEconDiscussMemberMeReputation } from "../../../../../providers/getEconDiscussMemberMeReputation";
import { MemberAuth } from "../../../../../decorators/MemberAuth";
import { MemberPayload } from "../../../../../decorators/payload/MemberPayload";

import { IEconDiscussUserReputation } from "../../../../../api/structures/IEconDiscussUserReputation";

@Controller("/econDiscuss/member/me/reputation")
export class EcondiscussMemberMeReputationController {
  /**
   * Get current reputation aggregate for authenticated user
   * (econ_discuss_user_reputations).
   *
   * Fetch the current reputation score for the caller from
   * econ_discuss_user_reputations.
   *
   * The econ_discuss_user_reputations table provides a compact view containing
   * user_id, score (Int), last_updated_at, and temporal columns (created_at,
   * updated_at, deleted_at). It is maintained based on entries in
   * econ_discuss_reputation_events. This endpoint is optimized for read
   * performance so client applications can determine eligibility for gated
   * features (e.g., polls, live rooms) without scanning the ledger.
   *
   * Security considerations: the caller must be authenticated and will receive
   * only their own reputation information. Entries with a non-null deleted_at
   * are treated as inactive/retired and should not be returned.
   *
   * Error handling: return 200 with the current aggregate when present. If no
   * aggregate exists yet for the user (e.g., new account), providers may return
   * a default score of zero or a 404 according to business policy; the DTO
   * supports explicit values to avoid ambiguity.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get()
  public async at(
    @MemberAuth()
    member: MemberPayload,
  ): Promise<IEconDiscussUserReputation> {
    try {
      return await getEconDiscussMemberMeReputation({
        member,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
