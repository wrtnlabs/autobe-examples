import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { getEconDiscussPostsPostIdPollResults } from "../../../../../providers/getEconDiscussPostsPostIdPollResults";
import { patchEconDiscussPostsPostIdPollResults } from "../../../../../providers/patchEconDiscussPostsPostIdPollResults";

import { IEconDiscussPollResults } from "../../../../../api/structures/IEconDiscussPollResults";
import { IEconDiscussPollResult } from "../../../../../api/structures/IEconDiscussPollResult";

@Controller("/econDiscuss/posts/:postId/poll/results")
export class EcondiscussPostsPollResultsController {
  /**
   * Get aggregated poll results derived from poll/response tables.
   *
   * Get aggregated results for the poll associated with a post. The Prisma
   * schema defines econ_discuss_polls (question, type, expert_only,
   * visibility_mode, allow_vote_change, start_at/end_at), answer options in
   * econ_discuss_poll_options, and respondent data in
   * econ_discuss_poll_responses and econ_discuss_poll_response_options. This
   * endpoint must not reveal individual responses; instead, it publishes
   * aggregate counts and, when applicable, rankings or numeric summaries.
   *
   * Security and visibility: results must respect
   * econ_discuss_polls.visibility_mode. For hidden_until_close, do not return
   * running results before end_at; for visible_after_vote, require the caller
   * to have a recorded econ_discuss_poll_responses row; for always_visible,
   * show running totals. Additionally, apply any minimum thresholds for
   * segments as per business rules (e.g., hide segments that do not meet
   * k-anonymity). The endpoint is read-only and typically public; enforcement
   * of expert_only participation does not imply restricted read access unless
   * policy dictates.
   *
   * Validation and behavior: verify that the postId has a poll
   * (econ_discuss_polls unique on econ_discuss_post_id). Calculate option
   * counts using econ_discuss_poll_response_options (including ranking
   * positions if needed) and include totalResponses. Exclude responses marked
   * quarantined/invalidated from tallies as required by integrity policy.
   * Return 404 when the post has no poll, and 409 when policy forbids showing
   * results at this time. Timestamps are in ISO 8601 where included, and the
   * standard error model applies.
   *
   * @param connection
   * @param postId Host post ID (UUID) that owns the poll
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get()
  public async at(
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
  ): Promise<IEconDiscussPollResults> {
    try {
      return await getEconDiscussPostsPostIdPollResults({
        postId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Aggregate and return poll results for a post’s poll (econ_discuss_polls and
   * related tables).
   *
   * Compute and return aggregated results for the poll attached to a specific
   * post. The underlying schema stores one poll per post in econ_discuss_polls,
   * with configuration fields such as question (text), question_type
   * (single_choice, multiple_choice, likert, ranking, numeric_estimate),
   * visibility_mode (hidden_until_close, visible_after_vote, always_visible),
   * expert_only (boolean), allow_vote_change (boolean), optional
   * min_voter_reputation and min_account_age_hours, and the start_at/end_at
   * schedule (all as timestamptz). Options are stored in
   * econ_discuss_poll_options with per-poll uniqueness and ordering via
   * position. Respondent data lives in econ_discuss_poll_responses with status
   * (active, withdrawn, quarantined, invalidated), and type-specific values
   * (likert_value, numeric_value). For multiple-choice and ranking types,
   * selected options are in econ_discuss_poll_response_options with an optional
   * position for ranking.
   *
   * Security and visibility rules follow the poll’s business configuration and
   * policy. For example, if visibility_mode is hidden_until_close and the poll
   * has not ended (end_at), the service must return either a minimal envelope
   * or deny access to running tallies according to application policy. For
   * expert_only polls, the results may still be viewable by the public after
   * close, but the provider should consult policy before exposing running
   * tallies. Records with deleted_at set in any of the relevant tables are
   * treated as inactive and excluded from results. The endpoint itself is
   * public for read, but the provider must enforce the poll’s visibility
   * constraints derived from econ_discuss_polls.
   *
   * This operation is related to detail retrieval of the poll configuration
   * (e.g., GET /posts/{postId}/poll) which can inform clients of question_type,
   * visibility_mode, and schedule before requesting results. Validation
   * includes ensuring the postId maps to an existing econ_discuss_posts row
   * that has an attached econ_discuss_polls row, verifying schedule windows
   * (start_at and end_at) against current time, and applying minimum segment
   * thresholds if the provider supports segmented outputs. If the poll is not
   * found or visibility rules prevent disclosure, return a not-found or
   * appropriate denial. Error handling should surface invalid states (e.g.,
   * question_type unsupported) as 400-level errors and missing resources as
   * 404.
   *
   * @param connection
   * @param postId Target post’s ID that hosts the poll
   * @param body Result computation parameters (e.g., segmentation controls,
   *   normalization window, pagination for option-level breakdowns)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IEconDiscussPollResult.IRequest,
  ): Promise<IEconDiscussPollResult> {
    try {
      return await patchEconDiscussPostsPostIdPollResults({
        postId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
