import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { getEconDiscussPostsPostIdLiveMessages } from "../../../../../providers/getEconDiscussPostsPostIdLiveMessages";
import { patchEconDiscussPostsPostIdLiveMessages } from "../../../../../providers/patchEconDiscussPostsPostIdLiveMessages";
import { getEconDiscussPostsPostIdLiveMessagesMessageId } from "../../../../../providers/getEconDiscussPostsPostIdLiveMessagesMessageId";

import { IPageIEconDiscussLiveMessage } from "../../../../../api/structures/IPageIEconDiscussLiveMessage";
import { IEconDiscussLiveMessage } from "../../../../../api/structures/IEconDiscussLiveMessage";

@Controller("/econDiscuss/posts/:postId/live/messages")
export class EcondiscussPostsLiveMessagesController {
  /**
   * List live messages for a post’s live thread (econ_discuss_live_messages).
   *
   * Fetch live discussion messages for a post’s associated live thread.
   * According to the Prisma schema comments, econ_discuss_live_threads
   * “represents a live discussion thread (room) attached to a specific post”
   * (1:1 with econ_discuss_posts), and econ_discuss_live_messages stores “raw
   * message content, type, and lifecycle timestamps” with allowed message_type
   * values (text, system, poll_prompt, poll_result, moderation_notice, pinned).
   * Results are chronologically ordered by created_at for fan-out and
   * transcript views, and the pinned boolean can be used by clients for
   * contextual pinning.
   *
   * Security and permissions follow the live thread’s configuration. While many
   * threads are publicly readable, access_scope on econ_discuss_live_threads
   * (public, followers_only, topic_subscribers_only, invite_only) governs
   * visibility. Expert-only participation does not necessarily restrict
   * reading, but implementers must enforce visibility checks based on the live
   * thread record. No authentication is required for publicly readable threads;
   * private scopes must be handled by business logic.
   *
   * Database linkage uses postId to resolve econ_discuss_live_threads via
   * econ_discuss_post_id, then returns associated econ_discuss_live_messages.
   * Only non-removed messages should be returned to end-users; records with
   * internal removal timestamps should be filtered out by provider logic. The
   * API supports paging (page, pageSize) and may accept a client-provided time
   * cursor (e.g., since as ISO 8601) to reduce payloads between polls.
   *
   * Related operations include creating a new message (POST
   * /posts/{postId}/live/messages), reading a specific message (GET
   * /posts/{postId}/live/messages/{messageId}), and updating a message (PUT
   * /posts/{postId}/live/messages/{messageId}). Error cases include 404 when
   * the post or its live thread does not exist, and 403 when access_scope
   * disallows reading for the current user context.
   *
   * @param connection
   * @param postId Target post’s ID whose live thread messages are requested
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get()
  public async getByPostid(
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
  ): Promise<IPageIEconDiscussLiveMessage> {
    try {
      return await getEconDiscussPostsPostIdLiveMessages({
        postId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and paginate live messages for a post’s live thread
   * (econ_discuss_live_messages).
   *
   * List messages belonging to a post’s live thread. The
   * econ_discuss_live_messages schema stores each message with a foreign key to
   * econ_discuss_live_threads (econ_discuss_live_thread_id), an optional author
   * econ_discuss_user_id to preserve transcripts when accounts are anonymized,
   * and fields such as message_type (e.g., text, system, poll_prompt,
   * poll_result, moderation_notice, pinned via the pinned boolean), edited_at
   * for limited edit windows, and deleted_at for removal that retains
   * transcript placeholders. Messages are ordered and queried using created_at
   * and indexed composite keys to support efficient retrieval.
   *
   * Security and visibility are governed by the parent thread’s access controls
   * on econ_discuss_live_threads (expert_only, access_scope). While the route
   * is public for read, the service must enforce scope, e.g., public vs
   * followers_only vs topic_subscribers_only vs invite_only. The read_at
   * concept is not part of this model; clients should rely on message
   * timestamps. The response uses a paginated container and can support
   * real-time refresh by specifying a since (ISO 8601) filter in the request
   * body to return only newer messages.
   *
   * Validation and errors: return 404 if the post does not exist or if no live
   * thread is associated; 400 for invalid pagination or filter values; and 403
   * if access_scope or expert_only rules disallow viewing for the caller.
   *
   * @param connection
   * @param postId Target post’s ID whose live messages are being requested
   * @param body Filter and pagination criteria for retrieving live messages
   *   (e.g., since, message types, pinned, page, pageSize)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async patchByPostid(
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IEconDiscussLiveMessage.IRequest,
  ): Promise<IPageIEconDiscussLiveMessage> {
    try {
      return await patchEconDiscussPostsPostIdLiveMessages({
        postId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a specific live message (econ_discuss_live_messages) by ID for a post.
   *
   * Return a specific live message from the live discussion attached to a post.
   * Per Prisma schema, econ_discuss_live_messages stores the message metadata
   * (message_type, content, pinned, edited_at, created_at) and links to the
   * thread via econ_discuss_live_thread_id. The enclosing
   * econ_discuss_live_threads record provides access_scope and expert_only
   * flags that must be enforced to protect visibility, and its lifecycle state
   * (scheduled, live, paused, ended, archived) guides read expectations (e.g.,
   * archived threads remain readable per policy).
   *
   * Security: Typically public reads are allowed for public threads, but
   * access_scope may restrict viewing (followers_only, topic_subscribers_only,
   * invite_only). Implementations must validate that the message’s thread
   * corresponds to the provided postId to avoid cross-thread access, and filter
   * out messages not eligible for end-user display.
   *
   * Error handling: 404 when the post, thread, or message is not found or does
   * not belong together; 403 when access is not permitted. This endpoint does
   * not modify data and returns the full message object on success.
   *
   * @param connection
   * @param postId Owning post’s ID for the live thread
   * @param messageId Live message ID within the post’s live thread
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":messageId")
  public async at(
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedParam("messageId")
    messageId: string & tags.Format<"uuid">,
  ): Promise<IEconDiscussLiveMessage> {
    try {
      return await getEconDiscussPostsPostIdLiveMessagesMessageId({
        postId,
        messageId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
