import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { patchEconDiscussLiveThreads } from "../../../providers/patchEconDiscussLiveThreads";
import { getEconDiscussLiveThreadsLiveThreadId } from "../../../providers/getEconDiscussLiveThreadsLiveThreadId";

import { IPageIEconDiscussLiveThread } from "../../../api/structures/IPageIEconDiscussLiveThread";
import { IEconDiscussLiveThread } from "../../../api/structures/IEconDiscussLiveThread";

@Controller("/econDiscuss/liveThreads")
export class EcondiscussLivethreadsController {
  /**
   * Search and paginate live threads (econ_discuss_live_threads) with filters
   * and sorting.
   *
   * Retrieve a filtered, paginated index of live discussion threads. The
   * backing schema econ_discuss_live_threads tracks lifecycle fields state,
   * scheduled_start_at, started_at, paused_at, ended_at, archived_at, as well
   * as governance flags expert_only and access_scope and performance
   * affordances like slow_mode_interval_seconds. Timestamps are stored as
   * timestamptz. Because there is exactly one live thread per post (unique
   * econ_discuss_post_id), clients can tie threads to their host content in
   * econ_discuss_posts for display contexts.
   *
   * Security considerations: this read endpoint is public, but business logic
   * should exclude threads that the current viewer cannot access (e.g.,
   * invite_only without authorization) and any rows marked inactive via
   * deleted_at. The access_scope influences who may view or participate; this
   * index should list only those threads visible to the requester. For curated
   * or role-restricted views, the provider may add further filtering based on
   * current user privileges.
   *
   * Validation and behavior: the request body supports pagination (page,
   * pageSize), sorting (e.g., created_at or started_at desc), and filters by
   * state, expert_only, access_scope, host_user_id, and scheduled time ranges.
   * The response returns a paginated summary optimized for list UIs, including
   * identifiers, current state, key timestamps, host reference, and flags.
   * Related operations include GET /liveThreads/{liveThreadId} for detail
   * retrieval and GET /posts/{postId}/live to fetch the thread bound to a
   * specific post.
   *
   * @param connection
   * @param body Filter, sort, and paginate live threads (state, expert_only,
   *   access_scope, host, time windows)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @TypedBody()
    body: IEconDiscussLiveThread.IRequest,
  ): Promise<IPageIEconDiscussLiveThread.ISummary> {
    try {
      return await patchEconDiscussLiveThreads({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a live thread by ID from econ_discuss_live_threads.
   *
   * Return the full live thread resource identified by liveThreadId. The
   * econ_discuss_live_threads schema includes state (scheduled, waiting, live,
   * paused, ended, archived), scheduling/transition timestamps
   * (scheduled_start_at, started_at, paused_at, ended_at, archived_at), an
   * expert_only boolean, access_scope string, and slow_mode_interval_seconds.
   * Associations link to the host post (econ_discuss_post_id) and the host user
   * (host_user_id). Timestamps are timestamptz and should be serialized as ISO
   * 8601.
   *
   * Security and visibility: although the route is public read, provider logic
   * must enforce access_scope and exclude records where deleted_at is set. If
   * the thread is invite_only and the requester lacks permission, a 404 or
   * forbidden should be returned according to policy. For archived threads,
   * content remains readable but participation is disabled by state.
   *
   * Validation and related operations: validate that the identifier is a proper
   * UUID and that the record exists. For message retrieval use the dedicated
   * messages route (e.g., per-post live messages), while this endpoint returns
   * the threadâ€™s metadata and current state. Related discovery is provided by
   * PATCH /liveThreads for search and by GET /posts/{postId}/live to fetch a
   * thread via its host post.
   *
   * @param connection
   * @param liveThreadId Identifier of the target live thread
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":liveThreadId")
  public async at(
    @TypedParam("liveThreadId")
    liveThreadId: string & tags.Format<"uuid">,
  ): Promise<IEconDiscussLiveThread> {
    try {
      return await getEconDiscussLiveThreadsLiveThreadId({
        liveThreadId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
