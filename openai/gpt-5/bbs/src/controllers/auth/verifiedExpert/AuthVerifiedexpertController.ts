import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthVerifiedExpertJoin } from "../../../providers/postAuthVerifiedExpertJoin";
import { postAuthVerifiedExpertLogin } from "../../../providers/postAuthVerifiedExpertLogin";
import { postAuthVerifiedExpertRefresh } from "../../../providers/postAuthVerifiedExpertRefresh";

import { IEconDiscussVerifiedExpert } from "../../../api/structures/IEconDiscussVerifiedExpert";
import { IEconDiscussVerifiedExpertJoin } from "../../../api/structures/IEconDiscussVerifiedExpertJoin";
import { IEconDiscussVerifiedExpertLogin } from "../../../api/structures/IEconDiscussVerifiedExpertLogin";
import { IEconDiscussVerifiedExpertRefresh } from "../../../api/structures/IEconDiscussVerifiedExpertRefresh";

@Controller("/auth/verifiedExpert")
export class AuthVerifiedexpertController {
  /**
   * Register verified expert account into econ_discuss_users and issue initial
   * tokens.
   *
   * This endpoint registers a new account intended to participate as a verified
   * expert after completing the separate verification program. It persists
   * identity in the Actors schema table econ_discuss_users, populating email,
   * password_hash (derived from the submitted password), and display_name.
   * Optional preferences such as timezone and locale are stored to support
   * notification scheduling and localization. Columns email_verified and
   * mfa_enabled are initialized to false, with mfa_secret and
   * mfa_recovery_codes left null until multi‑factor enrollment. Timestamps
   * created_at and updated_at are recorded by the application layer.
   *
   * Security considerations include secure password hashing mapped to
   * econ_discuss_users.password_hash and immediate token issuance. The new
   * account’s email_verified remains false, which allows read access but may
   * restrict posting or voting per policy until the email is confirmed. MFA is
   * not enabled at join time; enrollment occurs via dedicated MFA endpoints
   * backed by econ_discuss_users.mfa_enabled, mfa_secret, and
   * mfa_recovery_codes.
   *
   * From a data model perspective, this writes to econ_discuss_users only. Role
   * assignment tables such as econ_discuss_verified_experts are not modified
   * here; expert status is granted later through the verification workflow. If
   * the service maintains a general membership record in econ_discuss_members,
   * that may be created by downstream business logic but is not required for
   * the join call itself.
   *
   * Validation requires unique email (enforced by @@unique([email]) on
   * econ_discuss_users), non‑empty display_name, and a compliant password that
   * can be hashed into password_hash. The operation should reject duplicate
   * emails and return a conflict error without leaking whether an address
   * already exists, following authentication UX guidelines.
   *
   * This operation is typically followed by email verification (to toggle
   * econ_discuss_users.email_verified via a separate verify endpoint) and
   * optional MFA enrollment (which sets mfa_enabled and secrets). After
   * verification, users may proceed to post, vote, and start expert
   * verification, which eventually populates econ_discuss_verified_experts.
   *
   * @param connection
   * @param body Registration payload for a verified expert account.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: IEconDiscussVerifiedExpertJoin.ICreate,
  ): Promise<IEconDiscussVerifiedExpert.IAuthorized> {
    try {
      return await postAuthVerifiedExpertJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate econ_discuss_users and issue tokens for verifiedExpert
   * context.
   *
   * This login endpoint checks the submitted email and password against
   * econ_discuss_users.email and econ_discuss_users.password_hash, issuing
   * tokens on success. If econ_discuss_users.mfa_enabled is true, it requires a
   * valid one‑time code derived from mfa_secret or a valid value from
   * mfa_recovery_codes. Email verification state is read from
   * econ_discuss_users.email_verified for post‑login gating in downstream
   * features; the login may still succeed while the platform limits write
   * actions until verification is complete.
   *
   * The operation does not modify database rows on success except for typical
   * updated_at handling in econ_discuss_users performed by the application
   * where appropriate. It does not create or remove role records; presence of a
   * row in econ_discuss_verified_experts linked via
   * econ_discuss_verified_experts.user_id may be used by token generation to
   * include verifiedExpert claims used by authorization decorators.
   *
   * Security rules should enforce generic error messages on failure, rate
   * limiting after repeated failures, and optional device/session metadata
   * capture outside of this schema. MFA enforcement strictly relies on
   * econ_discuss_users.mfa_enabled and associated secret/recovery data
   * columns.
   *
   * This login is commonly paired with token refresh to rotate refresh tokens
   * and with email verification and MFA endpoints for strengthening account
   * assurance. Error handling should include invalid credentials, missing
   * second factor when required, and disabled accounts if deleted_at is set on
   * econ_discuss_users.
   *
   * @param connection
   * @param body Credentials (and optional 2FA code) for verified expert login.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: IEconDiscussVerifiedExpertLogin.ICreate,
  ): Promise<IEconDiscussVerifiedExpert.IAuthorized> {
    try {
      return await postAuthVerifiedExpertLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh verifiedExpert JWTs without modifying econ_discuss_users.
   *
   * The refresh endpoint returns a new authorized session for a verified expert
   * using a valid refresh token presented via secure channel (e.g., httpOnly
   * cookie or header as per policy). It does not create or update rows in
   * econ_discuss_users or role tables. Because token rotation and revocation
   * lists are implementation details, the database schema does not constrain
   * this operation; however, email_verified and mfa_enabled readouts may inform
   * claim composition.
   *
   * Security considerations include rotation on use, revocation on anomalies,
   * and denial when the refresh token is expired or invalid. The endpoint
   * should not require an access token and should produce a new token pair
   * following the project’s JWT policy. Error responses must be generic to
   * avoid leaking token state.
   *
   * Use this together with login to maintain short‑lived access tokens for
   * verified experts and to support concurrent device sessions consistent with
   * business policies.
   *
   * @param connection
   * @param body Refresh token container as defined by the service policy.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: IEconDiscussVerifiedExpertRefresh.ICreate,
  ): Promise<IEconDiscussVerifiedExpert.IAuthorized> {
    try {
      return await postAuthVerifiedExpertRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
