import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthVerifiedExpertMfaEnroll } from "../../../../../providers/postAuthVerifiedExpertMfaEnroll";
import { VerifiedexpertAuth } from "../../../../../decorators/VerifiedexpertAuth";
import { VerifiedexpertPayload } from "../../../../../decorators/payload/VerifiedexpertPayload";

import { IEconDiscussVerifiedExpertMfa } from "../../../../../api/structures/IEconDiscussVerifiedExpertMfa";
import { IEconDiscussVerifiedExpertMfaEnroll } from "../../../../../api/structures/IEconDiscussVerifiedExpertMfaEnroll";

@Controller("/auth/verifiedExpert/mfa/enroll")
export class AuthVerifiedexpertMfaEnrollController {
  /**
   * Begin 2FA setup using econ_discuss_users.mfa_secret and recovery codes.
   *
   * This endpoint prepares multi‑factor authentication by creating a new secret
   * for TOTP (stored in econ_discuss_users.mfa_secret) and issuing provisional
   * recovery codes (stored in econ_discuss_users.mfa_recovery_codes after
   * confirmation). It should present a provisioning URI for authenticator apps.
   * mfa_enabled remains false until the verify step succeeds, ensuring
   * incomplete enrollments do not lock users out.
   *
   * Security and integrity require rotating any existing secret and
   * invalidating prior recovery codes on re‑enroll attempts. This operation
   * affects only the current user’s econ_discuss_users row and records
   * updated_at; email and password_hash remain unchanged.
   *
   * @param connection
   * @param body Enrollment request (e.g., method TOTP).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async enrollMfa(
    @VerifiedexpertAuth()
    verifiedExpert: VerifiedexpertPayload,
    @TypedBody()
    body: IEconDiscussVerifiedExpertMfaEnroll.ICreate,
  ): Promise<IEconDiscussVerifiedExpertMfa.IEnroll> {
    try {
      return await postAuthVerifiedExpertMfaEnroll({
        verifiedExpert,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
