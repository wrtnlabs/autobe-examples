import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthVerifiedExpertMfaVerify } from "../../../../../providers/postAuthVerifiedExpertMfaVerify";
import { VerifiedexpertAuth } from "../../../../../decorators/VerifiedexpertAuth";
import { VerifiedexpertPayload } from "../../../../../decorators/payload/VerifiedexpertPayload";

import { IEconDiscussVerifiedExpertMfa } from "../../../../../api/structures/IEconDiscussVerifiedExpertMfa";
import { IEconDiscussVerifiedExpertMfaVerify } from "../../../../../api/structures/IEconDiscussVerifiedExpertMfaVerify";

@Controller("/auth/verifiedExpert/mfa/verify")
export class AuthVerifiedexpertMfaVerifyController {
  /**
   * Verify MFA and set econ_discuss_users.mfa_enabled = true.
   *
   * After the user scans the provisioning URI, this endpoint verifies a
   * submitted one‑time code against econ_discuss_users.mfa_secret and on
   * success sets econ_discuss_users.mfa_enabled = true while persisting the
   * secret and recovery codes. It updates updated_at; other profile fields are
   * untouched.
   *
   * If verification fails, do not enable mfa_enabled and return a generic
   * error. Successful verification completes MFA setup for the account,
   * enabling MFA checks during future /auth/verifiedExpert/login requests.
   *
   * @param connection
   * @param body One‑time code or recovery code to confirm setup.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async verifyMfa(
    @VerifiedexpertAuth()
    verifiedExpert: VerifiedexpertPayload,
    @TypedBody()
    body: IEconDiscussVerifiedExpertMfaVerify.ICreate,
  ): Promise<IEconDiscussVerifiedExpertMfa.IStatus> {
    try {
      return await postAuthVerifiedExpertMfaVerify({
        verifiedExpert,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
