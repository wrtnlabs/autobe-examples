import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthAdminJoin } from "../../../providers/postAuthAdminJoin";
import { postAuthAdminLogin } from "../../../providers/postAuthAdminLogin";
import { postAuthAdminRefresh } from "../../../providers/postAuthAdminRefresh";

import { IEconDiscussAdmin } from "../../../api/structures/IEconDiscussAdmin";

@Controller("/auth/admin")
export class AuthAdminController {
  /**
   * Register a new admin by creating econ_discuss_users and econ_discuss_admins
   * and return tokens.
   *
   * This endpoint registers a new administrator account and immediately issues
   * JWT tokens upon successful creation. It persists the base identity into the
   * Actors.econ_discuss_users table, specifically setting fields such as email
   * (unique identifier), password_hash (application-generated from the
   * submitted password), display_name, optional avatar_uri, timezone, and
   * locale. As per schema comments, email_verified should start as false until
   * verification completes, mfa_enabled should be false, with mfa_secret and
   * mfa_recovery_codes null.
   *
   * After creating the user, the operation inserts a corresponding role
   * assignment row into Actors.econ_discuss_admins using the new
   * econ_discuss_users.id as the user_id. This role record persists
   * administrative capabilities and policy flags including superuser (full
   * platform administration) and enforced_2fa (policy-relevant enforcement for
   * administrators), both documented in the Prisma schema.
   *
   * The endpoint is designed with security considerations in mind. Passwords
   * are never stored in plaintext and map to econ_discuss_users.password_hash.
   * MFA is not enabled at join time; admins can subsequently enable TOTP using
   * dedicated MFA endpoints tied to econ_discuss_users.mfa_enabled, mfa_secret,
   * and mfa_recovery_codes. Token issuance occurs only after both
   * econ_discuss_users and econ_discuss_admins are persisted.
   *
   * From a relational perspective, econ_discuss_admins has a unique constraint
   * on user_id, and a strict one-to-one relationship with econ_discuss_users,
   * ensuring a single administrator assignment per user. The login and refresh
   * flows later rely on econ_discuss_users.email and password_hash for
   * credential validation and on the presence of an econ_discuss_admins record
   * to assert admin scope.
   *
   * Validation rules align with the schema characteristics: email must be
   * unique; display_name is required for the identity surface; timezone is an
   * IANA identifier (e.g., Asia/Seoul) as stored in
   * econ_discuss_users.timezone; and locale aligns with
   * econ_discuss_users.locale. The provider should also initialize
   * email_verified=false with a follow-up verification flow using the dedicated
   * email endpoints.
   *
   * Related operations include POST /auth/admin/login for credential
   * authentication, POST /auth/admin/refresh for token rotation, and POST
   * /auth/admin/mfa/* endpoints for enabling TOTP-based MFA informed by
   * econ_discuss_users.mfa_secret and mfa_recovery_codes. Email verification
   * flows are available via /auth/admin/email/* and toggle
   * econ_discuss_users.email_verified once completed.
   *
   * @param connection
   * @param body Admin registration payload including email, password, display
   *   name, and optional preferences.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: IEconDiscussAdmin.ICreate,
  ): Promise<IEconDiscussAdmin.IAuthorized> {
    try {
      return await postAuthAdminJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate an admin using econ_discuss_users and econ_discuss_admins and
   * issue tokens.
   *
   * This operation authenticates an administrator using the econ_discuss_users
   * table fields email and password_hash, ensuring that plaintext credentials
   * are hashed and compared securely. It also verifies that a role assignment
   * exists in econ_discuss_admins (unique per user_id) to confirm the admin
   * scope documented by the schema.
   *
   * If the userâ€™s econ_discuss_users.email_verified is false, business policy
   * may restrict certain actions until verification completes; the table column
   * is designed to signal verification state. If
   * econ_discuss_admins.enforced_2fa is true, the service SHOULD require a
   * successful second factor, leveraging econ_discuss_users.mfa_enabled,
   * mfa_secret, and potential TOTP codes before issuing final tokens.
   *
   * On success, the endpoint issues JWT tokens and returns an authorized
   * payload typed as IEconDiscussAdmin.IAuthorized. The payload may include
   * role and permission claims derived from the existence of
   * econ_discuss_admins, and optional context like timezone
   * (econ_discuss_users.timezone) and locale (econ_discuss_users.locale) for
   * client experience.
   *
   * This endpoint aligns with schema relationships: econ_discuss_admins
   * references econ_discuss_users via user_id under a one-to-one unique
   * constraint. It does not create or modify role records; it only validates
   * their presence. Passwords are never stored or returned, and password_hash
   * remains confidential within econ_discuss_users.
   *
   * Use this in conjunction with the registration endpoint (/auth/admin/join),
   * token refresh (/auth/admin/refresh), and the MFA management endpoints that
   * directly reflect econ_discuss_users.mfa_* fields. Error handling should not
   * disclose whether the email exists, to avoid user enumeration.
   *
   * @param connection
   * @param body Admin login credentials and optional MFA code when required by
   *   policy.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: IEconDiscussAdmin.ILogin,
  ): Promise<IEconDiscussAdmin.IAuthorized> {
    try {
      return await postAuthAdminLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh administrator JWT tokens after validating econ_discuss_users and
   * econ_discuss_admins state.
   *
   * This endpoint accepts a valid refresh token and returns a new
   * access/refresh token pair. Before issuing new tokens, the service validates
   * that the subject corresponds to an existing econ_discuss_users row and that
   * a linked econ_discuss_admins record still exists, preserving admin scope.
   * If the admin role record has been removed, the operation must decline
   * refresh.
   *
   * The Actors.econ_discuss_users table provides core identity fields that can
   * be embedded as claims (e.g., userId from id, email, timezone, and locale),
   * while econ_discuss_admins confirms role-based privileges and can drive
   * claims such as superuser and enforced_2fa from its columns. The refresh
   * flow does not modify any of these tables directly.
   *
   * Security-wise, the endpoint supports rotation-on-use semantics. If policy
   * requires MFA enforcement (econ_discuss_admins.enforced_2fa) and the account
   * has econ_discuss_users.mfa_enabled=true, ensure that the session has
   * satisfied recent 2FA checks before token renewal.
   *
   * This endpoint should be paired with /auth/admin/login and /auth/admin/join
   * for initial issuance, and with MFA and email verification endpoints for
   * account hardening. Failures should be generic to avoid leaking token
   * validity details.
   *
   * @param connection
   * @param body Refresh token request payload (rotation-on-use).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: IEconDiscussAdmin.IRefresh,
  ): Promise<IEconDiscussAdmin.IAuthorized> {
    try {
      return await postAuthAdminRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
