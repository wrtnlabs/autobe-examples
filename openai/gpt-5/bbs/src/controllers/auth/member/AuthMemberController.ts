import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthMemberJoin } from "../../../providers/postAuthMemberJoin";
import { postAuthMemberLogin } from "../../../providers/postAuthMemberLogin";
import { postAuthMemberRefresh } from "../../../providers/postAuthMemberRefresh";
import { postAuthMemberLogoutAll } from "../../../providers/postAuthMemberLogoutAll";
import { MemberAuth } from "../../../decorators/MemberAuth";
import { MemberPayload } from "../../../decorators/payload/MemberPayload";
import { postAuthMemberLogout } from "../../../providers/postAuthMemberLogout";

import { IEconDiscussMember } from "../../../api/structures/IEconDiscussMember";

@Controller("/auth/member")
export class AuthMemberController {
  /**
   * Register a new Member by creating econ_discuss_users and assigning
   * econ_discuss_members (issue tokens).
   *
   * This endpoint registers a new Member using the Actors schema. It persists a
   * user in econ_discuss_users with the provided email (email), a securely
   * derived password_hash from the submitted password, a human-readable
   * display_name, and optional timezone and locale fields, as documented in the
   * Prisma comments. At creation time, email_verified is set to false to
   * reflect that email verification is pending; mfa_enabled is false and both
   * mfa_secret and mfa_recovery_codes are null as no multi-factor enrollment
   * has happened.
   *
   * Upon successful user creation, the API also establishes role membership by
   * inserting an econ_discuss_members record referencing the user via user_id
   * and populating joined_at, created_at, and updated_at. This follows the role
   * model where membership capabilities derive from the existence of an
   * econ_discuss_members row linked to econ_discuss_users.
   *
   * Security-wise, the operation validates uniqueness of
   * econ_discuss_users.email and rejects duplicates. Passwords are never stored
   * in plaintext; only password_hash is persisted according to the schema
   * comment. The response includes signed JWTs (access and refresh) and
   * essential subject claims derived from econ_discuss_users.id and role
   * context.
   *
   * This operation relates to subsequent flows like email verification
   * (email_verified flag) and 2FA enablement (mfa_enabled, mfa_secret,
   * mfa_recovery_codes). Clients commonly call
   * /auth/member/email/verification/resend to send a verification message after
   * registration.
   *
   * Error handling includes conflict on existing email (unique constraint on
   * econ_discuss_users.email), validation errors for required properties, and
   * generic server errors. All timestamps are populated using
   * created_at/updated_at columns as per Prisma definitions.
   *
   * @param connection
   * @param body Registration payload with credentials and profile basics.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: IEconDiscussMember.ICreate,
  ): Promise<IEconDiscussMember.IAuthorized> {
    try {
      return await postAuthMemberJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate a Member based on econ_discuss_users credentials and issue
   * tokens.
   *
   * This operation authenticates via the Actors schema: it loads
   * econ_discuss_users by email, verifies the provided password against
   * password_hash, and confirms the presence of an econ_discuss_members row for
   * role membership. If email_verified is false, the system may restrict
   * certain actions while still allowing login, consistent with the business
   * requirements.
   *
   * Multi-factor state derives from mfa_enabled; if true, the server may
   * require a valid one-time code before finalizing authentication. The
   * database stores 2FA artifacts in mfa_secret and mfa_recovery_codes; these
   * are never returned to clients.
   *
   * On success, the service issues access and refresh JWTs containing subject
   * identifiers derived from econ_discuss_users.id and role "member".
   * Timestamps like updated_at may be touched depending on auditing policies
   * but are schema-available.
   *
   * Related operations include /auth/member/refresh for token renewal,
   * /auth/member/mfa/setup and /auth/member/mfa/verify for enabling 2FA, and
   * /auth/member/password/reset for recovery.
   *
   * Errors include invalid credentials, missing member assignment (no
   * econ_discuss_members row), account restrictions, or rate-limit cooldowns.
   * The email uniqueness on econ_discuss_users is central to identity lookup.
   *
   * @param connection
   * @param body Email/password (and optional 2FA code) for authentication.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: IEconDiscussMember.ILogin,
  ): Promise<IEconDiscussMember.IAuthorized> {
    try {
      return await postAuthMemberLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh JWT tokens for a Member using submitted refresh token (stateless;
   * user in econ_discuss_users).
   *
   * This operation performs token renewal for authenticated sessions. It
   * accepts a refresh token in the request, validates its signature and claims,
   * and issues a new access token. Rotation of refresh tokens may be performed
   * per policy. The underlying user belongs to econ_discuss_users; the Member
   * role is indicated by the presence of an econ_discuss_members record.
   *
   * Because tokens are short-lived and not stored in the database schema, the
   * operation is stateless with respect to persistence. However, it may include
   * role data (member) and security flags like mfa_enabled in claims for
   * client-side hints.
   *
   * This endpoint is often invoked after /auth/member/login or after access
   * token expiration. If the refresh token is expired or revoked, the operation
   * fails, requiring a new login.
   *
   * No database write is required beyond optional audit trails; no Prisma table
   * is updated in this flow under the given schema.
   *
   * @param connection
   * @param body Refresh token payload for renewal/rotation.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: IEconDiscussMember.IRefresh,
  ): Promise<IEconDiscussMember.IAuthorized> {
    try {
      return await postAuthMemberRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Global logout for a Member (revoke active sessions across devices).
   *
   * This operation implements a global sign-out. It invalidates active refresh
   * tokens for the user across devices and requires re-authentication. The
   * Actors schema (econ_discuss_users) does not define token tables, so
   * revocation is managed out-of-band. The endpoint may update updated_at for
   * audit consistency.
   *
   * This is aligned with the business requirement to support "log out on all
   * devices" within 30 seconds.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("logoutAll")
  public async logoutAll(
    @MemberAuth()
    member: MemberPayload,
  ): Promise<void> {
    try {
      return await postAuthMemberLogoutAll({
        member,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Logout current session for a Member (revoke presented refresh token).
   *
   * This operation logs out only the current device/session. As in the schema,
   * no token persistence table exists; therefore, the server invalidates the
   * presented refresh token and prevents further renewals.
   *
   * This complements logoutAll and standard session lifecycle, with no changes
   * to econ_discuss_users beyond optional updated_at.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("logout")
  public async logout(
    @MemberAuth()
    member: MemberPayload,
  ): Promise<void> {
    try {
      return await postAuthMemberLogout({
        member,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
