import { Controller } from "@nestjs/common";
import { TypedRoute } from "@nestia/core";
import typia from "typia";
import { postAuthMemberEmailVerificationResend } from "../../../../../../providers/postAuthMemberEmailVerificationResend";
import { MemberAuth } from "../../../../../../decorators/MemberAuth";
import { MemberPayload } from "../../../../../../decorators/payload/MemberPayload";

import { IEconDiscussMember } from "../../../../../../api/structures/IEconDiscussMember";

@Controller("/auth/member/email/verification/resend")
export class AuthMemberEmailVerificationResendController {
  /**
   * Resend verification email for econ_discuss_users.email when email_verified
   * is false.
   *
   * This operation is available to authenticated members whose
   * econ_discuss_users.email_verified is false. It sends a new verification
   * email to the address stored in econ_discuss_users.email. The endpoint does
   * not change schema fields other than potentially touching updated_at for
   * bookkeeping.
   *
   * The API avoids email enumeration by requiring authentication and not
   * exposing whether an address exists for other accounts. It references the
   * userâ€™s current email from the database and reuses standard verification
   * flows handled by /auth/member/email/verify.
   *
   * Errors include already-verified state and rate-limit restrictions for
   * resends.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async resendVerification(
    @MemberAuth()
    member: MemberPayload,
  ): Promise<IEconDiscussMember.IEmailVerification> {
    try {
      return await postAuthMemberEmailVerificationResend({
        member,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
