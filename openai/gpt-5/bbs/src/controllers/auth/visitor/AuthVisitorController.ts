import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthVisitorJoin } from "../../../providers/postAuthVisitorJoin";
import { postAuthVisitorRefresh } from "../../../providers/postAuthVisitorRefresh";
import { VisitorAuth } from "../../../decorators/VisitorAuth";
import { VisitorPayload } from "../../../decorators/payload/VisitorPayload";

import { IEconDiscussVisitor } from "../../../api/structures/IEconDiscussVisitor";
import { IEconDiscussVisitorJoin } from "../../../api/structures/IEconDiscussVisitorJoin";
import { IEconDiscussVisitorRefresh } from "../../../api/structures/IEconDiscussVisitorRefresh";

@Controller("/auth/visitor")
export class AuthVisitorController {
  /**
   * Register a Visitor account in econ_discuss_users and assign
   * econ_discuss_visitors, returning Visitor authorization.
   *
   * Purpose and overview This operation registers a new account intended for
   * the Visitor role and returns authorized session tokens. It persists a base
   * identity in the Actors namespace using econ_discuss_users (id, email,
   * password_hash, display_name, avatar_uri?, timezone?, locale?,
   * email_verified, mfa_enabled, mfa_secret?, mfa_recovery_codes?, created_at,
   * updated_at, deleted_at?) and then assigns the role in econ_discuss_visitors
   * (id, user_id, notes?, created_at, updated_at, deleted_at?). The API
   * produces an authorization payload for client-side session establishment.
   *
   * Implementation details and schema alignment At minimum, the service writes
   * econ_discuss_users.email (unique per @@unique[email]) and
   * econ_discuss_users.password_hash (derived server-side from the plaintext
   * credential received), along with econ_discuss_users.display_name. It may
   * also record optional preferences to econ_discuss_users.timezone (e.g.,
   * "Asia/Seoul") and econ_discuss_users.locale (e.g., "en-US"). The operation
   * initializes econ_discuss_users.email_verified to false and
   * econ_discuss_users.mfa_enabled to false unless policy indicates otherwise.
   * Creation and update timestamps populate econ_discuss_users.created_at and
   * econ_discuss_users.updated_at. After creating the base user, it inserts an
   * econ_discuss_visitors record referencing the same user via
   * econ_discuss_visitors.user_id and initializes its created_at and
   * updated_at.
   *
   * Role relationship and business context The visitor capability is
   * represented explicitly by econ_discuss_visitors linked to
   * econ_discuss_users via user_id. Assigning this record signals platform
   * behavior consistent with a read-only baseline. The system may also create a
   * profile row later in econ_discuss_user_profiles, but that is not required
   * for registration. No moderator, admin, or member role rows are created by
   * this operation; it focuses on visitor onboarding only.
   *
   * Security considerations Passwords are never persisted in plaintext; the
   * requestâ€™s password is transformed into econ_discuss_users.password_hash by
   * the server. JWTs issued on success include at least claims for
   * econ_discuss_users.id and the Visitor role. If multi-factor authentication
   * is introduced later, econ_discuss_users.mfa_enabled and related
   * secret/recovery fields (mfa_secret, mfa_recovery_codes) remain unset here.
   * Email verification is tracked by econ_discuss_users.email_verified and may
   * gate certain capabilities until confirmed by separate flows.
   *
   * Related operations and error handling Clients typically call the refresh
   * endpoint (/auth/visitor/refresh) to rotate tokens. Conflicts on email are
   * returned as 409 when econ_discuss_users.email violates the unique
   * constraint. Validation problems on required inputs return 400. Excessive
   * attempts should return 429 according to policy. Successful registration
   * returns an authorization structure with access and refresh tokens aligned
   * to the Visitor role.
   *
   * @param connection
   * @param body Visitor registration payload including credentials and optional
   *   preferences.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: IEconDiscussVisitorJoin.ICreate,
  ): Promise<IEconDiscussVisitor.IAuthorized> {
    try {
      return await postAuthVisitorJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh Visitor JWTs after validating refresh token and confirming visitor
   * role via econ_discuss_visitors.
   *
   * Purpose and overview This operation rotates JWTs for a Visitor by consuming
   * a presented refresh token and returning a new authorized session. While no
   * content entities are changed, the service may check the underlying Actors
   * tables for account and role status: econ_discuss_users (id, email_verified,
   * mfa_enabled, created_at, updated_at, deleted_at?) and econ_discuss_visitors
   * (user_id). The objective is to sustain authenticated sessions with
   * short-lived access tokens and longer-lived refresh tokens.
   *
   * Implementation details and schema alignment The controller validates the
   * refresh token and, if accepted, issues new tokens associated with
   * econ_discuss_users.id and the Visitor role. The refresh logic can deny
   * rotation if the linked econ_discuss_users row indicates a state that
   * disallows continued sessions (e.g., removal signaled via deleted_at) or if
   * the econ_discuss_visitors relation no longer exists for the user_id. This
   * preserves coherence with role assignment represented in the
   * econ_discuss_visitors table.
   *
   * Role-specific integration and business context Visitor is a read-oriented
   * role captured by a row in econ_discuss_visitors. The refresh process
   * confirms the role remains applicable before minting new credentials. The
   * endpoint does not alter moderator, member, or admin tables.
   *
   * Security considerations The handler ensures refresh token validity and
   * rotation policy, producing new short-lived access tokens and an updated
   * refresh token where appropriate. Tokens embed minimal claims (user id and
   * Visitor role). Two-factor flags (econ_discuss_users.mfa_enabled) are
   * advisory; this endpoint does not enroll or verify second factors. Email
   * verification (econ_discuss_users.email_verified) can influence downstream
   * capabilities but does not prevent token issuance unless policy dictates.
   *
   * Related operations and error handling Use /auth/visitor/join to create an
   * initial account. Refresh token errors yield 401 or 403. Accounts without a
   * corresponding econ_discuss_visitors assignment or with states that disallow
   * continuation should return 403. On success, the response returns an
   * authorization structure suitable for client storage and subsequent API
   * access.
   *
   * @param connection
   * @param body Refresh request including an existing refresh token.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @VisitorAuth()
    visitor: VisitorPayload,
    @TypedBody()
    body: IEconDiscussVisitorRefresh.IRequest,
  ): Promise<IEconDiscussVisitor.IAuthorized> {
    try {
      return await postAuthVisitorRefresh({
        visitor,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
