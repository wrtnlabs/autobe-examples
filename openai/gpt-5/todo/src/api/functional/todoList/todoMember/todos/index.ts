import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListTodo } from "../../../../structures/ITodoListTodo";
import { IPageITodoListTodo } from "../../../../structures/IPageITodoListTodo";

/**
 * Search and paginate member-owned Todos from Prisma table todo_list_todos.
 *
 * Retrieve a filtered, ordered, and paginated list of Todo records from the
 * Prisma model todo_list_todos. According to the schema comments, each Todo
 * belongs to exactly one member via the foreign key column
 * todo_list_todo_member_id and has fields: id, title, is_completed,
 * completed_at (nullable), created_at, and updated_at. The list is strictly
 * scoped to the requesting member by matching todo_list_todo_member_id to the
 * authenticated member’s identifier. Business filtering includes three states
 * derived from is_completed: All (no additional filter), Active (is_completed =
 * false), and Completed (is_completed = true). The default ordering is
 * created_at descending so that newly created items appear first.
 *
 * Security considerations align with role-based access described in the
 * requirements: only todoMember actors can call this operation. guestVisitor
 * actors are denied. The provider must not return Todos owned by other members
 * and should avoid messages that reveal whether other members’ items exist.
 * Ownership enforcement is performed through the todo_list_todo_member_id
 * relation to the owner table todo_list_todo_members.
 *
 * This operation integrates directly with the underlying database entity
 * todo_list_todos and its relation owner. Validation rules include enforcing
 * allowed pagination bounds (default size 20; allowed 10–50 inclusive) and
 * accepted status filter values. Request parameters should be validated before
 * querying. The response returns a paginated collection optimized for list
 * displays as ITodoListTodo summaries, including page metadata.
 *
 * Related operations include the detail retrieval GET /todos/{todoId}, which
 * returns a single record owned by the requester. Typical error handling
 * includes returning an empty page when the requested page index exceeds
 * available results, and a validation error when pagination or filter
 * parameters violate policy.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination parameters for the member’s
 *   Todos
 * @path /todoList/todoMember/todos
 * @accessor api.functional.todoList.todoMember.todos.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filter, and pagination parameters for the member’s Todos */
    body: ITodoListTodo.IRequest;
  };
  export type Body = ITodoListTodo.IRequest;
  export type Response = IPageITodoListTodo.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoList/todoMember/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoList/todoMember/todos";
  export const random = (): IPageITodoListTodo.ISummary =>
    typia.random<IPageITodoListTodo.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single Todo from Prisma table todo_list_todos by id.
 *
 * Return a single Todo record from the Prisma model todo_list_todos identified
 * by the path parameter todoId. The database schema defines columns id (UUID
 * primary key), title, is_completed, completed_at (nullable), created_at, and
 * updated_at. The record is also linked to the owner via
 * todo_list_todo_member_id with a relation to todo_list_todo_members. Only the
 * owner is permitted to access the record in normal operation; other users must
 * not be able to infer its existence.
 *
 * Security and permissions: This endpoint is available to todoMember actors
 * only. The provider must verify that the requested record’s
 * todo_list_todo_member_id matches the authenticated member’s id. If the record
 * is not owned by the requester or does not exist, respond with a neutral
 * not-available outcome consistent with privacy requirements rather than
 * leaking ownership.
 *
 * Validation and error handling: Validate that todoId is a well-formed UUID
 * before querying. If the item is not found within the requester’s scope,
 * return a not-found response. This operation complements the collection
 * retrieval /todos (PATCH), which provides pagination and filtering. Timestamps
 * (created_at and updated_at) are returned as stored; completed_at is present
 * only when is_completed is true.
 *
 * @param props.connection
 * @param props.todoId Identifier of the Todo to retrieve (UUID from
 *   todo_list_todos.id)
 * @path /todoList/todoMember/todos/:todoId
 * @accessor api.functional.todoList.todoMember.todos.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the Todo to retrieve (UUID from todo_list_todos.id) */
    todoId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoListTodo;

  export const METADATA = {
    method: "GET",
    path: "/todoList/todoMember/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/todoMember/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoListTodo => typia.random<ITodoListTodo>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a Todo (todo_list_todos) by ID with ownership enforcement and hard
 * deletion.
 *
 * Delete a specific Todo item identified by todoId from the todo_list_todos
 * table. The Prisma schema comment describes this table as the core entity for
 * the minimal personal task list with a required title, a simple completion
 * state (is_completed), an optional completed_at timestamp recorded when
 * transitioning to completed, and lifecycle timestamps created_at and
 * updated_at. Each record belongs to exactly one member through
 * todo_list_todo_member_id and an owner relation to todo_list_todo_members.
 *
 * Security and permissions: Only the owning member is allowed to delete the
 * Todo. The provider must verify that the authenticated
 * todo_list_todo_members.id matches the
 * todo_list_todos.todo_list_todo_member_id for the target record. If the record
 * is not owned by the requester or is not visible, the service should return a
 * privacy-preserving not-available outcome without leaking existence details.
 *
 * Database relationships: The owner relation connects todo_list_todos to
 * todo_list_todo_members with onDelete: Cascade. This operation deletes a
 * single todo_list_todos record by id and does not modify the owner record. The
 * table lacks a deletion marker column; therefore, the deletion here is
 * complete and records are removed from storage.
 *
 * Validation and business rules: The path parameter todoId must be a valid UUID
 * string. The operation should be idempotent from a client perspective: if the
 * record is already absent or inaccessible to the requester, return a neutral
 * not-available result. When the deletion succeeds, subsequent list and detail
 * requests must no longer return the item.
 *
 * Related operations and behavior: Typical client flows include creating Todos,
 * listing per owner with newest-first ordering, updating titles, and toggling
 * completion. After a successful delete, client UIs should refresh lists to
 * reflect removal. Error handling should provide clear messages for validation
 * errors (malformed identifiers) and neutral handling for not-available cases.
 *
 * @param props.connection
 * @param props.todoId Unique identifier of the Todo to delete
 * @path /todoList/todoMember/todos/:todoId
 * @accessor api.functional.todoList.todoMember.todos.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the Todo to delete */
    todoId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoList/todoMember/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/todoMember/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
