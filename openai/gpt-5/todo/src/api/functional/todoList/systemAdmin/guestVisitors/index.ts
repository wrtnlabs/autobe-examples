import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListGuestVisitor } from "../../../../structures/ITodoListGuestVisitor";

/**
 * Get one Guest Visitor (todo_list_guest_visitors) by ID.
 *
 * This operation returns one guest visitor actor from the
 * todo_list_guest_visitors table by its primary key id. The Prisma schema
 * defines todo_list_guest_visitors with id (UUID primary key), created_at,
 * updated_at, and a deleted_at timestamp used to mark records as deactivated.
 * These entries are standalone within the Actors domain and are not linked to
 * business entities in this minimal scope, per the schema comment. They are
 * useful for optional auditing or policy analysis and are typically not
 * user-managed directly.
 *
 * Access is restricted to the systemAdmin role. Implementations should treat
 * these records as administrative metadata and avoid exposing any information
 * beyond what is necessary for oversight. When deleted_at is present, providers
 * should treat the record as not available and return a neutral 404 response
 * rather than disclosing details.
 *
 * The endpoint validates the guestVisitorId path parameter as a UUID and
 * returns a single ITodoListGuestVisitor resource when available. If the
 * identifier is malformed, respond with 400. If the record does not exist in
 * the accessible scope, respond with 404. No request body is required. This
 * read operation complements higher-level administrative reporting (not defined
 * here) and does not interact with user-managed Todo content.
 *
 * @param props.connection
 * @param props.guestVisitorId Unique identifier (UUID) of the target guest
 *   visitor
 * @path /todoList/systemAdmin/guestVisitors/:guestVisitorId
 * @accessor api.functional.todoList.systemAdmin.guestVisitors.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the target guest visitor */
    guestVisitorId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoListGuestVisitor;

  export const METADATA = {
    method: "GET",
    path: "/todoList/systemAdmin/guestVisitors/:guestVisitorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoList/systemAdmin/guestVisitors/${encodeURIComponent(props.guestVisitorId ?? "null")}`;
  export const random = (): ITodoListGuestVisitor =>
    typia.random<ITodoListGuestVisitor>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("guestVisitorId")(() => typia.assert(props.guestVisitorId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
