import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListTodoMemberJoin } from "../../../structures/ITodoListTodoMemberJoin";
import { ITodoListTodoMember } from "../../../structures/ITodoListTodoMember";
import { ITodoListTodoMemberLogin } from "../../../structures/ITodoListTodoMemberLogin";
import { ITodoListTodoMemberRefresh } from "../../../structures/ITodoListTodoMemberRefresh";
import { ITodoListTodoMemberDeactivate } from "../../../structures/ITodoListTodoMemberDeactivate";
import { ITodoListTodoMemberRestore } from "../../../structures/ITodoListTodoMemberRestore";
export * as password from "./password/index";

/**
 * Register a member in Prisma table todo_list_todo_members and issue JWTs.
 *
 * Purpose: Register a new todoMember account using `email` and a password,
 * persisting to the Prisma table `todo_list_todo_members`. The table defines
 * `id` (PK, UUID), `email` (unique), `password_hash` (hashed credential),
 * `created_at`, `updated_at`, and `deleted_at` (nullable). Registration inserts
 * a new row with `email` normalized to lowercase and a securely computed
 * `password_hash`. `created_at` and `updated_at` are set to the current time,
 * and `deleted_at` remains null to indicate an active member.
 *
 * Implementation: The provider must hash the incoming password before storage,
 * never persisting plaintext. The unique constraint on `email` (see
 * `@@unique([email])`) requires collision handling. On success, the service
 * generates JWTs for session establishment and returns an authorization DTO
 * representing the authenticated state. The flow does not modify other entities
 * like `todo_list_todos`.
 *
 * Role integration: This operation applies to the member role (business role:
 * todoMember) and results in ownership for future Todos via the relationship
 * from `todo_list_todos.todo_list_todo_member_id` to
 * `todo_list_todo_members.id`. Although Todos are not created here, this
 * account becomes the owner reference for all personal Todo operations.
 *
 * Security: Enforce password strength policies; minimize error detail on
 * `email` uniqueness conflicts to avoid enumeration. Ensure timestamps
 * (`created_at`, `updated_at`) are properly set. `deleted_at` must be null for
 * active accounts; attempts to register an email with a previously deactivated
 * account should follow policy (e.g., restoration) without disclosing sensitive
 * state.
 *
 * Related operations: Use Login to authenticate existing members using `email`
 * and `password_hash` verification, and Refresh to renew tokens using a valid
 * refresh token. Together these endpoints form the authentication lifecycle for
 * `todo_list_todo_members`.
 *
 * @param props.connection
 * @param props.body Registration payload including email and password.
 * @setHeader token.access Authorization
 *
 * @path /auth/todoMember/join
 * @accessor api.functional.auth.todoMember.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Registration payload including email and password. */
    body: ITodoListTodoMemberJoin.ICreate;
  };
  export type Body = ITodoListTodoMemberJoin.ICreate;
  export type Response = ITodoListTodoMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/todoMember/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/todoMember/join";
  export const random = (): ITodoListTodoMember.IAuthorized =>
    typia.random<ITodoListTodoMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate against Prisma table todo_list_todo_members and issue JWTs.
 *
 * Purpose: Authenticate a todoMember whose identity is recorded in
 * `todo_list_todo_members` with fields `email`, `password_hash`, `created_at`,
 * `updated_at`, and `deleted_at`. Login verifies that `deleted_at` is null
 * (active account) and the provided password matches `password_hash` using a
 * strong hash verifier.
 *
 * Implementation: Normalize the input email to lowercase before lookup, then
 * perform constant-time password verification against `password_hash`. Do not
 * reveal whether the email exists or whether the password is wrong; return a
 * neutral authentication failure. On success, issue new JWTs and return an
 * authorization payload. Optionally refresh `updated_at` to reflect recent
 * activity per policy.
 *
 * Role integration: Successful login yields authorization for the todoMember
 * role, enabling access to personal Todo operations via the relationship from
 * `todo_list_todos.todo_list_todo_member_id` to `todo_list_todo_members.id`.
 *
 * Security: Enforce lockout or throttling on repeated failures according to
 * policy; ensure safe handling of unique constraint on `email`. Prevent
 * authentication for deactivated accounts where `deleted_at` is not null unless
 * an explicit restore flow is executed.
 *
 * Related operations: Join for initial account creation and Refresh for token
 * renewal. These operations together manage the session lifecycle for
 * `todo_list_todo_members`.
 *
 * @param props.connection
 * @param props.body Login payload including email and password.
 * @setHeader token.access Authorization
 *
 * @path /auth/todoMember/login
 * @accessor api.functional.auth.todoMember.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Login payload including email and password. */
    body: ITodoListTodoMemberLogin.ICreate;
  };
  export type Body = ITodoListTodoMemberLogin.ICreate;
  export type Response = ITodoListTodoMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/todoMember/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/todoMember/login";
  export const random = (): ITodoListTodoMember.IAuthorized =>
    typia.random<ITodoListTodoMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh JWTs for an active member anchored to todo_list_todo_members.
 *
 * Purpose: Renew access for an authenticated todoMember using a valid refresh
 * token. The member identity is anchored to the `todo_list_todo_members` table
 * which defines `id`, `email`, `password_hash`, `created_at`, `updated_at`, and
 * `deleted_at`. Refresh verifies the token, locates the member, confirms
 * `deleted_at` is null, and returns newly minted JWTs.
 *
 * Implementation: Validate refresh token integrity and expiration, map it to
 * the member `id`, and ensure the corresponding row remains active. Avoid
 * touching `password_hash` or other member fields; only token issuance occurs.
 * Do not disclose account existence or state beyond necessary error semantics.
 *
 * Role integration: Successful refresh maintains the todoMember’s authenticated
 * state required for personal Todo operations whose ownership is tied via
 * `todo_list_todos.todo_list_todo_member_id`.
 *
 * Security: Enforce rotation/invalidation policies on refresh tokens; reject
 * tokens for deactivated accounts where `deleted_at` is not null. Log minimal,
 * non-sensitive telemetry.
 *
 * Related operations: Join for registration and Login for authenticating
 * credentials; Refresh for renewing session continuity.
 *
 * @param props.connection
 * @param props.body Refresh token payload for renewing session.
 * @setHeader token.access Authorization
 *
 * @path /auth/todoMember/refresh
 * @accessor api.functional.auth.todoMember.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token payload for renewing session. */
    body: ITodoListTodoMemberRefresh.ICreate;
  };
  export type Body = ITodoListTodoMemberRefresh.ICreate;
  export type Response = ITodoListTodoMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/todoMember/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/todoMember/refresh";
  export const random = (): ITodoListTodoMember.IAuthorized =>
    typia.random<ITodoListTodoMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Deactivate member by setting deleted_at in todo_list_todo_members.
 *
 * Purpose: Deactivate the authenticated todoMember account by setting
 * `deleted_at` on the corresponding row in `todo_list_todo_members`. This
 * aligns with the schema’s description of `deleted_at` as a soft deletion
 * marker where null means active.
 *
 * Implementation: Require authentication (role todoMember). Set `deleted_at` to
 * the current timestamp and update `updated_at` to now. Do not modify `email`
 * or `password_hash`. After success, the member should not be able to
 * authenticate or refresh tokens until restored. This operation does not remove
 * personal Todos in `todo_list_todos`; instead, authorization rules prevent
 * access while deactivated.
 *
 * Role integration: Represents a member-controlled security state change,
 * gating access to all personal Todo operations linked by ownership from
 * `todo_list_todos.todo_list_todo_member_id` to `todo_list_todo_members.id`.
 *
 * Security: Ensure confirmation semantics and neutral messaging. Consider
 * immediate token invalidation after deactivation to enforce session closure
 * across devices.
 *
 * Related operations: `restore` to clear `deleted_at`, `login` and `refresh` to
 * deny access while deactivated.
 *
 * @param props.connection
 * @param props.body Optional reason or confirmation metadata for deactivation.
 * @path /auth/todoMember/deactivate
 * @accessor api.functional.auth.todoMember.deactivate
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function deactivate(
  connection: IConnection,
  props: deactivate.Props,
): Promise<deactivate.Response> {
  return true === connection.simulate
    ? deactivate.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...deactivate.METADATA,
          path: deactivate.path(),
          status: null,
        },
        props.body,
      );
}
export namespace deactivate {
  export type Props = {
    /** Optional reason or confirmation metadata for deactivation. */
    body: ITodoListTodoMemberDeactivate.ICreate;
  };
  export type Body = ITodoListTodoMemberDeactivate.ICreate;
  export type Response = ITodoListTodoMember.ISecurity;

  export const METADATA = {
    method: "POST",
    path: "/auth/todoMember/deactivate",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/todoMember/deactivate";
  export const random = (): ITodoListTodoMember.ISecurity =>
    typia.random<ITodoListTodoMember.ISecurity>();
  export const simulate = (
    connection: IConnection,
    props: deactivate.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: deactivate.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Restore member by clearing deleted_at in todo_list_todo_members.
 *
 * Purpose: Restore a deactivated todoMember account by clearing `deleted_at` on
 * the member’s row in `todo_list_todo_members`. The schema defines `deleted_at`
 * as a nullable timestamp: null indicates an active account; a set value
 * indicates deactivation.
 *
 * Implementation: Require authenticated context with appropriate policy to
 * perform self-restore. Set `deleted_at` to null and update `updated_at` to the
 * current time. Do not change `email` or `password_hash`. This action
 * re-enables normal authentication and token refresh flows for the account.
 *
 * Role integration: Restoration reactivates access to personal Todo features
 * whose ownership is linked from `todo_list_todos.todo_list_todo_member_id` to
 * `todo_list_todo_members.id`.
 *
 * Security: Consider session hardening, audit logging, and requiring recent
 * authentication. Use neutral messages on failure to avoid disclosure.
 *
 * Related operations: `deactivate` to set `deleted_at`, `login` and `refresh`
 * to resume normal sessions after restoration.
 *
 * @param props.connection
 * @param props.body Optional confirmation metadata for restoration.
 * @path /auth/todoMember/restore
 * @accessor api.functional.auth.todoMember.restore
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function restore(
  connection: IConnection,
  props: restore.Props,
): Promise<restore.Response> {
  return true === connection.simulate
    ? restore.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...restore.METADATA,
          path: restore.path(),
          status: null,
        },
        props.body,
      );
}
export namespace restore {
  export type Props = {
    /** Optional confirmation metadata for restoration. */
    body: ITodoListTodoMemberRestore.ICreate;
  };
  export type Body = ITodoListTodoMemberRestore.ICreate;
  export type Response = ITodoListTodoMember.ISecurity;

  export const METADATA = {
    method: "POST",
    path: "/auth/todoMember/restore",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/todoMember/restore";
  export const random = (): ITodoListTodoMember.ISecurity =>
    typia.random<ITodoListTodoMember.ISecurity>();
  export const simulate = (
    connection: IConnection,
    props: restore.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: restore.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
