import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListGuestVisitor } from "../../../structures/ITodoListGuestVisitor";

/**
 * Register a guest actor (todo_list_guest_visitors) and issue initial JWT
 * tokens.
 *
 * This endpoint registers a temporary guest actor for the Minimal Todo List
 * service and issues JWT tokens appropriate for anonymous usage prior to
 * becoming a member. It directly relates to the Prisma model
 * Actors.todo_list_guest_visitors, which defines anonymous visitor records with
 * id as the UUID primary key, created_at for creation time, updated_at for last
 * modification time, and a nullable deleted_at column used to mark a record as
 * logically removed or deactivated (null means active).
 *
 * Because todo_list_guest_visitors stores no authentication credentials, this
 * operation must not accept or persist passwords or emails. The application
 * should only create a new actor entry and set created_at and updated_at based
 * on the current time policy. The lack of credential fields in this model
 * aligns with the business requirement that guests are unauthenticated and
 * operate with temporary tokens only.
 *
 * The registration integrates with the authorization layer by returning an
 * authorization payload (ITodoListGuestVisitor.IAuthorized) that contains
 * tokens and the minimal actor identity. Tokens enable subsequent public
 * interactions that require a guest actor context without granting access to
 * member-only Todo operations. The underlying database entity for this
 * operation is limited to todo_list_guest_visitors and has no relations to the
 * Todos domain.
 *
 * Security-wise, the endpoint is public but must enforce rate limiting and
 * basic abuse protections at the application layer. Since deleted_at exists to
 * indicate logical removal, the provider should avoid returning or reactivating
 * logically removed records during registration; instead, it should create a
 * new guest actor record to keep state clean and predictable.
 *
 * Related operations include /auth/guestVisitor/refresh for renewing tokens.
 * Typical errors include validation failures on malformed request payloads
 * (though the body is minimal), and system conditions that prevent record
 * creation. No ownership checks apply because guests do not own Todos and this
 * endpoint is open to unauthenticated callers.
 *
 * @param props.connection
 * @param props.body Optional client context for creating a guest actor; may be
 *   an empty object per policy.
 * @setHeader token.access Authorization
 *
 * @path /auth/guestVisitor/join
 * @accessor api.functional.auth.guestVisitor.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Optional client context for creating a guest actor; may be an empty
     * object per policy.
     */
    body: ITodoListGuestVisitor.ICreate;
  };
  export type Body = ITodoListGuestVisitor.ICreate;
  export type Response = ITodoListGuestVisitor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestVisitor/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestVisitor/join";
  export const random = (): ITodoListGuestVisitor.IAuthorized =>
    typia.random<ITodoListGuestVisitor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh guest tokens for an active guest actor (todo_list_guest_visitors).
 *
 * This endpoint renews guest authorization by exchanging a valid refresh token
 * for a fresh access token and, where applicable, a rotated refresh token. It
 * references the Prisma model Actors.todo_list_guest_visitors for identity,
 * which includes id (UUID primary key), created_at (creation time), updated_at
 * (last modification), and a nullable deleted_at column used to indicate that a
 * record has been logically removed (null means active).
 *
 * The request body (ITodoListGuestVisitor.IRefresh) provides the refresh token
 * and minimal client context needed to perform validation. As
 * todo_list_guest_visitors has no credential fields, this flow relies entirely
 * on token verification logic and does not consult passwords or email
 * identifiers.
 *
 * Implementation should verify that the guest actor indicated by token claims
 * corresponds to an active record (deleted_at is null) and that token
 * integrity, expiration, and rotation policy checks pass. If validation fails,
 * the provider must return a safe error without exposing internal state or
 * indicating which aspect failed.
 *
 * This operation is part of the guest authentication workflow and complements
 * /auth/guestVisitor/join, which issues the initial tokens. It does not alter
 * business entities in the Todos domain and solely manages authorization tokens
 * for an existing guest actor.
 *
 * Typical errors include invalid or expired refresh tokens, actor state
 * indicating logical removal, and policy violations such as reuse of a revoked
 * token. Successful responses return ITodoListGuestVisitor.IAuthorized with the
 * new tokens and any required session metadata.
 *
 * @param props.connection
 * @param props.body Refresh token exchange request for guest actors.
 * @setHeader token.access Authorization
 *
 * @path /auth/guestVisitor/refresh
 * @accessor api.functional.auth.guestVisitor.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token exchange request for guest actors. */
    body: ITodoListGuestVisitor.IRefresh;
  };
  export type Body = ITodoListGuestVisitor.IRefresh;
  export type Response = ITodoListGuestVisitor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestVisitor/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestVisitor/refresh";
  export const random = (): ITodoListGuestVisitor.IAuthorized =>
    typia.random<ITodoListGuestVisitor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
