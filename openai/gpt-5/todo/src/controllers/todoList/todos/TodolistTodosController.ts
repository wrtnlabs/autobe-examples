import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postTodoListTodos } from "../../../providers/postTodoListTodos";
import { TodomemberAuth } from "../../../decorators/TodomemberAuth";
import { TodomemberPayload } from "../../../decorators/payload/TodomemberPayload";
import { putTodoListTodosTodoId } from "../../../providers/putTodoListTodosTodoId";

import { ITodoListTodo } from "../../../api/structures/ITodoListTodo";

@Controller("/todoList/todos")
export class TodolistTodosController {
  /**
   * Create a Todo item in the todo_list_todos table.
   *
   * This endpoint creates a new Todo for the current user using the underlying
   * Prisma model todo_list_todos. According to the model description, each Todo
   * has a required single-line title, a completion state recorded in
   * is_completed (default false on creation), an optional completed_at
   * timestamp used only when completed, and lifecycle timestamps created_at and
   * updated_at. The operation sets defaults and timestamps in alignment with
   * these rules and persists the new record.
   *
   * Security and ownership considerations: the database column
   * todo_list_todo_member_id on todo_list_todos enforces strict per-owner
   * scoping via a foreign key to todo_list_todo_members.id. While this API
   * surface accepts only the minimal business field (title), the service
   * determines the owner and assigns todo_list_todo_member_id internally. In
   * deployments with authentication, the owner is the authenticated member; in
   * single-user local mode, an implicit member context is used. Clients do not
   * provide ownership identifiers directly in this minimal design.
   *
   * Validation and business rules: the title must be trimmed and validated per
   * business policy (e.g., length 1–100 characters and single-line with no
   * newline characters) consistent with the schema comments indicating title is
   * a required single-line task title. On success, the record is stored with
   * is_completed=false, created_at set once, and updated_at set to the current
   * time. The response maps Prisma fields to the DTO shape: id (string), title
   * (string), isCompleted (boolean), createdAt (string date-time), updatedAt
   * (string date-time).
   *
   * Related operations: clients typically follow creation with list retrieval
   * or detail retrieval to present the new item among the newest-first
   * ordering, though list retrieval is not defined in this minimal operation
   * set. Error handling includes rejecting invalid titles (validation failures)
   * and reporting temporary processing issues with appropriate messages. The
   * operation returns 201 Created semantics with the created entity in the
   * response body.
   *
   * @param connection
   * @param body Todo creation payload containing only the required title field
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @TodomemberAuth()
    todoMember: TodomemberPayload,
    @TypedBody()
    body: ITodoListTodo.ICreate,
  ): Promise<ITodoListTodo> {
    try {
      return await postTodoListTodos({
        todoMember,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a Todo in the todo_list_todos table by identifier.
   *
   * This endpoint updates a single Todo using the underlying Prisma model
   * todo_list_todos, which defines fields id (primary key UUID), title
   * (required single-line), is_completed (boolean), completed_at (optional
   * timestamp when completed), created_at (creation time), and updated_at (last
   * modification time). The operation modifies only user-editable fields: title
   * and isCompleted. Any change sets updated_at to the current time. If the
   * completion state changes to completed, completed_at is recorded; if
   * reverted to active, completed_at is cleared.
   *
   * Security and ownership: every todo_list_todos record is owned by a member
   * via todo_list_todo_member_id referencing todo_list_todo_members.id. The
   * provider enforces that the caller may only update items owned by the
   * current context. In single-user local mode, an implicit owner is used.
   * Clients do not pass ownership identifiers; authorization and scoping are
   * handled server-side against todo_list_todo_member_id.
   *
   * Validation and business rules: updates must honor title validation rules
   * (trimmed, single-line, length 1–100). Completion toggles are idempotent:
   * applying the same state repeatedly results in no additional changes beyond
   * ensuring the state is correct. The created_at field remains immutable. The
   * API returns the updated entity with mapped DTO fields (id, title,
   * isCompleted, createdAt, updatedAt). If the identifier does not correspond
   * to an item within the caller’s scope, the service returns a neutral
   * not-available outcome (commonly represented as 404 in transport-level
   * semantics). Invalid inputs produce validation errors.
   *
   * Related operations and error handling: this operation is typically paired
   * with create and list/detail retrieval in client flows. Validation failures
   * should be communicated with field-specific messages for title where
   * applicable. Transient errors should preserve durability guarantees so that
   * clients can safely retry without unintended duplication.
   *
   * @param connection
   * @param todoId Identifier of the Todo to update
   * @param body Fields to update on the Todo: title and/or isCompleted
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":todoId")
  public async update(
    @TodomemberAuth()
    todoMember: TodomemberPayload,
    @TypedParam("todoId")
    todoId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ITodoListTodo.IUpdate,
  ): Promise<ITodoListTodo> {
    try {
      return await putTodoListTodosTodoId({
        todoMember,
        todoId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
