import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunityModeratorJoin } from "../../../structures/ICommunityPlatformCommunityModeratorJoin";
import { ICommunityPlatformCommunityModerator } from "../../../structures/ICommunityPlatformCommunityModerator";
import { ICommunityPlatformCommunityModeratorLogin } from "../../../structures/ICommunityPlatformCommunityModeratorLogin";
import { ICommunityPlatformCommunityModeratorRefresh } from "../../../structures/ICommunityPlatformCommunityModeratorRefresh";

/**
 * Register a user (future community moderator) using community_platform_users
 * and initialize community_platform_member_users.
 *
 * Purpose and functionality: Registers a new platform user intending to become
 * a community moderator later by community assignment. The operation inserts a
 * row into Actors.community_platform_users with required unique identifiers
 * email and username, storing the credential as password_hash. It records
 * compliance timestamps (terms_accepted_at, privacy_accepted_at) and optional
 * marketing_opt_in/marketing_opt_in_at exactly as modeled. The initial flags
 * email_verified (Boolean) and account_state (String) are set according to
 * onboarding flow described in requirements (e.g., account_state may be
 * "PendingVerification" until email verification succeeds). created_at and
 * updated_at are set to current timestamps.
 *
 * Implementation details and validations: Enforce database-level uniqueness of
 * email and username (per @@unique) and validate password before hashing into
 * password_hash. Do not write to deleted_at. If business logic enables member
 * capabilities at join, insert a corresponding row into
 * Actors.community_platform_member_users with community_platform_user_id
 * referencing the created user and joined_at set to now; status may be null or
 * a workflow-specific String. No entries are written to
 * community_platform_community_moderators because moderator privileges are
 * granted by owners later per schema comments.
 *
 * Role-specific integration: Although the path is
 * /auth/communityModerator/join, this endpoint creates a general user
 * (community_platform_users) and optionally the member linkage
 * (community_platform_member_users). Moderator scope is community-specific and
 * realized subsequently through community_platform_community_moderators. This
 * aligns with the role being of kind "member" in the permission model.
 *
 * Security considerations: Passwords are never stored in plaintextâ€”only as
 * password_hash. email_verified remains false until a separate verification
 * succeeds. account_state governs capabilities (e.g., PendingVerification vs
 * Active) and maps to the String column. Audit fields like last_login_at are
 * untouched at join; they will be updated on login. Soft deletion via
 * deleted_at is not used here.
 *
 * Related operations and workflow: Typical flows call login after successful
 * verification, and token refresh to maintain sessions. Community moderator
 * assignment is done by community owners using
 * community_platform_community_moderators and is not part of this endpoint.
 * Error cases should reflect uniqueness violations and invalid registration
 * data as per the exception model.
 *
 * @param props.connection
 * @param props.body Registration payload with email, username, password,
 *   terms/privacy consent, and optional marketing consent.
 * @setHeader token.access Authorization
 *
 * @path /auth/communityModerator/join
 * @accessor api.functional.auth.communityModerator.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Registration payload with email, username, password, terms/privacy
     * consent, and optional marketing consent.
     */
    body: ICommunityPlatformCommunityModeratorJoin.ICreate;
  };
  export type Body = ICommunityPlatformCommunityModeratorJoin.ICreate;
  export type Response = ICommunityPlatformCommunityModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/communityModerator/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/communityModerator/join";
  export const random = (): ICommunityPlatformCommunityModerator.IAuthorized =>
    typia.random<ICommunityPlatformCommunityModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Login a community moderator using community_platform_users (password_hash,
 * email/username) and update last_login_at.
 *
 * Purpose and functionality: Authenticates a user who may hold moderator
 * responsibilities. It queries community_platform_users by email or username
 * (both unique) and validates the credential against password_hash. If the
 * account is eligible (e.g., email_verified is true and account_state indicates
 * an allowed state like "Active"), the endpoint issues access/refresh tokens
 * per session policy and returns an authorized payload.
 *
 * Implementation details: On successful login, set last_login_at to current
 * time and update updated_at. Respect the soft deletion model by rejecting
 * users where deleted_at is non-null. The controller must treat account_state
 * and email_verified exactly as persisted Boolean/String flags and must not
 * mutate terms_accepted_at, privacy_accepted_at, or marketing_opt_in fields
 * during login. No write is performed to community_platform_member_users or
 * community_platform_community_moderators by this endpoint.
 *
 * Role-specific integration: Although this uses the communityModerator path,
 * the underlying identity remains the user row in community_platform_users with
 * optional membership record in community_platform_member_users. Any moderator
 * privileges are scoped per community via
 * community_platform_community_moderators and are orthogonal to
 * authentication.
 *
 * Security considerations: Enforce indistinguishable failure messages to
 * prevent user enumeration. Passwords are handled via password_hash comparison.
 * Accounts with account_state indicating Locked/Deactivated/Banned or with
 * email_verified=false should be denied according to business rules. All tokens
 * should be short-lived access (e.g., ~20 minutes) with refresh validity (e.g.,
 * ~14 days) as per requirements; these time windows are not persisted in the
 * schema but apply to the returned token payload.
 *
 * Related operations: Registration precedes login; token refresh maintains
 * sessions. Session revocation and device lists are out of scope for this
 * schema and are not implemented here.
 *
 * @param props.connection
 * @param props.body Login credentials (email or username) and password.
 * @setHeader token.access Authorization
 *
 * @path /auth/communityModerator/login
 * @accessor api.functional.auth.communityModerator.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Login credentials (email or username) and password. */
    body: ICommunityPlatformCommunityModeratorLogin.IRequest;
  };
  export type Body = ICommunityPlatformCommunityModeratorLogin.IRequest;
  export type Response = ICommunityPlatformCommunityModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/communityModerator/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/communityModerator/login";
  export const random = (): ICommunityPlatformCommunityModerator.IAuthorized =>
    typia.random<ICommunityPlatformCommunityModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh tokens for communityModerator; verify community_platform_users
 * eligibility and issue new JWTs.
 *
 * Purpose and functionality: Exchanges a valid refresh token for new tokens for
 * a user who may hold moderator responsibilities. The endpoint validates the
 * refresh token and returns a fresh authorized payload. If the token encodes
 * userId, the system may look up community_platform_users to confirm the
 * account is still eligible (e.g., not Banned/Deleted and email_verified
 * true).
 *
 * Implementation details: Because the Prisma schema does not define a
 * refresh-token store, token validation is performed against cryptographic JWT
 * properties and server-managed revocation lists outside of schema scope. The
 * implementation SHOULD verify that deleted_at is null and that account_state
 * does not indicate forbidden states before issuing new tokens. No writes occur
 * to community_platform_users beyond optional updated_at touch.
 *
 * Role-specific integration: This operation serves the member-kind role path
 * for communityModerator but does not alter any moderator assignments in
 * community_platform_community_moderators. It simply maintains the session
 * lifecycle.
 *
 * Security considerations: Rotate access tokens with a lifespan consistent with
 * business requirements (e.g., ~20 minutes) and keep refresh tokens within
 * allowed lifetime (e.g., up to ~14 days). Deny refresh if the account fails
 * checks mapped to email_verified or account_state or if revocation lists
 * indicate invalidation.
 *
 * Related operations: Registration (join) and Login (login) precede refresh.
 * Password changes or security events may cause refresh denial, prompting full
 * re-authentication.
 *
 * @param props.connection
 * @param props.body Refresh request containing the current refresh token.
 * @setHeader token.access Authorization
 *
 * @path /auth/communityModerator/refresh
 * @accessor api.functional.auth.communityModerator.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh request containing the current refresh token. */
    body: ICommunityPlatformCommunityModeratorRefresh.IRequest;
  };
  export type Body = ICommunityPlatformCommunityModeratorRefresh.IRequest;
  export type Response = ICommunityPlatformCommunityModerator.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/communityModerator/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/communityModerator/refresh";
  export const random = (): ICommunityPlatformCommunityModerator.IAuthorized =>
    typia.random<ICommunityPlatformCommunityModerator.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
