import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformAdminUserJoin } from "../../../structures/ICommunityPlatformAdminUserJoin";
import { ICommunityPlatformAdminUser } from "../../../structures/ICommunityPlatformAdminUser";
import { ICommunityPlatformAdminUserLogin } from "../../../structures/ICommunityPlatformAdminUserLogin";
import { ICommunityPlatformAdminUserRefresh } from "../../../structures/ICommunityPlatformAdminUserRefresh";
export * as email from "./email/index";
export * as password from "./password/index";

/**
 * Register a new admin (community_platform_users +
 * community_platform_admin_users) and return authorized tokens.
 *
 * This operation registers a new site-wide administrator by creating records in
 * both the community_platform_users and community_platform_admin_users tables.
 *
 * It uses community_platform_users.email and community_platform_users.username
 * as unique identifiers, with collisions prevented by @@unique constraints.
 * Credentials are stored only as community_platform_users.password_hash, and no
 * plaintext password is kept. Consent timestamps are recorded in
 * community_platform_users.terms_accepted_at and
 * community_platform_users.privacy_accepted_at, satisfying compliance and audit
 * requirements noted in the schema.
 *
 * The account lifecycle is initialized using
 * community_platform_users.account_state (for example, "PendingVerification")
 * in combination with community_platform_users.email_verified. Optional
 * marketing preferences are captured using
 * community_platform_users.marketing_opt_in and
 * community_platform_users.marketing_opt_in_at. Auditing fields
 * community_platform_users.created_at, community_platform_users.updated_at, and
 * optionally community_platform_users.last_login_at are set appropriately
 * during provisioning.
 *
 * Admin privileges are granted by inserting a row into
 * community_platform_admin_users, linking via
 * community_platform_admin_users.community_platform_user_id and setting
 * community_platform_admin_users.granted_at to the current timestamp. The
 * relationship ensures global administrative capabilities as required by the
 * business role while maintaining historical grant/revoke data using
 * community_platform_admin_users.revoked_at when needed later.
 *
 * Upon success, the service issues JWT tokens for the newly created admin. The
 * response structure returns an authorized session aligned to
 * ICommunityPlatformAdminUser.IAuthorized and may include claims derived from
 * the user’s id and role assignment. Errors include uniqueness violations
 * (email/username), invalid credential policy, or missing consents. The
 * operation does not interact with logically deleted rows (deleted_at); it
 * always creates a new user.
 *
 * @param props.connection
 * @param props.body Admin registration payload with identifiers, password, and
 *   consent timestamps.
 * @setHeader token.access Authorization
 *
 * @path /auth/adminUser/join
 * @accessor api.functional.auth.adminUser.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Admin registration payload with identifiers, password, and consent
     * timestamps.
     */
    body: ICommunityPlatformAdminUserJoin.ICreate;
  };
  export type Body = ICommunityPlatformAdminUserJoin.ICreate;
  export type Response = ICommunityPlatformAdminUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/adminUser/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/adminUser/join";
  export const random = (): ICommunityPlatformAdminUser.IAuthorized =>
    typia.random<ICommunityPlatformAdminUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate an admin user (community_platform_users) and return authorized
 * tokens.
 *
 * This login operation verifies administrator credentials against the
 * community_platform_users table and confirms active admin assignment via
 * community_platform_admin_users.
 *
 * User identification uses community_platform_users.email or
 * community_platform_users.username, with credential verification against
 * community_platform_users.password_hash. The account must be eligible for
 * authentication based on community_platform_users.account_state (e.g., not
 * Locked, Deactivated, PendingDeletion, Deleted, or Banned) and
 * community_platform_users.email_verified where gating is required by policy.
 *
 * On successful authentication, the service updates
 * community_platform_users.last_login_at and
 * community_platform_users.updated_at to reflect the login event. It also
 * verifies that at least one active admin assignment exists in
 * community_platform_admin_users for the user, using
 * community_platform_admin_users.community_platform_user_id and ensuring
 * community_platform_admin_users.revoked_at is null when applicable.
 *
 * No new records are created by this action, and no archival fields are
 * modified beyond timestamp updates on the user. The operation then issues JWT
 * tokens containing claims necessary for authorization decisions.
 *
 * If the credentials are invalid or the account state is not eligible, the
 * provider returns a business error. Uniqueness constraints (email/username)
 * are not changed during login. The returned payload follows
 * ICommunityPlatformAdminUser.IAuthorized to convey authorized session
 * details.
 *
 * @param props.connection
 * @param props.body Admin login payload with email or username and password.
 * @setHeader token.access Authorization
 *
 * @path /auth/adminUser/login
 * @accessor api.functional.auth.adminUser.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Admin login payload with email or username and password. */
    body: ICommunityPlatformAdminUserLogin.ICreate;
  };
  export type Body = ICommunityPlatformAdminUserLogin.ICreate;
  export type Response = ICommunityPlatformAdminUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/adminUser/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/adminUser/login";
  export const random = (): ICommunityPlatformAdminUser.IAuthorized =>
    typia.random<ICommunityPlatformAdminUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh admin session tokens (validate against community_platform_users and
 * community_platform_admin_users).
 *
 * This operation renews an administrator’s session using a valid refresh token.
 * It uses the user identifier conveyed in token claims to load the matching row
 * from community_platform_users and confirms that the user still holds an
 * active admin grant via community_platform_admin_users.
 *
 * If the user is found and still eligible (based on
 * community_platform_users.account_state and email gating via
 * community_platform_users.email_verified where applicable), the provider
 * issues fresh access/refresh tokens and may update
 * community_platform_users.updated_at. The community_platform_admin_users table
 * is not changed by this operation; its grant metadata (granted_at, revoked_at)
 * is only read to ensure the admin role remains valid.
 *
 * No new rows are created, and no logical deletion timestamps are modified. The
 * operation focuses strictly on token lifecycle and authorization continuity
 * for administrators.
 *
 * On failures (expired/invalid refresh token or revoked admin status), the
 * operation returns a business error. The response schema is
 * ICommunityPlatformAdminUser.IAuthorized to deliver the renewed authorization
 * context.
 *
 * @param props.connection
 * @param props.body Refresh token exchange payload.
 * @setHeader token.access Authorization
 *
 * @path /auth/adminUser/refresh
 * @accessor api.functional.auth.adminUser.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token exchange payload. */
    body: ICommunityPlatformAdminUserRefresh.ICreate;
  };
  export type Body = ICommunityPlatformAdminUserRefresh.ICreate;
  export type Response = ICommunityPlatformAdminUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/adminUser/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/adminUser/refresh";
  export const random = (): ICommunityPlatformAdminUser.IAuthorized =>
    typia.random<ICommunityPlatformAdminUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
