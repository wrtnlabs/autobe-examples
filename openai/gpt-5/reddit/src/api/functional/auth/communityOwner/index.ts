import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunityOwner } from "../../../structures/ICommunityPlatformCommunityOwner";
export * as email from "./email/index";
export * as password from "./password/index";

/**
 * Register a community owner in community_platform_users and return
 * ICommunityPlatformCommunityOwner.IAuthorized.
 *
 * This endpoint registers a new account in the community_platform_users table
 * for a future community owner and returns authorization tokens. It uses fields
 * defined on community_platform_users including email (unique primary login
 * identifier), username (unique public handle), and password_hash
 * (non-reversible credential hash). Consent timestamps terms_accepted_at and
 * privacy_accepted_at are required for compliance and must be recorded from
 * user inputs at registration time, while marketing_opt_in and
 * marketing_opt_in_at are optional based on explicit opt-in.
 *
 * On successful registration, email_verified is initialized (typically false)
 * and account_state is set to a lifecycle value such as "PendingVerification"
 * or "Active" aligned with platform policy. last_login_at may be set to the
 * current time after token issuance. created_at and updated_at are
 * system-managed timestamps. The description aligns with schema comments that
 * emphasize unique constraints on email and username and capture of
 * audit-friendly timestamps.
 *
 * Security-wise, this operation is public and does not require prior
 * authentication. It returns initial JWT tokens suitable for the communityOwner
 * authentication context. Although ownership of a specific community is tracked
 * in community_platform_community_owners, this registration focuses solely on
 * identity creation in community_platform_users. The returned
 * ICommunityPlatformCommunityOwner.IAuthorized includes the access/refresh
 * tokens and user identifiers consistent with subsequent protected endpoints.
 *
 * Validation rules enforced mirror the schema: email and username must be
 * unique; password is stored as password_hash; terms_accepted_at and
 * privacy_accepted_at must be present. Account lifecycle values in
 * account_state will govern subsequent capabilities until email_verified
 * transitions to true via the verification flow.
 *
 * Related operations include POST /auth/communityOwner/email/verify to
 * transition email_verified and update account_state, and POST
 * /auth/communityOwner/login for subsequent sign-ins. Error handling covers
 * conflicts on email/username uniqueness and missing required consents.
 *
 * @param props.connection
 * @param props.body Registration payload with identifiers, password, and
 *   consents.
 * @setHeader token.access Authorization
 *
 * @path /auth/communityOwner/join
 * @accessor api.functional.auth.communityOwner.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Registration payload with identifiers, password, and consents. */
    body: ICommunityPlatformCommunityOwner.ICreate;
  };
  export type Body = ICommunityPlatformCommunityOwner.ICreate;
  export type Response = ICommunityPlatformCommunityOwner.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/communityOwner/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/communityOwner/join";
  export const random = (): ICommunityPlatformCommunityOwner.IAuthorized =>
    typia.random<ICommunityPlatformCommunityOwner.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate against community_platform_users and issue communityOwner
 * tokens.
 *
 * This endpoint authenticates a community owner using the core identity table
 * community_platform_users. It validates credentials against password_hash and
 * ensures the account meets required gates such as account_state not being
 * Locked, Deactivated, PendingDeletion, Deleted, or Banned. Where business
 * policy requires, email_verified must be true to gain full participation,
 * which is reflected by the email_verified flag stored on
 * community_platform_users.
 *
 * On successful authentication, last_login_at is updated to the current
 * timestamp, and updated_at is also advanced. The endpoint then returns
 * access/refresh tokens in ICommunityPlatformCommunityOwner.IAuthorized. Unique
 * identifiers like id, username, and email come from community_platform_users;
 * this operation does not interact with community ownership assignment tables
 * such as community_platform_community_owners.
 *
 * Security considerations include rate limiting invalid attempts and returning
 * neutral errors to prevent user enumeration. This is a public authentication
 * endpoint and does not require prior login. Failure modes include invalid
 * credentials, disallowed account_state, or unverified email depending on
 * policy.
 *
 * Complementary operations in this flow include /auth/communityOwner/refresh
 * for token renewal, /auth/communityOwner/email/verify to update
 * email_verified, and /auth/communityOwner/password for credential rotation.
 *
 * @param props.connection
 * @param props.body Login credentials (email or username) and password.
 * @setHeader token.access Authorization
 *
 * @path /auth/communityOwner/login
 * @accessor api.functional.auth.communityOwner.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Login credentials (email or username) and password. */
    body: ICommunityPlatformCommunityOwner.ILogin;
  };
  export type Body = ICommunityPlatformCommunityOwner.ILogin;
  export type Response = ICommunityPlatformCommunityOwner.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/communityOwner/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/communityOwner/login";
  export const random = (): ICommunityPlatformCommunityOwner.IAuthorized =>
    typia.random<ICommunityPlatformCommunityOwner.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh access for a community owner after validating
 * community_platform_users state.
 *
 * This endpoint exchanges a valid refresh token for a new authorized session
 * for the community owner. Although no direct writes to
 * community_platform_users are required, the service verifies that the user
 * still exists (id in community_platform_users), is not marked with a
 * disallowing account_state (e.g., Locked, Deactivated, PendingDeletion,
 * Deleted, Banned), and checks current email_verified. These fields originate
 * from the community_platform_users schema, which also records
 * created_at/updated_at timestamps for auditing.
 *
 * Security considerations include revocation checks and rotation semantics for
 * refresh tokens. The endpoint is accessible with a valid refresh token and
 * does not require an active access token. Results return
 * ICommunityPlatformCommunityOwner.IAuthorized to provide updated access
 * credentials consistent with the role.
 *
 * This operation integrates with /auth/communityOwner/login for initial sign-in
 * and can be used after registration via /auth/communityOwner/join if refresh
 * tokens are issued at that time. Error handling encompasses invalid/expired
 * refresh tokens and disqualifying account_state values observed in
 * community_platform_users.
 *
 * @param props.connection
 * @param props.body Refresh token exchange payload.
 * @setHeader token.access Authorization
 *
 * @path /auth/communityOwner/refresh
 * @accessor api.functional.auth.communityOwner.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token exchange payload. */
    body: ICommunityPlatformCommunityOwner.IRefresh;
  };
  export type Body = ICommunityPlatformCommunityOwner.IRefresh;
  export type Response = ICommunityPlatformCommunityOwner.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/communityOwner/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/communityOwner/refresh";
  export const random = (): ICommunityPlatformCommunityOwner.IAuthorized =>
    typia.random<ICommunityPlatformCommunityOwner.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
