import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformMemberUser } from "../../../structures/ICommunityPlatformMemberUser";

/**
 * Register a new member user in Actors.community_platform_users and assign
 * membership in Actors.community_platform_member_users.
 *
 * This endpoint registers a new member account by inserting a user into the
 * Actors.community_platform_users table and associating it with a member role
 * row in Actors.community_platform_member_users. The schema defines email and
 * username as unique, password_hash for non-reversible credential storage, and
 * consent fields terms_accepted_at and privacy_accepted_at that are required
 * for compliance. The email_verified boolean defaults to false until
 * verification flows complete, and account_state is a string used to gate
 * capabilities (e.g., PendingVerification, Active). The created_at and
 * updated_at timestamps must be set, and marketing_opt_in with
 * marketing_opt_in_at can be optionally recorded when applicable.
 *
 * Security-wise, plaintext passwords are never stored; only password_hash is
 * persisted as per the Prisma model comment. The registration flow must respect
 * uniqueness on email and username enforced by @@unique indexes. The new user’s
 * email_verified remains false, and participation features can be gated based
 * on this field together with account_state.
 *
 * This operation relates to the underlying user and membership entities. After
 * creating the user in community_platform_users, a corresponding record in
 * community_platform_member_users should be created to reflect the member role
 * assignment with joined_at and optional status fields. The link is via
 * community_platform_user_id.
 *
 * Validation must ensure required inputs exist and conform to business rules
 * (e.g., email format, username constraints, and password strength prior to
 * hashing). When marketing_opt_in is true, marketing_opt_in_at should be
 * timestamped; otherwise, both can remain false/null respectively. The
 * last_login_at field may remain null until the first successful login event.
 *
 * Error handling should include uniqueness violations on email or username and
 * validation failures. Since this endpoint issues authentication tokens for the
 * new account, ensure tokens are only minted after successful persistence and
 * any required checks against account_state in community_platform_users. The
 * response returns authorized token payload as
 * ICommunityPlatformMemberUser.IAuthorized suitable for immediate authenticated
 * use where policy allows.
 *
 * @param props.connection
 * @param props.body Registration payload including identifiers, credentials (to
 *   be hashed), and consent timestamps.
 * @setHeader token.access Authorization
 *
 * @path /auth/memberUser/join
 * @accessor api.functional.auth.memberUser.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Registration payload including identifiers, credentials (to be
     * hashed), and consent timestamps.
     */
    body: ICommunityPlatformMemberUser.ICreate;
  };
  export type Body = ICommunityPlatformMemberUser.ICreate;
  export type Response = ICommunityPlatformMemberUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/memberUser/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/memberUser/join";
  export const random = (): ICommunityPlatformMemberUser.IAuthorized =>
    typia.random<ICommunityPlatformMemberUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate a member user against Actors.community_platform_users and issue
 * tokens.
 *
 * This endpoint authenticates an existing account stored in
 * Actors.community_platform_users by verifying the supplied credentials against
 * the password_hash field. The model includes email and username as unique
 * identifiers that can be used for lookup, with password_hash for secure
 * comparison. The account_state string governs permissions and may deny login
 * for states such as Locked, Deactivated, PendingDeletion, Deleted, or Banned
 * based on business rules. The email_verified boolean can also be enforced to
 * restrict certain capabilities until verification is complete.
 *
 * Upon successful authentication, last_login_at should be updated to the
 * current timestamp, and updated_at reflects the modification to the user
 * record. The endpoint must not persist plaintext passwords at any time;
 * password_hash remains the canonical credential store as indicated in the
 * schema comments. If marketing_opt_in or other profile fields exist, they are
 * not changed by this operation.
 *
 * This operation does not create or delete records in related tables. It
 * strictly reads and updates fields in community_platform_users for auditing
 * (last_login_at) and session establishment. Any presence in
 * Actors.community_platform_member_users can be validated if necessary to
 * confirm the user indeed holds the member capability.
 *
 * Error handling includes handling unknown users, invalid credentials, and
 * account_state-based denials. On success, issue JWT tokens and return
 * ICommunityPlatformMemberUser.IAuthorized describing the authenticated session
 * context required for downstream protected operations.
 *
 * @param props.connection
 * @param props.body Login credentials identifying the user (email or username)
 *   and the secret to verify.
 * @setHeader token.access Authorization
 *
 * @path /auth/memberUser/login
 * @accessor api.functional.auth.memberUser.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Login credentials identifying the user (email or username) and the
     * secret to verify.
     */
    body: ICommunityPlatformMemberUser.ILogin;
  };
  export type Body = ICommunityPlatformMemberUser.ILogin;
  export type Response = ICommunityPlatformMemberUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/memberUser/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/memberUser/login";
  export const random = (): ICommunityPlatformMemberUser.IAuthorized =>
    typia.random<ICommunityPlatformMemberUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh JWT credentials for a member user by validating a refresh token
 * against state in Actors.community_platform_users.
 *
 * This endpoint validates a refresh token to mint new JWT credentials for a
 * member user whose core record lives in Actors.community_platform_users.
 * Before issuing new tokens, the service should re-verify authorization gates
 * derived from account_state (for example, disallow refresh when state reflects
 * Banned, Locked, Deactivated, PendingDeletion, or Deleted) and may consider
 * email_verified when policy requires restricting capabilities for unverified
 * accounts. The updated_at timestamp can be set when appropriate for auditing
 * refresh events, while last_login_at typically remains tied to interactive
 * logins.
 *
 * No schema fields store refresh tokens directly in the provided Prisma models;
 * validation therefore relies on token verification mechanisms external to the
 * schema. The endpoint only reads the user record to ensure eligibility and
 * current state. It does not modify password_hash, email, username, or
 * membership relations.
 *
 * Error handling should include invalid/expired refresh token and state-based
 * denials. On success, return new tokens encapsulated in
 * ICommunityPlatformMemberUser.IAuthorized so the client can continue
 * authorized operations without re-entering credentials.
 *
 * @param props.connection
 * @param props.body Refresh request payload carrying the refresh token as
 *   required by the application’s token strategy.
 * @setHeader token.access Authorization
 *
 * @path /auth/memberUser/refresh
 * @accessor api.functional.auth.memberUser.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh request payload carrying the refresh token as required by the
     * application’s token strategy.
     */
    body: ICommunityPlatformMemberUser.IRefresh;
  };
  export type Body = ICommunityPlatformMemberUser.IRefresh;
  export type Response = ICommunityPlatformMemberUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/memberUser/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/memberUser/refresh";
  export const random = (): ICommunityPlatformMemberUser.IAuthorized =>
    typia.random<ICommunityPlatformMemberUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
