import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommentVote } from "../../../../../structures/ICommunityPlatformCommentVote";

/**
 * Upsert or change a member’s vote (-1 or +1) for a comment
 * (community_platform_comment_votes).
 *
 * This operation modifies or creates a vote record in the Votes namespace for a
 * specific comment, aligning with the Prisma model
 * community_platform_comment_votes. The model defines: id (UUID),
 * community_platform_user_id (voter), community_platform_comment_id (target),
 * value (Int; valid values −1 or +1 only), created_at/updated_at, and
 * deleted_at. It enforces uniqueness for a user-target pair so that only one
 * vote can exist at a time via @@unique([community_platform_user_id,
 * community_platform_comment_id]). If a user has previously cleared a vote
 * (deleted_at populated), setting a new value should reactivate the vote by
 * updating value and clearing deleted_at.
 *
 * Security and permissions: Only authenticated members are allowed to vote. The
 * user must not be the author of the target comment (prevent self-voting per
 * business rules). Additionally, voting must be denied when either the target
 * comment node (community_platform_comments.locked_at) is locked or when the
 * parent post has been archived/locked
 * (community_platform_posts.archived_at/locked_at and visibility_state).
 * Eligibility gates described in the requirements (e.g., verified email,
 * account standing) apply.
 *
 * Database relationships: The vote record references community_platform_users
 * (voter) and community_platform_comments (target). The target comment
 * references a post (community_platform_posts) and a community
 * (community_platform_communities). Implementations should use the composite
 * unique constraint to upsert atomically, updating value and timestamps. If the
 * vote previously existed with deleted_at set, clearing that column effectively
 * restores the vote.
 *
 * Validation rules and business logic: The request must provide value ∈ {−1,
 * +1}. Attempts to submit 0 or other integers must be rejected. If the target
 * comment or its ancestor post is in a state that disallows voting
 * (locked/archived), the operation should fail. Rate limits in the requirements
 * (e.g., 60 vote actions/10 minutes and 600/24 hours with stricter limits for
 * low-trust accounts) should be enforced in provider logic; when triggered,
 * return the standardized error key. Self-voting must be prevented by comparing
 * the authenticated user id to the comment’s author id.
 *
 * Related operations: Clearing a user’s vote on a comment is handled by DELETE
 * /comments/{commentId}/vote, which deactivates the vote by timestamping
 * deleted_at. Post-level voting uses the analogous
 * community_platform_post_votes model and separate endpoints.
 *
 * @param props.connection
 * @param props.commentId Target comment’s ID (UUID) to vote on
 * @param props.body Vote value to set for this comment. Only -1 (downvote) or
 *   +1 (upvote) are accepted.
 * @path /communityPlatform/memberUser/comments/:commentId/vote
 * @accessor api.functional.communityPlatform.memberUser.comments.vote.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target comment’s ID (UUID) to vote on */
    commentId: string & tags.Format<"uuid">;

    /**
     * Vote value to set for this comment. Only -1 (downvote) or +1 (upvote)
     * are accepted.
     */
    body: ICommunityPlatformCommentVote.IUpdate;
  };
  export type Body = ICommunityPlatformCommentVote.IUpdate;
  export type Response = ICommunityPlatformCommentVote;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/memberUser/comments/:commentId/vote",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/memberUser/comments/${encodeURIComponent(props.commentId ?? "null")}/vote`;
  export const random = (): ICommunityPlatformCommentVote =>
    typia.random<ICommunityPlatformCommentVote>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Clear the member’s vote on a comment by timestamping deleted_at
 * (community_platform_comment_votes).
 *
 * This operation interacts with the Votes namespace and the Prisma model
 * community_platform_comment_votes. The model stores one vote per user per
 * comment with fields id, community_platform_user_id,
 * community_platform_comment_id, value (−1 or +1), created_at, updated_at, and
 * deleted_at. Clearing a vote populates deleted_at for the (user, comment) row,
 * so it no longer counts toward scores and karma computations, while retaining
 * history for governance analytics. Subsequent read models should exclude rows
 * with deleted_at set from active tallies.
 *
 * Security and permissions: Only authenticated members can clear their own
 * votes. If no existing vote row is found, treat the request as a no-op for
 * idempotency. Enforce business constraints from the requirements, including
 * restrictions when the comment/post is locked or archived. Implementations may
 * allow clear-only semantics under lock/archival if policy permits, but must
 * not allow setting or changing vote values in those states.
 *
 * Database relationships: The record references community_platform_users
 * (voter) and community_platform_comments (target). The composite unique
 * constraint ensures at most one row exists for each (user, comment). Clearing
 * does not permanently remove the row; instead, it timestamps deleted_at to
 * indicate it is inactive in standard queries.
 *
 * Behavior and errors: If a vote exists with deleted_at already set, repeated
 * clear requests should succeed without additional changes (idempotent
 * behavior). Apply rate limits consistent with the requirements and respond
 * with standardized error keys when limits are exceeded.
 *
 * Related operations: To set or change the vote value, use PUT
 * /comments/{commentId}/vote, which updates or creates the row and clears
 * deleted_at.
 *
 * @param props.connection
 * @param props.commentId Target comment’s ID (UUID) for which to clear the vote
 * @path /communityPlatform/memberUser/comments/:commentId/vote
 * @accessor api.functional.communityPlatform.memberUser.comments.vote.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target comment’s ID (UUID) for which to clear the vote */
    commentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/memberUser/comments/:commentId/vote",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/memberUser/comments/${encodeURIComponent(props.commentId ?? "null")}/vote`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
