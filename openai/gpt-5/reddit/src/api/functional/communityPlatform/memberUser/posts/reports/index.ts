import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformReport } from "../../../../../structures/ICommunityPlatformReport";

/**
 * Create a report for a post (community_platform_reports).
 *
 * Create a user-submitted safety report for a post. The underlying storage is
 * the community_platform_reports table, which defines these key columns: id
 * (PK), community_platform_user_id (reporter reference),
 * community_platform_post_id (target post), category (categorical reason
 * string), reason (free-text explanation), and created_at/updated_at
 * timestamps. The schema documentation specifies that exactly one of
 * community_platform_post_id or community_platform_comment_id must be set; this
 * endpoint sets the post reference from the path and leaves the comment
 * reference unset.
 *
 * Security and permissions: Only authenticated users are allowed to report
 * content. The reporter identity is taken from the authenticated session and
 * stored in community_platform_reports.community_platform_user_id. Business
 * rules from the requirements limit report abuse and duplication; the table
 * includes composite indexes to support deduplication windows by (reporter,
 * category, target). The service should return a clear business error (e.g.,
 * REPORT_DUPLICATE_OPEN) when a duplicate report exists within the policy
 * window.
 *
 * Entity relationships: The report references the target post via
 * community_platform_reports.community_platform_post_id and the reporter via
 * community_platform_reports.community_platform_user_id. The target post must
 * exist (referencing community_platform_posts.id). The operation should
 * validate that the target post is addressable and visible to the reporter per
 * policy before accepting the report.
 *
 * Validation and business logic: The request requires a category string and a
 * non-empty reason. Categories align with the documented moderation taxonomy
 * (e.g., spam, harassment/hate, sexual_content/child_safety, violence/threats,
 * self_harm_risk, illegal, doxxing, misinformation, off_topic/low_effort,
 * copyright, other). The service should trim and validate reason length. The
 * created row sets created_at/updated_at and associates the postId from the
 * path.
 *
 * Related operations: Use POST /comments/{commentId}/reports for reporting a
 * comment. These two operations are symmetrical and write to the same table
 * with different target columns. Error handling should surface standardized
 * keys from the exception model, such as REPORT_INVALID_CATEGORY,
 * REPORT_DUPLICATE_OPEN, and PERM_INSUFFICIENT_ROLE when the user lacks
 * permission.
 *
 * @param props.connection
 * @param props.postId Target post’s ID to report.
 * @param props.body Categorical reason and free-text explanation for reporting
 *   the post.
 * @path /communityPlatform/memberUser/posts/:postId/reports
 * @accessor api.functional.communityPlatform.memberUser.posts.reports.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Target post’s ID to report. */
    postId: string & tags.Format<"uuid">;

    /** Categorical reason and free-text explanation for reporting the post. */
    body: ICommunityPlatformReport.ICreate;
  };
  export type Body = ICommunityPlatformReport.ICreate;
  export type Response = ICommunityPlatformReport;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/memberUser/posts/:postId/reports",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/memberUser/posts/${encodeURIComponent(props.postId ?? "null")}/reports`;
  export const random = (): ICommunityPlatformReport =>
    typia.random<ICommunityPlatformReport>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
