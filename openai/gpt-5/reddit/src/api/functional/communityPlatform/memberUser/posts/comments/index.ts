import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformComment } from "../../../../../structures/ICommunityPlatformComment";

/**
 * Create a comment (community_platform_comments) under a post with optional
 * parent for nesting.
 *
 * This operation creates a new comment record in the
 * community_platform_comments table for the given post. The model defines
 * required fields including body and foreign keys to the post
 * (community_platform_post_id) and author (community_platform_user_id). The
 * optional parent_id supports hierarchical replies in the same post. The body
 * must be validated to meet the business requirement of 1–10,000 characters
 * after trimming whitespace; empty-only bodies are not permitted. The created
 * comment initializes edit_count and timestamps (created_at/updated_at)
 * appropriately and may set edited_at when edits occur later.
 *
 * Security and authorization follow role rules where only authenticated
 * participants (memberUser and above) may create comments. The server must
 * ensure the acting user has permission to participate in the target community
 * context and is not banned or restricted. The endpoint should also enforce
 * comment creation eligibility against the target post’s lifecycle, including
 * checks against community_platform_posts.locked_at, archived_at, and
 * visibility_state (e.g., Locked, Archived), where comments should not be
 * accepted. Records with deleted_at set in either the post or the chosen parent
 * comment must not be eligible as targets.
 *
 * This operation is related to the community_platform_posts and
 * community_platform_users tables through foreign keys, and supports nested
 * replies through the parent_id self-relation in community_platform_comments.
 * Implementation should ensure parent-child relationships remain within the
 * same post. Validation must surface business errors such as invalid length,
 * ineligible state (post locked or archived), or depth overflow. Additional
 * logic like rate limits and spam checks may apply according to business
 * requirements documents.
 *
 * Consumers typically pair this operation with GET /posts/{postId}/comments to
 * render the full comment tree after creation. Error handling should use the
 * platform’s standardized error model (e.g., COMMENT_VALIDATION_FAILED,
 * COMMENT_RATE_LIMITED, COMMENT_LOCKED, POST_ARCHIVED) and provide actionable
 * guidance. The response includes the newly created comment for immediate
 * client insertion into the thread.
 *
 * @param props.connection
 * @param props.postId Identifier of the target post to comment on
 * @param props.body Comment creation payload including body and optional
 *   parentId for nesting under the same post
 * @path /communityPlatform/memberUser/posts/:postId/comments
 * @accessor api.functional.communityPlatform.memberUser.posts.comments.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Identifier of the target post to comment on */
    postId: string & tags.Format<"uuid">;

    /**
     * Comment creation payload including body and optional parentId for
     * nesting under the same post
     */
    body: ICommunityPlatformComment.ICreate;
  };
  export type Body = ICommunityPlatformComment.ICreate;
  export type Response = ICommunityPlatformComment;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/memberUser/posts/:postId/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/memberUser/posts/${encodeURIComponent(props.postId ?? "null")}/comments`;
  export const random = (): ICommunityPlatformComment =>
    typia.random<ICommunityPlatformComment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
