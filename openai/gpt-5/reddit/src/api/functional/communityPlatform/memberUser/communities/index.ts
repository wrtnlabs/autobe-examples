import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunity } from "../../../../structures/ICommunityPlatformCommunity";
export * as subscribe from "./subscribe/index";
export * as posts from "./posts/index";

/**
 * Create a community in community_platform_communities.
 *
 * Create a community space following the design of the
 * community_platform_communities model. Per the schema comments, each community
 * has a globally unique handle in the name column used for routing and
 * mentions, and a human-readable display_name for UI surfaces. The visibility
 * column defines whether the community is public, restricted, or private. Flags
 * like nsfw influence downstream visibility and preview behavior, and
 * auto_archive_days determines when posts auto-archive to read-only (business
 * minimum 30).
 *
 * Security and permissions: This endpoint requires an authenticated user
 * eligible to create communities according to business policy. While the
 * database schema does not encode eligibility, the provider implementation
 * should validate account status and rate/eligibility rules before insertion.
 * After creation, ownership should be recorded via
 * community_platform_community_owners to reflect that the creator is the
 * initial owner for governance and moderation workflows.
 *
 * Entity relationships and behavior: Created communities are referenced by
 * subscriptions in community_platform_subscriptions and by content in
 * community_platform_posts. The quarantined boolean and quarantined_at
 * timestamp are reserved for trust & safety controls and are not intended to be
 * set by general users at creation time. Implementations should avoid returning
 * records that have a non-null deleted_at, as such records are treated as
 * removed from general listings.
 *
 * Validation and error handling: Enforce uniqueness of name, restrict
 * visibility to one of public | restricted | private, and require
 * auto_archive_days to be at least 30. If name conflicts occur, the service
 * should return a conflict-style error. If validation fails (e.g., invalid
 * visibility or insufficient archive window), return a clear error consistent
 * with the exception model. Related operations include GET
 * /communities/{communityId} to retrieve the community after creation.
 *
 * @param props.connection
 * @param props.body Community creation payload including unique handle,
 *   visibility, labeling, and archival policy
 * @path /communityPlatform/memberUser/communities
 * @accessor api.functional.communityPlatform.memberUser.communities.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Community creation payload including unique handle, visibility,
     * labeling, and archival policy
     */
    body: ICommunityPlatformCommunity.ICreate;
  };
  export type Body = ICommunityPlatformCommunity.ICreate;
  export type Response = ICommunityPlatformCommunity;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/memberUser/communities",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/memberUser/communities";
  export const random = (): ICommunityPlatformCommunity =>
    typia.random<ICommunityPlatformCommunity>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
