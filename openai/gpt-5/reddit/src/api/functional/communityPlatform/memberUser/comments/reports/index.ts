import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformReport } from "../../../../../structures/ICommunityPlatformReport";

/**
 * Create a report for a comment (community_platform_reports).
 *
 * Submit a safety report for a comment. The community_platform_reports table
 * models reports with: id (PK), community_platform_user_id (reporter user),
 * community_platform_comment_id (target comment), category (categorical
 * reason), reason (free-text explanation), and created_at/updated_at
 * timestamps. The schema comments emphasize that exactly one target reference
 * is provided (post or comment). This endpoint sets
 * community_platform_comment_id from the path and leaves the post reference
 * unset.
 *
 * Security and permissions: Only authenticated users may report comments; the
 * reporter is the current session user written to
 * community_platform_reports.community_platform_user_id. Business rules from
 * the requirements cover deduplication (per reporter, category, and target
 * within a time window) and abuse controls. The table’s composite indexes
 * support efficient checks, and violations should surface standard errors such
 * as REPORT_DUPLICATE_OPEN or REPORT_RATE_LIMITED.
 *
 * Entity relationships: The report ties to the target comment via
 * community_platform_reports.community_platform_comment_id and to the reporter
 * via community_platform_reports.community_platform_user_id. The target comment
 * must exist (community_platform_comments.id). The service should ensure the
 * reporter has access to the underlying post/community context before accepting
 * the report.
 *
 * Validation and business logic: The request requires a category string and a
 * non-empty, trimmed reason. Categories follow the moderation taxonomy (e.g.,
 * spam, harassment/hate, sexual_content/child_safety, violence/threats,
 * self_harm_risk, illegal, doxxing, misinformation, off_topic/low_effort,
 * copyright, other). The service sets timestamps and associates commentId from
 * the path parameter.
 *
 * Related operations: To report posts, use POST /posts/{postId}/reports. Both
 * operations persist to the same table with distinct target columns. Error
 * handling follows the standard model, including REPORT_INVALID_CATEGORY,
 * REPORT_DUPLICATE_OPEN, and PERM_INSUFFICIENT_ROLE.
 *
 * @param props.connection
 * @param props.commentId Target comment’s ID to report.
 * @param props.body Categorical reason and free-text explanation for reporting
 *   the comment.
 * @path /communityPlatform/memberUser/comments/:commentId/reports
 * @accessor api.functional.communityPlatform.memberUser.comments.reports.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Target comment’s ID to report. */
    commentId: string & tags.Format<"uuid">;

    /**
     * Categorical reason and free-text explanation for reporting the
     * comment.
     */
    body: ICommunityPlatformReport.ICreate;
  };
  export type Body = ICommunityPlatformReport.ICreate;
  export type Response = ICommunityPlatformReport;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/memberUser/comments/:commentId/reports",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/memberUser/comments/${encodeURIComponent(props.commentId ?? "null")}/reports`;
  export const random = (): ICommunityPlatformReport =>
    typia.random<ICommunityPlatformReport>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
