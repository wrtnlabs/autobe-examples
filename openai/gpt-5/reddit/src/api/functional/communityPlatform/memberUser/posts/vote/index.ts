import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPostVote } from "../../../../../structures/ICommunityPlatformPostVote";

/**
 * Set or change a post vote (community_platform_post_votes).
 *
 * Set or update the caller’s vote on a post identified by postId. In the Prisma
 * schema, community_platform_post_votes represents a single user’s vote on a
 * post and includes columns id, community_platform_user_id,
 * community_platform_post_id, value (only -1 or +1 are valid), created_at,
 * updated_at, and deleted_at. A composite unique index on
 * (community_platform_user_id, community_platform_post_id) guarantees exactly
 * one active vote per user and post, while deleted_at supports logical
 * retraction of a vote without removing history. Relationships enforce
 * referential integrity to community_platform_users (the voter) and
 * community_platform_posts (the target post) with onDelete: Cascade semantics.
 *
 * Security and permissions follow business rules: the caller must be an
 * authenticated user (member) with eligibility to vote, such as a verified
 * email and not being banned or restricted in the target community.
 * Implementations should prevent voting on one’s own content and disallow
 * changes when a post is Locked or Archived, consistent with content lifecycle
 * rules. Rate limiting should be applied per the voting requirements to
 * mitigate abuse. The request must supply a value of -1 (downvote) or +1
 * (upvote). If an identical value is already recorded and not deleted, the
 * operation is idempotent and leaves the record unchanged; if a different value
 * exists, it updates value and updated_at. If a logically deleted record exists
 * (deleted_at set), the operation should revive the vote by clearing deleted_at
 * and setting the requested value.
 *
 * This operation is typically used together with DELETE /posts/{postId}/vote to
 * clear a vote. Post detail retrieval (e.g., GET /posts/{postId}) is expected
 * to reflect the net score derived from active votes. Errors include not found
 * (post does not exist or not visible), permission/eligibility denials (e.g.,
 * attempting to vote on own content or voting on locked/archived content), and
 * rate limiting. The operation returns the resulting
 * community_platform_post_votes entity so clients can reflect current state in
 * UI.
 *
 * @param props.connection
 * @param props.postId Target post’s ID to vote on
 * @param props.body Desired vote value for the current user on the specified
 *   post. Only -1 or +1 are valid.
 * @path /communityPlatform/memberUser/posts/:postId/vote
 * @accessor api.functional.communityPlatform.memberUser.posts.vote.setVote
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function setVote(
  connection: IConnection,
  props: setVote.Props,
): Promise<setVote.Response> {
  return true === connection.simulate
    ? setVote.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...setVote.METADATA,
          path: setVote.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace setVote {
  export type Props = {
    /** Target post’s ID to vote on */
    postId: string & tags.Format<"uuid">;

    /**
     * Desired vote value for the current user on the specified post. Only
     * -1 or +1 are valid.
     */
    body: ICommunityPlatformPostVote.IUpdate;
  };
  export type Body = ICommunityPlatformPostVote.IUpdate;
  export type Response = ICommunityPlatformPostVote;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/memberUser/posts/:postId/vote",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/memberUser/posts/${encodeURIComponent(props.postId ?? "null")}/vote`;
  export const random = (): ICommunityPlatformPostVote =>
    typia.random<ICommunityPlatformPostVote>();
  export const simulate = (
    connection: IConnection,
    props: setVote.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: setVote.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Clear a post vote (community_platform_post_votes).
 *
 * Remove the caller’s active vote on the post identified by postId by marking
 * the corresponding community_platform_post_votes record as deleted through the
 * deleted_at timestamp. The underlying Prisma model includes id,
 * community_platform_user_id, community_platform_post_id, value, created_at,
 * updated_at, and deleted_at. Setting deleted_at indicates the vote is no
 * longer active and should be excluded from scores while preserving history. If
 * no active vote exists, the operation is idempotent and completes without
 * changing state. Referential integrity to community_platform_users (voter) and
 * community_platform_posts (target) is maintained, with onDelete: Cascade
 * semantics when targets are removed.
 *
 * Security and permissions align with business rules: only authenticated
 * eligible users can modify their own vote; voting changes must be denied when
 * a post is Locked or Archived and must respect restrictions such as bans. Rate
 * limits for vote actions may apply. This endpoint returns no body on success
 * to reflect a simple state-clearing action; clients can re-fetch post details
 * to obtain updated aggregate scores.
 *
 * Use this operation in tandem with PUT /posts/{postId}/vote to set a new vote
 * value later. Typical errors include post not found, insufficient permissions,
 * or state-based denials (e.g., locked/archived content disallowing vote
 * changes).
 *
 * @param props.connection
 * @param props.postId Target post’s ID whose vote should be cleared
 * @path /communityPlatform/memberUser/posts/:postId/vote
 * @accessor api.functional.communityPlatform.memberUser.posts.vote.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target post’s ID whose vote should be cleared */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/memberUser/posts/:postId/vote",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/memberUser/posts/${encodeURIComponent(props.postId ?? "null")}/vote`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
