import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformSubscription } from "../../../../../structures/ICommunityPlatformSubscription";

/**
 * Create or re-activate a subscription (community_platform_subscriptions) for
 * the current user in a community.
 *
 * Subscribe the current authenticated user to the specified community by
 * inserting or re-activating a row in the Communities namespace table
 * community_platform_subscriptions. According to the Prisma schema, this table
 * maintains a unique mapping per (community_platform_user_id,
 * community_platform_community_id) via a composite unique constraint and tracks
 * attributes such as status (pending | subscribed | banned | blocked), muted
 * (Boolean) with muted_at, and lifecycle timestamps (created_at, updated_at,
 * deleted_at). This operation focuses exclusively on establishing an active
 * subscription for feed inclusion and does not manage muting or unsubscription
 * flows.
 *
 * Security and eligibility considerations derive from related schema entities.
 * The target community is stored in community_platform_communities with fields
 * including visibility (public/restricted/private), nsfw (Boolean), and
 * quarantined (Boolean), which inform business logic about whether a user can
 * subscribe immediately or must await approval (e.g., status="pending" for
 * private or restricted communities). The subscriber is the authenticated
 * principal backed by community_platform_users (email_verified Boolean and
 * account_state string such as PendingVerification, Active, Locked,
 * Deactivated, PendingDeletion, Deleted, Banned). Implementations typically
 * require an authenticated user in good standing and a community that can
 * accept new subscribers under its visibility and safety settings.
 *
 * From a data integrity standpoint, the community_platform_subscriptions table
 * enforces uniqueness on (community_platform_user_id,
 * community_platform_community_id) and offers indexes for efficient retrieval
 * by user or community and by status plus deleted_at. If a prior row exists
 * with an inactive state indicated via the deleted_at column, this operation
 * should treat the request as idempotent by restoring it to an active state and
 * setting status to "subscribed" as appropriate. When a current active record
 * exists, this operation should be no-op and return the existing state,
 * maintaining deterministic idempotency.
 *
 * Related operations in the broader system (not included here) could cover
 * unsubscription, muting, or administrative bans, but they are intentionally
 * out of scope to align with the interface instructions. Expected errors
 * include attempts to subscribe to non-existent communities, attempts by users
 * with account_state that disallows participation, or attempts to subscribe
 * where the community has set the user’s status to banned or blocked.
 *
 * @param props.connection
 * @param props.communityId Target community’s ID to subscribe to.
 * @path /communityPlatform/memberUser/communities/:communityId/subscribe
 * @accessor api.functional.communityPlatform.memberUser.communities.subscribe.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
      );
}
export namespace create {
  export type Props = {
    /** Target community’s ID to subscribe to. */
    communityId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformSubscription;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/memberUser/communities/:communityId/subscribe",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/memberUser/communities/${encodeURIComponent(props.communityId ?? "null")}/subscribe`;
  export const random = (): ICommunityPlatformSubscription =>
    typia.random<ICommunityPlatformSubscription>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
