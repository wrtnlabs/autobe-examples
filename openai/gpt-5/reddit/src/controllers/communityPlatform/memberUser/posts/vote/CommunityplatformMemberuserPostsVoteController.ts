import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { putCommunityPlatformMemberUserPostsPostIdVote } from "../../../../../providers/putCommunityPlatformMemberUserPostsPostIdVote";
import { MemberuserAuth } from "../../../../../decorators/MemberuserAuth";
import { MemberuserPayload } from "../../../../../decorators/payload/MemberuserPayload";
import { deleteCommunityPlatformMemberUserPostsPostIdVote } from "../../../../../providers/deleteCommunityPlatformMemberUserPostsPostIdVote";

import { ICommunityPlatformPostVote } from "../../../../../api/structures/ICommunityPlatformPostVote";

@Controller("/communityPlatform/memberUser/posts/:postId/vote")
export class CommunityplatformMemberuserPostsVoteController {
  /**
   * Set or change a post vote (community_platform_post_votes).
   *
   * Set or update the caller’s vote on a post identified by postId. In the
   * Prisma schema, community_platform_post_votes represents a single user’s
   * vote on a post and includes columns id, community_platform_user_id,
   * community_platform_post_id, value (only -1 or +1 are valid), created_at,
   * updated_at, and deleted_at. A composite unique index on
   * (community_platform_user_id, community_platform_post_id) guarantees exactly
   * one active vote per user and post, while deleted_at supports logical
   * retraction of a vote without removing history. Relationships enforce
   * referential integrity to community_platform_users (the voter) and
   * community_platform_posts (the target post) with onDelete: Cascade
   * semantics.
   *
   * Security and permissions follow business rules: the caller must be an
   * authenticated user (member) with eligibility to vote, such as a verified
   * email and not being banned or restricted in the target community.
   * Implementations should prevent voting on one’s own content and disallow
   * changes when a post is Locked or Archived, consistent with content
   * lifecycle rules. Rate limiting should be applied per the voting
   * requirements to mitigate abuse. The request must supply a value of -1
   * (downvote) or +1 (upvote). If an identical value is already recorded and
   * not deleted, the operation is idempotent and leaves the record unchanged;
   * if a different value exists, it updates value and updated_at. If a
   * logically deleted record exists (deleted_at set), the operation should
   * revive the vote by clearing deleted_at and setting the requested value.
   *
   * This operation is typically used together with DELETE /posts/{postId}/vote
   * to clear a vote. Post detail retrieval (e.g., GET /posts/{postId}) is
   * expected to reflect the net score derived from active votes. Errors include
   * not found (post does not exist or not visible), permission/eligibility
   * denials (e.g., attempting to vote on own content or voting on
   * locked/archived content), and rate limiting. The operation returns the
   * resulting community_platform_post_votes entity so clients can reflect
   * current state in UI.
   *
   * @param connection
   * @param postId Target post’s ID to vote on
   * @param body Desired vote value for the current user on the specified post.
   *   Only -1 or +1 are valid.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put()
  public async setVote(
    @MemberuserAuth()
    memberUser: MemberuserPayload,
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformPostVote.IUpdate,
  ): Promise<ICommunityPlatformPostVote> {
    try {
      return await putCommunityPlatformMemberUserPostsPostIdVote({
        memberUser,
        postId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Clear a post vote (community_platform_post_votes).
   *
   * Remove the caller’s active vote on the post identified by postId by marking
   * the corresponding community_platform_post_votes record as deleted through
   * the deleted_at timestamp. The underlying Prisma model includes id,
   * community_platform_user_id, community_platform_post_id, value, created_at,
   * updated_at, and deleted_at. Setting deleted_at indicates the vote is no
   * longer active and should be excluded from scores while preserving history.
   * If no active vote exists, the operation is idempotent and completes without
   * changing state. Referential integrity to community_platform_users (voter)
   * and community_platform_posts (target) is maintained, with onDelete: Cascade
   * semantics when targets are removed.
   *
   * Security and permissions align with business rules: only authenticated
   * eligible users can modify their own vote; voting changes must be denied
   * when a post is Locked or Archived and must respect restrictions such as
   * bans. Rate limits for vote actions may apply. This endpoint returns no body
   * on success to reflect a simple state-clearing action; clients can re-fetch
   * post details to obtain updated aggregate scores.
   *
   * Use this operation in tandem with PUT /posts/{postId}/vote to set a new
   * vote value later. Typical errors include post not found, insufficient
   * permissions, or state-based denials (e.g., locked/archived content
   * disallowing vote changes).
   *
   * @param connection
   * @param postId Target post’s ID whose vote should be cleared
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete()
  public async erase(
    @MemberuserAuth()
    memberUser: MemberuserPayload,
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteCommunityPlatformMemberUserPostsPostIdVote({
        memberUser,
        postId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
