import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postCommunityPlatformMemberUserPostsPostIdReports } from "../../../../../providers/postCommunityPlatformMemberUserPostsPostIdReports";
import { MemberuserAuth } from "../../../../../decorators/MemberuserAuth";
import { MemberuserPayload } from "../../../../../decorators/payload/MemberuserPayload";

import { ICommunityPlatformReport } from "../../../../../api/structures/ICommunityPlatformReport";

@Controller("/communityPlatform/memberUser/posts/:postId/reports")
export class CommunityplatformMemberuserPostsReportsController {
  /**
   * Create a report for a post (community_platform_reports).
   *
   * Create a user-submitted safety report for a post. The underlying storage is
   * the community_platform_reports table, which defines these key columns: id
   * (PK), community_platform_user_id (reporter reference),
   * community_platform_post_id (target post), category (categorical reason
   * string), reason (free-text explanation), and created_at/updated_at
   * timestamps. The schema documentation specifies that exactly one of
   * community_platform_post_id or community_platform_comment_id must be set;
   * this endpoint sets the post reference from the path and leaves the comment
   * reference unset.
   *
   * Security and permissions: Only authenticated users are allowed to report
   * content. The reporter identity is taken from the authenticated session and
   * stored in community_platform_reports.community_platform_user_id. Business
   * rules from the requirements limit report abuse and duplication; the table
   * includes composite indexes to support deduplication windows by (reporter,
   * category, target). The service should return a clear business error (e.g.,
   * REPORT_DUPLICATE_OPEN) when a duplicate report exists within the policy
   * window.
   *
   * Entity relationships: The report references the target post via
   * community_platform_reports.community_platform_post_id and the reporter via
   * community_platform_reports.community_platform_user_id. The target post must
   * exist (referencing community_platform_posts.id). The operation should
   * validate that the target post is addressable and visible to the reporter
   * per policy before accepting the report.
   *
   * Validation and business logic: The request requires a category string and a
   * non-empty reason. Categories align with the documented moderation taxonomy
   * (e.g., spam, harassment/hate, sexual_content/child_safety,
   * violence/threats, self_harm_risk, illegal, doxxing, misinformation,
   * off_topic/low_effort, copyright, other). The service should trim and
   * validate reason length. The created row sets created_at/updated_at and
   * associates the postId from the path.
   *
   * Related operations: Use POST /comments/{commentId}/reports for reporting a
   * comment. These two operations are symmetrical and write to the same table
   * with different target columns. Error handling should surface standardized
   * keys from the exception model, such as REPORT_INVALID_CATEGORY,
   * REPORT_DUPLICATE_OPEN, and PERM_INSUFFICIENT_ROLE when the user lacks
   * permission.
   *
   * @param connection
   * @param postId Target postâ€™s ID to report.
   * @param body Categorical reason and free-text explanation for reporting the
   *   post.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @MemberuserAuth()
    memberUser: MemberuserPayload,
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformReport.ICreate,
  ): Promise<ICommunityPlatformReport> {
    try {
      return await postCommunityPlatformMemberUserPostsPostIdReports({
        memberUser,
        postId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
