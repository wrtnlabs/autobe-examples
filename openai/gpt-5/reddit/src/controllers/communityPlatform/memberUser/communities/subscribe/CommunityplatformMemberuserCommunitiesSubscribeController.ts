import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postCommunityPlatformMemberUserCommunitiesCommunityIdSubscribe } from "../../../../../providers/postCommunityPlatformMemberUserCommunitiesCommunityIdSubscribe";
import { MemberuserAuth } from "../../../../../decorators/MemberuserAuth";
import { MemberuserPayload } from "../../../../../decorators/payload/MemberuserPayload";

import { ICommunityPlatformSubscription } from "../../../../../api/structures/ICommunityPlatformSubscription";

@Controller("/communityPlatform/memberUser/communities/:communityId/subscribe")
export class CommunityplatformMemberuserCommunitiesSubscribeController {
  /**
   * Create or re-activate a subscription (community_platform_subscriptions) for
   * the current user in a community.
   *
   * Subscribe the current authenticated user to the specified community by
   * inserting or re-activating a row in the Communities namespace table
   * community_platform_subscriptions. According to the Prisma schema, this
   * table maintains a unique mapping per (community_platform_user_id,
   * community_platform_community_id) via a composite unique constraint and
   * tracks attributes such as status (pending | subscribed | banned | blocked),
   * muted (Boolean) with muted_at, and lifecycle timestamps (created_at,
   * updated_at, deleted_at). This operation focuses exclusively on establishing
   * an active subscription for feed inclusion and does not manage muting or
   * unsubscription flows.
   *
   * Security and eligibility considerations derive from related schema
   * entities. The target community is stored in community_platform_communities
   * with fields including visibility (public/restricted/private), nsfw
   * (Boolean), and quarantined (Boolean), which inform business logic about
   * whether a user can subscribe immediately or must await approval (e.g.,
   * status="pending" for private or restricted communities). The subscriber is
   * the authenticated principal backed by community_platform_users
   * (email_verified Boolean and account_state string such as
   * PendingVerification, Active, Locked, Deactivated, PendingDeletion, Deleted,
   * Banned). Implementations typically require an authenticated user in good
   * standing and a community that can accept new subscribers under its
   * visibility and safety settings.
   *
   * From a data integrity standpoint, the community_platform_subscriptions
   * table enforces uniqueness on (community_platform_user_id,
   * community_platform_community_id) and offers indexes for efficient retrieval
   * by user or community and by status plus deleted_at. If a prior row exists
   * with an inactive state indicated via the deleted_at column, this operation
   * should treat the request as idempotent by restoring it to an active state
   * and setting status to "subscribed" as appropriate. When a current active
   * record exists, this operation should be no-op and return the existing
   * state, maintaining deterministic idempotency.
   *
   * Related operations in the broader system (not included here) could cover
   * unsubscription, muting, or administrative bans, but they are intentionally
   * out of scope to align with the interface instructions. Expected errors
   * include attempts to subscribe to non-existent communities, attempts by
   * users with account_state that disallows participation, or attempts to
   * subscribe where the community has set the user’s status to banned or
   * blocked.
   *
   * @param connection
   * @param communityId Target community’s ID to subscribe to.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @MemberuserAuth()
    memberUser: MemberuserPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
  ): Promise<ICommunityPlatformSubscription> {
    try {
      return await postCommunityPlatformMemberUserCommunitiesCommunityIdSubscribe(
        {
          memberUser,
          communityId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
