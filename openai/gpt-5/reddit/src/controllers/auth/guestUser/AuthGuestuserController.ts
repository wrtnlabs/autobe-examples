import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthGuestUserJoin } from "../../../providers/postAuthGuestUserJoin";
import { postAuthGuestUserRefresh } from "../../../providers/postAuthGuestUserRefresh";

import { ICommunityPlatformGuestUser } from "../../../api/structures/ICommunityPlatformGuestUser";

@Controller("/auth/guestUser")
export class AuthGuestuserController {
  /**
   * Register a guest-capable identity and assign guest role using
   * community_platform_users and community_platform_guest_users.
   *
   * This public endpoint provisions a guest-capable identity and immediately
   * assigns the guest designation using the Actors schema. It inserts into
   * community_platform_users with required columns including email, username,
   * password_hash (derived by the server), email_verified, account_state,
   * terms_accepted_at, privacy_accepted_at, and timestamps such as created_at
   * and updated_at. Optional fields like display_name, avatar_uri, and
   * marketing_opt_in/marketing_opt_in_at are handled per submitted data and
   * policy. The server should set last_login_at upon successful token issuance
   * to support account activity auditing.
   *
   * Guest role assignment is persisted in community_platform_guest_users by
   * linking the newly created community_platform_users.id into
   * community_platform_guest_users.community_platform_user_id and stamping
   * granted_at. Lifecycle fields revoked_at and deleted_at in role tables are
   * reserved for future transitions; they are not manipulated by this
   * operation. Business uniqueness on community_platform_users.email and
   * community_platform_users.username determines conflict handling during
   * registration.
   *
   * Within platform security rules, email_verified and account_state (e.g.,
   * PendingVerification vs Active) gate participation in later flows. Even as a
   * guest, issuance of tokens must honor session limits, and refresh is handled
   * by the companion /auth/guestUser/refresh. All timestamps are stored as
   * Timestamptz per schema (e.g., terms_accepted_at, privacy_accepted_at) to
   * support localization and audit requirements.
   *
   * Validation observes the schema comments: the password_hash is stored
   * non-reversibly; plaintext passwords are never persisted. Since guests do
   * not perform a credentials login, servers can generate a secure
   * password_hash internally to satisfy the non-null column while still
   * enforcing Terms/Privacy acceptance. The request must collect required
   * registration inputs to satisfy non-null constraints and policy, including
   * unique identifiers, while the response returns an authorization payload
   * type.
   *
   * Related operations include token refresh using the same role and audit of
   * last_login_at updates in community_platform_users. Error behavior is shaped
   * by database constraints and business checks on uniqueness and consent
   * timestamps; violations should return clear messages aligned with the
   * exception model.
   *
   * @param connection
   * @param body Guest registration inputs sufficient to create
   *   community_platform_users and record Terms/Privacy acceptance; server may
   *   derive password_hash and initial account_state.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ICommunityPlatformGuestUser.IJoin,
  ): Promise<ICommunityPlatformGuestUser.IAuthorized> {
    try {
      return await postAuthGuestUserJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh guest tokens validating community_platform_users state and guest
   * assignment in community_platform_guest_users.
   *
   * This endpoint renews guest session tokens by validating an incoming refresh
   * token and returning a fresh authorization bundle. It relies on the Actors
   * tables: community_platform_users for identity status (email_verified,
   * account_state, last_login_at, updated_at) and
   * community_platform_guest_users to ensure the guest designation remains
   * current (revoked_at not set). No credential validation occurs because
   * guests do not log in; instead, refresh relies on token validity and any
   * device/session checks the service enforces.
   *
   * Upon success, the provider updates community_platform_users.last_login_at
   * for audit and sets updated_at. If the backing userâ€™s account_state is
   * incompatible (e.g., Locked or Banned), the provider denies refresh. All
   * timestamps are recorded using Timestamptz per schema guidance. Business
   * rules around token lifetimes (access vs refresh) and rotation are applied
   * consistently.
   *
   * Related operations include /auth/guestUser/join to obtain the initial
   * authorization. Error outcomes follow unique constraint or state
   * validations: invalid/expired refresh token, revoked session, or disallowed
   * account_state. This operation does not modify role assignment records; it
   * only validates their current state.
   *
   * @param connection
   * @param body Refresh token inputs for renewing guest authorization.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ICommunityPlatformGuestUser.IRefresh,
  ): Promise<ICommunityPlatformGuestUser.IAuthorized> {
    try {
      return await postAuthGuestUserRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
