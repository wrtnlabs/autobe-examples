import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthCommunityModeratorJoin } from "../../../providers/postAuthCommunityModeratorJoin";
import { postAuthCommunityModeratorLogin } from "../../../providers/postAuthCommunityModeratorLogin";
import { postAuthCommunityModeratorRefresh } from "../../../providers/postAuthCommunityModeratorRefresh";

import { ICommunityPlatformCommunityModerator } from "../../../api/structures/ICommunityPlatformCommunityModerator";
import { ICommunityPlatformCommunityModeratorJoin } from "../../../api/structures/ICommunityPlatformCommunityModeratorJoin";
import { ICommunityPlatformCommunityModeratorLogin } from "../../../api/structures/ICommunityPlatformCommunityModeratorLogin";
import { ICommunityPlatformCommunityModeratorRefresh } from "../../../api/structures/ICommunityPlatformCommunityModeratorRefresh";

@Controller("/auth/communityModerator")
export class AuthCommunitymoderatorController {
  /**
   * Register a user (future community moderator) using community_platform_users
   * and initialize community_platform_member_users.
   *
   * Purpose and functionality: Registers a new platform user intending to
   * become a community moderator later by community assignment. The operation
   * inserts a row into Actors.community_platform_users with required unique
   * identifiers email and username, storing the credential as password_hash. It
   * records compliance timestamps (terms_accepted_at, privacy_accepted_at) and
   * optional marketing_opt_in/marketing_opt_in_at exactly as modeled. The
   * initial flags email_verified (Boolean) and account_state (String) are set
   * according to onboarding flow described in requirements (e.g., account_state
   * may be "PendingVerification" until email verification succeeds). created_at
   * and updated_at are set to current timestamps.
   *
   * Implementation details and validations: Enforce database-level uniqueness
   * of email and username (per @@unique) and validate password before hashing
   * into password_hash. Do not write to deleted_at. If business logic enables
   * member capabilities at join, insert a corresponding row into
   * Actors.community_platform_member_users with community_platform_user_id
   * referencing the created user and joined_at set to now; status may be null
   * or a workflow-specific String. No entries are written to
   * community_platform_community_moderators because moderator privileges are
   * granted by owners later per schema comments.
   *
   * Role-specific integration: Although the path is
   * /auth/communityModerator/join, this endpoint creates a general user
   * (community_platform_users) and optionally the member linkage
   * (community_platform_member_users). Moderator scope is community-specific
   * and realized subsequently through community_platform_community_moderators.
   * This aligns with the role being of kind "member" in the permission model.
   *
   * Security considerations: Passwords are never stored in plaintextâ€”only as
   * password_hash. email_verified remains false until a separate verification
   * succeeds. account_state governs capabilities (e.g., PendingVerification vs
   * Active) and maps to the String column. Audit fields like last_login_at are
   * untouched at join; they will be updated on login. Soft deletion via
   * deleted_at is not used here.
   *
   * Related operations and workflow: Typical flows call login after successful
   * verification, and token refresh to maintain sessions. Community moderator
   * assignment is done by community owners using
   * community_platform_community_moderators and is not part of this endpoint.
   * Error cases should reflect uniqueness violations and invalid registration
   * data as per the exception model.
   *
   * @param connection
   * @param body Registration payload with email, username, password,
   *   terms/privacy consent, and optional marketing consent.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ICommunityPlatformCommunityModeratorJoin.ICreate,
  ): Promise<ICommunityPlatformCommunityModerator.IAuthorized> {
    try {
      return await postAuthCommunityModeratorJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Login a community moderator using community_platform_users (password_hash,
   * email/username) and update last_login_at.
   *
   * Purpose and functionality: Authenticates a user who may hold moderator
   * responsibilities. It queries community_platform_users by email or username
   * (both unique) and validates the credential against password_hash. If the
   * account is eligible (e.g., email_verified is true and account_state
   * indicates an allowed state like "Active"), the endpoint issues
   * access/refresh tokens per session policy and returns an authorized
   * payload.
   *
   * Implementation details: On successful login, set last_login_at to current
   * time and update updated_at. Respect the soft deletion model by rejecting
   * users where deleted_at is non-null. The controller must treat account_state
   * and email_verified exactly as persisted Boolean/String flags and must not
   * mutate terms_accepted_at, privacy_accepted_at, or marketing_opt_in fields
   * during login. No write is performed to community_platform_member_users or
   * community_platform_community_moderators by this endpoint.
   *
   * Role-specific integration: Although this uses the communityModerator path,
   * the underlying identity remains the user row in community_platform_users
   * with optional membership record in community_platform_member_users. Any
   * moderator privileges are scoped per community via
   * community_platform_community_moderators and are orthogonal to
   * authentication.
   *
   * Security considerations: Enforce indistinguishable failure messages to
   * prevent user enumeration. Passwords are handled via password_hash
   * comparison. Accounts with account_state indicating
   * Locked/Deactivated/Banned or with email_verified=false should be denied
   * according to business rules. All tokens should be short-lived access (e.g.,
   * ~20 minutes) with refresh validity (e.g., ~14 days) as per requirements;
   * these time windows are not persisted in the schema but apply to the
   * returned token payload.
   *
   * Related operations: Registration precedes login; token refresh maintains
   * sessions. Session revocation and device lists are out of scope for this
   * schema and are not implemented here.
   *
   * @param connection
   * @param body Login credentials (email or username) and password.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ICommunityPlatformCommunityModeratorLogin.IRequest,
  ): Promise<ICommunityPlatformCommunityModerator.IAuthorized> {
    try {
      return await postAuthCommunityModeratorLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh tokens for communityModerator; verify community_platform_users
   * eligibility and issue new JWTs.
   *
   * Purpose and functionality: Exchanges a valid refresh token for new tokens
   * for a user who may hold moderator responsibilities. The endpoint validates
   * the refresh token and returns a fresh authorized payload. If the token
   * encodes userId, the system may look up community_platform_users to confirm
   * the account is still eligible (e.g., not Banned/Deleted and email_verified
   * true).
   *
   * Implementation details: Because the Prisma schema does not define a
   * refresh-token store, token validation is performed against cryptographic
   * JWT properties and server-managed revocation lists outside of schema scope.
   * The implementation SHOULD verify that deleted_at is null and that
   * account_state does not indicate forbidden states before issuing new tokens.
   * No writes occur to community_platform_users beyond optional updated_at
   * touch.
   *
   * Role-specific integration: This operation serves the member-kind role path
   * for communityModerator but does not alter any moderator assignments in
   * community_platform_community_moderators. It simply maintains the session
   * lifecycle.
   *
   * Security considerations: Rotate access tokens with a lifespan consistent
   * with business requirements (e.g., ~20 minutes) and keep refresh tokens
   * within allowed lifetime (e.g., up to ~14 days). Deny refresh if the account
   * fails checks mapped to email_verified or account_state or if revocation
   * lists indicate invalidation.
   *
   * Related operations: Registration (join) and Login (login) precede refresh.
   * Password changes or security events may cause refresh denial, prompting
   * full re-authentication.
   *
   * @param connection
   * @param body Refresh request containing the current refresh token.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ICommunityPlatformCommunityModeratorRefresh.IRequest,
  ): Promise<ICommunityPlatformCommunityModerator.IAuthorized> {
    try {
      return await postAuthCommunityModeratorRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
