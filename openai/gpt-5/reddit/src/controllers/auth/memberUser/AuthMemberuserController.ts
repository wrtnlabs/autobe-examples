import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthMemberUserJoin } from "../../../providers/postAuthMemberUserJoin";
import { postAuthMemberUserLogin } from "../../../providers/postAuthMemberUserLogin";
import { postAuthMemberUserRefresh } from "../../../providers/postAuthMemberUserRefresh";

import { ICommunityPlatformMemberUser } from "../../../api/structures/ICommunityPlatformMemberUser";

@Controller("/auth/memberUser")
export class AuthMemberuserController {
  /**
   * Register a new member user in Actors.community_platform_users and assign
   * membership in Actors.community_platform_member_users.
   *
   * This endpoint registers a new member account by inserting a user into the
   * Actors.community_platform_users table and associating it with a member role
   * row in Actors.community_platform_member_users. The schema defines email and
   * username as unique, password_hash for non-reversible credential storage,
   * and consent fields terms_accepted_at and privacy_accepted_at that are
   * required for compliance. The email_verified boolean defaults to false until
   * verification flows complete, and account_state is a string used to gate
   * capabilities (e.g., PendingVerification, Active). The created_at and
   * updated_at timestamps must be set, and marketing_opt_in with
   * marketing_opt_in_at can be optionally recorded when applicable.
   *
   * Security-wise, plaintext passwords are never stored; only password_hash is
   * persisted as per the Prisma model comment. The registration flow must
   * respect uniqueness on email and username enforced by @@unique indexes. The
   * new user’s email_verified remains false, and participation features can be
   * gated based on this field together with account_state.
   *
   * This operation relates to the underlying user and membership entities.
   * After creating the user in community_platform_users, a corresponding record
   * in community_platform_member_users should be created to reflect the member
   * role assignment with joined_at and optional status fields. The link is via
   * community_platform_user_id.
   *
   * Validation must ensure required inputs exist and conform to business rules
   * (e.g., email format, username constraints, and password strength prior to
   * hashing). When marketing_opt_in is true, marketing_opt_in_at should be
   * timestamped; otherwise, both can remain false/null respectively. The
   * last_login_at field may remain null until the first successful login
   * event.
   *
   * Error handling should include uniqueness violations on email or username
   * and validation failures. Since this endpoint issues authentication tokens
   * for the new account, ensure tokens are only minted after successful
   * persistence and any required checks against account_state in
   * community_platform_users. The response returns authorized token payload as
   * ICommunityPlatformMemberUser.IAuthorized suitable for immediate
   * authenticated use where policy allows.
   *
   * @param connection
   * @param body Registration payload including identifiers, credentials (to be
   *   hashed), and consent timestamps.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ICommunityPlatformMemberUser.ICreate,
  ): Promise<ICommunityPlatformMemberUser.IAuthorized> {
    try {
      return await postAuthMemberUserJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate a member user against Actors.community_platform_users and
   * issue tokens.
   *
   * This endpoint authenticates an existing account stored in
   * Actors.community_platform_users by verifying the supplied credentials
   * against the password_hash field. The model includes email and username as
   * unique identifiers that can be used for lookup, with password_hash for
   * secure comparison. The account_state string governs permissions and may
   * deny login for states such as Locked, Deactivated, PendingDeletion,
   * Deleted, or Banned based on business rules. The email_verified boolean can
   * also be enforced to restrict certain capabilities until verification is
   * complete.
   *
   * Upon successful authentication, last_login_at should be updated to the
   * current timestamp, and updated_at reflects the modification to the user
   * record. The endpoint must not persist plaintext passwords at any time;
   * password_hash remains the canonical credential store as indicated in the
   * schema comments. If marketing_opt_in or other profile fields exist, they
   * are not changed by this operation.
   *
   * This operation does not create or delete records in related tables. It
   * strictly reads and updates fields in community_platform_users for auditing
   * (last_login_at) and session establishment. Any presence in
   * Actors.community_platform_member_users can be validated if necessary to
   * confirm the user indeed holds the member capability.
   *
   * Error handling includes handling unknown users, invalid credentials, and
   * account_state-based denials. On success, issue JWT tokens and return
   * ICommunityPlatformMemberUser.IAuthorized describing the authenticated
   * session context required for downstream protected operations.
   *
   * @param connection
   * @param body Login credentials identifying the user (email or username) and
   *   the secret to verify.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ICommunityPlatformMemberUser.ILogin,
  ): Promise<ICommunityPlatformMemberUser.IAuthorized> {
    try {
      return await postAuthMemberUserLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh JWT credentials for a member user by validating a refresh token
   * against state in Actors.community_platform_users.
   *
   * This endpoint validates a refresh token to mint new JWT credentials for a
   * member user whose core record lives in Actors.community_platform_users.
   * Before issuing new tokens, the service should re-verify authorization gates
   * derived from account_state (for example, disallow refresh when state
   * reflects Banned, Locked, Deactivated, PendingDeletion, or Deleted) and may
   * consider email_verified when policy requires restricting capabilities for
   * unverified accounts. The updated_at timestamp can be set when appropriate
   * for auditing refresh events, while last_login_at typically remains tied to
   * interactive logins.
   *
   * No schema fields store refresh tokens directly in the provided Prisma
   * models; validation therefore relies on token verification mechanisms
   * external to the schema. The endpoint only reads the user record to ensure
   * eligibility and current state. It does not modify password_hash, email,
   * username, or membership relations.
   *
   * Error handling should include invalid/expired refresh token and state-based
   * denials. On success, return new tokens encapsulated in
   * ICommunityPlatformMemberUser.IAuthorized so the client can continue
   * authorized operations without re-entering credentials.
   *
   * @param connection
   * @param body Refresh request payload carrying the refresh token as required
   *   by the application’s token strategy.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ICommunityPlatformMemberUser.IRefresh,
  ): Promise<ICommunityPlatformMemberUser.IAuthorized> {
    try {
      return await postAuthMemberUserRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
