import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthCommunityOwnerJoin } from "../../../providers/postAuthCommunityOwnerJoin";
import { postAuthCommunityOwnerLogin } from "../../../providers/postAuthCommunityOwnerLogin";
import { postAuthCommunityOwnerRefresh } from "../../../providers/postAuthCommunityOwnerRefresh";

import { ICommunityPlatformCommunityOwner } from "../../../api/structures/ICommunityPlatformCommunityOwner";

@Controller("/auth/communityOwner")
export class AuthCommunityownerController {
  /**
   * Register a community owner in community_platform_users and return
   * ICommunityPlatformCommunityOwner.IAuthorized.
   *
   * This endpoint registers a new account in the community_platform_users table
   * for a future community owner and returns authorization tokens. It uses
   * fields defined on community_platform_users including email (unique primary
   * login identifier), username (unique public handle), and password_hash
   * (non-reversible credential hash). Consent timestamps terms_accepted_at and
   * privacy_accepted_at are required for compliance and must be recorded from
   * user inputs at registration time, while marketing_opt_in and
   * marketing_opt_in_at are optional based on explicit opt-in.
   *
   * On successful registration, email_verified is initialized (typically false)
   * and account_state is set to a lifecycle value such as "PendingVerification"
   * or "Active" aligned with platform policy. last_login_at may be set to the
   * current time after token issuance. created_at and updated_at are
   * system-managed timestamps. The description aligns with schema comments that
   * emphasize unique constraints on email and username and capture of
   * audit-friendly timestamps.
   *
   * Security-wise, this operation is public and does not require prior
   * authentication. It returns initial JWT tokens suitable for the
   * communityOwner authentication context. Although ownership of a specific
   * community is tracked in community_platform_community_owners, this
   * registration focuses solely on identity creation in
   * community_platform_users. The returned
   * ICommunityPlatformCommunityOwner.IAuthorized includes the access/refresh
   * tokens and user identifiers consistent with subsequent protected
   * endpoints.
   *
   * Validation rules enforced mirror the schema: email and username must be
   * unique; password is stored as password_hash; terms_accepted_at and
   * privacy_accepted_at must be present. Account lifecycle values in
   * account_state will govern subsequent capabilities until email_verified
   * transitions to true via the verification flow.
   *
   * Related operations include POST /auth/communityOwner/email/verify to
   * transition email_verified and update account_state, and POST
   * /auth/communityOwner/login for subsequent sign-ins. Error handling covers
   * conflicts on email/username uniqueness and missing required consents.
   *
   * @param connection
   * @param body Registration payload with identifiers, password, and consents.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ICommunityPlatformCommunityOwner.ICreate,
  ): Promise<ICommunityPlatformCommunityOwner.IAuthorized> {
    try {
      return await postAuthCommunityOwnerJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate against community_platform_users and issue communityOwner
   * tokens.
   *
   * This endpoint authenticates a community owner using the core identity table
   * community_platform_users. It validates credentials against password_hash
   * and ensures the account meets required gates such as account_state not
   * being Locked, Deactivated, PendingDeletion, Deleted, or Banned. Where
   * business policy requires, email_verified must be true to gain full
   * participation, which is reflected by the email_verified flag stored on
   * community_platform_users.
   *
   * On successful authentication, last_login_at is updated to the current
   * timestamp, and updated_at is also advanced. The endpoint then returns
   * access/refresh tokens in ICommunityPlatformCommunityOwner.IAuthorized.
   * Unique identifiers like id, username, and email come from
   * community_platform_users; this operation does not interact with community
   * ownership assignment tables such as community_platform_community_owners.
   *
   * Security considerations include rate limiting invalid attempts and
   * returning neutral errors to prevent user enumeration. This is a public
   * authentication endpoint and does not require prior login. Failure modes
   * include invalid credentials, disallowed account_state, or unverified email
   * depending on policy.
   *
   * Complementary operations in this flow include /auth/communityOwner/refresh
   * for token renewal, /auth/communityOwner/email/verify to update
   * email_verified, and /auth/communityOwner/password for credential rotation.
   *
   * @param connection
   * @param body Login credentials (email or username) and password.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ICommunityPlatformCommunityOwner.ILogin,
  ): Promise<ICommunityPlatformCommunityOwner.IAuthorized> {
    try {
      return await postAuthCommunityOwnerLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh access for a community owner after validating
   * community_platform_users state.
   *
   * This endpoint exchanges a valid refresh token for a new authorized session
   * for the community owner. Although no direct writes to
   * community_platform_users are required, the service verifies that the user
   * still exists (id in community_platform_users), is not marked with a
   * disallowing account_state (e.g., Locked, Deactivated, PendingDeletion,
   * Deleted, Banned), and checks current email_verified. These fields originate
   * from the community_platform_users schema, which also records
   * created_at/updated_at timestamps for auditing.
   *
   * Security considerations include revocation checks and rotation semantics
   * for refresh tokens. The endpoint is accessible with a valid refresh token
   * and does not require an active access token. Results return
   * ICommunityPlatformCommunityOwner.IAuthorized to provide updated access
   * credentials consistent with the role.
   *
   * This operation integrates with /auth/communityOwner/login for initial
   * sign-in and can be used after registration via /auth/communityOwner/join if
   * refresh tokens are issued at that time. Error handling encompasses
   * invalid/expired refresh tokens and disqualifying account_state values
   * observed in community_platform_users.
   *
   * @param connection
   * @param body Refresh token exchange payload.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ICommunityPlatformCommunityOwner.IRefresh,
  ): Promise<ICommunityPlatformCommunityOwner.IAuthorized> {
    try {
      return await postAuthCommunityOwnerRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
