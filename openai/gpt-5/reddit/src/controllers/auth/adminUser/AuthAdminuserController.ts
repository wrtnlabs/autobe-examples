import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthAdminUserJoin } from "../../../providers/postAuthAdminUserJoin";
import { postAuthAdminUserLogin } from "../../../providers/postAuthAdminUserLogin";
import { postAuthAdminUserRefresh } from "../../../providers/postAuthAdminUserRefresh";

import { ICommunityPlatformAdminUser } from "../../../api/structures/ICommunityPlatformAdminUser";
import { ICommunityPlatformAdminUserJoin } from "../../../api/structures/ICommunityPlatformAdminUserJoin";
import { ICommunityPlatformAdminUserLogin } from "../../../api/structures/ICommunityPlatformAdminUserLogin";
import { ICommunityPlatformAdminUserRefresh } from "../../../api/structures/ICommunityPlatformAdminUserRefresh";

@Controller("/auth/adminUser")
export class AuthAdminuserController {
  /**
   * Register a new admin (community_platform_users +
   * community_platform_admin_users) and return authorized tokens.
   *
   * This operation registers a new site-wide administrator by creating records
   * in both the community_platform_users and community_platform_admin_users
   * tables.
   *
   * It uses community_platform_users.email and
   * community_platform_users.username as unique identifiers, with collisions
   * prevented by @@unique constraints. Credentials are stored only as
   * community_platform_users.password_hash, and no plaintext password is kept.
   * Consent timestamps are recorded in
   * community_platform_users.terms_accepted_at and
   * community_platform_users.privacy_accepted_at, satisfying compliance and
   * audit requirements noted in the schema.
   *
   * The account lifecycle is initialized using
   * community_platform_users.account_state (for example, "PendingVerification")
   * in combination with community_platform_users.email_verified. Optional
   * marketing preferences are captured using
   * community_platform_users.marketing_opt_in and
   * community_platform_users.marketing_opt_in_at. Auditing fields
   * community_platform_users.created_at, community_platform_users.updated_at,
   * and optionally community_platform_users.last_login_at are set appropriately
   * during provisioning.
   *
   * Admin privileges are granted by inserting a row into
   * community_platform_admin_users, linking via
   * community_platform_admin_users.community_platform_user_id and setting
   * community_platform_admin_users.granted_at to the current timestamp. The
   * relationship ensures global administrative capabilities as required by the
   * business role while maintaining historical grant/revoke data using
   * community_platform_admin_users.revoked_at when needed later.
   *
   * Upon success, the service issues JWT tokens for the newly created admin.
   * The response structure returns an authorized session aligned to
   * ICommunityPlatformAdminUser.IAuthorized and may include claims derived from
   * the user’s id and role assignment. Errors include uniqueness violations
   * (email/username), invalid credential policy, or missing consents. The
   * operation does not interact with logically deleted rows (deleted_at); it
   * always creates a new user.
   *
   * @param connection
   * @param body Admin registration payload with identifiers, password, and
   *   consent timestamps.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ICommunityPlatformAdminUserJoin.ICreate,
  ): Promise<ICommunityPlatformAdminUser.IAuthorized> {
    try {
      return await postAuthAdminUserJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate an admin user (community_platform_users) and return authorized
   * tokens.
   *
   * This login operation verifies administrator credentials against the
   * community_platform_users table and confirms active admin assignment via
   * community_platform_admin_users.
   *
   * User identification uses community_platform_users.email or
   * community_platform_users.username, with credential verification against
   * community_platform_users.password_hash. The account must be eligible for
   * authentication based on community_platform_users.account_state (e.g., not
   * Locked, Deactivated, PendingDeletion, Deleted, or Banned) and
   * community_platform_users.email_verified where gating is required by
   * policy.
   *
   * On successful authentication, the service updates
   * community_platform_users.last_login_at and
   * community_platform_users.updated_at to reflect the login event. It also
   * verifies that at least one active admin assignment exists in
   * community_platform_admin_users for the user, using
   * community_platform_admin_users.community_platform_user_id and ensuring
   * community_platform_admin_users.revoked_at is null when applicable.
   *
   * No new records are created by this action, and no archival fields are
   * modified beyond timestamp updates on the user. The operation then issues
   * JWT tokens containing claims necessary for authorization decisions.
   *
   * If the credentials are invalid or the account state is not eligible, the
   * provider returns a business error. Uniqueness constraints (email/username)
   * are not changed during login. The returned payload follows
   * ICommunityPlatformAdminUser.IAuthorized to convey authorized session
   * details.
   *
   * @param connection
   * @param body Admin login payload with email or username and password.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ICommunityPlatformAdminUserLogin.ICreate,
  ): Promise<ICommunityPlatformAdminUser.IAuthorized> {
    try {
      return await postAuthAdminUserLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh admin session tokens (validate against community_platform_users and
   * community_platform_admin_users).
   *
   * This operation renews an administrator’s session using a valid refresh
   * token. It uses the user identifier conveyed in token claims to load the
   * matching row from community_platform_users and confirms that the user still
   * holds an active admin grant via community_platform_admin_users.
   *
   * If the user is found and still eligible (based on
   * community_platform_users.account_state and email gating via
   * community_platform_users.email_verified where applicable), the provider
   * issues fresh access/refresh tokens and may update
   * community_platform_users.updated_at. The community_platform_admin_users
   * table is not changed by this operation; its grant metadata (granted_at,
   * revoked_at) is only read to ensure the admin role remains valid.
   *
   * No new rows are created, and no logical deletion timestamps are modified.
   * The operation focuses strictly on token lifecycle and authorization
   * continuity for administrators.
   *
   * On failures (expired/invalid refresh token or revoked admin status), the
   * operation returns a business error. The response schema is
   * ICommunityPlatformAdminUser.IAuthorized to deliver the renewed
   * authorization context.
   *
   * @param connection
   * @param body Refresh token exchange payload.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ICommunityPlatformAdminUserRefresh.ICreate,
  ): Promise<ICommunityPlatformAdminUser.IAuthorized> {
    try {
      return await postAuthAdminUserRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
