{"operations":[{"specification":"Create a public authentication endpoint for guest users to receive an initial JWT authorization package without credential-based login. This operation is associated with the Prisma DB tables Actors.community_platform_users and Actors.community_platform_guest_users. It will create a user identity row in community_platform_users (id, email, username, password_hash, email_verified, account_state, terms_accepted_at, privacy_accepted_at, marketing_opt_in/marketing_opt_in_at, last_login_at, created_at, updated_at) and a guest role assignment row in community_platform_guest_users (id, community_platform_user_id, granted_at, revoked_at, created_at, updated_at). The endpoint issues tokens upon successful creation and assignment, aligning with the business requirement that guests do not log in with credentials but may obtain temporary access tokens.\n\nThe request body references a DTO that provides registration inputs necessary to satisfy the required non-null columns on community_platform_users (e.g., email, username, and Terms/Privacy acceptance timestamps), while the server will derive password_hash and initial account_state as appropriate for a guest session. The response body returns an authorized payload type ICommunityPlatformGuestUser.IAuthorized containing access/refresh tokens and the minimal user context consistent with role resolution.\n\nThis operation ties directly to business rules: unique email (community_platform_users.email) and unique username (community_platform_users.username) must be enforced; email_verified determines participation gating; account_state governs capability constraints; and the guest role is recorded in community_platform_guest_users with granted_at for audit. The join endpoint must be idempotent when the same email/username is re-submitted according to policy (e.g., conflict vs. reuse), and must record last_login_at on issuance to support security notifications.\n\nSecurity considerations: no prior authentication is required; inputs are validated against platform constraints; tokens must respect session durations defined at service level; and audit trails should capture creation and role grant events. Related operations: /auth/guestUser/refresh for token renewal. Prisma indices and constraints (unique on email and username) shape error behavior on duplicates.","authorizationType":"join","description":"This public endpoint provisions a guest-capable identity and immediately assigns the guest designation using the Actors schema. It inserts into community_platform_users with required columns including email, username, password_hash (derived by the server), email_verified, account_state, terms_accepted_at, privacy_accepted_at, and timestamps such as created_at and updated_at. Optional fields like display_name, avatar_uri, and marketing_opt_in/marketing_opt_in_at are handled per submitted data and policy. The server should set last_login_at upon successful token issuance to support account activity auditing.\n\nGuest role assignment is persisted in community_platform_guest_users by linking the newly created community_platform_users.id into community_platform_guest_users.community_platform_user_id and stamping granted_at. Lifecycle fields revoked_at and deleted_at in role tables are reserved for future transitions; they are not manipulated by this operation. Business uniqueness on community_platform_users.email and community_platform_users.username determines conflict handling during registration.\n\nWithin platform security rules, email_verified and account_state (e.g., PendingVerification vs Active) gate participation in later flows. Even as a guest, issuance of tokens must honor session limits, and refresh is handled by the companion /auth/guestUser/refresh. All timestamps are stored as Timestamptz per schema (e.g., terms_accepted_at, privacy_accepted_at) to support localization and audit requirements.\n\nValidation observes the schema comments: the password_hash is stored non-reversibly; plaintext passwords are never persisted. Since guests do not perform a credentials login, servers can generate a secure password_hash internally to satisfy the non-null column while still enforcing Terms/Privacy acceptance. The request must collect required registration inputs to satisfy non-null constraints and policy, including unique identifiers, while the response returns an authorization payload type.\n\nRelated operations include token refresh using the same role and audit of last_login_at updates in community_platform_users. Error behavior is shaped by database constraints and business checks on uniqueness and consent timestamps; violations should return clear messages aligned with the exception model.","summary":"Register a guest-capable identity and assign guest role using community_platform_users and community_platform_guest_users.","parameters":[],"requestBody":{"description":"Guest registration inputs sufficient to create community_platform_users and record Terms/Privacy acceptance; server may derive password_hash and initial account_state.","typeName":"ICommunityPlatformGuestUser.IJoin"},"responseBody":{"description":"Authorized session payload for a newly registered guest user with access and refresh tokens.","typeName":"ICommunityPlatformGuestUser.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/guestUser/join","method":"post"},{"specification":"Create a public token refresh endpoint for guest users to renew JWT access using a valid refresh token. This operation primarily interacts with Actors.community_platform_users by updating last_login_at to reflect renewed activity and validating that the underlying account_state and email_verified values allow continued access. It also respects any guest role assignment recorded in Actors.community_platform_guest_users to ensure the user is still designated as a guest (revoked_at must be null for an active designation).\n\nThe request body references a DTO containing the refresh token and device context as needed by the service. The response returns ICommunityPlatformGuestUser.IAuthorized with a new access token (and possibly a rotated refresh token) per session policy. This endpoint does not require prior standard authentication but requires a valid refresh token per the platform’s session and device management rules.\n\nSecurity and compliance considerations: issue tokens honoring configured expirations; rotate refresh tokens when appropriate; record last_login_at in community_platform_users and update updated_at to reflect activity. If account_state indicates Locked, Deactivated, PendingDeletion, Deleted, or Banned, the refresh must be denied. The endpoint should be resilient to token replay attempts according to device/session revocation policies.","authorizationType":"refresh","description":"This endpoint renews guest session tokens by validating an incoming refresh token and returning a fresh authorization bundle. It relies on the Actors tables: community_platform_users for identity status (email_verified, account_state, last_login_at, updated_at) and community_platform_guest_users to ensure the guest designation remains current (revoked_at not set). No credential validation occurs because guests do not log in; instead, refresh relies on token validity and any device/session checks the service enforces.\n\nUpon success, the provider updates community_platform_users.last_login_at for audit and sets updated_at. If the backing user’s account_state is incompatible (e.g., Locked or Banned), the provider denies refresh. All timestamps are recorded using Timestamptz per schema guidance. Business rules around token lifetimes (access vs refresh) and rotation are applied consistently.\n\nRelated operations include /auth/guestUser/join to obtain the initial authorization. Error outcomes follow unique constraint or state validations: invalid/expired refresh token, revoked session, or disallowed account_state. This operation does not modify role assignment records; it only validates their current state.","summary":"Refresh guest tokens validating community_platform_users state and guest assignment in community_platform_guest_users.","parameters":[],"requestBody":{"description":"Refresh token inputs for renewing guest authorization.","typeName":"ICommunityPlatformGuestUser.IRefresh"},"responseBody":{"description":"Authorized session payload with renewed access (and possibly rotated refresh) tokens for a guest user.","typeName":"ICommunityPlatformGuestUser.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/guestUser/refresh","method":"post"},{"specification":"Create registration endpoint for member users of communityPlatform. This operation creates a new record in Actors.community_platform_users and an accompanying membership record in Actors.community_platform_member_users. Required inputs align with schema fields: email (unique), username (unique), and a credential that will be stored only as password_hash. It will also persist consent timestamps into terms_accepted_at and privacy_accepted_at, optionally record marketing_opt_in and marketing_opt_in_at, initialize email_verified to false, set account_state to a registration-appropriate value (e.g., PendingVerification), and set created_at/updated_at. On success, issue JWT credentials appropriate for a newly registered member user and return them as an authorized payload. This endpoint does not expose or store plaintext passwords; only password_hash is stored per schema comments. The operation is public and does not require prior authentication.\n\nPrisma tables involved and referenced by behavior: community_platform_users (core user identity, credentials, account lifecycle and consent timestamps) and community_platform_member_users (member role assignment with joined_at and optional status). Unique constraints exist on email and username. The system should set last_login_at at the first authenticated session creation moment if desired by business rules, but that timestamp is optional at registration. No deletion behavior occurs here; deleted_at is not touched.\n\nReturned response matches ICommunityPlatformMemberUser.IAuthorized, representing access/refresh tokens and the authenticated principal info required by downstream protected endpoints.","authorizationType":"join","description":"This endpoint registers a new member account by inserting a user into the Actors.community_platform_users table and associating it with a member role row in Actors.community_platform_member_users. The schema defines email and username as unique, password_hash for non-reversible credential storage, and consent fields terms_accepted_at and privacy_accepted_at that are required for compliance. The email_verified boolean defaults to false until verification flows complete, and account_state is a string used to gate capabilities (e.g., PendingVerification, Active). The created_at and updated_at timestamps must be set, and marketing_opt_in with marketing_opt_in_at can be optionally recorded when applicable.\n\nSecurity-wise, plaintext passwords are never stored; only password_hash is persisted as per the Prisma model comment. The registration flow must respect uniqueness on email and username enforced by @@unique indexes. The new user’s email_verified remains false, and participation features can be gated based on this field together with account_state.\n\nThis operation relates to the underlying user and membership entities. After creating the user in community_platform_users, a corresponding record in community_platform_member_users should be created to reflect the member role assignment with joined_at and optional status fields. The link is via community_platform_user_id.\n\nValidation must ensure required inputs exist and conform to business rules (e.g., email format, username constraints, and password strength prior to hashing). When marketing_opt_in is true, marketing_opt_in_at should be timestamped; otherwise, both can remain false/null respectively. The last_login_at field may remain null until the first successful login event.\n\nError handling should include uniqueness violations on email or username and validation failures. Since this endpoint issues authentication tokens for the new account, ensure tokens are only minted after successful persistence and any required checks against account_state in community_platform_users. The response returns authorized token payload as ICommunityPlatformMemberUser.IAuthorized suitable for immediate authenticated use where policy allows.","summary":"Register a new member user in Actors.community_platform_users and assign membership in Actors.community_platform_member_users.","parameters":[],"requestBody":{"description":"Registration payload including identifiers, credentials (to be hashed), and consent timestamps.","typeName":"ICommunityPlatformMemberUser.ICreate"},"responseBody":{"description":"Authorized session payload for the newly registered member user, including issued tokens and principal info.","typeName":"ICommunityPlatformMemberUser.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/memberUser/join","method":"post"},{"specification":"Create login endpoint for member users of communityPlatform. This operation authenticates against Actors.community_platform_users by locating a user via either email or username and verifying the provided credential against the stored password_hash. It validates account_state (e.g., should not be Locked, Deactivated, PendingDeletion, Deleted, or Banned for standard login) and can enforce email_verified checks per business policy. On successful authentication, it updates last_login_at, and issues JWT access/refresh tokens returned as an authorized payload. This is a public endpoint; it requires credentials but not a prior session.\n\nPrimary Prisma table: community_platform_users for identity, password_hash, email_verified, account_state, last_login_at, and updated_at. No write occurs to role tables during login beyond optional membership checks present in community_platform_member_users, but applications may assert membership existence. No removal or archival states are modified here.","authorizationType":"login","description":"This endpoint authenticates an existing account stored in Actors.community_platform_users by verifying the supplied credentials against the password_hash field. The model includes email and username as unique identifiers that can be used for lookup, with password_hash for secure comparison. The account_state string governs permissions and may deny login for states such as Locked, Deactivated, PendingDeletion, Deleted, or Banned based on business rules. The email_verified boolean can also be enforced to restrict certain capabilities until verification is complete.\n\nUpon successful authentication, last_login_at should be updated to the current timestamp, and updated_at reflects the modification to the user record. The endpoint must not persist plaintext passwords at any time; password_hash remains the canonical credential store as indicated in the schema comments. If marketing_opt_in or other profile fields exist, they are not changed by this operation.\n\nThis operation does not create or delete records in related tables. It strictly reads and updates fields in community_platform_users for auditing (last_login_at) and session establishment. Any presence in Actors.community_platform_member_users can be validated if necessary to confirm the user indeed holds the member capability.\n\nError handling includes handling unknown users, invalid credentials, and account_state-based denials. On success, issue JWT tokens and return ICommunityPlatformMemberUser.IAuthorized describing the authenticated session context required for downstream protected operations.","summary":"Authenticate a member user against Actors.community_platform_users and issue tokens.","parameters":[],"requestBody":{"description":"Login credentials identifying the user (email or username) and the secret to verify.","typeName":"ICommunityPlatformMemberUser.ILogin"},"responseBody":{"description":"Authorized session payload for the authenticated member user, with issued tokens and principal claims.","typeName":"ICommunityPlatformMemberUser.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/memberUser/login","method":"post"},{"specification":"Create refresh endpoint for member users of communityPlatform. This operation accepts a refresh token and, if valid, issues new JWT access/refresh tokens for the same principal represented in Actors.community_platform_users. It rechecks current account_state and email_verified before issuing new tokens, ensuring the user has not transitioned into restricted states since the previous session. It does not require an active access token, only a valid refresh token presented per application policy (e.g., cookie or body parameter). This endpoint is public in the sense of not requiring an existing access token; however, it requires a valid refresh token to proceed.\n\nPrimary Prisma table: community_platform_users for identity, account_state, email_verified, updated_at, and possible audit fields. No writes to role tables occur during refresh. The endpoint returns a new ICommunityPlatformMemberUser.IAuthorized payload on success.","authorizationType":"refresh","description":"This endpoint validates a refresh token to mint new JWT credentials for a member user whose core record lives in Actors.community_platform_users. Before issuing new tokens, the service should re-verify authorization gates derived from account_state (for example, disallow refresh when state reflects Banned, Locked, Deactivated, PendingDeletion, or Deleted) and may consider email_verified when policy requires restricting capabilities for unverified accounts. The updated_at timestamp can be set when appropriate for auditing refresh events, while last_login_at typically remains tied to interactive logins.\n\nNo schema fields store refresh tokens directly in the provided Prisma models; validation therefore relies on token verification mechanisms external to the schema. The endpoint only reads the user record to ensure eligibility and current state. It does not modify password_hash, email, username, or membership relations.\n\nError handling should include invalid/expired refresh token and state-based denials. On success, return new tokens encapsulated in ICommunityPlatformMemberUser.IAuthorized so the client can continue authorized operations without re-entering credentials.","summary":"Refresh JWT credentials for a member user by validating a refresh token against state in Actors.community_platform_users.","parameters":[],"requestBody":{"description":"Refresh request payload carrying the refresh token as required by the application’s token strategy.","typeName":"ICommunityPlatformMemberUser.IRefresh"},"responseBody":{"description":"Authorized session payload with newly issued tokens for the same principal.","typeName":"ICommunityPlatformMemberUser.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/memberUser/refresh","method":"post"},{"specification":"Design an authentication registration (join) endpoint for community owners. This operation creates a new row in the core identity table community_platform_users and immediately assigns the user the member capabilities suitable for owning communities in subsequent workflows (ownership itself is managed by community_platform_community_owners, not by this call). The request will collect minimal credentials and consents required by the schema: email (unique), username (unique), and a password that will be stored as password_hash. It will also capture terms_accepted_at and privacy_accepted_at timestamps, and optionally marketing_opt_in with marketing_opt_in_at. Email verification state (email_verified) will be initialized per business policy and account_state set accordingly (e.g., PendingVerification or Active). The endpoint will issue JWTs upon successful creation to authorize further actions as a communityOwner role. Response uses ICommunityPlatformCommunityOwner.IAuthorized to provide tokens and profile basics.","authorizationType":"join","description":"This endpoint registers a new account in the community_platform_users table for a future community owner and returns authorization tokens. It uses fields defined on community_platform_users including email (unique primary login identifier), username (unique public handle), and password_hash (non-reversible credential hash). Consent timestamps terms_accepted_at and privacy_accepted_at are required for compliance and must be recorded from user inputs at registration time, while marketing_opt_in and marketing_opt_in_at are optional based on explicit opt-in.\n\nOn successful registration, email_verified is initialized (typically false) and account_state is set to a lifecycle value such as \"PendingVerification\" or \"Active\" aligned with platform policy. last_login_at may be set to the current time after token issuance. created_at and updated_at are system-managed timestamps. The description aligns with schema comments that emphasize unique constraints on email and username and capture of audit-friendly timestamps.\n\nSecurity-wise, this operation is public and does not require prior authentication. It returns initial JWT tokens suitable for the communityOwner authentication context. Although ownership of a specific community is tracked in community_platform_community_owners, this registration focuses solely on identity creation in community_platform_users. The returned ICommunityPlatformCommunityOwner.IAuthorized includes the access/refresh tokens and user identifiers consistent with subsequent protected endpoints.\n\nValidation rules enforced mirror the schema: email and username must be unique; password is stored as password_hash; terms_accepted_at and privacy_accepted_at must be present. Account lifecycle values in account_state will govern subsequent capabilities until email_verified transitions to true via the verification flow.\n\nRelated operations include POST /auth/communityOwner/email/verify to transition email_verified and update account_state, and POST /auth/communityOwner/login for subsequent sign-ins. Error handling covers conflicts on email/username uniqueness and missing required consents.","summary":"Register a community owner in community_platform_users and return ICommunityPlatformCommunityOwner.IAuthorized.","parameters":[],"requestBody":{"description":"Registration payload with identifiers, password, and consents.","typeName":"ICommunityPlatformCommunityOwner.ICreate"},"responseBody":{"description":"Authorization result with tokens and user context for communityOwner.","typeName":"ICommunityPlatformCommunityOwner.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/communityOwner/join","method":"post"},{"specification":"Design a login endpoint for community owners authenticating against community_platform_users. The operation accepts either email or username plus password, validates against password_hash, and enforces account lifecycle gates using account_state and email_verified. On success, it updates last_login_at and issues fresh JWTs for the communityOwner context. Response uses ICommunityPlatformCommunityOwner.IAuthorized.","authorizationType":"login","description":"This endpoint authenticates a community owner using the core identity table community_platform_users. It validates credentials against password_hash and ensures the account meets required gates such as account_state not being Locked, Deactivated, PendingDeletion, Deleted, or Banned. Where business policy requires, email_verified must be true to gain full participation, which is reflected by the email_verified flag stored on community_platform_users.\n\nOn successful authentication, last_login_at is updated to the current timestamp, and updated_at is also advanced. The endpoint then returns access/refresh tokens in ICommunityPlatformCommunityOwner.IAuthorized. Unique identifiers like id, username, and email come from community_platform_users; this operation does not interact with community ownership assignment tables such as community_platform_community_owners.\n\nSecurity considerations include rate limiting invalid attempts and returning neutral errors to prevent user enumeration. This is a public authentication endpoint and does not require prior login. Failure modes include invalid credentials, disallowed account_state, or unverified email depending on policy.\n\nComplementary operations in this flow include /auth/communityOwner/refresh for token renewal, /auth/communityOwner/email/verify to update email_verified, and /auth/communityOwner/password for credential rotation.","summary":"Authenticate against community_platform_users and issue communityOwner tokens.","parameters":[],"requestBody":{"description":"Login credentials (email or username) and password.","typeName":"ICommunityPlatformCommunityOwner.ILogin"},"responseBody":{"description":"Authorized session info (access/refresh tokens, subject identifiers).","typeName":"ICommunityPlatformCommunityOwner.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/communityOwner/login","method":"post"},{"specification":"Design a token refresh endpoint for community owners that renews short-lived access tokens using a valid refresh token. The endpoint does not modify database tables directly but must confirm that the underlying subject in community_platform_users is still valid (e.g., not Locked/Deactivated/Banned/Deleted) and reflect current flags such as email_verified and account_state when issuing new tokens. Response uses ICommunityPlatformCommunityOwner.IAuthorized.","authorizationType":"refresh","description":"This endpoint exchanges a valid refresh token for a new authorized session for the community owner. Although no direct writes to community_platform_users are required, the service verifies that the user still exists (id in community_platform_users), is not marked with a disallowing account_state (e.g., Locked, Deactivated, PendingDeletion, Deleted, Banned), and checks current email_verified. These fields originate from the community_platform_users schema, which also records created_at/updated_at timestamps for auditing.\n\nSecurity considerations include revocation checks and rotation semantics for refresh tokens. The endpoint is accessible with a valid refresh token and does not require an active access token. Results return ICommunityPlatformCommunityOwner.IAuthorized to provide updated access credentials consistent with the role.\n\nThis operation integrates with /auth/communityOwner/login for initial sign-in and can be used after registration via /auth/communityOwner/join if refresh tokens are issued at that time. Error handling encompasses invalid/expired refresh tokens and disqualifying account_state values observed in community_platform_users.","summary":"Refresh access for a community owner after validating community_platform_users state.","parameters":[],"requestBody":{"description":"Refresh token exchange payload.","typeName":"ICommunityPlatformCommunityOwner.IRefresh"},"responseBody":{"description":"Newly authorized tokens and subject context.","typeName":"ICommunityPlatformCommunityOwner.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/communityOwner/refresh","method":"post"},{"specification":"Design an email verification confirmation endpoint for community owners to transition the user’s email_verified flag and possibly adjust account_state in community_platform_users. This endpoint accepts a verification token (implementation-specific) and, upon successful validation, updates email_verified to true and sets account_state (e.g., Active) according to business rules. Returns updated authorization context so the user can proceed without re-login.","authorizationType":null,"description":"This endpoint finalizes email verification by updating community_platform_users.email_verified to true and, where applicable, transitioning community_platform_users.account_state from values like \"PendingVerification\" to an allowed state such as \"Active\". These fields are explicitly defined on community_platform_users and control participation eligibility elsewhere on the platform.\n\nThe request supplies a verification artifact that the service validates out-of-band (token storage is implementation-specific and not modeled in the schema). Upon success, the server updates updated_at, may set last_login_at if a session is resumed, and returns fresh tokens to streamline the onboarding flow. The operation ties directly into the registration and login lifecycle documented in the business requirements.\n\nSecurity considerations include one-time use and short-lived verification artifacts, throttling resends, and neutral error messages that avoid user enumeration. Failures include invalid or expired verification artifacts, or records not found in community_platform_users.\n\nUse this endpoint after POST /auth/communityOwner/join when email_verified is false, or when a user re-requests verification. Related flows include POST /auth/communityOwner/login and POST /auth/communityOwner/refresh.","summary":"Confirm email for a community owner by setting community_platform_users.email_verified and adjusting account_state.","parameters":[],"requestBody":{"description":"Verification payload containing the verification artifact.","typeName":"ICommunityPlatformCommunityOwner.IVerifyEmail"},"responseBody":{"description":"Authorized result after verification to continue as communityOwner.","typeName":"ICommunityPlatformCommunityOwner.IAuthorized"},"authorizationRole":null,"name":"verifyEmail","prerequisites":[],"path":"/auth/communityOwner/email/verify","method":"post"},{"specification":"Design a password change endpoint for authenticated community owners. This endpoint validates the current password against community_platform_users.password_hash, and upon success, replaces it with a new hash. It updates updated_at and may update last_login_at depending on policy. This is a security operation requiring an authenticated user context and does not alter ownership assignments.","authorizationType":null,"description":"This operation allows a logged-in community owner to rotate credentials by updating community_platform_users.password_hash with a hash of the new password. The request includes the current password for verification and a new password; the service compares against password_hash stored on community_platform_users. On success, updated_at is advanced, and security policies may also update last_login_at to reflect credential rotation.\n\nAccess is restricted to authenticated users in the communityOwner role. The endpoint does not interact with role assignment tables like community_platform_community_owners; it strictly operates on the core identity in community_platform_users. This aligns with schema comments emphasizing non-reversible password hashes and audit timestamps created_at/updated_at.\n\nError handling includes invalid current password, missing new password, or disallowed account_state (e.g., Locked/Deactivated). Pair this operation with /auth/communityOwner/login for sign-in and /auth/communityOwner/refresh for session renewal post-rotation.","summary":"Change password by updating community_platform_users.password_hash for the authenticated community owner.","parameters":[],"requestBody":{"description":"Current and new password values for rotation.","typeName":"ICommunityPlatformCommunityOwner.IChangePassword"},"responseBody":{"description":"Updated authentication context after password change (tokens may be rotated).","typeName":"ICommunityPlatformCommunityOwner.IAuthorized"},"authorizationRole":"communityOwner","name":"changePassword","prerequisites":[],"path":"/auth/communityOwner/password","method":"put"},{"specification":"Create the communityModerator registration endpoint scoped to the member-kind role. This operation will create a new platform user in the Actors schema table community_platform_users and initialize member capabilities in community_platform_member_users. It must capture registration inputs that map to the Prisma columns: email (unique), username (unique), password hashed into password_hash, email_verified initially false, account_state initially set to a registration-appropriate state such as \"PendingVerification\" as a string in account_state, terms_accepted_at and privacy_accepted_at timestamps, and optional marketing_opt_in plus marketing_opt_in_at. The controller will also set created_at/updated_at and must not set deleted_at. No community-level moderator assignment is created here; community_platform_community_moderators is managed by community owners later. The response returns an authorized session payload (JWT-based) appropriate for a newly joined member-kind role.","authorizationType":"join","description":"Purpose and functionality: Registers a new platform user intending to become a community moderator later by community assignment. The operation inserts a row into Actors.community_platform_users with required unique identifiers email and username, storing the credential as password_hash. It records compliance timestamps (terms_accepted_at, privacy_accepted_at) and optional marketing_opt_in/marketing_opt_in_at exactly as modeled. The initial flags email_verified (Boolean) and account_state (String) are set according to onboarding flow described in requirements (e.g., account_state may be \"PendingVerification\" until email verification succeeds). created_at and updated_at are set to current timestamps.\n\nImplementation details and validations: Enforce database-level uniqueness of email and username (per @@unique) and validate password before hashing into password_hash. Do not write to deleted_at. If business logic enables member capabilities at join, insert a corresponding row into Actors.community_platform_member_users with community_platform_user_id referencing the created user and joined_at set to now; status may be null or a workflow-specific String. No entries are written to community_platform_community_moderators because moderator privileges are granted by owners later per schema comments.\n\nRole-specific integration: Although the path is /auth/communityModerator/join, this endpoint creates a general user (community_platform_users) and optionally the member linkage (community_platform_member_users). Moderator scope is community-specific and realized subsequently through community_platform_community_moderators. This aligns with the role being of kind \"member\" in the permission model.\n\nSecurity considerations: Passwords are never stored in plaintext—only as password_hash. email_verified remains false until a separate verification succeeds. account_state governs capabilities (e.g., PendingVerification vs Active) and maps to the String column. Audit fields like last_login_at are untouched at join; they will be updated on login. Soft deletion via deleted_at is not used here.\n\nRelated operations and workflow: Typical flows call login after successful verification, and token refresh to maintain sessions. Community moderator assignment is done by community owners using community_platform_community_moderators and is not part of this endpoint. Error cases should reflect uniqueness violations and invalid registration data as per the exception model.","summary":"Register a user (future community moderator) using community_platform_users and initialize community_platform_member_users.","parameters":[],"requestBody":{"description":"Registration payload with email, username, password, terms/privacy consent, and optional marketing consent.","typeName":"ICommunityPlatformCommunityModeratorJoin.ICreate"},"responseBody":{"description":"Authorized session payload for the communityModerator role on successful registration.","typeName":"ICommunityPlatformCommunityModerator.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/communityModerator/join","method":"post"},{"specification":"Authenticate a community moderator (member-kind role) using credentials stored in Actors.community_platform_users. The operation validates the supplied email or username against unique columns email/username and verifies the supplied password against password_hash. It checks email_verified (Boolean) and account_state (String) to ensure eligibility (e.g., Active), then issues JWT tokens. On success, update last_login_at and updated_at on community_platform_users. This operation does not modify community_platform_community_moderators; moderator scope is managed elsewhere.","authorizationType":"login","description":"Purpose and functionality: Authenticates a user who may hold moderator responsibilities. It queries community_platform_users by email or username (both unique) and validates the credential against password_hash. If the account is eligible (e.g., email_verified is true and account_state indicates an allowed state like \"Active\"), the endpoint issues access/refresh tokens per session policy and returns an authorized payload.\n\nImplementation details: On successful login, set last_login_at to current time and update updated_at. Respect the soft deletion model by rejecting users where deleted_at is non-null. The controller must treat account_state and email_verified exactly as persisted Boolean/String flags and must not mutate terms_accepted_at, privacy_accepted_at, or marketing_opt_in fields during login. No write is performed to community_platform_member_users or community_platform_community_moderators by this endpoint.\n\nRole-specific integration: Although this uses the communityModerator path, the underlying identity remains the user row in community_platform_users with optional membership record in community_platform_member_users. Any moderator privileges are scoped per community via community_platform_community_moderators and are orthogonal to authentication.\n\nSecurity considerations: Enforce indistinguishable failure messages to prevent user enumeration. Passwords are handled via password_hash comparison. Accounts with account_state indicating Locked/Deactivated/Banned or with email_verified=false should be denied according to business rules. All tokens should be short-lived access (e.g., ~20 minutes) with refresh validity (e.g., ~14 days) as per requirements; these time windows are not persisted in the schema but apply to the returned token payload.\n\nRelated operations: Registration precedes login; token refresh maintains sessions. Session revocation and device lists are out of scope for this schema and are not implemented here.","summary":"Login a community moderator using community_platform_users (password_hash, email/username) and update last_login_at.","parameters":[],"requestBody":{"description":"Login credentials (email or username) and password.","typeName":"ICommunityPlatformCommunityModeratorLogin.IRequest"},"responseBody":{"description":"Authorized session payload with access/refresh tokens for the communityModerator role.","typeName":"ICommunityPlatformCommunityModerator.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/communityModerator/login","method":"post"},{"specification":"Refresh JWT tokens for a community moderator using a valid refresh token. No database table is required to persist refresh tokens in the provided schema; the operation validates the refresh token and re-issues tokens. It references Actors.community_platform_users only to load the current account_state/email_verified if needed and to ensure the user has not been soft-deleted (deleted_at is null).","authorizationType":"refresh","description":"Purpose and functionality: Exchanges a valid refresh token for new tokens for a user who may hold moderator responsibilities. The endpoint validates the refresh token and returns a fresh authorized payload. If the token encodes userId, the system may look up community_platform_users to confirm the account is still eligible (e.g., not Banned/Deleted and email_verified true).\n\nImplementation details: Because the Prisma schema does not define a refresh-token store, token validation is performed against cryptographic JWT properties and server-managed revocation lists outside of schema scope. The implementation SHOULD verify that deleted_at is null and that account_state does not indicate forbidden states before issuing new tokens. No writes occur to community_platform_users beyond optional updated_at touch.\n\nRole-specific integration: This operation serves the member-kind role path for communityModerator but does not alter any moderator assignments in community_platform_community_moderators. It simply maintains the session lifecycle.\n\nSecurity considerations: Rotate access tokens with a lifespan consistent with business requirements (e.g., ~20 minutes) and keep refresh tokens within allowed lifetime (e.g., up to ~14 days). Deny refresh if the account fails checks mapped to email_verified or account_state or if revocation lists indicate invalidation.\n\nRelated operations: Registration (join) and Login (login) precede refresh. Password changes or security events may cause refresh denial, prompting full re-authentication.","summary":"Refresh tokens for communityModerator; verify community_platform_users eligibility and issue new JWTs.","parameters":[],"requestBody":{"description":"Refresh request containing the current refresh token.","typeName":"ICommunityPlatformCommunityModeratorRefresh.IRequest"},"responseBody":{"description":"New authorized session payload with rotated tokens.","typeName":"ICommunityPlatformCommunityModerator.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/communityModerator/refresh","method":"post"},{"specification":"Allow an authenticated community moderator (member-kind) to change their password by updating password_hash in Actors.community_platform_users. This operation targets the caller’s own account (special-case \"/my/\" scope). It requires the current password for verification and a compliant new password. On success, update updated_at and rotate tokens in the response if desired by policy. Does not modify any role assignment tables (e.g., community_platform_community_moderators).","authorizationType":null,"description":"Purpose and functionality: Enables a logged-in user to change their password securely. The implementation verifies the current credential against password_hash in community_platform_users, and on success, replaces password_hash with the new value. The endpoint also updates updated_at and may rotate tokens for continued access, aligning with security guidance.\n\nImplementation details: The only persisted fields affected are password_hash and updated_at on community_platform_users. last_login_at is not necessarily modified by a password change. No changes are made to email_verified, account_state, terms_accepted_at, privacy_accepted_at, or marketing_opt_in fields. Soft deletion (deleted_at) must be null to proceed.\n\nRole-specific integration and business context: The caller holds communityModerator capabilities in specific communities via community_platform_community_moderators; password changes do not affect those assignments. This is a self-scope operation and therefore uses a \"/my/\" path. The user remains a member-kind user.\n\nSecurity considerations: Require the current password and validate against password_hash; enforce password strength; on success, consider revoking other sessions and rotating tokens per policy. Avoid leaking whether an account exists to other parties. Ensure audit coverage through external logging consistent with non-functional requirements.\n\nRelated operations: Users may need to re-login or refresh tokens post-change. Password reset via emailed one-time links is intentionally omitted because no reset-token persistence exists in the provided schema.","summary":"Change own password by updating password_hash in community_platform_users for the authenticated communityModerator.","parameters":[],"requestBody":{"description":"Current password and new password to set.","typeName":"ICommunityPlatformCommunityModeratorPassword.IUpdate"},"responseBody":{"description":"Security result indicating that the password was updated and sessions may be rotated.","typeName":"ICommunityPlatformCommunityModerator.ISecurity"},"authorizationRole":"communityModerator","name":"updatePassword","prerequisites":[],"path":"/my/password","method":"put"},{"specification":"Create an admin registration endpoint that provisions a new platform user in community_platform_users and assigns site-wide admin privileges by creating a related row in community_platform_admin_users. The endpoint accepts identifiers and consents required by the business rules: unique email (community_platform_users.email), unique username (community_platform_users.username), password to be hashed into community_platform_users.password_hash, and acceptance timestamps for terms and privacy (community_platform_users.terms_accepted_at, community_platform_users.privacy_accepted_at). Initial flags include email verification status (community_platform_users.email_verified, typically false until verification) and account lifecycle state (community_platform_users.account_state, e.g., \"PendingVerification\" → later \"Active\"). Optionally record marketing opt-in (community_platform_users.marketing_opt_in, marketing_opt_in_at).\n\nAfter successful creation, issue JWT tokens representing the admin session. Admin designation is persisted via community_platform_admin_users with community_platform_admin_users.community_platform_user_id referencing the newly created user and community_platform_admin_users.granted_at set to now. Timestamps on the user (created_at, updated_at) are set, and last_login_at may be updated on initial token issuance in line with auditing rules.\n\nDependencies and relationships: community_platform_users is the core identity table; community_platform_admin_users captures admin role assignment with grant/revoke lifecycle fields (granted_at, revoked_at). The operation must enforce DB-level uniqueness on email/username (@@unique) and initialize fields to satisfy business and audit expectations. No other tables are modified in this registration step.\n\nSecurity considerations: Ensure account_state honors platform business rules and that password_hash is non-reversible. Email verification gating is enforced using email_verified. The response returns an authorized token payload bound to the admin role.\n\nError handling references Prisma constraints and business rules: uniqueness conflicts on email/username, invalid password policy, or missing consents. The operation should not touch deleted records (deleted_at) for visible lists; instead, create a fresh user entry.","authorizationType":"join","description":"This operation registers a new site-wide administrator by creating records in both the community_platform_users and community_platform_admin_users tables.\n\nIt uses community_platform_users.email and community_platform_users.username as unique identifiers, with collisions prevented by @@unique constraints. Credentials are stored only as community_platform_users.password_hash, and no plaintext password is kept. Consent timestamps are recorded in community_platform_users.terms_accepted_at and community_platform_users.privacy_accepted_at, satisfying compliance and audit requirements noted in the schema.\n\nThe account lifecycle is initialized using community_platform_users.account_state (for example, \"PendingVerification\") in combination with community_platform_users.email_verified. Optional marketing preferences are captured using community_platform_users.marketing_opt_in and community_platform_users.marketing_opt_in_at. Auditing fields community_platform_users.created_at, community_platform_users.updated_at, and optionally community_platform_users.last_login_at are set appropriately during provisioning.\n\nAdmin privileges are granted by inserting a row into community_platform_admin_users, linking via community_platform_admin_users.community_platform_user_id and setting community_platform_admin_users.granted_at to the current timestamp. The relationship ensures global administrative capabilities as required by the business role while maintaining historical grant/revoke data using community_platform_admin_users.revoked_at when needed later.\n\nUpon success, the service issues JWT tokens for the newly created admin. The response structure returns an authorized session aligned to ICommunityPlatformAdminUser.IAuthorized and may include claims derived from the user’s id and role assignment. Errors include uniqueness violations (email/username), invalid credential policy, or missing consents. The operation does not interact with logically deleted rows (deleted_at); it always creates a new user.","summary":"Register a new admin (community_platform_users + community_platform_admin_users) and return authorized tokens.","parameters":[],"requestBody":{"description":"Admin registration payload with identifiers, password, and consent timestamps.","typeName":"ICommunityPlatformAdminUserJoin.ICreate"},"responseBody":{"description":"Authorized admin session after successful registration.","typeName":"ICommunityPlatformAdminUser.IAuthorized"},"authorizationRole":null,"name":"join","prerequisites":[],"path":"/auth/adminUser/join","method":"post"},{"specification":"Authenticate an existing administrator using credentials associated to community_platform_users and issue JWT tokens bound to admin privileges. The endpoint accepts either email (community_platform_users.email) or username (community_platform_users.username) plus a password to verify against community_platform_users.password_hash. On success, update community_platform_users.last_login_at and community_platform_users.updated_at for audit.\n\nEligibility checks rely on community_platform_users.account_state (must not be e.g., Locked, Deactivated, PendingDeletion, Deleted, Banned) and community_platform_users.email_verified as a gating control for participation. The user must have an active admin role grant via community_platform_admin_users pointing to the user (and with community_platform_admin_users.revoked_at = NULL when enforced by application logic).\n\nNo new database rows are created; instead, this operation reads user/admin assignment records and updates timestamps. The response returns an authorized admin token bundle conforming to ICommunityPlatformAdminUser.IAuthorized.","authorizationType":"login","description":"This login operation verifies administrator credentials against the community_platform_users table and confirms active admin assignment via community_platform_admin_users.\n\nUser identification uses community_platform_users.email or community_platform_users.username, with credential verification against community_platform_users.password_hash. The account must be eligible for authentication based on community_platform_users.account_state (e.g., not Locked, Deactivated, PendingDeletion, Deleted, or Banned) and community_platform_users.email_verified where gating is required by policy.\n\nOn successful authentication, the service updates community_platform_users.last_login_at and community_platform_users.updated_at to reflect the login event. It also verifies that at least one active admin assignment exists in community_platform_admin_users for the user, using community_platform_admin_users.community_platform_user_id and ensuring community_platform_admin_users.revoked_at is null when applicable.\n\nNo new records are created by this action, and no archival fields are modified beyond timestamp updates on the user. The operation then issues JWT tokens containing claims necessary for authorization decisions.\n\nIf the credentials are invalid or the account state is not eligible, the provider returns a business error. Uniqueness constraints (email/username) are not changed during login. The returned payload follows ICommunityPlatformAdminUser.IAuthorized to convey authorized session details.","summary":"Authenticate an admin user (community_platform_users) and return authorized tokens.","parameters":[],"requestBody":{"description":"Admin login payload with email or username and password.","typeName":"ICommunityPlatformAdminUserLogin.ICreate"},"responseBody":{"description":"Authorized admin session after successful login.","typeName":"ICommunityPlatformAdminUser.IAuthorized"},"authorizationRole":null,"name":"login","prerequisites":[],"path":"/auth/adminUser/login","method":"post"},{"specification":"Exchange a valid refresh token for a new set of JWT tokens for an administrator session. Although refresh tokens are typically stored out-of-band, this endpoint validates token claims against community_platform_users (e.g., user id) and confirms active admin status via community_platform_admin_users. It may update community_platform_users.updated_at and optionally community_platform_users.last_login_at for audit trace.\n\nThe endpoint does not mutate role assignment rows; it only confirms that community_platform_admin_users still considers the user an active admin (community_platform_admin_users.revoked_at is null when enforced at application level). The response returns a renewed authorized payload conforming to ICommunityPlatformAdminUser.IAuthorized.","authorizationType":"refresh","description":"This operation renews an administrator’s session using a valid refresh token. It uses the user identifier conveyed in token claims to load the matching row from community_platform_users and confirms that the user still holds an active admin grant via community_platform_admin_users.\n\nIf the user is found and still eligible (based on community_platform_users.account_state and email gating via community_platform_users.email_verified where applicable), the provider issues fresh access/refresh tokens and may update community_platform_users.updated_at. The community_platform_admin_users table is not changed by this operation; its grant metadata (granted_at, revoked_at) is only read to ensure the admin role remains valid.\n\nNo new rows are created, and no logical deletion timestamps are modified. The operation focuses strictly on token lifecycle and authorization continuity for administrators.\n\nOn failures (expired/invalid refresh token or revoked admin status), the operation returns a business error. The response schema is ICommunityPlatformAdminUser.IAuthorized to deliver the renewed authorization context.","summary":"Refresh admin session tokens (validate against community_platform_users and community_platform_admin_users).","parameters":[],"requestBody":{"description":"Refresh token exchange payload.","typeName":"ICommunityPlatformAdminUserRefresh.ICreate"},"responseBody":{"description":"Renewed authorized admin session.","typeName":"ICommunityPlatformAdminUser.IAuthorized"},"authorizationRole":null,"name":"refresh","prerequisites":[],"path":"/auth/adminUser/refresh","method":"post"},{"specification":"Confirm an administrator’s email address by updating community_platform_users.email_verified to true and, if necessary, transitioning community_platform_users.account_state to an active state according to business rules. This endpoint relies on a verification token provided out-of-band (e.g., via email link) and does not require additional role rows to be created or modified.\n\nThe operation writes audit fields on the user (community_platform_users.updated_at). It does not interact with community_platform_admin_users except to ensure that admin capabilities remain intact post-verification. The response conveys a simple status summarizing verification outcome.","authorizationType":null,"description":"This endpoint verifies an admin user’s email address by flipping community_platform_users.email_verified to true for the identified account.\n\nThe request contains a verification token that resolves to a specific community_platform_users.id. After validating the token, the provider sets email_verified to true and may update community_platform_users.account_state to an active value consistent with platform policy.\n\nOnly community_platform_users is written in this process; community_platform_admin_users is not modified. Standard audit fields community_platform_users.updated_at are updated to reflect the verification.\n\nIf the token is invalid or expired, the operation returns a business error without changing any records. Successful execution returns a concise summary suitable for user feedback and client routing.\n\nThis verification step is required by business rules to unlock participation capabilities controlled by email gating.","summary":"Verify admin user email by updating community_platform_users.email_verified.","parameters":[],"requestBody":{"description":"Email verification payload carrying the verification token.","typeName":"ICommunityPlatformAdminUserEmailVerify.ICreate"},"responseBody":{"description":"Verification result summary.","typeName":"ICommunityPlatformAdminUserVerification.ISummary"},"authorizationRole":null,"name":"verifyEmail","prerequisites":[],"path":"/auth/adminUser/email/verify","method":"post"},{"specification":"Resend an email verification message to an admin user who has not completed verification. The operation reads community_platform_users (email, email_verified) and triggers an email dispatch flow. It may record throttling out-of-band; no persistent DB fields are required to change, but community_platform_users.updated_at can be set for audit if desired.","authorizationType":null,"description":"This operation resends a verification email for an administrator account using the email in community_platform_users.email.\n\nIt first checks community_platform_users.email_verified to avoid unnecessary sends when the account is already verified. The operation may apply rate limits, but those are handled outside this schema. It can update community_platform_users.updated_at for audit purposes if configured.\n\nNo records in community_platform_admin_users are changed by this operation. Its sole purpose is to issue a new verification link to the admin’s email address.\n\nIf the administrator is already verified or the account cannot be found, the provider returns a business error. On success, a summary response indicates that a new verification email has been sent.\n\nThis operation complements /auth/adminUser/email/verify to complete the verification lifecycle.","summary":"Resend admin email verification using community_platform_users.email.","parameters":[],"requestBody":{"description":"Resend email verification request (identifies the target admin by email or username).","typeName":"ICommunityPlatformAdminUserEmailResend.ICreate"},"responseBody":{"description":"Resend action status summary.","typeName":"ICommunityPlatformAdminUserVerification.ISummary"},"authorizationRole":null,"name":"resendVerification","prerequisites":[],"path":"/auth/adminUser/email/resend","method":"post"},{"specification":"Initiate an admin password reset by generating a one-time reset token and, optionally, setting community_platform_users.account_state to a reset-required value (e.g., \"PasswordResetRequired\") based on business policy. The operation identifies the target via community_platform_users.email or username and sends a reset link out-of-band. No password data is changed at this stage.","authorizationType":null,"description":"This operation starts a password reset for an admin user by issuing a one-time reset token associated with a community_platform_users.id.\n\nThe request locates the user by community_platform_users.email or community_platform_users.username. Based on business rules, community_platform_users.account_state may be updated to a value such as \"PasswordResetRequired\" to enforce a reset at next login. The provider may also update community_platform_users.updated_at.\n\nNo change is made to community_platform_users.password_hash in this step. Role assignment rows in community_platform_admin_users are not altered. The operation sends a reset link to the user’s email address.\n\nIf the account is not found or cannot accept resets due to account_state, the provider returns a business error. On success, the response summarizes that a reset link has been sent.\n\nThis operation precedes confirmation at /auth/adminUser/password/reset/confirm.","summary":"Initiate admin password reset (may set community_platform_users.account_state policy value).","parameters":[],"requestBody":{"description":"Admin password reset request (identify account by email or username).","typeName":"ICommunityPlatformAdminUserPasswordResetRequest.ICreate"},"responseBody":{"description":"Password reset initiation status summary.","typeName":"ICommunityPlatformAdminUserPasswordReset.ISummary"},"authorizationRole":null,"name":"requestPasswordReset","prerequisites":[],"path":"/auth/adminUser/password/reset","method":"post"},{"specification":"Complete an admin password reset by validating a one-time token and updating community_platform_users.password_hash to the new value. The operation should also restore community_platform_users.account_state to an active value and update audit fields (updated_at). Session revocation policies may be applied out-of-band.","authorizationType":null,"description":"This endpoint finalizes an administrator’s password reset.\n\nAfter validating the provided reset token, the provider sets community_platform_users.password_hash to the new credential and updates community_platform_users.updated_at. It may also transition community_platform_users.account_state from a reset-required state back to an active state according to policy, and revoke existing sessions where applicable.\n\nThe operation targets only community_platform_users; it does not modify community_platform_admin_users. Timestamps and auditing fields are recorded for compliance.\n\nIf the token is invalid, expired, or the new password fails policy, the provider returns a business error. On success, a concise summary indicates completion of the reset.\n\nThis endpoint follows /auth/adminUser/password/reset and precedes subsequent login with the new credentials.","summary":"Confirm admin password reset by updating community_platform_users.password_hash.","parameters":[],"requestBody":{"description":"Reset confirmation payload with token and new password.","typeName":"ICommunityPlatformAdminUserPasswordResetConfirm.ICreate"},"responseBody":{"description":"Password reset completion status summary.","typeName":"ICommunityPlatformAdminUserPasswordReset.ISummary"},"authorizationRole":null,"name":"confirmPasswordReset","prerequisites":[{"endpoint":{"path":"/auth/adminUser/password/reset","method":"post"},"description":"A password reset must be initiated to issue a valid one-time reset token before confirmation. This creates the reset artifact required by the confirm step; without it, the provided token will be invalid or missing and the password hash cannot be updated."}],"path":"/auth/adminUser/password/reset/confirm","method":"post"},{"specification":"Allow an authenticated administrator to change their password by providing the current password and a new password. The operation verifies the current credential against community_platform_users.password_hash, updates it with the new hash, and records audit fields like community_platform_users.updated_at (and optionally community_platform_users.last_login_at, depending on policy).","authorizationType":null,"description":"This role-protected operation lets a logged-in admin rotate credentials safely.\n\nThe provider verifies the current password against community_platform_users.password_hash before persisting the new hash. On success, it updates community_platform_users.updated_at and may set community_platform_users.last_login_at per auditing policy.\n\nThe operation does not modify community_platform_admin_users; it affects only community_platform_users for the authenticated subject. The change is limited to the current user; no path parameters are required because identity derives from the authenticated session.\n\nIf the current password does not match or the new password violates policy, the service returns a business error. On success, a brief status summary is returned to the client.\n\nSecurity-wise, this is a sensitive action and therefore requires the caller to be an authenticated admin user.","summary":"Change password for the authenticated admin by updating community_platform_users.password_hash.","parameters":[],"requestBody":{"description":"Authenticated password change payload with current and new password.","typeName":"ICommunityPlatformAdminUserPasswordChange.IUpdate"},"responseBody":{"description":"Password change status summary.","typeName":"ICommunityPlatformAdminUserPasswordChange.ISummary"},"authorizationRole":"adminUser","name":"changePassword","prerequisites":[],"path":"/auth/adminUser/password","method":"put"},{"specification":"Create a new community record in the community_platform_communities table. This operation accepts the core configuration required to initialize a community as described in the Prisma schema: a globally unique handle stored in name, optional display_name and description, a visibility mode (public | restricted | private), nsfw labeling, and an auto_archive_days integer (minimum 30 days per business rules). Optional defaults for language and region can also be provided. On successful creation, application logic should establish ownership using the community_platform_community_owners table and return the newly created community entity. Records with fields such as quarantined and quarantined_at are system-managed and typically not set during creation.","authorizationType":null,"description":"Create a community space following the design of the community_platform_communities model. Per the schema comments, each community has a globally unique handle in the name column used for routing and mentions, and a human-readable display_name for UI surfaces. The visibility column defines whether the community is public, restricted, or private. Flags like nsfw influence downstream visibility and preview behavior, and auto_archive_days determines when posts auto-archive to read-only (business minimum 30).\n\nSecurity and permissions: This endpoint requires an authenticated user eligible to create communities according to business policy. While the database schema does not encode eligibility, the provider implementation should validate account status and rate/eligibility rules before insertion. After creation, ownership should be recorded via community_platform_community_owners to reflect that the creator is the initial owner for governance and moderation workflows.\n\nEntity relationships and behavior: Created communities are referenced by subscriptions in community_platform_subscriptions and by content in community_platform_posts. The quarantined boolean and quarantined_at timestamp are reserved for trust & safety controls and are not intended to be set by general users at creation time. Implementations should avoid returning records that have a non-null deleted_at, as such records are treated as removed from general listings.\n\nValidation and error handling: Enforce uniqueness of name, restrict visibility to one of public | restricted | private, and require auto_archive_days to be at least 30. If name conflicts occur, the service should return a conflict-style error. If validation fails (e.g., invalid visibility or insufficient archive window), return a clear error consistent with the exception model. Related operations include GET /communities/{communityId} to retrieve the community after creation.","summary":"Create a community in community_platform_communities","parameters":[],"requestBody":{"description":"Community creation payload including unique handle, visibility, labeling, and archival policy","typeName":"ICommunityPlatformCommunity.ICreate"},"responseBody":{"description":"The newly created community entity with assigned identifiers and persisted configuration","typeName":"ICommunityPlatformCommunity"},"authorizationRole":"memberUser","name":"create","prerequisites":[],"path":"/communityPlatform/memberUser/communities","method":"post"},{"specification":"Retrieve a single community from the community_platform_communities table by its primary key id (UUID). The operation returns the full community entity as modeled in the Prisma schema, including fields such as name (unique handle), display_name, description, visibility, nsfw, auto_archive_days, language, region, quarantined, quarantined_at, created_at, and updated_at. Implementations should exclude records with a non-null deleted_at from normal responses.","authorizationType":null,"description":"Fetch community details according to the community_platform_communities model. As described in the schema comments, each record represents a top-level space organizing posts and memberships with a unique name handle and optional display_name and description. The visibility field indicates public, restricted, or private access modes; nsfw influences safety gating; auto_archive_days configures when threads move to read-only state. Language and region provide discovery defaults, and quarantined indicates safety-restricted discovery behavior with quarantined_at capturing the start timestamp.\n\nSecurity and permissions: This read operation can be exposed publicly, but the provider must enforce business policies based on the community’s visibility and safety flags. For example, private communities should only reveal details to approved viewers, and quarantined content may require acknowledgment before exposure. Records where deleted_at is set should be treated as removed from general listings and not returned by default.\n\nRelationships and error behavior: Communities are linked to owners and moderators through community_platform_community_owners and community_platform_community_moderators, and to subscriptions via community_platform_subscriptions. If the requested id does not correspond to a visible community (e.g., missing, treated as removed, or access denied by visibility settings), return a not-found or access-denied style error consistent with the exception model. This endpoint pairs naturally with POST /communities for creation flows.","summary":"Get community details by id from community_platform_communities","parameters":[{"name":"communityId","description":"Unique identifier (UUID) of the target community","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"The community entity identified by communityId","typeName":"ICommunityPlatformCommunity"},"authorizationRole":null,"name":"at","prerequisites":[{"endpoint":{"path":"/communityPlatform/memberUser/communities","method":"post"},"description":"A community must be created to obtain a valid communityId before it can be retrieved. Without creation, this GET would fail (e.g., not found)."}],"path":"/communityPlatform/communities/{communityId}","method":"get"},{"specification":"Create or re-activate a user-to-community follow record in the community_platform_subscriptions table. This endpoint subscribes the authenticated user to a target community identified by communityId and ensures a single active mapping per (user, community). If an inactive row exists for this pair, implementation should re-use it by clearing its deleted_at marker and setting status to the active subscribed state. Relationships: community_platform_subscriptions.user -> community_platform_users.id and community_platform_subscriptions.community -> community_platform_communities.id.","authorizationType":null,"description":"Subscribe the current authenticated user to the specified community by inserting or re-activating a row in the Communities namespace table community_platform_subscriptions. According to the Prisma schema, this table maintains a unique mapping per (community_platform_user_id, community_platform_community_id) via a composite unique constraint and tracks attributes such as status (pending | subscribed | banned | blocked), muted (Boolean) with muted_at, and lifecycle timestamps (created_at, updated_at, deleted_at). This operation focuses exclusively on establishing an active subscription for feed inclusion and does not manage muting or unsubscription flows.\n\nSecurity and eligibility considerations derive from related schema entities. The target community is stored in community_platform_communities with fields including visibility (public/restricted/private), nsfw (Boolean), and quarantined (Boolean), which inform business logic about whether a user can subscribe immediately or must await approval (e.g., status=\"pending\" for private or restricted communities). The subscriber is the authenticated principal backed by community_platform_users (email_verified Boolean and account_state string such as PendingVerification, Active, Locked, Deactivated, PendingDeletion, Deleted, Banned). Implementations typically require an authenticated user in good standing and a community that can accept new subscribers under its visibility and safety settings.\n\nFrom a data integrity standpoint, the community_platform_subscriptions table enforces uniqueness on (community_platform_user_id, community_platform_community_id) and offers indexes for efficient retrieval by user or community and by status plus deleted_at. If a prior row exists with an inactive state indicated via the deleted_at column, this operation should treat the request as idempotent by restoring it to an active state and setting status to \"subscribed\" as appropriate. When a current active record exists, this operation should be no-op and return the existing state, maintaining deterministic idempotency.\n\nRelated operations in the broader system (not included here) could cover unsubscription, muting, or administrative bans, but they are intentionally out of scope to align with the interface instructions. Expected errors include attempts to subscribe to non-existent communities, attempts by users with account_state that disallows participation, or attempts to subscribe where the community has set the user’s status to banned or blocked.","summary":"Create or re-activate a subscription (community_platform_subscriptions) for the current user in a community.","parameters":[{"name":"communityId","description":"Target community’s ID to subscribe to.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"The resulting subscription mapping for the user and community.","typeName":"ICommunityPlatformSubscription"},"authorizationRole":"memberUser","name":"create","prerequisites":[{"endpoint":{"path":"/communityPlatform/memberUser/communities","method":"post"},"description":"Community must be created before a user can subscribe to it. This operation creates the community and provides the communityId referenced by the subscription."}],"path":"/communityPlatform/memberUser/communities/{communityId}/subscribe","method":"post"},{"specification":"Create a new post in the community_platform_posts table for a specific community. The post is authored by the authenticated user and validated against the schema’s content model: title, type (TEXT | LINK | IMAGE), and the corresponding payload fields (body for TEXT, link_url for LINK, image_url for IMAGE). Additional labels (nsfw, spoiler) and visibility_state may be applied per business rules. Relations: author -> community_platform_users.id and community -> community_platform_communities.id.","authorizationType":null,"description":"Publish a new community post associated with community_platform_posts. The Prisma schema models posts with fields including title, type (application-enforced TEXT | LINK | IMAGE), body (TEXT only), link_url (LINK only), image_url (IMAGE only), label booleans nsfw and spoiler, and lifecycle attributes such as visibility_state (e.g., Active, PendingReview, Locked, Archived), locked_at, archived_at, edited_at, edit_count, created_at, updated_at, and deleted_at. This endpoint creates a record linked to the target community (community_platform_communities.id) and the authenticated author (community_platform_users.id).\n\nValidation and business logic follow the platform requirements: for TEXT posts, require a non-empty body within allowed length; for LINK posts, require an http/https URL within length limits; for IMAGE posts, require an image resource URI string (the API uses URIs rather than binary payloads). Communities can enforce defaults like nsfw or spoiler gating based on community_platform_communities.nsfw and visibility rules; initial visibility_state is typically set to Active unless moderation or automated policies choose PendingReview. The author’s eligibility can be derived from community_platform_users fields such as email_verified (must be true for participation) and account_state (must allow posting).\n\nOn success, the operation returns the newly created post including identifiers and the submitted content fields mapped to the appropriate columns (title, type, body/link_url/image_url). Common error cases include invalid content type/payload combinations, community not found, author not eligible (e.g., email not verified), or community constraints that disallow the selected post type for that community.\n\nThis operation complements listing and detail retrieval endpoints (not defined here) and is intentionally limited to creation per the interface instructions. Any moderation workflows (lock, archive, remove) are outside the scope of this endpoint.","summary":"Create a new post record (community_platform_posts) within a specified community.","parameters":[{"name":"communityId","description":"The community ID where the post will be created.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Post creation payload including title, type, and type-specific content fields.","typeName":"ICommunityPlatformPost.ICreate"},"responseBody":{"description":"The created post with identifiers and submitted fields.","typeName":"ICommunityPlatformPost"},"authorizationRole":"memberUser","name":"create","prerequisites":[{"endpoint":{"path":"/communityPlatform/memberUser/communities","method":"post"},"description":"Community must exist before a post can be created within it. This operation creates the community and yields the communityId used by the post."}],"path":"/communityPlatform/memberUser/communities/{communityId}/posts","method":"post"},{"specification":"Retrieve an ordered, paginated collection of posts for a specific community using the community_platform_posts table. The endpoint accepts a communityId path parameter and returns posts that belong to that community (community_platform_posts.community_platform_community_id). Rankings for New/Top/Hot/Controversial are implementation-defined based on created_at and vote aggregates in community_platform_post_votes, while eligibility must honor community settings in community_platform_communities.\n\nPagination should be deterministic and exclude posts where deleted_at is not null. Visibility filtering should consider visibility_state values that are not intended for general audiences (e.g., RemovedByModeration, RemovedByAdmin, DeletedByAuthor, PendingReview) and enforce read-only behavior for archived items (archived_at not null). Community-level policies (visibility public/restricted/private, nsfw, quarantined, auto_archive_days) from community_platform_communities must be applied before returning results.","authorizationType":null,"authorizationRole":null,"description":"Retrieve a paginated, eligibility-filtered list of posts from the community_platform_posts table for the specified community.\n\nSecurity and eligibility: Implementations must enforce community visibility (public/restricted/private), NSFW preference handling, and quarantine behavior from community_platform_communities. Items in states like RemovedByModeration, RemovedByAdmin, DeletedByAuthor, or PendingReview are typically excluded from general lists, while archived posts remain visible but read-only. Always exclude rows where deleted_at is set.\n\nSorting behavior: The platform supports New (created_at desc), Top (net approval over a time window), Hot (recency-weighted engagement), and Controversial (high total votes, near-balanced polarity). If a client does not provide optional query parameters for sort/time window, the implementation SHOULD apply a sensible default (e.g., New for community view) consistent with business rules. This contract does not define query parameters beyond the path; query usage is implementation-specific.\n\nRelationships and ranking sources: Posts belong to a community via community_platform_community_id and to authors via community_platform_user_id. Vote data in community_platform_post_votes provides aggregates for Top/Controversial/Hot. Implementations should ensure list projections include fields suitable for list UIs (e.g., title, type, nsfw, spoiler, visibility_state, locked_at, archived_at, created_at) without exposing sensitive data.\n\nErrors: COMMUNITY_PRIVATE (insufficient permission), SORT_UNSUPPORTED (when unsupported query sort is supplied), and not found when community does not exist or is inaccessible.","method":"get","name":"index","parameters":[{"name":"communityId","description":"Target community’s ID (UUID) whose posts will be listed.","schema":{"type":"string","format":"uuid"}}],"path":"/communityPlatform/communities/{communityId}/posts","prerequisites":[{"endpoint":{"path":"/communityPlatform/memberUser/communities","method":"post"},"description":"Community must be created before its posts can be listed. The list endpoint requires a valid communityId referencing community_platform_communities.id; without an existing community, the listing would fail (not found)."}],"requestBody":null,"responseBody":{"description":"Paginated list of community posts suitable for list displays with deterministic ordering and eligibility filtering.","typeName":"IPageICommunityPlatformPost"},"summary":"List community posts (community_platform_posts) with deterministic, paginated results."},{"specification":"Retrieve a single post by its identifier from the community_platform_posts table. Returns the detailed post record including core fields (title, type, optional body/link_url/image_url, nsfw, spoiler, visibility_state, locked_at, archived_at, edited_at, edit_count, created_at, updated_at) and respects eligibility based on the post’s community (community_platform_communities) and viewer context. Optional derived aggregates (e.g., score) may be included if the DTO supports them and they are computed from community_platform_post_votes.","authorizationType":null,"authorizationRole":null,"description":"Fetch detailed information for a single post stored in community_platform_posts.\n\nSecurity and eligibility: Enforce community visibility (public/restricted/private), NSFW preferences, and quarantine behavior from community_platform_communities before returning content. Use visibility_state to gate interactions (Locked disables new comments/vote changes; Archived disables edits and new interactions). Exclude posts with deleted_at set from normal results.\n\nRelationships: The post references its author via community_platform_user_id (community_platform_users) and its community via community_platform_community_id (community_platform_communities). Votes are recorded in community_platform_post_votes and may be used to derive metrics such as score in the response if supported by the DTO.\n\nErrors: not found when post does not exist or is ineligible for viewing under policy; access denied for private/restricted communities when the viewer lacks permission; temporary unavailability when systems are degraded.","method":"get","name":"at","parameters":[{"name":"postId","description":"Target post’s ID (UUID).","schema":{"type":"string","format":"uuid"}}],"path":"/communityPlatform/posts/{postId}","prerequisites":[{"endpoint":{"path":"/communityPlatform/memberUser/communities","method":"post"},"description":"A community must exist to host the post because posts reference community_platform_communities.id. Creating a community provides the context required to create a post."},{"endpoint":{"path":"/communityPlatform/memberUser/communities/{communityId}/posts","method":"post"},"description":"The post must be created before it can be retrieved by ID. This operation creates the community_platform_posts row that supplies postId for the GET."}],"requestBody":null,"responseBody":{"description":"Detailed post resource aligned with fields in community_platform_posts.","typeName":"ICommunityPlatformPost"},"summary":"Get detailed post (community_platform_posts) by ID."},{"specification":"Idempotently set or change the authenticated member’s vote on a specific post. This operation targets the Votes namespace table community_platform_post_votes and upserts a single (user, post) vote record with value constrained to -1 or +1. It uses the composite uniqueness on (community_platform_user_id, community_platform_post_id) and honors the deleted_at soft-deletion column to revive a previously cleared vote when applicable. The post relationship comes from community_platform_posts via community_platform_post_id and the voter relationship comes from community_platform_users via community_platform_user_id. On success, it returns the current vote record after applying the change.","authorizationType":null,"description":"Set or update the caller’s vote on a post identified by postId. In the Prisma schema, community_platform_post_votes represents a single user’s vote on a post and includes columns id, community_platform_user_id, community_platform_post_id, value (only -1 or +1 are valid), created_at, updated_at, and deleted_at. A composite unique index on (community_platform_user_id, community_platform_post_id) guarantees exactly one active vote per user and post, while deleted_at supports logical retraction of a vote without removing history. Relationships enforce referential integrity to community_platform_users (the voter) and community_platform_posts (the target post) with onDelete: Cascade semantics.\n\nSecurity and permissions follow business rules: the caller must be an authenticated user (member) with eligibility to vote, such as a verified email and not being banned or restricted in the target community. Implementations should prevent voting on one’s own content and disallow changes when a post is Locked or Archived, consistent with content lifecycle rules. Rate limiting should be applied per the voting requirements to mitigate abuse. The request must supply a value of -1 (downvote) or +1 (upvote). If an identical value is already recorded and not deleted, the operation is idempotent and leaves the record unchanged; if a different value exists, it updates value and updated_at. If a logically deleted record exists (deleted_at set), the operation should revive the vote by clearing deleted_at and setting the requested value.\n\nThis operation is typically used together with DELETE /posts/{postId}/vote to clear a vote. Post detail retrieval (e.g., GET /posts/{postId}) is expected to reflect the net score derived from active votes. Errors include not found (post does not exist or not visible), permission/eligibility denials (e.g., attempting to vote on own content or voting on locked/archived content), and rate limiting. The operation returns the resulting community_platform_post_votes entity so clients can reflect current state in UI.","summary":"Set or change a post vote (community_platform_post_votes)","parameters":[{"name":"postId","description":"Target post’s ID to vote on","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Desired vote value for the current user on the specified post. Only -1 or +1 are valid.","typeName":"ICommunityPlatformPostVote.IUpdate"},"responseBody":{"description":"The current vote record for this user and post after applying the operation","typeName":"ICommunityPlatformPostVote"},"authorizationRole":"memberUser","name":"setVote","prerequisites":[{"endpoint":{"path":"/communityPlatform/memberUser/communities/{communityId}/posts","method":"post"},"description":"A post must exist before a user can set or change their vote on it. This operation creates the target post that yields postId; without an existing post, the voting action cannot be performed."}],"path":"/communityPlatform/memberUser/posts/{postId}/vote","method":"put"},{"specification":"Clear the authenticated member’s vote on a specific post. This operation manipulates the Votes namespace table community_platform_post_votes by marking the user’s existing (user, post) vote as cleared through the deleted_at column (logical deletion). The composite uniqueness on (community_platform_user_id, community_platform_post_id) ensures at most one vote record per user and post; clearing a vote retains the record for audit and analytics while excluding it from active tallies.","authorizationType":null,"description":"Remove the caller’s active vote on the post identified by postId by marking the corresponding community_platform_post_votes record as deleted through the deleted_at timestamp. The underlying Prisma model includes id, community_platform_user_id, community_platform_post_id, value, created_at, updated_at, and deleted_at. Setting deleted_at indicates the vote is no longer active and should be excluded from scores while preserving history. If no active vote exists, the operation is idempotent and completes without changing state. Referential integrity to community_platform_users (voter) and community_platform_posts (target) is maintained, with onDelete: Cascade semantics when targets are removed.\n\nSecurity and permissions align with business rules: only authenticated eligible users can modify their own vote; voting changes must be denied when a post is Locked or Archived and must respect restrictions such as bans. Rate limits for vote actions may apply. This endpoint returns no body on success to reflect a simple state-clearing action; clients can re-fetch post details to obtain updated aggregate scores.\n\nUse this operation in tandem with PUT /posts/{postId}/vote to set a new vote value later. Typical errors include post not found, insufficient permissions, or state-based denials (e.g., locked/archived content disallowing vote changes).","summary":"Clear a post vote (community_platform_post_votes)","parameters":[{"name":"postId","description":"Target post’s ID whose vote should be cleared","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRole":"memberUser","name":"erase","prerequisites":[{"endpoint":{"path":"/communityPlatform/memberUser/communities/{communityId}/posts","method":"post"},"description":"A post must exist before a user can clear their vote on it. This operation creates the target post that yields postId; if the post does not exist, there is no vote relationship to clear."}],"path":"/communityPlatform/memberUser/posts/{postId}/vote","method":"delete"},{"specification":"Create a new comment under a specific post. Operates on the community_platform_comments table and links to the target post in community_platform_posts via community_platform_post_id and to the author in community_platform_users via community_platform_user_id. Supports optional parent_id for nested replies up to the platform-defined maximum depth, and enforces body length validation. Business logic must ensure target post is eligible for new comments (e.g., not Locked/Archived via community_platform_posts.locked_at/archived_at or visibility_state) and excludes parents or posts where deleted_at is set. On success, returns the created comment entity for client display and threading.","authorizationType":null,"description":"This operation creates a new comment record in the community_platform_comments table for the given post. The model defines required fields including body and foreign keys to the post (community_platform_post_id) and author (community_platform_user_id). The optional parent_id supports hierarchical replies in the same post. The body must be validated to meet the business requirement of 1–10,000 characters after trimming whitespace; empty-only bodies are not permitted. The created comment initializes edit_count and timestamps (created_at/updated_at) appropriately and may set edited_at when edits occur later.\n\nSecurity and authorization follow role rules where only authenticated participants (memberUser and above) may create comments. The server must ensure the acting user has permission to participate in the target community context and is not banned or restricted. The endpoint should also enforce comment creation eligibility against the target post’s lifecycle, including checks against community_platform_posts.locked_at, archived_at, and visibility_state (e.g., Locked, Archived), where comments should not be accepted. Records with deleted_at set in either the post or the chosen parent comment must not be eligible as targets.\n\nThis operation is related to the community_platform_posts and community_platform_users tables through foreign keys, and supports nested replies through the parent_id self-relation in community_platform_comments. Implementation should ensure parent-child relationships remain within the same post. Validation must surface business errors such as invalid length, ineligible state (post locked or archived), or depth overflow. Additional logic like rate limits and spam checks may apply according to business requirements documents.\n\nConsumers typically pair this operation with GET /posts/{postId}/comments to render the full comment tree after creation. Error handling should use the platform’s standardized error model (e.g., COMMENT_VALIDATION_FAILED, COMMENT_RATE_LIMITED, COMMENT_LOCKED, POST_ARCHIVED) and provide actionable guidance. The response includes the newly created comment for immediate client insertion into the thread.","summary":"Create a comment (community_platform_comments) under a post with optional parent for nesting","parameters":[{"name":"postId","description":"Identifier of the target post to comment on","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Comment creation payload including body and optional parentId for nesting under the same post","typeName":"ICommunityPlatformComment.ICreate"},"responseBody":{"description":"The newly created comment entity with identifiers and timestamps for client rendering","typeName":"ICommunityPlatformComment"},"authorizationRole":"memberUser","name":"create","prerequisites":[{"endpoint":{"path":"/communityPlatform/memberUser/communities/{communityId}/posts","method":"post"},"description":"The target post must exist before a comment can be created under it. This operation creates the post that provides the postId referenced by the comment creation; if the post does not exist, comment creation will fail."}],"path":"/communityPlatform/memberUser/posts/{postId}/comments","method":"post"},{"specification":"Retrieve the full set of comments for a specific post from the community_platform_comments table, including nested replies through the parent_id self-relation. Returns a tree-structured response that aggregates comments belonging to the post (community_platform_post_id equals the given postId) and excludes records where deleted_at is set. This read-only operation is designed for public viewing of discussions and does not include pagination, following the interface requirements.","authorizationType":null,"description":"This operation reads comment data from the community_platform_comments table for the given post identifier and organizes results into a tree based on the parent_id self-relation. Each comment includes core fields from the schema: id, community_platform_post_id, community_platform_user_id, optional parent_id for nesting, body, locked_at for thread-level locking, edit_count and edited_at for edit transparency, and created_at/updated_at timestamps. Results should exclude comments where deleted_at is set and may indicate placeholders for unavailable content according to business policies.\n\nSecurity-wise, this endpoint is designed for public read access where the target post and community are publicly visible. If the community or post has more restrictive visibility (e.g., private, restricted, quarantined), the provider should enforce eligibility based on viewer context. The operation does not require authentication for public content, and sensitive states (e.g., Removed by moderation) should be represented according to the platform’s visibility rules rather than leaking private details.\n\nThis operation relates directly to community_platform_posts for the target post and to community_platform_users for authorship, while modeling hierarchical structure through the parent_id relation in community_platform_comments. It complements POST /posts/{postId}/comments for write operations. Error handling should align with the exception model (e.g., PROFILE_PRIVATE when viewer cannot access, SYS_TEMPORARY_UNAVAILABLE on transient failures). The response returns a comment tree for client rendering without pagination or sorting parameters, focusing on complete nested structure for the specified post.","summary":"Get tree-structured comments (community_platform_comments) for a post","parameters":[{"name":"postId","description":"Identifier of the post whose comments are requested","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Tree-structured comments for the specified post, including nested replies","typeName":"ICommunityPlatformComment.ITree"},"authorizationRole":null,"name":"index","prerequisites":[{"endpoint":{"path":"/communityPlatform/memberUser/communities/{communityId}/posts","method":"post"},"description":"The post must exist before its comments can be retrieved. This operation creates the post that provides the postId; without an existing post, fetching its comments is invalid."}],"path":"/communityPlatform/posts/{postId}/comments","method":"get"},{"specification":"Update (upsert) the authenticated member’s vote on a specific comment. This endpoint targets the community_platform_comment_votes table, which stores a single user’s upvote/downvote per comment (enforced by a composite unique index on (community_platform_user_id, community_platform_comment_id)). When a vote already exists (including a previously cleared one with deleted_at set), this operation updates the value to -1 or +1 and clears deleted_at; when none exists, it creates a new record linked to the target comment (community_platform_comments.id) and voter (community_platform_users.id). Business constraints include: one active vote per user per comment, prevention of voting on one’s own content, and disabling vote changes when the comment/post is locked or archived per requirements.","authorizationType":null,"description":"This operation modifies or creates a vote record in the Votes namespace for a specific comment, aligning with the Prisma model community_platform_comment_votes. The model defines: id (UUID), community_platform_user_id (voter), community_platform_comment_id (target), value (Int; valid values −1 or +1 only), created_at/updated_at, and deleted_at. It enforces uniqueness for a user-target pair so that only one vote can exist at a time via @@unique([community_platform_user_id, community_platform_comment_id]). If a user has previously cleared a vote (deleted_at populated), setting a new value should reactivate the vote by updating value and clearing deleted_at.\n\nSecurity and permissions: Only authenticated members are allowed to vote. The user must not be the author of the target comment (prevent self-voting per business rules). Additionally, voting must be denied when either the target comment node (community_platform_comments.locked_at) is locked or when the parent post has been archived/locked (community_platform_posts.archived_at/locked_at and visibility_state). Eligibility gates described in the requirements (e.g., verified email, account standing) apply.\n\nDatabase relationships: The vote record references community_platform_users (voter) and community_platform_comments (target). The target comment references a post (community_platform_posts) and a community (community_platform_communities). Implementations should use the composite unique constraint to upsert atomically, updating value and timestamps. If the vote previously existed with deleted_at set, clearing that column effectively restores the vote.\n\nValidation rules and business logic: The request must provide value ∈ {−1, +1}. Attempts to submit 0 or other integers must be rejected. If the target comment or its ancestor post is in a state that disallows voting (locked/archived), the operation should fail. Rate limits in the requirements (e.g., 60 vote actions/10 minutes and 600/24 hours with stricter limits for low-trust accounts) should be enforced in provider logic; when triggered, return the standardized error key. Self-voting must be prevented by comparing the authenticated user id to the comment’s author id.\n\nRelated operations: Clearing a user’s vote on a comment is handled by DELETE /comments/{commentId}/vote, which deactivates the vote by timestamping deleted_at. Post-level voting uses the analogous community_platform_post_votes model and separate endpoints.","summary":"Upsert or change a member’s vote (-1 or +1) for a comment (community_platform_comment_votes).","parameters":[{"name":"commentId","description":"Target comment’s ID (UUID) to vote on","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Vote value to set for this comment. Only -1 (downvote) or +1 (upvote) are accepted.","typeName":"ICommunityPlatformCommentVote.IUpdate"},"responseBody":{"description":"The persisted vote record after upsert/update, reflecting the current value and timestamps.","typeName":"ICommunityPlatformCommentVote"},"authorizationRole":"memberUser","name":"update","prerequisites":[{"endpoint":{"path":"/communityPlatform/memberUser/posts/{postId}/comments","method":"post"},"description":"A comment must exist before a user can set or change a vote on it. This operation creates the target comment (producing commentId) that the vote references; if the comment is missing, the vote upsert cannot proceed."}],"path":"/communityPlatform/memberUser/comments/{commentId}/vote","method":"put"},{"specification":"Clear the authenticated member’s vote on a specific comment by marking the corresponding record in community_platform_comment_votes as inactive using the deleted_at timestamp. The operation locates the voter’s unique vote row for the target comment (composite unique index on (community_platform_user_id, community_platform_comment_id)) and sets deleted_at to the current time, effectively removing the vote from active aggregates without permanently deleting the record. When no active vote exists, the operation should behave idempotently and return success with no effect.","authorizationType":null,"description":"This operation interacts with the Votes namespace and the Prisma model community_platform_comment_votes. The model stores one vote per user per comment with fields id, community_platform_user_id, community_platform_comment_id, value (−1 or +1), created_at, updated_at, and deleted_at. Clearing a vote populates deleted_at for the (user, comment) row, so it no longer counts toward scores and karma computations, while retaining history for governance analytics. Subsequent read models should exclude rows with deleted_at set from active tallies.\n\nSecurity and permissions: Only authenticated members can clear their own votes. If no existing vote row is found, treat the request as a no-op for idempotency. Enforce business constraints from the requirements, including restrictions when the comment/post is locked or archived. Implementations may allow clear-only semantics under lock/archival if policy permits, but must not allow setting or changing vote values in those states.\n\nDatabase relationships: The record references community_platform_users (voter) and community_platform_comments (target). The composite unique constraint ensures at most one row exists for each (user, comment). Clearing does not permanently remove the row; instead, it timestamps deleted_at to indicate it is inactive in standard queries.\n\nBehavior and errors: If a vote exists with deleted_at already set, repeated clear requests should succeed without additional changes (idempotent behavior). Apply rate limits consistent with the requirements and respond with standardized error keys when limits are exceeded.\n\nRelated operations: To set or change the vote value, use PUT /comments/{commentId}/vote, which updates or creates the row and clears deleted_at.","summary":"Clear the member’s vote on a comment by timestamping deleted_at (community_platform_comment_votes).","parameters":[{"name":"commentId","description":"Target comment’s ID (UUID) for which to clear the vote","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRole":"memberUser","name":"erase","prerequisites":[{"endpoint":{"path":"/communityPlatform/memberUser/posts/{postId}/comments","method":"post"},"description":"A comment must exist for a user’s vote row to be addressable for clearing. Creating the comment (producing commentId) ensures the delete operation can locate and deactivate the user’s vote record; without an existing comment, there is no valid target context."}],"path":"/communityPlatform/memberUser/comments/{commentId}/vote","method":"delete"},{"specification":"Retrieve a specific user’s public profile and authored activity. This operation reads from the Prisma tables community_platform_users (core identity), community_platform_user_karmas (aggregated karma totals), community_platform_posts (authored posts), and community_platform_comments (authored comments). It returns a consolidated profile view: basic public user info (id, username, optional display_name, optional avatar_uri), karma totals, and lightweight lists of the user’s posts and comments. Records that are no longer meant to appear in normal queries should be filtered according to their state fields as described in the schema (e.g., visibility_state on posts, and lock/archive indicators). This endpoint is read-only and designed for simple detail retrieval via GET.","authorizationType":null,"description":"This endpoint returns a consolidated public profile for a single user. It is centered on the community_platform_users model, whose description states it stores login identifiers, credential hash, account lifecycle, consent timestamps, and profile basics, and is referenced by role assignment tables and content authorship. From this table, only non-sensitive, public-facing attributes should be surfaced in the profile (e.g., id, username, display_name, avatar_uri). Fields such as password_hash and email must never be exposed in the response. The account_state and email_verified flags may influence visibility decisions per business policy, but the response should remain limited to allowed public information.\n\nKarma information is sourced from community_platform_user_karmas, which aggregates post_karma, comment_karma, and total_karma for the user. These values provide the profile’s reputation summary. The schema comment indicates these totals are maintained by application logic based on votes; the endpoint only reads the current snapshot without recalculating.\n\nAuthored content summaries derive from community_platform_posts and community_platform_comments where community_platform_user_id matches the path userId. For posts, relevant fields include id, community references, title, type (TEXT|LINK|IMAGE enforced at the application layer), content pointers (body/link_url/image_url used according to type), labels (nsfw, spoiler), timestamps (created_at, updated_at, edited_at, locked_at, archived_at), and an optional visibility_state describing lifecycle (Active, Locked, Archived, RemovedByModeration, RemovedByAdmin, DeletedByAuthor, PendingReview, LegalHold). For comments, relevant fields include id, post linkage, parent_id for nesting, body, timestamps (created_at, updated_at, edited_at), edit_count, and locked_at for thread restrictions.\n\nSecurity and privacy: guest viewers may access public profile data; sensitive attributes like email and password_hash must be excluded. If community or content-level policies restrict visibility (e.g., NSFW gating, private communities), the provider should omit or redact items accordingly. The operation itself is public, but downstream business logic enforces role-based visibility and community access rules.\n\nValidation and behavior: the path parameter userId must be a valid UUID referencing community_platform_users.id. If the user does not exist or is not accessible by policy, the service should return an appropriate not-found or privacy-constrained response. This endpoint is a simple detail retrieval; it does not paginate or sort activity beyond a basic, provider-defined ordering consistent with business expectations for a compact profile view.\n\nRelated operations: GET /communityPlatform/users/{userId}/karma provides a focused view of karma totals and may be used when only reputation data is needed. Profile retrieval may also be followed by separate calls to post or comment detail endpoints if clients need full content objects beyond the lightweight summaries included here.\n\nError handling expectations: return a not-found outcome when the target user record does not exist, and a privacy outcome when the viewer cannot access the profile due to privacy settings or blocks. Avoid leaking information about restricted records in error messages.","summary":"Get a user’s consolidated profile from community_platform_users with authored posts/comments and aggregated karma.","parameters":[{"name":"userId","description":"Unique identifier of the target user (community_platform_users.id).","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Consolidated user profile including public account fields, aggregated karma, and lightweight lists of authored posts and comments.","typeName":"ICommunityPlatformUserProfile"},"authorizationRole":null,"name":"at","prerequisites":[],"path":"/communityPlatform/users/{userId}/profile","method":"get"},{"specification":"Retrieve karma totals for a specific user from the Prisma table community_platform_user_karmas. This operation reads the aggregated fields post_karma, comment_karma, and total_karma for the row uniquely associated with community_platform_users.id (via community_platform_user_id). It is a read-only, simple detail fetch designed to quickly return reputation totals without loading profile or activity lists.","authorizationType":null,"description":"This endpoint returns the current karma snapshot for a user. The community_platform_user_karmas model contains integer aggregates: post_karma (from votes on posts), comment_karma (from votes on comments), and total_karma (overall). The schema notes the application maintains these values based on voting activity. The endpoint performs no recalculation; it simply reads the latest stored values.\n\nThe user linkage is community_platform_user_id referencing community_platform_users.id. Providers should ensure the path parameter userId is a valid UUID and resolve the corresponding karma row. If no karma row exists yet for a legitimate user, the service may return zeros or an initialized structure as per business policy, but must not fabricate data that conflicts with the schema.\n\nSecurity and privacy: karma totals are non-sensitive aggregates suitable for public display in accordance with profile visibility rules. The endpoint is public, but downstream logic should still honor any platform-wide restrictions that might affect exposure (e.g., banned accounts’ visibility policies).\n\nRelationship to other entities: while this operation does not retrieve content, it is related to voting tables community_platform_post_votes and community_platform_comment_votes, which the application uses to compute or update karma. It also complements the profile endpoint, which may embed the same totals when returning broader profile information.\n\nExpected behavior and errors: return a not-found outcome if the referenced user does not exist; if the user exists but has no karma record yet, return an initialized response consistent with platform defaults. Input validation ensures userId is a UUID.","summary":"Get a user’s karma totals from community_platform_user_karmas.","parameters":[{"name":"userId","description":"Unique identifier of the target user (community_platform_users.id).","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Aggregated karma totals for the specified user.","typeName":"ICommunityPlatformUserKarma"},"authorizationRole":null,"name":"at","prerequisites":[],"path":"/communityPlatform/users/{userId}/karma","method":"get"},{"specification":"Create a new safety report targeting a specific post. This operation persists a record into the community_platform_reports table, associating the authenticated reporter (community_platform_reports.community_platform_user_id) with the target post (community_platform_reports.community_platform_post_id). Only one target is allowed per report row as documented in the Prisma schema comments: exactly one of post or comment must be set. The API sets the post reference from the path parameter and does not accept comment targeting in this route. Required inputs are the categorical reason (category) and free-text explanation (reason). Timestamps (created_at, updated_at) are maintained by the service. The response returns the created report resource.","authorizationType":null,"description":"Create a user-submitted safety report for a post. The underlying storage is the community_platform_reports table, which defines these key columns: id (PK), community_platform_user_id (reporter reference), community_platform_post_id (target post), category (categorical reason string), reason (free-text explanation), and created_at/updated_at timestamps. The schema documentation specifies that exactly one of community_platform_post_id or community_platform_comment_id must be set; this endpoint sets the post reference from the path and leaves the comment reference unset.\n\nSecurity and permissions: Only authenticated users are allowed to report content. The reporter identity is taken from the authenticated session and stored in community_platform_reports.community_platform_user_id. Business rules from the requirements limit report abuse and duplication; the table includes composite indexes to support deduplication windows by (reporter, category, target). The service should return a clear business error (e.g., REPORT_DUPLICATE_OPEN) when a duplicate report exists within the policy window.\n\nEntity relationships: The report references the target post via community_platform_reports.community_platform_post_id and the reporter via community_platform_reports.community_platform_user_id. The target post must exist (referencing community_platform_posts.id). The operation should validate that the target post is addressable and visible to the reporter per policy before accepting the report.\n\nValidation and business logic: The request requires a category string and a non-empty reason. Categories align with the documented moderation taxonomy (e.g., spam, harassment/hate, sexual_content/child_safety, violence/threats, self_harm_risk, illegal, doxxing, misinformation, off_topic/low_effort, copyright, other). The service should trim and validate reason length. The created row sets created_at/updated_at and associates the postId from the path.\n\nRelated operations: Use POST /comments/{commentId}/reports for reporting a comment. These two operations are symmetrical and write to the same table with different target columns. Error handling should surface standardized keys from the exception model, such as REPORT_INVALID_CATEGORY, REPORT_DUPLICATE_OPEN, and PERM_INSUFFICIENT_ROLE when the user lacks permission.","summary":"Create a report for a post (community_platform_reports).","parameters":[{"name":"postId","description":"Target post’s ID to report.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Categorical reason and free-text explanation for reporting the post.","typeName":"ICommunityPlatformReport.ICreate"},"responseBody":{"description":"Created report resource with reporter, target post reference, category, and reason.","typeName":"ICommunityPlatformReport"},"authorizationRole":"memberUser","name":"create","prerequisites":[{"endpoint":{"path":"/communityPlatform/memberUser/communities/{communityId}/posts","method":"post"},"description":"The target post must exist so a valid postId is available to associate with the report. If no post exists, the report creation will fail due to a missing target reference."}],"path":"/communityPlatform/memberUser/posts/{postId}/reports","method":"post"},{"specification":"Create a new safety report targeting a specific comment. This operation writes a record to the community_platform_reports table, associating the authenticated reporter (community_platform_reports.community_platform_user_id) with the target comment (community_platform_reports.community_platform_comment_id). As described in the Prisma schema, exactly one of the two possible foreign keys (post or comment) should be set; this route sets the comment reference based on the path parameter. The request body carries the category and free-text reason. The response returns the created report resource.","authorizationType":null,"description":"Submit a safety report for a comment. The community_platform_reports table models reports with: id (PK), community_platform_user_id (reporter user), community_platform_comment_id (target comment), category (categorical reason), reason (free-text explanation), and created_at/updated_at timestamps. The schema comments emphasize that exactly one target reference is provided (post or comment). This endpoint sets community_platform_comment_id from the path and leaves the post reference unset.\n\nSecurity and permissions: Only authenticated users may report comments; the reporter is the current session user written to community_platform_reports.community_platform_user_id. Business rules from the requirements cover deduplication (per reporter, category, and target within a time window) and abuse controls. The table’s composite indexes support efficient checks, and violations should surface standard errors such as REPORT_DUPLICATE_OPEN or REPORT_RATE_LIMITED.\n\nEntity relationships: The report ties to the target comment via community_platform_reports.community_platform_comment_id and to the reporter via community_platform_reports.community_platform_user_id. The target comment must exist (community_platform_comments.id). The service should ensure the reporter has access to the underlying post/community context before accepting the report.\n\nValidation and business logic: The request requires a category string and a non-empty, trimmed reason. Categories follow the moderation taxonomy (e.g., spam, harassment/hate, sexual_content/child_safety, violence/threats, self_harm_risk, illegal, doxxing, misinformation, off_topic/low_effort, copyright, other). The service sets timestamps and associates commentId from the path parameter.\n\nRelated operations: To report posts, use POST /posts/{postId}/reports. Both operations persist to the same table with distinct target columns. Error handling follows the standard model, including REPORT_INVALID_CATEGORY, REPORT_DUPLICATE_OPEN, and PERM_INSUFFICIENT_ROLE.","summary":"Create a report for a comment (community_platform_reports).","parameters":[{"name":"commentId","description":"Target comment’s ID to report.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Categorical reason and free-text explanation for reporting the comment.","typeName":"ICommunityPlatformReport.ICreate"},"responseBody":{"description":"Created report resource with reporter, target comment reference, category, and reason.","typeName":"ICommunityPlatformReport"},"authorizationRole":"memberUser","name":"create","prerequisites":[{"endpoint":{"path":"/communityPlatform/memberUser/posts/{postId}/comments","method":"post"},"description":"The target comment must exist so a valid commentId is available to associate with the report. If no comment exists, the report creation will fail due to a missing target reference."}],"path":"/communityPlatform/memberUser/comments/{commentId}/reports","method":"post"}],"components":{"authorization":[{"name":"guestUser","description":"Unauthenticated visitors who can browse public communities, view public posts and comments, read community rules, and see user profiles with public visibility. Cannot create or interact with content beyond read-only access.","kind":"guest"},{"name":"memberUser","description":"Authenticated users who can create and join communities, create posts and comments, vote, report content, manage their profile and subscriptions, and delete or edit their own content within policy limits.","kind":"member"},{"name":"communityOwner","description":"Authenticated users who created a community and can manage community settings, appoint and remove moderators, set rules, and perform all moderator actions for that community.","kind":"member"},{"name":"communityModerator","description":"Authenticated users appointed by a community owner to moderate a specific community, including removing content, approving posts, managing reports, and restricting user participation within that community.","kind":"member"},{"name":"adminUser","description":"Site-wide administrators with elevated permissions to manage users, communities, system-wide settings, trust and safety enforcement, and respond to escalations across all communities.","kind":"admin"}],"schemas":{"IPage.IPagination":{"type":"object","properties":{"current":{"type":"integer","minimum":0,"description":"Current page number."},"limit":{"type":"integer","minimum":0,"description":"Limitation of records per a page."},"records":{"type":"integer","minimum":0,"description":"Total records in the database."},"pages":{"type":"integer","minimum":0,"description":"Total pages.\n\nEqual to {@link records} / {@link limit} with ceiling."}},"required":["current","limit","records","pages"],"description":"Page information."},"IAuthorizationToken":{"type":"object","properties":{"access":{"type":"string","description":"JWT access token for authenticated requests.\n\nThis token should be included in the Authorization header for subsequent\nauthenticated API requests as `Bearer {token}`."},"refresh":{"type":"string","description":"Refresh token for obtaining new access tokens.\n\nThis token can be used to request new access tokens when the current access\ntoken expires, extending the user's session."},"expired_at":{"type":"string","format":"date-time","description":"Access token expiration timestamp.\n\nISO 8601 date-time string indicating when the access token will expire and\ncan no longer be used for authentication."},"refreshable_until":{"type":"string","format":"date-time","description":"Refresh token expiration timestamp.\n\nISO 8601 date-time string indicating the latest time until which the\nrefresh token can be used to obtain new access tokens."}},"required":["access","refresh","expired_at","refreshable_until"],"description":"Authorization token response structure.\n\nThis interface defines the structure of the authorization token response\nreturned after successful user authentication. It contains both access and\nrefresh tokens along with their expiration information.\n\nThis token structure is automatically included in API schemas when the system\ndetects authorization roles in the requirements analysis phase. It provides a\nstandard format for JWT-based authentication across the generated backend\napplications."},"IPageICommunityPlatformPost":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformPost"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"ICommunityPlatformGuestUser.IJoin":{"type":"object","x-autobe-prisma-schema":"community_platform_users","properties":{"email":{"type":"string","format":"email","description":"Unique email address used as a primary login identifier for the user, stored in Actors.community_platform_users.email.\n\nPer Prisma schema comments, this field is case-insensitive unique and is used for authentication communications and verification flows. The value must be a valid email address format."},"username":{"type":"string","description":"Public handle for the user, stored in Actors.community_platform_users.username.\n\nThis identifier must be globally unique across the platform and is used for mentions and profile URLs. Business rules typically allow letters, numbers, and underscores within 3–20 characters. Prefer case-insensitive uniqueness at the database layer."},"terms_accepted_at":{"type":"string","format":"date-time","description":"Timestamp when the user accepted the Terms of Service, persisted in Actors.community_platform_users.terms_accepted_at.\n\nThe Prisma schema uses timestamptz for auditability. This is required to satisfy compliance requirements at registration time."},"privacy_accepted_at":{"type":"string","format":"date-time","description":"Timestamp when the user accepted the Privacy Policy, persisted in Actors.community_platform_users.privacy_accepted_at.\n\nThe Prisma schema uses timestamptz for auditability. This is required at registration time to satisfy compliance requirements."},"marketing_opt_in":{"type":"boolean","description":"Whether the user explicitly opted in to marketing communications, persisted to Actors.community_platform_users.marketing_opt_in.\n\nDefaults to false when no opt-in is offered. If true, the provider records a timestamp in marketing_opt_in_at on the server side; clients must not supply that timestamp in this Create DTO."}},"required":["email","username","terms_accepted_at","privacy_accepted_at"],"description":"Guest registration inputs sufficient to create a row in Actors.community_platform_users and immediately assign a guest designation via Actors.community_platform_guest_users.\n\nThis DTO maps to non-null columns on community_platform_users per Prisma schema comments: unique email, unique username, and consent timestamps terms_accepted_at and privacy_accepted_at. The server derives password_hash and initializes account_state/email_verified for a guest session; plaintext passwords are never accepted or stored. Optional marketing consent can be indicated through marketing_opt_in, while the corresponding marketing_opt_in_at is stamped by the server upon opt-in."},"ICommunityPlatformGuestUser.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Authenticated user id (community_platform_users.id)."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"},"role":{"const":"guestUser","description":"Role kind for the session."}},"required":["id","token"],"description":"Authorization response for guest user including JWT token information."},"ICommunityPlatformGuestUser.IRefresh":{"type":"object","properties":{"refresh_token":{"type":"string","description":"Valid refresh token to renew guest authorization."}},"required":["refresh_token"],"description":"Guest token refresh request payload."},"ICommunityPlatformMemberUser.ICreate":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Unique email used as a primary login identifier.\n\nPrisma column: community_platform_users.email. A unique index enforces case-insensitive uniqueness at the database level per deployment. Must be a valid email address."},"username":{"type":"string","minLength":3,"maxLength":20,"pattern":"^[A-Za-z0-9_]{3,20}$","description":"Public handle shown in profiles and used in mentions. Must be unique across the platform.\n\nPrisma column: community_platform_users.username. Business rule: 3–20 characters; letters, digits, and underscores only."},"password":{"type":"string","minLength":8,"maxLength":64,"pattern":"^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d\\S]{8,64}$","description":"Plaintext password provided at registration. The backend MUST hash this into community_platform_users.password_hash and MUST NOT store plaintext.\n\nPolicy (business requirements): 8–64 characters, at least one letter and one number; reject commonly breached passwords."},"terms_accepted_at":{"type":"string","format":"date-time","description":"Timestamp when Terms of Service were accepted.\n\nPrisma column: community_platform_users.terms_accepted_at (timestamptz). Recorded for compliance and audit."},"privacy_accepted_at":{"type":"string","format":"date-time","description":"Timestamp when the Privacy Policy was accepted.\n\nPrisma column: community_platform_users.privacy_accepted_at (timestamptz). Recorded for compliance and audit."},"marketing_opt_in":{"type":"boolean","description":"Whether the user explicitly opts into marketing communications.\n\nPrisma column: community_platform_users.marketing_opt_in (Boolean). When true, providers should stamp marketing_opt_in_at server-side. When omitted or false, default handling should record a false value in the database."}},"required":["email","username","password","terms_accepted_at","privacy_accepted_at"],"description":"Member registration request body for POST /auth/memberUser/join.\n\nThis DTO maps to the Actors core identity model community_platform_users for creation-time fields and follows the schema comments: store only password_hash (derived from the provided password), enforce unique email and username, capture consent timestamps, and initialize lifecycle flags (email_verified, account_state) server-side.\n\nSecurity: Do not accept system-managed fields such as id, created_at, updated_at, or deleted_at from clients. Actor IDs and ownership fields are derived from authentication context, not client input."},"ICommunityPlatformMemberUser.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Primary key from Actors.community_platform_users.id.\n\nThis identifier uniquely represents the authenticated member user account within the platform and is used for all subsequent authorization and ownership relations."},"username":{"type":"string","description":"Public handle from Actors.community_platform_users.username.\n\nThis value is globally unique across the platform and is commonly used for profile URLs and mentions, as described in the Prisma schema comments."},"display_name":{"type":"string","description":"Optional display name from Actors.community_platform_users.display_name.\n\nWhen present, this is a mutable, user-chosen label for profile presentation. It is not guaranteed to be unique."},"avatar_uri":{"type":"string","maxLength":80000,"description":"Optional avatar URI from Actors.community_platform_users.avatar_uri.\n\nRepresents a public-facing image resource location used by clients to render user avatars. The database column allows up to 80,000 characters."},"email_verified":{"type":"boolean","description":"Email verification flag from Actors.community_platform_users.email_verified.\n\nWhen true, the account has completed verification and may unlock participation features according to business policy."},"account_state":{"type":"string","description":"Lifecycle state from Actors.community_platform_users.account_state (e.g., PendingVerification, Active, Locked, Deactivated, PendingDeletion, Deleted, Banned).\n\nDownstream services use this value to gate capabilities at login/refresh time and for security decisions."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","token"],"description":"Authorization response for a Member user.\n\nThis DTO is returned after successful authentication flows (join/login/refresh) for a member-capable identity stored in Actors.community_platform_users. It purposely excludes sensitive fields like password_hash and email while providing basic public profile context and the issued JWT token bundle.\n\nSecurity note: The token is provided via the standard IAuthorizationToken component. The included properties (id, username, display_name, avatar_uri, email_verified, account_state) mirror non-sensitive columns documented in the Prisma model for community_platform_users to support client rendering and capability gating."},"ICommunityPlatformMemberUser.ILogin":{"type":"object","properties":{"email":{"oneOf":[{"type":"string","format":"email"},{"type":"null"}],"description":"Login using email (mutually exclusive with username)."},"username":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Login using username (mutually exclusive with email)."},"password":{"type":"string","description":"Plain password for verification."}},"required":["password"],"description":"Member login payload. Provide either email or username plus password."},"ICommunityPlatformMemberUser.IRefresh":{"type":"object","properties":{"refresh_token":{"type":"string","description":"Refresh token to renew member authorization."}},"required":["refresh_token"],"description":"Member refresh request payload."},"ICommunityPlatformCommunityOwner.ICreate":{"type":"object","x-autobe-prisma-schema":"community_platform_users","properties":{"email":{"type":"string","format":"email","description":"Unique email address for the account (community_platform_users.email).\n\nThe Prisma schema enforces uniqueness (@@unique) and serves as a primary login identifier. Stored as a string and used for verification workflows and notifications."},"username":{"type":"string","minLength":3,"maxLength":20,"pattern":"^[A-Za-z0-9_]{3,20}$","description":"Public handle for the account (community_platform_users.username).\n\nMust be unique platform-wide per Prisma @@unique. Allowed characters: letters, numbers, and underscores per business rules."},"password":{"type":"string","minLength":8,"maxLength":64,"description":"Plaintext password to be hashed into community_platform_users.password_hash by the server.\n\nSecurity: clients MUST NOT send pre-hashed values. The backend derives a non-reversible password_hash and never persists plaintext. This field does not exist in Prisma and is used only to compute password_hash."},"display_name":{"type":"string","description":"Optional profile display name mapped to community_platform_users.display_name.\n\nPurely presentational and may be edited later per policy."},"avatar_uri":{"type":"string","format":"uri","description":"Optional avatar URI mapped to community_platform_users.avatar_uri.\n\nStored as a string (VarChar) in Prisma; providers may validate allowed schemes and size constraints."},"terms_accepted_at":{"type":"string","format":"date-time","description":"Timestamp when Terms of Service were accepted (community_platform_users.terms_accepted_at).\n\nRequired for compliance and audit; stored as timestamptz."},"privacy_accepted_at":{"type":"string","format":"date-time","description":"Timestamp when Privacy Policy was accepted (community_platform_users.privacy_accepted_at).\n\nRequired for compliance and audit; stored as timestamptz."},"marketing_opt_in":{"type":"boolean","description":"Whether the user explicitly opted in to marketing communications (community_platform_users.marketing_opt_in).\n\nOptional at registration; defaults are defined by business policy."},"marketing_opt_in_at":{"type":"string","format":"date-time","description":"Timestamp when marketing opt-in was granted (community_platform_users.marketing_opt_in_at).\n\nOptional; when provided, must be a valid timestamptz per schema comments."}},"required":["email","username","password","terms_accepted_at","privacy_accepted_at"],"description":"Community Owner registration request used by POST /auth/communityOwner/join.\n\nThis DTO maps to the Actors core identity model community_platform_users for fields that are user-provided at registration. The server sets system-managed fields such as id, created_at, updated_at, email_verified, account_state, and deleted_at and hashes the supplied password into password_hash before persistence, in accordance with Prisma comments.\n\nSecurity and compliance: do not accept identifiers like id or system timestamps from clients. The password field is accepted only to derive password_hash; plaintext is never stored. Business rules enforce uniqueness for email and username and require consent timestamps for Terms and Privacy."},"ICommunityPlatformCommunityOwner.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Authenticated user id."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"},"role":{"const":"communityOwner","description":"Role kind for the session."}},"required":["id","token"],"description":"Authorization response for community owner with JWT token information."},"ICommunityPlatformCommunityOwner.ILogin":{"oneOf":[{"required":["email","password"]},{"required":["username","password"]}],"description":"Login request for Community Owner accounts.\n\nAllows authentication by either email or username along with a plaintext password. The backend validates credentials against community_platform_users.password_hash and applies account_state and email_verified gates. No x-autobe-prisma-schema linkage because this is a request wrapper and includes a plaintext password field."},"ICommunityPlatformCommunityOwner.IRefresh":{"type":"object","properties":{"refresh_token":{"type":"string","description":"Refresh token to renew owner session."}},"required":["refresh_token"],"description":"Community owner refresh request payload."},"ICommunityPlatformCommunityOwner.IVerifyEmail":{"type":"object","properties":{"verification_token":{"type":"string","description":"One-time verification artifact to confirm email ownership."}},"required":["verification_token"],"description":"Email verification confirmation payload."},"ICommunityPlatformCommunityOwner.IChangePassword":{"type":"object","properties":{"current_password":{"type":"string","description":"Current credential for verification."},"new_password":{"type":"string","description":"New credential to set after validation."}},"required":["current_password","new_password"],"description":"Password change request for authenticated community owner."},"ICommunityPlatformCommunityModeratorJoin.ICreate":{"type":"object","x-autobe-prisma-schema":"community_platform_users","properties":{"email":{"type":"string","format":"email","description":"Unique email address for the new account.\n\nMaps to Actors.community_platform_users.email. The Prisma model enforces uniqueness via @@unique([email]). Case-insensitive uniqueness is recommended in implementation. Used as a primary login identifier."},"username":{"type":"string","minLength":3,"maxLength":20,"pattern":"^[A-Za-z0-9_]{3,20}$","description":"Public handle for the user (3–20 characters; letters, numbers, underscores).\n\nMaps to Actors.community_platform_users.username, which must be unique (@@unique([username])). This value is used in profile URLs and mentions; prefer case-insensitive uniqueness at the database level as noted in the Prisma comments."},"password":{"type":"string","minLength":8,"maxLength":64,"pattern":"(?=.*[A-Za-z])(?=.*\\d).{8,64}","description":"Plaintext password provided for registration; never stored directly.\n\nThe service hashes this into Actors.community_platform_users.password_hash before persistence, per Prisma schema guidance. Must meet strength rules (>= 1 letter and >= 1 number; 8–64 characters)."},"terms_accepted_at":{"type":"string","format":"date-time","description":"Timestamp when Terms of Service were accepted.\n\nPersists to Actors.community_platform_users.terms_accepted_at (Timestamptz). Required for compliance and audit per the Prisma schema comments."},"privacy_accepted_at":{"type":"string","format":"date-time","description":"Timestamp when the Privacy Policy was accepted.\n\nPersists to Actors.community_platform_users.privacy_accepted_at (Timestamptz). Required for compliance and audit per the Prisma schema comments."},"marketing_opt_in":{"type":"boolean","description":"Whether the registrant explicitly opted in to marketing communications.\n\nMaps to Actors.community_platform_users.marketing_opt_in. If true, providers should set marketing_opt_in_at accordingly."},"marketing_opt_in_at":{"type":"string","format":"date-time","description":"Timestamp when marketing opt-in was granted.\n\nMaps to Actors.community_platform_users.marketing_opt_in_at (Timestamptz). Typically set only when marketing_opt_in is true; otherwise may be omitted."}},"required":["email","username","password","terms_accepted_at","privacy_accepted_at"],"description":"Registration request body for a user intending to become a community moderator (member-kind role).\n\nOn success, the service creates a row in Actors.community_platform_users using the supplied identifiers and consents, hashing the provided password into password_hash, initializing lifecycle flags (e.g., email_verified=false, account_state=\"PendingVerification\"), and setting created_at/updated_at. It may also create a membership row in Actors.community_platform_member_users to enable participant capabilities, per business rules. Prisma schema comments emphasize unique constraints on email and username and the use of Timestamptz for consent timestamps.\n\nSecurity note: plaintext password is accepted only for hashing; the stored field is password_hash. System-managed fields like id, created_at, updated_at, and deleted_at are not accepted in this client DTO."},"ICommunityPlatformCommunityModerator.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Authenticated user id."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"},"role":{"const":"communityModerator","description":"Role kind for the session."}},"required":["id","token"],"description":"Authorization response for community moderator with JWT token information."},"ICommunityPlatformCommunityModeratorLogin.IByEmail":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Login identifier using the user’s email address.\n\nMaps to community_platform_users.email (unique). The Prisma model enforces uniqueness at the database layer; application logic should treat comparison case-insensitively and validate syntactic correctness via this email format."},"password":{"type":"string","minLength":8,"maxLength":64,"description":"Plaintext password submitted by the client for verification.\n\nBackends MUST compare a derived hash to community_platform_users.password_hash and MUST NEVER store this plaintext value. Strength rules follow the Authentication requirements (8–64 characters)."}},"required":["email","password"],"description":"Login-by-email variant for community moderator authentication.\n\nThis DTO is used when authenticating with community_platform_users.email and a password. It complements the username-based variant and is referenced by the union request type. Only request-time plaintext is allowed; the server compares against password_hash and never persists the plaintext."},"ICommunityPlatformCommunityModeratorLogin.IByUsername":{"type":"object","properties":{"username":{"type":"string","minLength":3,"maxLength":64,"description":"Platform username used to locate the account.\n\nMaps to community_platform_users.username (unique). The Prisma schema recommends case-insensitive uniqueness; concrete character rules are enforced by application policy."},"password":{"type":"string","minLength":8,"maxLength":64,"description":"Plaintext password provided by the client for verification.\n\nBackends MUST compare its hash to community_platform_users.password_hash and MUST NEVER store the plaintext value. Enforce 8–64 characters per Authentication requirements."}},"required":["username","password"],"description":"Login-by-username variant for community moderator authentication.\n\nThis shape is valid when authenticating with community_platform_users.username and a password. It is referenced by the union request type."},"ICommunityPlatformCommunityModeratorLogin.IRequest":{"oneOf":[{"$ref":"#/components/schemas/ICommunityPlatformCommunityModeratorLogin.IByEmail"},{"$ref":"#/components/schemas/ICommunityPlatformCommunityModeratorLogin.IByUsername"}],"description":"Union request type for community moderator login supporting either email+password or username+password.\n\nThis schema references only named object types (no inline definitions) to comply with the naming rules. Clients must provide exactly one of the supported shapes."},"ICommunityPlatformCommunityModeratorRefresh.IRequest":{"type":"object","properties":{"refresh_token":{"type":"string","description":"Refresh token to renew moderator session."}},"required":["refresh_token"],"description":"Community moderator refresh request payload."},"ICommunityPlatformCommunityModeratorPassword.IUpdate":{"type":"object","properties":{"current_password":{"type":"string","description":"Current credential for verification."},"new_password":{"type":"string","description":"New credential to set after validation."}},"required":["current_password","new_password"],"description":"Password change request for authenticated community moderator."},"ICommunityPlatformAdminUserJoin.ICreate":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Unique email address for the new administrator account.\n\nPrisma column mapping: community_platform_users.email. The Prisma model enforces uniqueness via @@unique([email]). Values are case-insensitive by business policy even if stored as text. This field is used for login and for sending verification and security notifications."},"username":{"type":"string","minLength":3,"maxLength":20,"pattern":"^[A-Za-z0-9_]{3,20}$","description":"Public handle for the administrator, unique platform-wide. Allowed characters are letters, numbers, and underscore only; 3–20 characters.\n\nPrisma column mapping: community_platform_users.username. The Prisma model enforces uniqueness via @@unique([username]). Used for profile URLs and mentions."},"password":{"type":"string","minLength":8,"maxLength":64,"pattern":"^(?=.*[A-Za-z])(?=.*\\d)[\\s\\S]{8,64}$","description":"Plaintext password supplied by the client for credential setup. The backend MUST hash this value into community_platform_users.password_hash before storage. Do not persist plaintext.\n\nSecurity and validation: 8–64 characters, require at least one letter and one number. Backends may apply additional strength checks. Prisma column reference for the hashed value: community_platform_users.password_hash."},"terms_accepted_at":{"type":"string","format":"date-time","description":"Timestamp when Terms of Service were accepted by the registrant.\n\nPrisma column mapping: community_platform_users.terms_accepted_at (Timestamptz). Required for compliance and audit trails."},"privacy_accepted_at":{"type":"string","format":"date-time","description":"Timestamp when Privacy Policy was accepted by the registrant.\n\nPrisma column mapping: community_platform_users.privacy_accepted_at (Timestamptz). Required for compliance and audit trails."},"marketing_opt_in":{"type":"boolean","description":"Whether the registrant explicitly opted in to marketing communications.\n\nPrisma column mapping: community_platform_users.marketing_opt_in. Optional; defaults to false at the application layer when not provided."},"marketing_opt_in_at":{"type":"string","format":"date-time","description":"Timestamp when marketing opt-in was granted. Provide only when marketing_opt_in is true.\n\nPrisma column mapping: community_platform_users.marketing_opt_in_at (Timestamptz). Optional; null when not opted in."}},"required":["email","username","password","terms_accepted_at","privacy_accepted_at"],"description":"Admin registration request body.\n\nThis DTO creates a core identity in community_platform_users and grants admin privileges in a separate table. Fields map to the Prisma model columns per the Actors schema comments: unique email and username, password captured in plaintext here but stored as a non-reversible hash (password_hash), and required consent timestamps (terms_accepted_at, privacy_accepted_at). Optional marketing preferences can be recorded using marketing_opt_in and marketing_opt_in_at.\n\nSecurity and business rules: plaintext password must never be stored; backend hashes to community_platform_users.password_hash. Email verification (community_platform_users.email_verified) and account_state are set server-side per onboarding policy and are not part of this request."},"ICommunityPlatformCommunityModerator.ISecurity":{"type":"object","properties":{"status":{"type":"string","description":"Outcome summary of the password update (e.g., updated, sessions_rotated)."}},"required":["status"],"description":"Security result after moderator password change."},"ICommunityPlatformAdminUser.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Authenticated user id."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"},"role":{"const":"adminUser","description":"Role kind for the session."}},"required":["id","token"],"description":"Authorization response for admin user with JWT token information."},"ICommunityPlatformAdminUserLogin.ICreate":{"oneOf":[{"$ref":"#/components/schemas/ICommunityPlatformAdminUserLogin.IByEmail"},{"$ref":"#/components/schemas/ICommunityPlatformAdminUserLogin.IByUsername"}],"description":"Administrator login request supporting exactly one of two credential forms.\n\nUse email + password (ICommunityPlatformAdminUserLogin.IByEmail) or username + password (ICommunityPlatformAdminUserLogin.IByUsername). Both variants are validated against Actors.community_platform_users: email/username for lookup and password_hash for server-side verification. No plaintext credentials are persisted.\n\nSecurity note: This DTO is for authentication requests only. Do not include identity fields (id) or system timestamps (created_at/updated_at) in requests. Password hashing is strictly a backend responsibility."},"ICommunityPlatformAdminUserRefresh.ICreate":{"type":"object","properties":{"refresh_token":{"type":"string","description":"Refresh token to renew admin session."}},"required":["refresh_token"],"description":"Administrator refresh request payload."},"ICommunityPlatformAdminUserEmailVerify.ICreate":{"type":"object","properties":{"verification_token":{"type":"string","description":"One-time email verification artifact."}},"required":["verification_token"],"description":"Administrator email verification payload."},"IEAdminVerificationStatus":{"oneOf":[{"const":"verified","description":"Enumerated status values representing high-level outcomes for administrator email verification flows.\n\nThis enumeration summarizes results for either an email verification confirmation or a resend request without exposing sensitive internals.\n\n- verified: The administrator’s email has been successfully verified during this operation.\n- already_verified: The administrator’s email was already verified prior to this operation.\n- sent: A verification email has been (re)sent successfully to the administrator.\n\nBusiness context: These outcomes align with lifecycle semantics stored on community_platform_users (email_verified boolean and account_state string). This is a response-layer construct and does not map directly to any Prisma column."},{"const":"already_verified","description":"Enumerated status values representing high-level outcomes for administrator email verification flows.\n\nThis enumeration summarizes results for either an email verification confirmation or a resend request without exposing sensitive internals.\n\n- verified: The administrator’s email has been successfully verified during this operation.\n- already_verified: The administrator’s email was already verified prior to this operation.\n- sent: A verification email has been (re)sent successfully to the administrator.\n\nBusiness context: These outcomes align with lifecycle semantics stored on community_platform_users (email_verified boolean and account_state string). This is a response-layer construct and does not map directly to any Prisma column."},{"const":"sent","description":"Enumerated status values representing high-level outcomes for administrator email verification flows.\n\nThis enumeration summarizes results for either an email verification confirmation or a resend request without exposing sensitive internals.\n\n- verified: The administrator’s email has been successfully verified during this operation.\n- already_verified: The administrator’s email was already verified prior to this operation.\n- sent: A verification email has been (re)sent successfully to the administrator.\n\nBusiness context: These outcomes align with lifecycle semantics stored on community_platform_users (email_verified boolean and account_state string). This is a response-layer construct and does not map directly to any Prisma column."}],"description":"Enumerated status values representing high-level outcomes for administrator email verification flows.\n\nThis enumeration summarizes results for either an email verification confirmation or a resend request without exposing sensitive internals.\n\n- verified: The administrator’s email has been successfully verified during this operation.\n- already_verified: The administrator’s email was already verified prior to this operation.\n- sent: A verification email has been (re)sent successfully to the administrator.\n\nBusiness context: These outcomes align with lifecycle semantics stored on community_platform_users (email_verified boolean and account_state string). This is a response-layer construct and does not map directly to any Prisma column."},"ICommunityPlatformAdminUserVerification.ISummary":{"type":"object","properties":{"ok":{"type":"boolean","description":"Operation success indicator.\n\nTrue when the verification workflow step completed successfully (e.g., email verified or verification email re-sent). False when processed but unable to complete the intended action (e.g., resend throttled). Fatal errors should be returned via the standardized error model rather than this summary object."},"status":{"$ref":"#/components/schemas/IEAdminVerificationStatus","description":"Outcome category for the verification-related action.\n\nUses IEAdminVerificationStatus to provide a compact, programmatic result suitable for client branching."},"message":{"type":"string","description":"Human-readable description of the outcome.\n\nProvides concise, user-facing context (for example, \"Verification email sent.\", \"Email already verified.\", or \"Email verification completed.\"). Avoid sensitive details and adhere to localization and accessibility guidance."},"retry_after_seconds":{"type":"integer","format":"int32","minimum":0,"description":"Optional throttling hint for resend flows.\n\nIndicates the earliest retry window in seconds when a resend is rate-limited. Omit when not applicable. Not persisted in Prisma; computed at runtime from policy and recent activity."}},"required":["ok","status","message"],"description":"Verification result summary for administrator email verification and resend flows.\n\nThis DTO is used by endpoints that confirm an admin’s email or re-send a verification message. It does not directly correspond to a Prisma model; rather, it reflects the effect of operations that read/update community_platform_users (notably email_verified and account_state) as described in the Prisma schema comments. The summary conveys a safe subset of information suitable for clients without exposing sensitive details.\n\nSecurity and privacy: The object intentionally avoids personally identifying fields (such as email) and should be localized for end users while the stable programmatic status values remain language-neutral."},"ICommunityPlatformAdminUserEmailResend.ICreate":{"oneOf":[{"required":["email"]},{"required":["username"]}],"description":"Request body to re-send a verification email for an administrator account.\n\nExactly one identifying input is required: email or username. The provider resolves the target using community_platform_users (email or username) and, if email_verified is false, triggers a verification email dispatch per policy. No Prisma columns are written by this request itself; providers may update community_platform_users.updated_at for audit. Responses should be neutral to prevent user enumeration."},"ICommunityPlatformAdminUserPasswordResetRequest.ICreate":{"oneOf":[{"required":["email"]},{"required":["username"]}],"description":"Admin password reset request payload (initiation).\n\nIdentifies the administrator by either email or username and triggers issuance of a one-time reset artifact out-of-band (e.g., email link). This request does not change credentials; it only begins the reset flow. Implementations must respond neutrally regardless of lookup outcome and may record audit timestamps on community_platform_users."},"ICommunityPlatformAdminUserPasswordReset.ISummary":{"type":"object","properties":{"status":{"type":"string","description":"Outcome summary of password reset (e.g., reset_sent, reset_confirmed)."}},"required":["status"],"description":"Status summary for admin password reset lifecycle."},"ICommunityPlatformAdminUserPasswordResetConfirm.ICreate":{"type":"object","properties":{"reset_token":{"type":"string","description":"One-time reset token."},"new_password":{"type":"string","description":"New password to set."}},"required":["reset_token","new_password"],"description":"Administrator password reset confirmation payload."},"ICommunityPlatformAdminUserPasswordChange.IUpdate":{"type":"object","properties":{"current_password":{"type":"string","description":"Current credential for verification."},"new_password":{"type":"string","description":"New credential to set."}},"required":["current_password","new_password"],"description":"Authenticated administrator password change payload."},"ICommunityPlatformAdminUserPasswordChange.ISummary":{"type":"object","properties":{"status":{"type":"string","description":"Outcome summary (e.g., updated, sessions_rotated)."}},"required":["status"],"description":"Password change result summary for administrators."},"IECommunityVisibility":{"oneOf":[{"const":"public","description":"Community visibility mode as stored in Prisma model community_platform_communities.visibility.\n\nAllowed values reflect business access semantics:\n- public: Anyone can view; participation may still require eligibility.\n- restricted: Readable by all, but posting/commenting restricted per community policy.\n- private: Membership approval required to view and participate.\n\nThis enum supplies a stable vocabulary for API schemas; the underlying Prisma column is a String field constrained by application logic."},{"const":"restricted","description":"Community visibility mode as stored in Prisma model community_platform_communities.visibility.\n\nAllowed values reflect business access semantics:\n- public: Anyone can view; participation may still require eligibility.\n- restricted: Readable by all, but posting/commenting restricted per community policy.\n- private: Membership approval required to view and participate.\n\nThis enum supplies a stable vocabulary for API schemas; the underlying Prisma column is a String field constrained by application logic."},{"const":"private","description":"Community visibility mode as stored in Prisma model community_platform_communities.visibility.\n\nAllowed values reflect business access semantics:\n- public: Anyone can view; participation may still require eligibility.\n- restricted: Readable by all, but posting/commenting restricted per community policy.\n- private: Membership approval required to view and participate.\n\nThis enum supplies a stable vocabulary for API schemas; the underlying Prisma column is a String field constrained by application logic."}],"description":"Community visibility mode as stored in Prisma model community_platform_communities.visibility.\n\nAllowed values reflect business access semantics:\n- public: Anyone can view; participation may still require eligibility.\n- restricted: Readable by all, but posting/commenting restricted per community policy.\n- private: Membership approval required to view and participate.\n\nThis enum supplies a stable vocabulary for API schemas; the underlying Prisma column is a String field constrained by application logic."},"ICommunityPlatformCommunity.ICreate":{"type":"object","x-autobe-prisma-schema":"community_platform_communities","properties":{"name":{"type":"string","description":"Globally unique URL-safe handle for the community.\n\nPrisma column: community_platform_communities.name.\n\nBusiness rules: Must be unique platform-wide; used in routing and mentions."},"display_name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Human-friendly community title for UI surfaces.\n\nPrisma column: community_platform_communities.display_name (nullable)."},"description":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional about/description text for discovery and rule transparency.\n\nPrisma column: community_platform_communities.description (nullable)."},"visibility":{"$ref":"#/components/schemas/IECommunityVisibility","description":"Community visibility mode controlling access.\n\nPrisma column: community_platform_communities.visibility.\n\nAllowed values: public | restricted | private."},"nsfw":{"type":"boolean","description":"Whether the community is labeled Not Safe For Work.\n\nPrisma column: community_platform_communities.nsfw.\n\nBusiness effect: Enforces visibility gates and preview shielding per policy."},"auto_archive_days":{"type":"integer","minimum":30,"description":"Number of days after which posts auto-archive (read-only). Must be ≥ 30.\n\nPrisma column: community_platform_communities.auto_archive_days (integer)."},"language":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional default language code (e.g., \"en\", \"ko\").\n\nPrisma column: community_platform_communities.language (nullable)."},"region":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional default region code (e.g., \"US\", \"KR\").\n\nPrisma column: community_platform_communities.region (nullable)."}},"required":["name","visibility","nsfw","auto_archive_days"],"description":"Create DTO for communities aligned to Prisma model community_platform_communities.\n\nSecurity and integrity: Excludes system-managed fields (id, created_at, updated_at, deleted_at, quarantined, quarantined_at) and any ownership/actor identifiers. Accepts only business-editable fields required to initialize a community per requirements.\n\nRequired properties reflect non-null columns or business mandates (name, visibility, nsfw, auto_archive_days). Optional presentation and discovery hints (display_name, description, language, region) may be supplied by the creator."},"ICommunityPlatformCommunity":{"type":"object","x-autobe-prisma-schema":"community_platform_communities","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the community.\n\nPrisma column: id (UUID)."},"name":{"type":"string","description":"Globally unique community handle used for routing and mentions.\n\nPrisma column: name (unique)."},"display_name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Human-readable title for the community.\n\nPrisma column: display_name (nullable)."},"description":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional about text used for discovery and policy transparency.\n\nPrisma column: description (nullable)."},"visibility":{"type":"string","description":"Community visibility mode controlling read/write: public | restricted | private.\n\nPrisma column: visibility."},"nsfw":{"type":"boolean","description":"Whether the community is marked Not Safe For Work.\n\nPrisma column: nsfw."},"auto_archive_days":{"type":"integer","description":"Number of days after which posts auto-archive (>= 30).\n\nPrisma column: auto_archive_days."},"language":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional default language code (e.g., en, ko).\n\nPrisma column: language (nullable)."},"region":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional default region code (e.g., KR, US).\n\nPrisma column: region (nullable)."},"quarantined":{"type":"boolean","description":"Whether discovery is restricted per safety policy.\n\nPrisma column: quarantined."},"quarantined_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when quarantine began.\n\nPrisma column: quarantined_at (nullable)."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp.\n\nPrisma column: created_at."},"updated_at":{"type":"string","format":"date-time","description":"Last update timestamp.\n\nPrisma column: updated_at."}},"required":["id","name","visibility","nsfw","auto_archive_days","quarantined","created_at","updated_at"],"description":"Community entity as defined in Prisma community_platform_communities.\n\nIncludes configuration for visibility, safety labels, and archival policy. Relationships to owners/moderators/subscriptions and posts are handled via foreign tables."},"ICommunityPlatformSubscription":{"type":"object","x-autobe-prisma-schema":"community_platform_subscriptions","properties":{"id":{"type":"string","format":"uuid","description":"Primary key.\n\nPrisma: id."},"community_platform_community_id":{"type":"string","format":"uuid","description":"Target community id.\n\nPrisma: community_platform_community_id."},"status":{"type":"string","description":"Subscription status: pending | subscribed | banned | blocked.\n\nPrisma: status."},"muted":{"type":"boolean","description":"Suppress delivery in Home without unsubscribing.\n\nPrisma: muted."},"muted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when muted.\n\nPrisma: muted_at."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp.\n\nPrisma: created_at."},"updated_at":{"type":"string","format":"date-time","description":"Last update timestamp.\n\nPrisma: updated_at."}},"required":["id","community_platform_community_id","status","muted","created_at","updated_at"],"description":"Subscription mapping between user and community (Prisma: community_platform_subscriptions).\n\nResponse omits user-id to minimize exposure; providers can infer from auth context."},"IECommunityPlatformPostType":{"oneOf":[{"const":"TEXT","description":"Enumeration of post content types as enforced by application logic.\n\nThis maps directly to community_platform_posts.type, which the service constrains to one of TEXT, LINK, or IMAGE."},{"const":"LINK","description":"Enumeration of post content types as enforced by application logic.\n\nThis maps directly to community_platform_posts.type, which the service constrains to one of TEXT, LINK, or IMAGE."},{"const":"IMAGE","description":"Enumeration of post content types as enforced by application logic.\n\nThis maps directly to community_platform_posts.type, which the service constrains to one of TEXT, LINK, or IMAGE."}],"description":"Enumeration of post content types as enforced by application logic.\n\nThis maps directly to community_platform_posts.type, which the service constrains to one of TEXT, LINK, or IMAGE."},"IECommunityPlatformPostVisibilityState":{"oneOf":[{"const":"Active","description":"Enumeration of business lifecycle states stored in community_platform_posts.visibility_state.\n\nThese states drive eligibility and interaction rules across feeds and detail views."},{"const":"Locked","description":"Enumeration of business lifecycle states stored in community_platform_posts.visibility_state.\n\nThese states drive eligibility and interaction rules across feeds and detail views."},{"const":"Archived","description":"Enumeration of business lifecycle states stored in community_platform_posts.visibility_state.\n\nThese states drive eligibility and interaction rules across feeds and detail views."},{"const":"RemovedByModeration","description":"Enumeration of business lifecycle states stored in community_platform_posts.visibility_state.\n\nThese states drive eligibility and interaction rules across feeds and detail views."},{"const":"RemovedByAdmin","description":"Enumeration of business lifecycle states stored in community_platform_posts.visibility_state.\n\nThese states drive eligibility and interaction rules across feeds and detail views."},{"const":"DeletedByAuthor","description":"Enumeration of business lifecycle states stored in community_platform_posts.visibility_state.\n\nThese states drive eligibility and interaction rules across feeds and detail views."},{"const":"PendingReview","description":"Enumeration of business lifecycle states stored in community_platform_posts.visibility_state.\n\nThese states drive eligibility and interaction rules across feeds and detail views."},{"const":"LegalHold","description":"Enumeration of business lifecycle states stored in community_platform_posts.visibility_state.\n\nThese states drive eligibility and interaction rules across feeds and detail views."}],"description":"Enumeration of business lifecycle states stored in community_platform_posts.visibility_state.\n\nThese states drive eligibility and interaction rules across feeds and detail views."},"ICommunityPlatformPost.ICreate":{"oneOf":[{"$ref":"#/components/schemas/ICommunityPlatformPost.ICreate.ITEXT"},{"$ref":"#/components/schemas/ICommunityPlatformPost.ICreate.ILINK"},{"$ref":"#/components/schemas/ICommunityPlatformPost.ICreate.IIMAGE"}],"description":"Post creation request union with discriminator on \"type\".\n\nThis schema aggregates the TEXT, LINK, and IMAGE creation variants under a single DTO referenced by operations. The discriminator aligns with community_platform_posts.type and enables validation routing.\n\nPrisma linkage: community_platform_posts. All properties in variant schemas correspond to columns in this model (title, type, body/link_url/image_url, nsfw, spoiler).","x-autobe-prisma-schema":"community_platform_posts"},"ICommunityPlatformPost.ICreate.ITEXT":{"type":"object","properties":{"title":{"type":"string","minLength":1,"maxLength":300,"description":"Post headline.\n\nBusiness rule: 1–300 characters; trimmed of whitespace per community_platform_posts.title."},"type":{"type":"string","const":"TEXT","description":"Discriminator for TEXT post creation. Must be exactly \"TEXT\".\n\nMaps to community_platform_posts.type; application constrains to TEXT here."},"body":{"type":"string","minLength":1,"maxLength":40000,"description":"Body text for TEXT posts.\n\nRequired for TEXT; maps to community_platform_posts.body. Max 40,000 characters per business rules."},"nsfw":{"type":"boolean","description":"Label indicating Not Safe For Work.\n\nMaps to community_platform_posts.nsfw; optional on create; may be defaulted by community settings."},"spoiler":{"type":"boolean","description":"Label indicating spoiler content.\n\nMaps to community_platform_posts.spoiler; optional on create."}},"required":["title","type","body"],"description":"Create a TEXT post.\n\nThis variant enforces presence of textual body and constrains type to TEXT.\n\nPrisma linkage: community_platform_posts (title, type, body, nsfw, spoiler).","x-autobe-prisma-schema":"community_platform_posts"},"ICommunityPlatformPost.ICreate.ILINK":{"type":"object","properties":{"title":{"type":"string","minLength":1,"maxLength":300,"description":"Post headline.\n\nBusiness rule: 1–300 characters; trimmed of whitespace per community_platform_posts.title."},"type":{"type":"string","const":"LINK","description":"Discriminator for LINK post creation. Must be exactly \"LINK\".\n\nMaps to community_platform_posts.type; application constrains to LINK here."},"link_url":{"type":"string","format":"uri","maxLength":2048,"description":"Destination URL for LINK posts (http/https).\n\nMaps to community_platform_posts.link_url. Business limit: up to 2,048 characters."},"nsfw":{"type":"boolean","description":"Label indicating Not Safe For Work.\n\nMaps to community_platform_posts.nsfw; optional on create; may be defaulted by community settings."},"spoiler":{"type":"boolean","description":"Label indicating spoiler content.\n\nMaps to community_platform_posts.spoiler; optional on create."}},"required":["title","type","link_url"],"description":"Create a LINK post.\n\nThis variant enforces a valid http/https URL and constrains type to LINK. The server may perform additional domain policy checks and duplicate detection.\n\nPrisma linkage: community_platform_posts (title, type, link_url, nsfw, spoiler).","x-autobe-prisma-schema":"community_platform_posts"},"ICommunityPlatformPost.ICreate.IIMAGE":{"type":"object","properties":{"title":{"type":"string","minLength":1,"maxLength":300,"description":"Post headline.\n\nBusiness rule: 1–300 characters; trimmed of surrounding whitespace per community_platform_posts.title."},"type":{"type":"string","const":"IMAGE","description":"Discriminator for IMAGE post creation. Must be exactly \"IMAGE\".\n\nMaps to community_platform_posts.type; application constrains to IMAGE here."},"image_url":{"type":"string","format":"uri","description":"Image URI for IMAGE posts (JPEG/PNG/GIF) stored as a string reference.\n\nMaps to community_platform_posts.image_url. Server enforces media constraints and storage policy."},"nsfw":{"type":"boolean","description":"Label indicating Not Safe For Work.\n\nMaps to community_platform_posts.nsfw; optional at creation and may be defaulted by community settings."},"spoiler":{"type":"boolean","description":"Label indicating spoiler content.\n\nMaps to community_platform_posts.spoiler; optional at creation."}},"required":["title","type","image_url"],"description":"Create an IMAGE post.\n\nThis variant requires an image URL and constrains type to IMAGE. Large binary payloads are handled out-of-band; this schema carries the persisted reference per Prisma.\n\nPrisma linkage: community_platform_posts (title, type, image_url, nsfw, spoiler).","x-autobe-prisma-schema":"community_platform_posts"},"ICommunityPlatformPost":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Primary key (UUID) of the post. Maps to community_platform_posts.id."},"community_platform_user_id":{"type":"string","format":"uuid","description":"Author user id (UUID). Maps to community_platform_posts.community_platform_user_id referencing community_platform_users.id."},"community_platform_community_id":{"type":"string","format":"uuid","description":"Community id (UUID). Maps to community_platform_posts.community_platform_community_id referencing community_platform_communities.id."},"title":{"type":"string","description":"Post headline text. Maps to community_platform_posts.title. Business rule: 1–300 characters at creation."},"type":{"$ref":"#/components/schemas/IECommunityPlatformPostType","description":"Content type enforced at application layer. Maps to community_platform_posts.type."},"body":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Body text for TEXT posts. Nullable/omitted for non-TEXT posts. Maps to community_platform_posts.body."},"link_url":{"oneOf":[{"type":"string","format":"uri"},{"type":"null"}],"description":"Destination URL for LINK posts. Nullable/omitted for non-LINK posts. Maps to community_platform_posts.link_url."},"image_url":{"oneOf":[{"type":"string","format":"uri"},{"type":"null"}],"description":"Image URI for IMAGE posts. Nullable/omitted for non-IMAGE posts. Maps to community_platform_posts.image_url."},"nsfw":{"type":"boolean","description":"NSFW label controlling visibility gates. Maps to community_platform_posts.nsfw."},"spoiler":{"type":"boolean","description":"Spoiler label controlling preview shielding. Maps to community_platform_posts.spoiler."},"visibility_state":{"oneOf":[{"$ref":"#/components/schemas/IECommunityPlatformPostVisibilityState"},{"type":"null"}],"description":"Business lifecycle state as modeled by community_platform_posts.visibility_state. Nullable."},"locked_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when the post was locked (no new comments and vote changes). Maps to community_platform_posts.locked_at."},"archived_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when the post was archived (read-only). Maps to community_platform_posts.archived_at."},"edited_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp of the last author edit. Maps to community_platform_posts.edited_at."},"edit_count":{"type":"integer","description":"Number of author edits. Maps to community_platform_posts.edit_count."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp (UTC). Maps to community_platform_posts.created_at."},"updated_at":{"type":"string","format":"date-time","description":"Last update timestamp (UTC). Maps to community_platform_posts.updated_at."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Soft deletion timestamp. When non-null, the record is logically deleted and excluded from standard queries. Maps to community_platform_posts.deleted_at."}},"required":["id","community_platform_user_id","community_platform_community_id","title","type","nsfw","spoiler","edit_count","created_at","updated_at"],"description":"Post entity representing records from Prisma model community_platform_posts.\n\nIncludes identifiers (id, community/community user links), content fields (title, type, body/link_url/image_url per type), labels (nsfw, spoiler), lifecycle metadata (visibility_state, locked_at, archived_at), edit transparency (edited_at, edit_count), and audit timestamps (created_at, updated_at, deleted_at).\n\nSensitive credentials do not exist on this model, and ownership is represented by foreign keys. Records where deleted_at is non-null are typically filtered out of list/detail endpoints.","x-autobe-prisma-schema":"community_platform_posts"},"ICommunityPlatformPostVote.IUpdate":{"type":"object","x-autobe-prisma-schema":"community_platform_post_votes","properties":{"value":{"oneOf":[{"const":-1,"description":"Vote value to apply for the authenticated user on the specified post.\n\nOnly two integer values are accepted per business rules and Prisma schema comments: -1 for a downvote and +1 for an upvote. Any other integer is invalid.\n\nSecurity note: the user and post identifiers are inferred from the path and authenticated context. Do not include user or post IDs in this DTO."},{"const":1,"description":"Vote value to apply for the authenticated user on the specified post.\n\nOnly two integer values are accepted per business rules and Prisma schema comments: -1 for a downvote and +1 for an upvote. Any other integer is invalid.\n\nSecurity note: the user and post identifiers are inferred from the path and authenticated context. Do not include user or post IDs in this DTO."}],"description":"Vote value to apply for the authenticated user on the specified post.\n\nOnly two integer values are accepted per business rules and Prisma schema comments: -1 for a downvote and +1 for an upvote. Any other integer is invalid.\n\nSecurity note: the user and post identifiers are inferred from the path and authenticated context. Do not include user or post IDs in this DTO."}},"required":[],"description":"Request DTO for setting or changing a post vote.\n\nMaps directly to the community_platform_post_votes.value column in the Prisma model. This DTO purposefully excludes identity fields (community_platform_user_id and community_platform_post_id) because those are derived from authentication context and route parameters.\n\nPer security requirements, ownership and actor fields must never be accepted from client input. Although Update DTOs follow a Partial<T> pattern (all fields optional), the corresponding endpoint can still enforce `value` presence at runtime."},"ICommunityPlatformPostVote":{"type":"object","x-autobe-prisma-schema":"community_platform_post_votes","properties":{"id":{"type":"string","format":"uuid","description":"Primary key.\n\nPrisma: id."},"community_platform_post_id":{"type":"string","format":"uuid","description":"Target post id.\n\nPrisma: community_platform_post_id."},"value":{"oneOf":[{"const":-1,"description":"Vote value: -1 (downvote) or +1 (upvote).\n\nPrisma: value."},{"const":1,"description":"Vote value: -1 (downvote) or +1 (upvote).\n\nPrisma: value."}],"description":"Vote value: -1 (downvote) or +1 (upvote).\n\nPrisma: value."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp.\n\nPrisma: created_at."},"updated_at":{"type":"string","format":"date-time","description":"Last update timestamp.\n\nPrisma: updated_at."}},"required":["id","community_platform_post_id","value","created_at","updated_at"],"description":"Post vote record (Prisma: community_platform_post_votes)."},"ICommunityPlatformComment.ICreate":{"type":"object","x-autobe-prisma-schema":"community_platform_comments","properties":{"body":{"type":"string","minLength":1,"maxLength":10000,"description":"Comment text content to create.\n\nMaps to community_platform_comments.body in the Prisma schema. Business rule: 1–10,000 Unicode characters after trimming whitespace; empty-only text is not permitted. The service will normalize line endings and may apply additional policy validation (e.g., word filters) per business requirements."},"parent_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional parent comment identifier for nesting within the same post.\n\nDirectly corresponds to community_platform_comments.parent_id in the Prisma model (nullable UUID). When provided, this must reference an existing comment on the same post. Depth limits and lock/archive constraints are enforced by the service."}},"required":["body"],"description":"Request body for creating a new comment under a post, with optional nesting.\n\nThis DTO is used by write operations that create comments in the Content domain. It accepts only end-user-editable fields: the comment body and optional parent_id for nested replies. The target postId and author are derived from the path parameter and authenticated session, respectively, and therefore are not accepted here to prevent impersonation or cross-posting.\n\nSecurity and validation notes:\n- The author identity (user) comes from the authenticated context and is never taken from client input.\n- The target post is specified via the request path, not the body.\n- The parent_id, if present, must belong to the same post and respect maximum depth and lock/archive rules. The provider enforces these constraints before creation.\n- Body must be 1–10,000 characters after trimming, consistent with Prisma column comments for community_platform_comments.body."},"ICommunityPlatformComment":{"type":"object","x-autobe-prisma-schema":"community_platform_comments","properties":{"id":{"type":"string","format":"uuid","description":"Primary key.\n\nPrisma: id."},"community_platform_post_id":{"type":"string","format":"uuid","description":"Target post id.\n\nPrisma: community_platform_post_id."},"community_platform_user_id":{"type":"string","format":"uuid","description":"Author user id.\n\nPrisma: community_platform_user_id."},"parent_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional parent comment id.\n\nPrisma: parent_id (nullable)."},"body":{"type":"string","description":"Comment text (1–10,000 chars).\n\nPrisma: body."},"locked_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when this thread node was locked.\n\nPrisma: locked_at (nullable)."},"edited_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Last edit timestamp.\n\nPrisma: edited_at (nullable)."},"edit_count":{"type":"integer","description":"Number of author edits.\n\nPrisma: edit_count."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp.\n\nPrisma: created_at."},"updated_at":{"type":"string","format":"date-time","description":"Last update timestamp.\n\nPrisma: updated_at."}},"required":["id","community_platform_post_id","community_platform_user_id","body","edit_count","created_at","updated_at"],"description":"Comment entity (Prisma: community_platform_comments) with nesting via parent_id and lifecycle fields."},"ICommunityPlatformComment.ITree":{"type":"object","properties":{"post_id":{"type":"string","format":"uuid","description":"The post whose comments are represented."},"items":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformCommentNode"},"description":"Tree roots with nested replies in each node."}},"required":["post_id","items"],"description":"Tree-structured comment response. Uses ICommunityPlatformCommentNode for hierarchical representation.\n\nNot a direct Prisma mapping; built from community_platform_comments."},"ICommunityPlatformCommentVote.IUpdate":{"type":"object","x-autobe-prisma-schema":"community_platform_comment_votes","properties":{"value":{"oneOf":[{"const":-1,"description":"Desired vote value for this user on the specified comment.\n\nPrisma: community_platform_comment_votes.value. Only -1 (downvote) or +1 (upvote) are valid. The server upserts the (user, comment) vote row accordingly and clears deleted_at when reviving a previously cleared vote."},{"const":1,"description":"Desired vote value for this user on the specified comment.\n\nPrisma: community_platform_comment_votes.value. Only -1 (downvote) or +1 (upvote) are valid. The server upserts the (user, comment) vote row accordingly and clears deleted_at when reviving a previously cleared vote."}],"description":"Desired vote value for this user on the specified comment.\n\nPrisma: community_platform_comment_votes.value. Only -1 (downvote) or +1 (upvote) are valid. The server upserts the (user, comment) vote row accordingly and clears deleted_at when reviving a previously cleared vote."}},"required":[],"description":"Request body to set or change the caller’s vote on a comment.\n\nThis DTO corresponds to the Prisma table community_platform_comment_votes, constrained to the mutable property value. Actor and target identifiers are taken from path/auth context; system fields (id, created_at, updated_at, deleted_at) are server-managed and not part of the request."},"ICommunityPlatformCommentVote":{"type":"object","x-autobe-prisma-schema":"community_platform_comment_votes","properties":{"id":{"type":"string","format":"uuid","description":"Primary key.\n\nPrisma: id."},"community_platform_comment_id":{"type":"string","format":"uuid","description":"Target comment id.\n\nPrisma: community_platform_comment_id."},"value":{"oneOf":[{"const":-1,"description":"Vote value: -1 (downvote) or +1 (upvote).\n\nPrisma: value."},{"const":1,"description":"Vote value: -1 (downvote) or +1 (upvote).\n\nPrisma: value."}],"description":"Vote value: -1 (downvote) or +1 (upvote).\n\nPrisma: value."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp.\n\nPrisma: created_at."},"updated_at":{"type":"string","format":"date-time","description":"Last update timestamp.\n\nPrisma: updated_at."}},"required":["id","community_platform_comment_id","value","created_at","updated_at"],"description":"Comment vote record (Prisma: community_platform_comment_votes)."},"ICommunityPlatformUserProfile":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"User id (community_platform_users.id)."},"username":{"type":"string","description":"Public handle (community_platform_users.username)."},"display_name":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional display name (community_platform_users.display_name)."},"avatar_uri":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional avatar URI (community_platform_users.avatar_uri)."},"karma":{"$ref":"#/components/schemas/ICommunityPlatformUserKarma","description":"Aggregated karma totals for the user."},"posts":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformPost.ISummary"},"description":"Lightweight list of authored posts visible to the viewer."},"comments":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformComment.ISummary"},"description":"Lightweight list of authored comments visible to the viewer."}},"required":["id","username","karma","posts","comments"],"description":"Consolidated public profile view combining safe public fields from community_platform_users with aggregated karma and activity summaries.\n\nSecurity: Excludes sensitive identifiers like email and password_hash."},"ICommunityPlatformUserKarma":{"type":"object","x-autobe-prisma-schema":"community_platform_user_karmas","properties":{"post_karma":{"type":"integer","description":"Cumulative karma derived from votes on the user’s posts.\n\nThis value is sourced from the Votes domain and maintained by the application. May be negative per business rules."},"comment_karma":{"type":"integer","description":"Cumulative karma derived from votes on the user’s comments.\n\nThis value is maintained by application logic and can be negative."},"total_karma":{"type":"integer","description":"Total karma for the user (post + comment and other applicable sources).\n\nThis integer is a denormalized aggregate intended for quick profile display and ranking."}},"required":["post_karma","comment_karma","total_karma"],"description":"Aggregated karma totals for a user from Prisma model community_platform_user_karmas.\n\nThis schema exposes only the non-sensitive integer aggregates necessary for profile and list displays and aligns with the business rule that karma values can be negative."},"ICommunityPlatformPost.ISummary":{"type":"object","x-autobe-prisma-schema":"community_platform_posts","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the post row.\n\nPrisma: community_platform_posts.id (UUID)."},"community_platform_community_id":{"type":"string","format":"uuid","description":"Target community’s identifier.\n\nPrisma: community_platform_posts.community_platform_community_id referencing community_platform_communities.id."},"title":{"type":"string","description":"Human-readable headline of the post.\n\nPrisma: community_platform_posts.title. Business rule enforced at write-time: 1–300 characters trimmed."},"type":{"oneOf":[{"const":"TEXT"},{"const":"LINK"},{"const":"IMAGE"}],"description":"Post content type constrained by business rules to one of TEXT | LINK | IMAGE.\n\nPrisma: community_platform_posts.type (free-form String), constrained by application logic."},"nsfw":{"type":"boolean","description":"NSFW label for visibility gating and previews.\n\nPrisma: community_platform_posts.nsfw (Boolean)."},"spoiler":{"type":"boolean","description":"Spoiler label controlling preview shielding.\n\nPrisma: community_platform_posts.spoiler (Boolean)."},"visibility_state":{"oneOf":[{"const":"Active"},{"const":"Locked"},{"const":"Archived"},{"const":"RemovedByModeration"},{"const":"RemovedByAdmin"},{"const":"DeletedByAuthor"},{"const":"PendingReview"},{"const":"LegalHold"},{"type":"null"}],"description":"Business visibility state of the post (nullable in DB).\n\nPrisma: community_platform_posts.visibility_state (String?)."},"locked_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when the post was locked (nullable).\n\nPrisma: community_platform_posts.locked_at (Timestamptz?)."},"archived_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when the post was archived (nullable).\n\nPrisma: community_platform_posts.archived_at (Timestamptz?)."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp (UTC, timestamptz).\n\nPrisma: community_platform_posts.created_at."}},"required":["id","community_platform_community_id","title","type","nsfw","spoiler","created_at"],"description":"Summary DTO for community_platform_posts.\n\nThis schema presents essential, list-optimized fields while excluding heavy payload columns such as body, link_url, and image_url. It aligns with the Prisma model’s columns and business semantics for labels and lifecycle state.\n\nUse this type for list and profile views where minimal fields are preferred and where clients may need to check gating and lifecycle at a glance (NSFW, spoiler, visibility_state, locked_at, archived_at)."},"ICommunityPlatformComment.ISummary":{"type":"object","x-autobe-prisma-schema":"community_platform_comments","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the comment (community_platform_comments.id).\n\nServes as the stable identifier in thread structures."},"community_platform_post_id":{"type":"string","format":"uuid","description":"Foreign key referencing the target post (community_platform_posts.id).\n\nEnsures the comment is associated to a single post."},"parent_id":{"oneOf":[{"type":"string","format":"uuid"},{"type":"null"}],"description":"Optional parent comment id enabling nested replies.\n\nBacked by community_platform_comments.parent_id (nullable)."},"locked_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp when this comment node was locked; prevents new replies beneath this node.\n\nMaps to community_platform_comments.locked_at."},"edited_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp of the last author edit for this comment.\n\nMaps to community_platform_comments.edited_at."},"edit_count":{"type":"integer","description":"Number of times the comment was edited by the author.\n\nStored in community_platform_comments.edit_count and used for edit transparency indicators."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp (UTC) of the comment.\n\nBacked by community_platform_comments.created_at."}},"required":["id","community_platform_post_id","edit_count","created_at"],"description":"Summary DTO for comments based on Prisma model community_platform_comments.\n\nOmits large text content (body) for efficiency and privacy in list views, while preserving essential relational and lifecycle metadata for threading and moderation-aware displays."},"ICommunityPlatformReport.ICreate":{"type":"object","x-autobe-prisma-schema":"community_platform_reports","properties":{"category":{"$ref":"#/components/schemas/IEReportCategory","description":"Required categorical reason for the report.\n\nMaps to community_platform_reports.category. Clients must use one of the allowed values defined by IEReportCategory."},"reason":{"type":"string","minLength":1,"description":"Required free-text explanation for the report.\n\nMaps to community_platform_reports.reason. Provide concise, actionable context for moderators."}},"required":["category","reason"],"description":"Create DTO for submitting a new report.\n\nThis request body accepts only business input fields: category and reason. The reporter ID is taken from authentication context; the target (post or comment) is specified by the API path parameter; and system-managed fields such as id, created_at, and updated_at are set by the server.\n\nSecurity: never accept actor IDs, IDs, or timestamps from clients. This DTO maps to community_platform_reports for validation while restricting inputs to safe fields."},"IEReportCategory":{"oneOf":[{"const":"spam","description":"Report category enumeration mapped to community_platform_reports.category.\n\nThis enum reflects the standardized moderation taxonomy described in the business requirements and Prisma schema comments. It enables consistent triage, routing, and analytics across communities and the site-wide safety program.\n\nTypical categories include spam, harassment/hate, sexual content/child safety, violence/threats, self-harm risk, illegal, doxxing, misinformation, off-topic/low-effort, copyright, and other."},{"const":"harassment/hate","description":"Report category enumeration mapped to community_platform_reports.category.\n\nThis enum reflects the standardized moderation taxonomy described in the business requirements and Prisma schema comments. It enables consistent triage, routing, and analytics across communities and the site-wide safety program.\n\nTypical categories include spam, harassment/hate, sexual content/child safety, violence/threats, self-harm risk, illegal, doxxing, misinformation, off-topic/low-effort, copyright, and other."},{"const":"sexual_content/child_safety","description":"Report category enumeration mapped to community_platform_reports.category.\n\nThis enum reflects the standardized moderation taxonomy described in the business requirements and Prisma schema comments. It enables consistent triage, routing, and analytics across communities and the site-wide safety program.\n\nTypical categories include spam, harassment/hate, sexual content/child safety, violence/threats, self-harm risk, illegal, doxxing, misinformation, off-topic/low-effort, copyright, and other."},{"const":"violence/threats","description":"Report category enumeration mapped to community_platform_reports.category.\n\nThis enum reflects the standardized moderation taxonomy described in the business requirements and Prisma schema comments. It enables consistent triage, routing, and analytics across communities and the site-wide safety program.\n\nTypical categories include spam, harassment/hate, sexual content/child safety, violence/threats, self-harm risk, illegal, doxxing, misinformation, off-topic/low-effort, copyright, and other."},{"const":"self_harm_risk","description":"Report category enumeration mapped to community_platform_reports.category.\n\nThis enum reflects the standardized moderation taxonomy described in the business requirements and Prisma schema comments. It enables consistent triage, routing, and analytics across communities and the site-wide safety program.\n\nTypical categories include spam, harassment/hate, sexual content/child safety, violence/threats, self-harm risk, illegal, doxxing, misinformation, off-topic/low-effort, copyright, and other."},{"const":"illegal","description":"Report category enumeration mapped to community_platform_reports.category.\n\nThis enum reflects the standardized moderation taxonomy described in the business requirements and Prisma schema comments. It enables consistent triage, routing, and analytics across communities and the site-wide safety program.\n\nTypical categories include spam, harassment/hate, sexual content/child safety, violence/threats, self-harm risk, illegal, doxxing, misinformation, off-topic/low-effort, copyright, and other."},{"const":"doxxing","description":"Report category enumeration mapped to community_platform_reports.category.\n\nThis enum reflects the standardized moderation taxonomy described in the business requirements and Prisma schema comments. It enables consistent triage, routing, and analytics across communities and the site-wide safety program.\n\nTypical categories include spam, harassment/hate, sexual content/child safety, violence/threats, self-harm risk, illegal, doxxing, misinformation, off-topic/low-effort, copyright, and other."},{"const":"misinformation","description":"Report category enumeration mapped to community_platform_reports.category.\n\nThis enum reflects the standardized moderation taxonomy described in the business requirements and Prisma schema comments. It enables consistent triage, routing, and analytics across communities and the site-wide safety program.\n\nTypical categories include spam, harassment/hate, sexual content/child safety, violence/threats, self-harm risk, illegal, doxxing, misinformation, off-topic/low-effort, copyright, and other."},{"const":"off_topic/low_effort","description":"Report category enumeration mapped to community_platform_reports.category.\n\nThis enum reflects the standardized moderation taxonomy described in the business requirements and Prisma schema comments. It enables consistent triage, routing, and analytics across communities and the site-wide safety program.\n\nTypical categories include spam, harassment/hate, sexual content/child safety, violence/threats, self-harm risk, illegal, doxxing, misinformation, off-topic/low-effort, copyright, and other."},{"const":"copyright","description":"Report category enumeration mapped to community_platform_reports.category.\n\nThis enum reflects the standardized moderation taxonomy described in the business requirements and Prisma schema comments. It enables consistent triage, routing, and analytics across communities and the site-wide safety program.\n\nTypical categories include spam, harassment/hate, sexual content/child safety, violence/threats, self-harm risk, illegal, doxxing, misinformation, off-topic/low-effort, copyright, and other."},{"const":"other","description":"Report category enumeration mapped to community_platform_reports.category.\n\nThis enum reflects the standardized moderation taxonomy described in the business requirements and Prisma schema comments. It enables consistent triage, routing, and analytics across communities and the site-wide safety program.\n\nTypical categories include spam, harassment/hate, sexual content/child safety, violence/threats, self-harm risk, illegal, doxxing, misinformation, off-topic/low-effort, copyright, and other."}],"description":"Report category enumeration mapped to community_platform_reports.category.\n\nThis enum reflects the standardized moderation taxonomy described in the business requirements and Prisma schema comments. It enables consistent triage, routing, and analytics across communities and the site-wide safety program.\n\nTypical categories include spam, harassment/hate, sexual content/child safety, violence/threats, self-harm risk, illegal, doxxing, misinformation, off-topic/low-effort, copyright, and other."},"ICommunityPlatformReport":{"oneOf":[{"required":["community_platform_post_id"]},{"required":["community_platform_comment_id"]}],"description":"Safety report entity for posts or comments.\n\nThis schema directly maps to the Prisma model community_platform_reports. It captures the reporter (community_platform_user_id), the target (exactly one of community_platform_post_id or community_platform_comment_id), the categorical reason (category), and a free-text explanation (reason). Timestamps (created_at, updated_at) are recorded as timestamptz.\n\nBusiness rules: exactly one target must be present; duplicates within a time window may be rejected; reporter identity comes from the authenticated session. Sensitive fields such as credentials are never included.","x-autobe-prisma-schema":"community_platform_reports"},"ICommunityPlatformCommentNode":{"type":"object","properties":{"comment":{"$ref":"#/components/schemas/ICommunityPlatformComment","description":"Comment entity for this node."},"children":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformCommentNode"},"description":"Nested replies under this node."}},"required":["comment","children"],"description":"A node in the comment tree consisting of a comment and its nested children."},"ICommunityPlatformAdminUserLogin.IByEmail":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Administrator’s email address.\n\nMaps to Prisma column community_platform_users.email, which is unique and used for authentication lookup."},"password":{"type":"string","minLength":8,"maxLength":64,"description":"Plaintext password submitted by the client.\n\nServer compares the provided value to community_platform_users.password_hash after hashing, per security policy."}},"required":["email","password"],"description":"Login payload variant for administrators using email + password.\n\nThis request DTO aligns to Actors.community_platform_users columns: email (unique identifier) and password_hash (server-side verification only)."},"ICommunityPlatformAdminUserLogin.IByUsername":{"type":"object","properties":{"username":{"type":"string","description":"Username uniquely identifying the administrator account.\n\nThis maps to Prisma model column community_platform_users.username, which is unique and used for public handle and authentication lookup."},"password":{"type":"string","minLength":8,"maxLength":64,"description":"Plaintext password submitted by the client for verification.\n\nServer verifies against community_platform_users.password_hash and never stores plaintext. Clients MUST NOT send pre-hashed values; hashing is performed by the backend."}},"required":["username","password"],"description":"Login payload variant for administrators using username + password.\n\nThis DTO is used only for request input and does not correspond directly to a single Prisma row; however, its properties are validated against the Actors schema columns (community_platform_users.username and community_platform_users.password_hash)."}}}}